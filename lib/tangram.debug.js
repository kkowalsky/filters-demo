(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require("./lib/babel/polyfill");

},{"./lib/babel/polyfill":2}],2:[function(require,module,exports){
(function (global){
"use strict";

if (global._babelPolyfill) {
  throw new Error("only one instance of babel/polyfill is allowed");
}
global._babelPolyfill = true;

require("core-js/shim");

require("regenerator-babel/runtime");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"core-js/shim":3,"regenerator-babel/runtime":4}],3:[function(require,module,exports){
/**
 * Core.js 0.6.1
 * https://github.com/zloirock/core-js
 * License: http://rock.mit-license.org
 * Â© 2015 Denis Pushkarev
 */
!function(global, framework, undefined){
'use strict';

/******************************************************************************
 * Module : common                                                            *
 ******************************************************************************/

  // Shortcuts for [[Class]] & property names
var OBJECT          = 'Object'
  , FUNCTION        = 'Function'
  , ARRAY           = 'Array'
  , STRING          = 'String'
  , NUMBER          = 'Number'
  , REGEXP          = 'RegExp'
  , DATE            = 'Date'
  , MAP             = 'Map'
  , SET             = 'Set'
  , WEAKMAP         = 'WeakMap'
  , WEAKSET         = 'WeakSet'
  , SYMBOL          = 'Symbol'
  , PROMISE         = 'Promise'
  , MATH            = 'Math'
  , ARGUMENTS       = 'Arguments'
  , PROTOTYPE       = 'prototype'
  , CONSTRUCTOR     = 'constructor'
  , TO_STRING       = 'toString'
  , TO_STRING_TAG   = TO_STRING + 'Tag'
  , TO_LOCALE       = 'toLocaleString'
  , HAS_OWN         = 'hasOwnProperty'
  , FOR_EACH        = 'forEach'
  , ITERATOR        = 'iterator'
  , FF_ITERATOR     = '@@' + ITERATOR
  , PROCESS         = 'process'
  , CREATE_ELEMENT  = 'createElement'
  // Aliases global objects and prototypes
  , Function        = global[FUNCTION]
  , Object          = global[OBJECT]
  , Array           = global[ARRAY]
  , String          = global[STRING]
  , Number          = global[NUMBER]
  , RegExp          = global[REGEXP]
  , Date            = global[DATE]
  , Map             = global[MAP]
  , Set             = global[SET]
  , WeakMap         = global[WEAKMAP]
  , WeakSet         = global[WEAKSET]
  , Symbol          = global[SYMBOL]
  , Math            = global[MATH]
  , TypeError       = global.TypeError
  , RangeError      = global.RangeError
  , setTimeout      = global.setTimeout
  , setImmediate    = global.setImmediate
  , clearImmediate  = global.clearImmediate
  , parseInt        = global.parseInt
  , isFinite        = global.isFinite
  , process         = global[PROCESS]
  , nextTick        = process && process.nextTick
  , document        = global.document
  , html            = document && document.documentElement
  , navigator       = global.navigator
  , define          = global.define
  , console         = global.console || {}
  , ArrayProto      = Array[PROTOTYPE]
  , ObjectProto     = Object[PROTOTYPE]
  , FunctionProto   = Function[PROTOTYPE]
  , Infinity        = 1 / 0
  , DOT             = '.';

// http://jsperf.com/core-js-isobject
function isObject(it){
  return it !== null && (typeof it == 'object' || typeof it == 'function');
}
function isFunction(it){
  return typeof it == 'function';
}
// Native function?
var isNative = ctx(/./.test, /\[native code\]\s*\}\s*$/, 1);

// Object internal [[Class]] or toStringTag
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring
var toString = ObjectProto[TO_STRING];
function setToStringTag(it, tag, stat){
  if(it && !has(it = stat ? it : it[PROTOTYPE], SYMBOL_TAG))hidden(it, SYMBOL_TAG, tag);
}
function cof(it){
  return toString.call(it).slice(8, -1);
}
function classof(it){
  var O, T;
  return it == undefined ? it === undefined ? 'Undefined' : 'Null'
    : typeof (T = (O = Object(it))[SYMBOL_TAG]) == 'string' ? T : cof(O);
}

// Function
var call  = FunctionProto.call
  , apply = FunctionProto.apply
  , REFERENCE_GET;
// Partial apply
function part(/* ...args */){
  var fn     = assertFunction(this)
    , length = arguments.length
    , args   = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((args[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that    = this
      , _length = arguments.length
      , i = 0, j = 0, _args;
    if(!holder && !_length)return invoke(fn, args, that);
    _args = args.slice();
    if(holder)for(;length > i; i++)if(_args[i] === _)_args[i] = arguments[j++];
    while(_length > j)_args.push(arguments[j++]);
    return invoke(fn, _args, that);
  }
}
// Optional / simple context binding
function ctx(fn, that, length){
  assertFunction(fn);
  if(~length && that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    }
    case 2: return function(a, b){
      return fn.call(that, a, b);
    }
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    }
  } return function(/* ...args */){
      return fn.apply(that, arguments);
  }
}
// Fast apply
// http://jsperf.lnkit.com/fast-apply/5
function invoke(fn, args, that){
  var un = that === undefined;
  switch(args.length | 0){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
    case 5: return un ? fn(args[0], args[1], args[2], args[3], args[4])
                      : fn.call(that, args[0], args[1], args[2], args[3], args[4]);
  } return              fn.apply(that, args);
}

// Object:
var create           = Object.create
  , getPrototypeOf   = Object.getPrototypeOf
  , setPrototypeOf   = Object.setPrototypeOf
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , getOwnDescriptor = Object.getOwnPropertyDescriptor
  , getKeys          = Object.keys
  , getNames         = Object.getOwnPropertyNames
  , getSymbols       = Object.getOwnPropertySymbols
  , isFrozen         = Object.isFrozen
  , has              = ctx(call, ObjectProto[HAS_OWN], 2)
  // Dummy, fix for not array-like ES3 string in es5 module
  , ES5Object        = Object
  , Dict;
function toObject(it){
  return ES5Object(assertDefined(it));
}
function returnIt(it){
  return it;
}
function returnThis(){
  return this;
}
function get(object, key){
  if(has(object, key))return object[key];
}
function ownKeys(it){
  assertObject(it);
  return getSymbols ? getNames(it).concat(getSymbols(it)) : getNames(it);
}
// 19.1.2.1 Object.assign(target, source, ...)
var assign = Object.assign || function(target, source){
  var T = Object(assertDefined(target))
    , l = arguments.length
    , i = 1;
  while(l > i){
    var S      = ES5Object(arguments[i++])
      , keys   = getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)T[key = keys[j++]] = S[key];
  }
  return T;
}
function keyOf(object, el){
  var O      = toObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
}

// Array
// array('str1,str2,str3') => ['str1', 'str2', 'str3']
function array(it){
  return String(it).split(',');
}
var push    = ArrayProto.push
  , unshift = ArrayProto.unshift
  , slice   = ArrayProto.slice
  , splice  = ArrayProto.splice
  , indexOf = ArrayProto.indexOf
  , forEach = ArrayProto[FOR_EACH];
/*
 * 0 -> forEach
 * 1 -> map
 * 2 -> filter
 * 3 -> some
 * 4 -> every
 * 5 -> find
 * 6 -> findIndex
 */
function createArrayMethod(type){
  var isMap       = type == 1
    , isFilter    = type == 2
    , isSome      = type == 3
    , isEvery     = type == 4
    , isFindIndex = type == 6
    , noholes     = type == 5 || isFindIndex;
  return function(callbackfn/*, that = undefined */){
    var O      = Object(assertDefined(this))
      , that   = arguments[1]
      , self   = ES5Object(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = isMap ? Array(length) : isFilter ? [] : undefined
      , val, res;
    for(;length > index; index++)if(noholes || index in self){
      val = self[index];
      res = f(val, index, O);
      if(type){
        if(isMap)result[index] = res;             // map
        else if(res)switch(type){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(isEvery)return false;           // every
      }
    }
    return isFindIndex ? -1 : isSome || isEvery ? isEvery : result;
  }
}
function createArrayContains(isContains){
  return function(el /*, fromIndex = 0 */){
    var O      = toObject(this)
      , length = toLength(O.length)
      , index  = toIndex(arguments[1], length);
    if(isContains && el != el){
      for(;length > index; index++)if(sameNaN(O[index]))return isContains || index;
    } else for(;length > index; index++)if(isContains || index in O){
      if(O[index] === el)return isContains || index;
    } return !isContains && -1;
  }
}
function generic(A, B){
  // strange IE quirks mode bug -> use typeof vs isFunction
  return typeof A == 'function' ? A : B;
}

// Math
var MAX_SAFE_INTEGER = 0x1fffffffffffff // pow(2, 53) - 1 == 9007199254740991
  , pow    = Math.pow
  , abs    = Math.abs
  , ceil   = Math.ceil
  , floor  = Math.floor
  , max    = Math.max
  , min    = Math.min
  , random = Math.random
  , trunc  = Math.trunc || function(it){
      return (it > 0 ? floor : ceil)(it);
    }
// 20.1.2.4 Number.isNaN(number)
function sameNaN(number){
  return number != number;
}
// 7.1.4 ToInteger
function toInteger(it){
  return isNaN(it) ? 0 : trunc(it);
}
// 7.1.15 ToLength
function toLength(it){
  return it > 0 ? min(toInteger(it), MAX_SAFE_INTEGER) : 0;
}
function toIndex(index, length){
  var index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
}
function lz(num){
  return num > 9 ? num : '0' + num;
}

function createReplacer(regExp, replace, isStatic){
  var replacer = isObject(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(isStatic ? it : this).replace(regExp, replacer);
  }
}
function createPointAt(toString){
  return function(pos){
    var s = String(assertDefined(this))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return toString ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? toString ? s.charAt(i) : a
      : toString ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  }
}

// Assertion & errors
var REDUCE_ERROR = 'Reduce of empty object with no initial value';
function assert(condition, msg1, msg2){
  if(!condition)throw TypeError(msg2 ? msg1 + msg2 : msg1);
}
function assertDefined(it){
  if(it == undefined)throw TypeError('Function called on null or undefined');
  return it;
}
function assertFunction(it){
  assert(isFunction(it), it, ' is not a function!');
  return it;
}
function assertObject(it){
  assert(isObject(it), it, ' is not an object!');
  return it;
}
function assertInstance(it, Constructor, name){
  assert(it instanceof Constructor, name, ": use the 'new' operator!");
}

// Property descriptors & Symbol
function descriptor(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  }
}
function simpleSet(object, key, value){
  object[key] = value;
  return object;
}
function createDefiner(bitmap){
  return DESC ? function(object, key, value){
    return defineProperty(object, key, descriptor(bitmap, value));
  } : simpleSet;
}
function uid(key){
  return SYMBOL + '(' + key + ')_' + (++sid + random())[TO_STRING](36);
}
function getWellKnownSymbol(name, setter){
  return (Symbol && Symbol[name]) || (setter ? Symbol : safeSymbol)(SYMBOL + DOT + name);
}
// The engine works fine with descriptors? Thank's IE8 for his funny defineProperty.
var DESC = !!function(){
      try {
        return defineProperty({}, 'a', {get: function(){ return 2 }}).a == 2;
      } catch(e){}
    }()
  , sid    = 0
  , hidden = createDefiner(1)
  , set    = Symbol ? simpleSet : hidden
  , safeSymbol = Symbol || uid;
function assignHidden(target, src){
  for(var key in src)hidden(target, key, src[key]);
  return target;
}

var SYMBOL_UNSCOPABLES = getWellKnownSymbol('unscopables')
  , ArrayUnscopables   = ArrayProto[SYMBOL_UNSCOPABLES] || {}
  , SYMBOL_TAG         = getWellKnownSymbol(TO_STRING_TAG)
  , SYMBOL_SPECIES     = getWellKnownSymbol('species')
  , SYMBOL_ITERATOR;
function setSpecies(C){
  if(DESC && (framework || !isNative(C)))defineProperty(C, SYMBOL_SPECIES, {
    configurable: true,
    get: returnThis
  });
}

/******************************************************************************
 * Module : common.export                                                     *
 ******************************************************************************/

var NODE = cof(process) == PROCESS
  , core = {}
  , path = framework ? global : core
  , old  = global.core
  , exportGlobal
  // type bitmap
  , FORCED = 1
  , GLOBAL = 2
  , STATIC = 4
  , PROTO  = 8
  , BIND   = 16
  , WRAP   = 32;
function $define(type, name, source){
  var key, own, out, exp
    , isGlobal = type & GLOBAL
    , target   = isGlobal ? global : (type & STATIC)
        ? global[name] : (global[name] || ObjectProto)[PROTOTYPE]
    , exports  = isGlobal ? core : core[name] || (core[name] = {});
  if(isGlobal)source = name;
  for(key in source){
    // there is a similar native
    own = !(type & FORCED) && target && key in target
      && (!isFunction(target[key]) || isNative(target[key]));
    // export native or passed
    out = (own ? target : source)[key];
    // prevent global pollution for namespaces
    if(!framework && isGlobal && !isFunction(target[key]))exp = source[key];
    // bind timers to global for call from export context
    else if(type & BIND && own)exp = ctx(out, global);
    // wrap global constructors for prevent change them in library
    else if(type & WRAP && !framework && target[key] == out){
      exp = function(param){
        return this instanceof out ? new out(param) : out(param);
      }
      exp[PROTOTYPE] = out[PROTOTYPE];
    } else exp = type & PROTO && isFunction(out) ? ctx(call, out) : out;
    // extend global
    if(framework && target && !own){
      if(isGlobal)target[key] = out;
      else delete target[key] && hidden(target, key, out);
    }
    // export
    if(exports[key] != out)hidden(exports, key, exp);
  }
}
// CommonJS export
if(typeof module != 'undefined' && module.exports)module.exports = core;
// RequireJS export
else if(isFunction(define) && define.amd)define(function(){return core});
// Export to global object
else exportGlobal = true;
if(exportGlobal || framework){
  core.noConflict = function(){
    global.core = old;
    return core;
  }
  global.core = core;
}

/******************************************************************************
 * Module : common.iterators                                                  *
 ******************************************************************************/

SYMBOL_ITERATOR = getWellKnownSymbol(ITERATOR);
var ITER  = safeSymbol('iter')
  , KEY   = 1
  , VALUE = 2
  , Iterators = {}
  , IteratorPrototype = {}
    // Safari has byggy iterators w/o `next`
  , BUGGY_ITERATORS = 'keys' in ArrayProto && !('next' in [].keys());
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
setIterator(IteratorPrototype, returnThis);
function setIterator(O, value){
  hidden(O, SYMBOL_ITERATOR, value);
  // Add iterator for FF iterator protocol
  FF_ITERATOR in ArrayProto && hidden(O, FF_ITERATOR, value);
}
function createIterator(Constructor, NAME, next, proto){
  Constructor[PROTOTYPE] = create(proto || IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
}
function defineIterator(Constructor, NAME, value, DEFAULT){
  var proto = Constructor[PROTOTYPE]
    , iter  = get(proto, SYMBOL_ITERATOR) || get(proto, FF_ITERATOR) || (DEFAULT && get(proto, DEFAULT)) || value;
  if(framework){
    // Define iterator
    setIterator(proto, iter);
    if(iter !== value){
      var iterProto = getPrototypeOf(iter.call(new Constructor));
      // Set @@toStringTag to native iterators
      setToStringTag(iterProto, NAME + ' Iterator', true);
      // FF fix
      has(proto, FF_ITERATOR) && setIterator(iterProto, returnThis);
    }
  }
  // Plug for library
  Iterators[NAME] = iter;
  // FF & v8 fix
  Iterators[NAME + ' Iterator'] = returnThis;
  return iter;
}
function defineStdIterators(Base, NAME, Constructor, next, DEFAULT, IS_SET){
  function createIter(kind){
    return function(){
      return new Constructor(this, kind);
    }
  }
  createIterator(Constructor, NAME, next);
  var entries = createIter(KEY+VALUE)
    , values  = createIter(VALUE);
  if(DEFAULT == VALUE)values = defineIterator(Base, NAME, values, 'values');
  else entries = defineIterator(Base, NAME, entries, 'entries');
  if(DEFAULT){
    $define(PROTO + FORCED * BUGGY_ITERATORS, NAME, {
      entries: entries,
      keys: IS_SET ? values : createIter(KEY),
      values: values
    });
  }
}
function iterResult(done, value){
  return {value: value, done: !!done};
}
function isIterable(it){
  var O      = Object(it)
    , Symbol = global[SYMBOL]
    , hasExt = (Symbol && Symbol[ITERATOR] || FF_ITERATOR) in O;
  return hasExt || SYMBOL_ITERATOR in O || has(Iterators, classof(O));
}
function getIterator(it){
  var Symbol  = global[SYMBOL]
    , ext     = it[Symbol && Symbol[ITERATOR] || FF_ITERATOR]
    , getIter = ext || it[SYMBOL_ITERATOR] || Iterators[classof(it)];
  return assertObject(getIter.call(it));
}
function stepCall(fn, value, entries){
  return entries ? invoke(fn, value) : fn(value);
}
function checkDangerIterClosing(fn){
  var danger = true;
  var O = {
    next: function(){ throw 1 },
    'return': function(){ danger = false }
  };
  O[SYMBOL_ITERATOR] = returnThis;
  try {
    fn(O);
  } catch(e){}
  return danger;
}
function closeIterator(iterator){
  var ret = iterator['return'];
  if(ret !== undefined)ret.call(iterator);
}
function safeIterClose(exec, iterator){
  try {
    exec(iterator);
  } catch(e){
    closeIterator(iterator);
    throw e;
  }
}
function forOf(iterable, entries, fn, that){
  safeIterClose(function(iterator){
    var f = ctx(fn, that, entries ? 2 : 1)
      , step;
    while(!(step = iterator.next()).done)if(stepCall(f, step.value, entries) === false){
      return closeIterator(iterator);
    }
  }, getIterator(iterable));
}

/******************************************************************************
 * Module : es6.symbol                                                        *
 ******************************************************************************/

// ECMAScript 6 symbols shim
!function(TAG, SymbolRegistry, AllSymbols, setter){
  // 19.4.1.1 Symbol([description])
  if(!isNative(Symbol)){
    Symbol = function(description){
      assert(!(this instanceof Symbol), SYMBOL + ' is not a ' + CONSTRUCTOR);
      var tag = uid(description)
        , sym = set(create(Symbol[PROTOTYPE]), TAG, tag);
      AllSymbols[tag] = sym;
      DESC && setter && defineProperty(ObjectProto, tag, {
        configurable: true,
        set: function(value){
          hidden(this, tag, value);
        }
      });
      return sym;
    }
    hidden(Symbol[PROTOTYPE], TO_STRING, function(){
      return this[TAG];
    });
  }
  $define(GLOBAL + WRAP, {Symbol: Symbol});
  
  var symbolStatics = {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key){
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = Symbol(key);
    },
    // 19.4.2.4 Symbol.iterator
    iterator: SYMBOL_ITERATOR || getWellKnownSymbol(ITERATOR),
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: part.call(keyOf, SymbolRegistry),
    // 19.4.2.10 Symbol.species
    species: SYMBOL_SPECIES,
    // 19.4.2.13 Symbol.toStringTag
    toStringTag: SYMBOL_TAG = getWellKnownSymbol(TO_STRING_TAG, true),
    // 19.4.2.14 Symbol.unscopables
    unscopables: SYMBOL_UNSCOPABLES,
    pure: safeSymbol,
    set: set,
    useSetter: function(){setter = true},
    useSimple: function(){setter = false}
  };
  // 19.4.2.2 Symbol.hasInstance
  // 19.4.2.3 Symbol.isConcatSpreadable
  // 19.4.2.6 Symbol.match
  // 19.4.2.8 Symbol.replace
  // 19.4.2.9 Symbol.search
  // 19.4.2.11 Symbol.split
  // 19.4.2.12 Symbol.toPrimitive
  forEach.call(array('hasInstance,isConcatSpreadable,match,replace,search,split,toPrimitive'),
    function(it){
      symbolStatics[it] = getWellKnownSymbol(it);
    }
  );
  $define(STATIC, SYMBOL, symbolStatics);
  
  setToStringTag(Symbol, SYMBOL);
  
  $define(STATIC + FORCED * !isNative(Symbol), OBJECT, {
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) || result.push(key);
      return result;
    },
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: function(it){
      var names = getNames(toObject(it)), result = [], key, i = 0;
      while(names.length > i)has(AllSymbols, key = names[i++]) && result.push(AllSymbols[key]);
      return result;
    }
  });
  
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, MATH, true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
}(safeSymbol('tag'), {}, {}, true);

/******************************************************************************
 * Module : es6.object.statics                                                *
 ******************************************************************************/

!function(){
  var objectStatic = {
    // 19.1.3.1 Object.assign(target, source)
    assign: assign,
    // 19.1.3.10 Object.is(value1, value2)
    is: function(x, y){
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    }
  };
  // 19.1.3.19 Object.setPrototypeOf(O, proto)
  // Works with __proto__ only. Old v8 can't works with null proto objects.
  '__proto__' in ObjectProto && function(buggy, set){
    try {
      set = ctx(call, getOwnDescriptor(ObjectProto, '__proto__').set, 2);
      set({}, ArrayProto);
    } catch(e){ buggy = true }
    objectStatic.setPrototypeOf = setPrototypeOf = setPrototypeOf || function(O, proto){
      assertObject(O);
      assert(proto === null || isObject(proto), proto, ": can't set as prototype!");
      if(buggy)O.__proto__ = proto;
      else set(O, proto);
      return O;
    }
  }();
  $define(STATIC, OBJECT, objectStatic);
}();

/******************************************************************************
 * Module : es6.object.prototype                                              *
 ******************************************************************************/

!function(tmp){
  // 19.1.3.6 Object.prototype.toString()
  tmp[SYMBOL_TAG] = DOT;
  if(cof(tmp) != DOT)hidden(ObjectProto, TO_STRING, function(){
    return '[object ' + classof(this) + ']';
  });
}({});

/******************************************************************************
 * Module : es6.object.statics-accept-primitives                              *
 ******************************************************************************/

!function(){
  // Object static methods accept primitives
  function wrapObjectMethod(key, MODE){
    var fn  = Object[key]
      , exp = core[OBJECT][key]
      , f   = 0
      , o   = {};
    if(!exp || isNative(exp)){
      o[key] = MODE == 1 ? function(it){
        return isObject(it) ? fn(it) : it;
      } : MODE == 2 ? function(it){
        return isObject(it) ? fn(it) : true;
      } : MODE == 3 ? function(it){
        return isObject(it) ? fn(it) : false;
      } : MODE == 4 ? function(it, key){
        return fn(toObject(it), key);
      } : function(it){
        return fn(toObject(it));
      };
      try { fn(DOT) }
      catch(e){ f = 1 }
      $define(STATIC + FORCED * f, OBJECT, o);
    }
  }
  wrapObjectMethod('freeze', 1);
  wrapObjectMethod('seal', 1);
  wrapObjectMethod('preventExtensions', 1);
  wrapObjectMethod('isFrozen', 2);
  wrapObjectMethod('isSealed', 2);
  wrapObjectMethod('isExtensible', 3);
  wrapObjectMethod('getOwnPropertyDescriptor', 4);
  wrapObjectMethod('getPrototypeOf');
  wrapObjectMethod('keys');
  wrapObjectMethod('getOwnPropertyNames');
}();

/******************************************************************************
 * Module : es6.function                                                      *
 ******************************************************************************/

!function(NAME){
  // 19.2.4.2 name
  NAME in FunctionProto || (DESC && defineProperty(FunctionProto, NAME, {
    configurable: true,
    get: function(){
      var match = String(this).match(/^\s*function ([^ (]*)/)
        , name  = match ? match[1] : '';
      has(this, NAME) || defineProperty(this, NAME, descriptor(5, name));
      return name;
    },
    set: function(value){
      has(this, NAME) || defineProperty(this, NAME, descriptor(0, value));
    }
  }));
}('name');

/******************************************************************************
 * Module : es6.number.constructor                                            *
 ******************************************************************************/

Number('0o1') && Number('0b1') || function(_Number, NumberProto){
  function toNumber(it){
    if(isObject(it))it = toPrimitive(it);
    if(typeof it == 'string' && it.length > 2 && it.charCodeAt(0) == 48){
      var binary = false;
      switch(it.charCodeAt(1)){
        case 66 : case 98  : binary = true;
        case 79 : case 111 : return parseInt(it.slice(2), binary ? 2 : 8);
      }
    } return +it;
  }
  function toPrimitive(it){
    var fn, val;
    if(isFunction(fn = it.valueOf) && !isObject(val = fn.call(it)))return val;
    if(isFunction(fn = it[TO_STRING]) && !isObject(val = fn.call(it)))return val;
    throw TypeError("Can't convert object to number");
  }
  Number = function Number(it){
    return this instanceof Number ? new _Number(toNumber(it)) : toNumber(it);
  }
  forEach.call(DESC ? getNames(_Number)
  : array('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY'), function(key){
    key in Number || defineProperty(Number, key, getOwnDescriptor(_Number, key));
  });
  Number[PROTOTYPE] = NumberProto;
  NumberProto[CONSTRUCTOR] = Number;
  hidden(global, NUMBER, Number);
}(Number, Number[PROTOTYPE]);

/******************************************************************************
 * Module : es6.number.statics                                                *
 ******************************************************************************/

!function(isInteger){
  $define(STATIC, NUMBER, {
    // 20.1.2.1 Number.EPSILON
    EPSILON: pow(2, -52),
    // 20.1.2.2 Number.isFinite(number)
    isFinite: function(it){
      return typeof it == 'number' && isFinite(it);
    },
    // 20.1.2.3 Number.isInteger(number)
    isInteger: isInteger,
    // 20.1.2.4 Number.isNaN(number)
    isNaN: sameNaN,
    // 20.1.2.5 Number.isSafeInteger(number)
    isSafeInteger: function(number){
      return isInteger(number) && abs(number) <= MAX_SAFE_INTEGER;
    },
    // 20.1.2.6 Number.MAX_SAFE_INTEGER
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    // 20.1.2.10 Number.MIN_SAFE_INTEGER
    MIN_SAFE_INTEGER: -MAX_SAFE_INTEGER,
    // 20.1.2.12 Number.parseFloat(string)
    parseFloat: parseFloat,
    // 20.1.2.13 Number.parseInt(string, radix)
    parseInt: parseInt
  });
// 20.1.2.3 Number.isInteger(number)
}(Number.isInteger || function(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
});

/******************************************************************************
 * Module : es6.math                                                          *
 ******************************************************************************/

// ECMAScript 6 shim
!function(){
  // 20.2.2.28 Math.sign(x)
  var E    = Math.E
    , exp  = Math.exp
    , log  = Math.log
    , sqrt = Math.sqrt
    , sign = Math.sign || function(x){
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
  
  // 20.2.2.5 Math.asinh(x)
  function asinh(x){
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
  }
  // 20.2.2.14 Math.expm1(x)
  function expm1(x){
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
  }
    
  $define(STATIC, MATH, {
    // 20.2.2.3 Math.acosh(x)
    acosh: function(x){
      return (x = +x) < 1 ? NaN : isFinite(x) ? log(x / E + sqrt(x + 1) * sqrt(x - 1) / E) + 1 : x;
    },
    // 20.2.2.5 Math.asinh(x)
    asinh: asinh,
    // 20.2.2.7 Math.atanh(x)
    atanh: function(x){
      return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
    },
    // 20.2.2.9 Math.cbrt(x)
    cbrt: function(x){
      return sign(x = +x) * pow(abs(x), 1 / 3);
    },
    // 20.2.2.11 Math.clz32(x)
    clz32: function(x){
      return (x >>>= 0) ? 32 - x[TO_STRING](2).length : 32;
    },
    // 20.2.2.12 Math.cosh(x)
    cosh: function(x){
      return (exp(x = +x) + exp(-x)) / 2;
    },
    // 20.2.2.14 Math.expm1(x)
    expm1: expm1,
    // 20.2.2.16 Math.fround(x)
    // TODO: fallback for IE9-
    fround: function(x){
      return new Float32Array([x])[0];
    },
    // 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])
    hypot: function(value1, value2){
      var sum  = 0
        , len1 = arguments.length
        , len2 = len1
        , args = Array(len1)
        , larg = -Infinity
        , arg;
      while(len1--){
        arg = args[len1] = +arguments[len1];
        if(arg == Infinity || arg == -Infinity)return Infinity;
        if(arg > larg)larg = arg;
      }
      larg = arg || 1;
      while(len2--)sum += pow(args[len2] / larg, 2);
      return larg * sqrt(sum);
    },
    // 20.2.2.18 Math.imul(x, y)
    imul: function(x, y){
      var UInt16 = 0xffff
        , xn = +x
        , yn = +y
        , xl = UInt16 & xn
        , yl = UInt16 & yn;
      return 0 | xl * yl + ((UInt16 & xn >>> 16) * yl + xl * (UInt16 & yn >>> 16) << 16 >>> 0);
    },
    // 20.2.2.20 Math.log1p(x)
    log1p: function(x){
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
    },
    // 20.2.2.21 Math.log10(x)
    log10: function(x){
      return log(x) / Math.LN10;
    },
    // 20.2.2.22 Math.log2(x)
    log2: function(x){
      return log(x) / Math.LN2;
    },
    // 20.2.2.28 Math.sign(x)
    sign: sign,
    // 20.2.2.30 Math.sinh(x)
    sinh: function(x){
      return (abs(x = +x) < 1) ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
    },
    // 20.2.2.33 Math.tanh(x)
    tanh: function(x){
      var a = expm1(x = +x)
        , b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    },
    // 20.2.2.34 Math.trunc(x)
    trunc: trunc
  });
}();

/******************************************************************************
 * Module : es6.string                                                        *
 ******************************************************************************/

!function(fromCharCode){
  function assertNotRegExp(it){
    if(cof(it) == REGEXP)throw TypeError();
  }
  
  $define(STATIC, STRING, {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function(x){
      var res = []
        , len = arguments.length
        , i   = 0
        , code
      while(len > i){
        code = +arguments[i++];
        if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000
          ? fromCharCode(code)
          : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
        );
      } return res.join('');
    },
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function(callSite){
      var raw = toObject(callSite.raw)
        , len = toLength(raw.length)
        , sln = arguments.length
        , res = []
        , i   = 0;
      while(len > i){
        res.push(String(raw[i++]));
        if(i < sln)res.push(String(arguments[i]));
      } return res.join('');
    }
  });
  
  $define(PROTO, STRING, {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: createPointAt(false),
    // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
    endsWith: function(searchString /*, endPosition = @length */){
      assertNotRegExp(searchString);
      var that = String(assertDefined(this))
        , endPosition = arguments[1]
        , len = toLength(that.length)
        , end = endPosition === undefined ? len : min(toLength(endPosition), len);
      searchString += '';
      return that.slice(end - searchString.length, end) === searchString;
    },
    // 21.1.3.7 String.prototype.includes(searchString, position = 0)
    includes: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      return !!~String(assertDefined(this)).indexOf(searchString, arguments[1]);
    },
    // 21.1.3.13 String.prototype.repeat(count)
    repeat: function(count){
      var str = String(assertDefined(this))
        , res = ''
        , n   = toInteger(count);
      if(0 > n || n == Infinity)throw RangeError("Count can't be negative");
      for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
      return res;
    },
    // 21.1.3.18 String.prototype.startsWith(searchString [, position ])
    startsWith: function(searchString /*, position = 0 */){
      assertNotRegExp(searchString);
      var that  = String(assertDefined(this))
        , index = toLength(min(arguments[1], that.length));
      searchString += '';
      return that.slice(index, index + searchString.length) === searchString;
    }
  });
}(String.fromCharCode);

/******************************************************************************
 * Module : es6.array.statics                                                 *
 ******************************************************************************/

!function(){
  $define(STATIC + FORCED * checkDangerIterClosing(Array.from), ARRAY, {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
      var O       = Object(assertDefined(arrayLike))
        , mapfn   = arguments[1]
        , mapping = mapfn !== undefined
        , f       = mapping ? ctx(mapfn, arguments[2], 2) : undefined
        , index   = 0
        , length, result, step;
      if(isIterable(O)){
        result = new (generic(this, Array));
        safeIterClose(function(iterator){
          for(; !(step = iterator.next()).done; index++){
            result[index] = mapping ? f(step.value, index) : step.value;
          }
        }, getIterator(O));
      } else {
        result = new (generic(this, Array))(length = toLength(O.length));
        for(; length > index; index++){
          result[index] = mapping ? f(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }
  });
  
  $define(STATIC, ARRAY, {
    // 22.1.2.3 Array.of( ...items)
    of: function(/* ...args */){
      var index  = 0
        , length = arguments.length
        , result = new (generic(this, Array))(length);
      while(length > index)result[index] = arguments[index++];
      result.length = length;
      return result;
    }
  });
  
  setSpecies(Array);
}();

/******************************************************************************
 * Module : es6.array.prototype                                               *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
    copyWithin: function(target /* = 0 */, start /* = 0, end = @length */){
      var O     = Object(assertDefined(this))
        , len   = toLength(O.length)
        , to    = toIndex(target, len)
        , from  = toIndex(start, len)
        , end   = arguments[2]
        , fin   = end === undefined ? len : toIndex(end, len)
        , count = min(fin - from, len - to)
        , inc   = 1;
      if(from < to && to < from + count){
        inc  = -1;
        from = from + count - 1;
        to   = to + count - 1;
      }
      while(count-- > 0){
        if(from in O)O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
      } return O;
    },
    // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
    fill: function(value /*, start = 0, end = @length */){
      var O      = Object(assertDefined(this))
        , length = toLength(O.length)
        , index  = toIndex(arguments[1], length)
        , end    = arguments[2]
        , endPos = end === undefined ? length : toIndex(end, length);
      while(endPos > index)O[index++] = value;
      return O;
    },
    // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
    find: createArrayMethod(5),
    // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
    findIndex: createArrayMethod(6)
  });
  
  if(framework){
    // 22.1.3.31 Array.prototype[@@unscopables]
    forEach.call(array('find,findIndex,fill,copyWithin,entries,keys,values'), function(it){
      ArrayUnscopables[it] = true;
    });
    SYMBOL_UNSCOPABLES in ArrayProto || hidden(ArrayProto, SYMBOL_UNSCOPABLES, ArrayUnscopables);
  }
}();

/******************************************************************************
 * Module : es6.iterators                                                     *
 ******************************************************************************/

!function(at){
  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  defineStdIterators(Array, ARRAY, function(iterated, kind){
    set(this, ITER, {o: toObject(iterated), i: 0, k: kind});
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , kind  = iter.k
      , index = iter.i++;
    if(!O || index >= O.length){
      iter.o = undefined;
      return iterResult(1);
    }
    if(kind == KEY)  return iterResult(0, index);
    if(kind == VALUE)return iterResult(0, O[index]);
                     return iterResult(0, [index, O[index]]);
  }, VALUE);
  
  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators[ARGUMENTS] = Iterators[ARRAY];
  
  // 21.1.3.27 String.prototype[@@iterator]()
  defineStdIterators(String, STRING, function(iterated){
    set(this, ITER, {o: String(iterated), i: 0});
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function(){
    var iter  = this[ITER]
      , O     = iter.o
      , index = iter.i
      , point;
    if(index >= O.length)return iterResult(1);
    point = at.call(O, index);
    iter.i += point.length;
    return iterResult(0, point);
  });
}(createPointAt(true));

/******************************************************************************
 * Module : es6.regexp                                                        *
 ******************************************************************************/

DESC && !function(RegExpProto, _RegExp){  
  // RegExp allows a regex with flags as the pattern
  if(!function(){try{return RegExp(/a/g, 'i') == '/a/i'}catch(e){}}()){
    RegExp = function RegExp(pattern, flags){
      return new _RegExp(cof(pattern) == REGEXP && flags !== undefined
        ? pattern.source : pattern, flags);
    }
    forEach.call(getNames(_RegExp), function(key){
      key in RegExp || defineProperty(RegExp, key, {
        configurable: true,
        get: function(){ return _RegExp[key] },
        set: function(it){ _RegExp[key] = it }
      });
    });
    RegExpProto[CONSTRUCTOR] = RegExp;
    RegExp[PROTOTYPE] = RegExpProto;
    hidden(global, REGEXP, RegExp);
  }
  
  // 21.2.5.3 get RegExp.prototype.flags()
  if(/./g.flags != 'g')defineProperty(RegExpProto, 'flags', {
    configurable: true,
    get: createReplacer(/^.*\/(\w*)$/, '$1')
  });
  
  setSpecies(RegExp);
}(RegExp[PROTOTYPE], RegExp);

/******************************************************************************
 * Module : web.immediate                                                     *
 ******************************************************************************/

// setImmediate shim
// Node.js 0.9+ & IE10+ has setImmediate, else:
isFunction(setImmediate) && isFunction(clearImmediate) || function(ONREADYSTATECHANGE){
  var postMessage      = global.postMessage
    , addEventListener = global.addEventListener
    , MessageChannel   = global.MessageChannel
    , counter          = 0
    , queue            = {}
    , defer, channel, port;
  setImmediate = function(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(isFunction(fn) ? fn : Function(fn), args);
    }
    defer(counter);
    return counter;
  }
  clearImmediate = function(id){
    delete queue[id];
  }
  function run(id){
    if(has(queue, id)){
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  }
  function listner(event){
    run(event.data);
  }
  // Node.js 0.8-
  if(NODE){
    defer = function(id){
      nextTick(part.call(run, id));
    }
  // Modern browsers, skip implementation for WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is object
  } else if(addEventListener && isFunction(postMessage) && !global.importScripts){
    defer = function(id){
      postMessage(id, '*');
    }
    addEventListener('message', listner, false);
  // WebWorkers
  } else if(isFunction(MessageChannel)){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listner;
    defer = ctx(port.postMessage, port, 1);
  // IE8-
  } else if(document && ONREADYSTATECHANGE in document[CREATE_ELEMENT]('script')){
    defer = function(id){
      html.appendChild(document[CREATE_ELEMENT]('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run(id);
      }
    }
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(run, 0, id);
    }
  }
}('onreadystatechange');
$define(GLOBAL + BIND, {
  setImmediate:   setImmediate,
  clearImmediate: clearImmediate
});

/******************************************************************************
 * Module : es6.promise                                                       *
 ******************************************************************************/

// ES6 promises shim
// Based on https://github.com/getify/native-promise-only/
!function(Promise, test){
  isFunction(Promise) && isFunction(Promise.resolve)
  && Promise.resolve(test = new Promise(function(){})) == test
  || function(asap, RECORD){
    function isThenable(it){
      var then;
      if(isObject(it))then = it.then;
      return isFunction(then) ? then : false;
    }
    function handledRejectionOrHasOnRejected(promise){
      var record = promise[RECORD]
        , chain  = record.c
        , i      = 0
        , react;
      if(record.h)return true;
      while(chain.length > i){
        react = chain[i++];
        if(react.fail || handledRejectionOrHasOnRejected(react.P))return true;
      }
    }
    function notify(record, reject){
      var chain = record.c;
      if(reject || chain.length)asap(function(){
        var promise = record.p
          , value   = record.v
          , ok      = record.s == 1
          , i       = 0;
        if(reject && !handledRejectionOrHasOnRejected(promise)){
          setTimeout(function(){
            if(!handledRejectionOrHasOnRejected(promise)){
              if(NODE){
                if(!process.emit('unhandledRejection', value, promise)){
                  // default node.js behavior
                }
              } else if(isFunction(console.error)){
                console.error('Unhandled promise rejection', value);
              }
            }
          }, 1e3);
        } else while(chain.length > i)!function(react){
          var cb = ok ? react.ok : react.fail
            , ret, then;
          try {
            if(cb){
              if(!ok)record.h = true;
              ret = cb === true ? value : cb(value);
              if(ret === react.P){
                react.rej(TypeError(PROMISE + '-chain cycle'));
              } else if(then = isThenable(ret)){
                then.call(ret, react.res, react.rej);
              } else react.res(ret);
            } else react.rej(value);
          } catch(err){
            react.rej(err);
          }
        }(chain[i++]);
        chain.length = 0;
      });
    }
    function resolve(value){
      var record = this
        , then, wrapper;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      try {
        if(then = isThenable(value)){
          wrapper = {r: record, d: false}; // wrap
          then.call(value, ctx(resolve, wrapper, 1), ctx(reject, wrapper, 1));
        } else {
          record.v = value;
          record.s = 1;
          notify(record);
        }
      } catch(err){
        reject.call(wrapper || {r: record, d: false}, err); // wrap
      }
    }
    function reject(value){
      var record = this;
      if(record.d)return;
      record.d = true;
      record = record.r || record; // unwrap
      record.v = value;
      record.s = 2;
      notify(record, true);
    }
    function getConstructor(C){
      var S = assertObject(C)[SYMBOL_SPECIES];
      return S != undefined ? S : C;
    }
    // 25.4.3.1 Promise(executor)
    Promise = function(executor){
      assertFunction(executor);
      assertInstance(this, Promise, PROMISE);
      var record = {
        p: this,      // promise
        c: [],        // chain
        s: 0,         // state
        d: false,     // done
        v: undefined, // value
        h: false      // handled rejection
      };
      hidden(this, RECORD, record);
      try {
        executor(ctx(resolve, record, 1), ctx(reject, record, 1));
      } catch(err){
        reject.call(record, err);
      }
    }
    assignHidden(Promise[PROTOTYPE], {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function(onFulfilled, onRejected){
        var S = assertObject(assertObject(this)[CONSTRUCTOR])[SYMBOL_SPECIES];
        var react = {
          ok:   isFunction(onFulfilled) ? onFulfilled : true,
          fail: isFunction(onRejected)  ? onRejected  : false
        } , P = react.P = new (S != undefined ? S : Promise)(function(resolve, reject){
          react.res = assertFunction(resolve);
          react.rej = assertFunction(reject);
        }), record = this[RECORD];
        record.c.push(react);
        record.s && notify(record);
        return P;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function(onRejected){
        return this.then(undefined, onRejected);
      }
    });
    assignHidden(Promise, {
      // 25.4.4.1 Promise.all(iterable)
      all: function(iterable){
        var Promise = getConstructor(this)
          , values  = [];
        return new Promise(function(resolve, reject){
          forOf(iterable, false, push, values);
          var remaining = values.length
            , results   = Array(remaining);
          if(remaining)forEach.call(values, function(promise, index){
            Promise.resolve(promise).then(function(value){
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });
          else resolve(results);
        });
      },
      // 25.4.4.4 Promise.race(iterable)
      race: function(iterable){
        var Promise = getConstructor(this);
        return new Promise(function(resolve, reject){
          forOf(iterable, false, function(promise){
            Promise.resolve(promise).then(resolve, reject);
          });
        });
      },
      // 25.4.4.5 Promise.reject(r)
      reject: function(r){
        return new (getConstructor(this))(function(resolve, reject){
          reject(r);
        });
      },
      // 25.4.4.6 Promise.resolve(x)
      resolve: function(x){
        return isObject(x) && RECORD in x && getPrototypeOf(x) === this[PROTOTYPE]
          ? x : new (getConstructor(this))(function(resolve, reject){
            resolve(x);
          });
      }
    });
  }(nextTick || setImmediate, safeSymbol('record'));
  setToStringTag(Promise, PROMISE);
  setSpecies(Promise);
  $define(GLOBAL + FORCED * !isNative(Promise), {Promise: Promise});
}(global[PROMISE]);

/******************************************************************************
 * Module : es6.collections                                                   *
 ******************************************************************************/

// ECMAScript 6 collections shim
!function(){
  var UID   = safeSymbol('uid')
    , O1    = safeSymbol('O1')
    , WEAK  = safeSymbol('weak')
    , LEAK  = safeSymbol('leak')
    , LAST  = safeSymbol('last')
    , FIRST = safeSymbol('first')
    , SIZE  = DESC ? safeSymbol('size') : 'size'
    , uid   = 0
    , tmp   = {};
  
  function getCollection(C, NAME, methods, commonMethods, isMap, isWeak){
    var ADDER = isMap ? 'set' : 'add'
      , proto = C && C[PROTOTYPE]
      , O     = {};
    function initFromIterable(that, iterable){
      if(iterable != undefined)forOf(iterable, isMap, that[ADDER], that);
      return that;
    }
    function fixSVZ(key, chain){
      var method = proto[key];
      if(framework)proto[key] = function(a, b){
        var result = method.call(this, a === 0 ? 0 : a, b);
        return chain ? this : result;
      };
    }
    if(!isNative(C) || !(isWeak || (!BUGGY_ITERATORS && has(proto, FOR_EACH) && has(proto, 'entries')))){
      // create collection constructor
      C = isWeak
        ? function(iterable){
            assertInstance(this, C, NAME);
            set(this, UID, uid++);
            initFromIterable(this, iterable);
          }
        : function(iterable){
            var that = this;
            assertInstance(that, C, NAME);
            set(that, O1, create(null));
            set(that, SIZE, 0);
            set(that, LAST, undefined);
            set(that, FIRST, undefined);
            initFromIterable(that, iterable);
          };
      assignHidden(assignHidden(C[PROTOTYPE], methods), commonMethods);
      isWeak || !DESC || defineProperty(C[PROTOTYPE], 'size', {get: function(){
        return assertDefined(this[SIZE]);
      }});
    } else {
      var Native = C
        , inst   = new C
        , chain  = inst[ADDER](isWeak ? {} : -0, 1)
        , buggyZero;
      // wrap to init collections from iterable
      if(checkDangerIterClosing(function(O){ new C(O) })){
        C = function(iterable){
          assertInstance(this, C, NAME);
          return initFromIterable(new Native, iterable);
        }
        C[PROTOTYPE] = proto;
        if(framework)proto[CONSTRUCTOR] = C;
      }
      isWeak || inst[FOR_EACH](function(val, key){
        buggyZero = 1 / key === -Infinity;
      });
      // fix converting -0 key to +0
      if(buggyZero){
        fixSVZ('delete');
        fixSVZ('has');
        isMap && fixSVZ('get');
      }
      // + fix .add & .set for chaining
      if(buggyZero || chain !== inst)fixSVZ(ADDER, true);
    }
    setToStringTag(C, NAME);
    setSpecies(C);
    
    O[NAME] = C;
    $define(GLOBAL + WRAP + FORCED * !isNative(C), O);
    
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    isWeak || defineStdIterators(C, NAME, function(iterated, kind){
      set(this, ITER, {o: iterated, k: kind});
    }, function(){
      var iter  = this[ITER]
        , kind  = iter.k
        , entry = iter.l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!iter.o || !(iter.l = entry = entry ? entry.n : iter.o[FIRST])){
        // or finish the iteration
        iter.o = undefined;
        return iterResult(1);
      }
      // return step by kind
      if(kind == KEY)  return iterResult(0, entry.k);
      if(kind == VALUE)return iterResult(0, entry.v);
                       return iterResult(0, [entry.k, entry.v]);   
    }, isMap ? KEY+VALUE : VALUE, !isMap);
    
    return C;
  }
  
  function fastKey(it, create){
    // return primitive with prefix
    if(!isObject(it))return (typeof it == 'string' ? 'S' : 'P') + it;
    // can't set id to frozen object
    if(isFrozen(it))return 'F';
    if(!has(it, UID)){
      // not necessary to add id
      if(!create)return 'E';
      // add missing object id
      hidden(it, UID, ++uid);
    // return object id with prefix
    } return 'O' + it[UID];
  }
  function getEntry(that, key){
    // fast case
    var index = fastKey(key), entry;
    if(index != 'F')return that[O1][index];
    // frozen object case
    for(entry = that[FIRST]; entry; entry = entry.n){
      if(entry.k == key)return entry;
    }
  }
  function def(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry)entry.v = value;
    // create new entry
    else {
      that[LAST] = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that[LAST],          // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that[FIRST])that[FIRST] = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index != 'F')that[O1][index] = entry;
    } return that;
  }

  var collectionMethods = {
    // 23.1.3.1 Map.prototype.clear()
    // 23.2.3.2 Set.prototype.clear()
    clear: function(){
      for(var that = this, data = that[O1], entry = that[FIRST]; entry; entry = entry.n){
        entry.r = true;
        if(entry.p)entry.p = entry.p.n = undefined;
        delete data[entry.i];
      }
      that[FIRST] = that[LAST] = undefined;
      that[SIZE] = 0;
    },
    // 23.1.3.3 Map.prototype.delete(key)
    // 23.2.3.4 Set.prototype.delete(value)
    'delete': function(key){
      var that  = this
        , entry = getEntry(that, key);
      if(entry){
        var next = entry.n
          , prev = entry.p;
        delete that[O1][entry.i];
        entry.r = true;
        if(prev)prev.n = next;
        if(next)next.p = prev;
        if(that[FIRST] == entry)that[FIRST] = next;
        if(that[LAST] == entry)that[LAST] = prev;
        that[SIZE]--;
      } return !!entry;
    },
    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
    forEach: function(callbackfn /*, that = undefined */){
      var f = ctx(callbackfn, arguments[1], 3)
        , entry;
      while(entry = entry ? entry.n : this[FIRST]){
        f(entry.v, entry.k, this);
        // revert to the last existing entry
        while(entry && entry.r)entry = entry.p;
      }
    },
    // 23.1.3.7 Map.prototype.has(key)
    // 23.2.3.7 Set.prototype.has(value)
    has: function(key){
      return !!getEntry(this, key);
    }
  }
  
  // 23.1 Map Objects
  Map = getCollection(Map, MAP, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function(key){
      var entry = getEntry(this, key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function(key, value){
      return def(this, key === 0 ? 0 : key, value);
    }
  }, collectionMethods, true);
  
  // 23.2 Set Objects
  Set = getCollection(Set, SET, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function(value){
      return def(this, value = value === 0 ? 0 : value, value);
    }
  }, collectionMethods);
  
  function defWeak(that, key, value){
    if(isFrozen(assertObject(key)))leakStore(that).set(key, value);
    else {
      has(key, WEAK) || hidden(key, WEAK, {});
      key[WEAK][that[UID]] = value;
    } return that;
  }
  function leakStore(that){
    return that[LEAK] || hidden(that, LEAK, new Map)[LEAK];
  }
  
  var weakMethods = {
    // 23.3.3.2 WeakMap.prototype.delete(key)
    // 23.4.3.3 WeakSet.prototype.delete(value)
    'delete': function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this)['delete'](key);
      return has(key, WEAK) && has(key[WEAK], this[UID]) && delete key[WEAK][this[UID]];
    },
    // 23.3.3.4 WeakMap.prototype.has(key)
    // 23.4.3.4 WeakSet.prototype.has(value)
    has: function(key){
      if(!isObject(key))return false;
      if(isFrozen(key))return leakStore(this).has(key);
      return has(key, WEAK) && has(key[WEAK], this[UID]);
    }
  };
  
  // 23.3 WeakMap Objects
  WeakMap = getCollection(WeakMap, WEAKMAP, {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function(key){
      if(isObject(key)){
        if(isFrozen(key))return leakStore(this).get(key);
        if(has(key, WEAK))return key[WEAK][this[UID]];
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function(key, value){
      return defWeak(this, key, value);
    }
  }, weakMethods, true, true);
  
  // IE11 WeakMap frozen keys fix
  if(framework && new WeakMap().set(Object.freeze(tmp), 7).get(tmp) != 7){
    forEach.call(array('delete,has,get,set'), function(key){
      var method = WeakMap[PROTOTYPE][key];
      WeakMap[PROTOTYPE][key] = function(a, b){
        // store frozen objects on leaky map
        if(isObject(a) && isFrozen(a)){
          var result = leakStore(this)[key](a, b);
          return key == 'set' ? this : result;
        // store all the rest on native weakmap
        } return method.call(this, a, b);
      };
    });
  }
  
  // 23.4 WeakSet Objects
  WeakSet = getCollection(WeakSet, WEAKSET, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function(value){
      return defWeak(this, value, true);
    }
  }, weakMethods, false, true);
}();

/******************************************************************************
 * Module : es6.reflect                                                       *
 ******************************************************************************/

!function(){
  function Enumerate(iterated){
    var keys = [], key;
    for(key in iterated)keys.push(key);
    set(this, ITER, {o: iterated, a: keys, i: 0});
  }
  createIterator(Enumerate, OBJECT, function(){
    var iter = this[ITER]
      , keys = iter.a
      , key;
    do {
      if(iter.i >= keys.length)return iterResult(1);
    } while(!((key = keys[iter.i++]) in iter.o));
    return iterResult(0, key);
  });
  
  function wrap(fn){
    return function(it){
      assertObject(it);
      try {
        return fn.apply(undefined, arguments), true;
      } catch(e){
        return false;
      }
    }
  }
  
  function reflectGet(target, propertyKey/*, receiver*/){
    var receiver = arguments.length < 3 ? target : arguments[2]
      , desc = getOwnDescriptor(assertObject(target), propertyKey), proto;
    if(desc)return has(desc, 'value')
      ? desc.value
      : desc.get === undefined
        ? undefined
        : desc.get.call(receiver);
    return isObject(proto = getPrototypeOf(target))
      ? reflectGet(proto, propertyKey, receiver)
      : undefined;
  }
  function reflectSet(target, propertyKey, V/*, receiver*/){
    var receiver = arguments.length < 4 ? target : arguments[3]
      , ownDesc  = getOwnDescriptor(assertObject(target), propertyKey)
      , existingDescriptor, proto;
    if(!ownDesc){
      if(isObject(proto = getPrototypeOf(target))){
        return reflectSet(proto, propertyKey, V, receiver);
      }
      ownDesc = descriptor(0);
    }
    if(has(ownDesc, 'value')){
      if(ownDesc.writable === false || !isObject(receiver))return false;
      existingDescriptor = getOwnDescriptor(receiver, propertyKey) || descriptor(0);
      existingDescriptor.value = V;
      return defineProperty(receiver, propertyKey, existingDescriptor), true;
    }
    return ownDesc.set === undefined
      ? false
      : (ownDesc.set.call(receiver, V), true);
  }
  var isExtensible = Object.isExtensible || returnIt;
  
  var reflect = {
    // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
    apply: ctx(call, apply, 3),
    // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
    construct: function(target, argumentsList /*, newTarget*/){
      var proto    = assertFunction(arguments.length < 3 ? target : arguments[2])[PROTOTYPE]
        , instance = create(isObject(proto) ? proto : ObjectProto)
        , result   = apply.call(target, instance, argumentsList);
      return isObject(result) ? result : instance;
    },
    // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
    defineProperty: wrap(defineProperty),
    // 26.1.4 Reflect.deleteProperty(target, propertyKey)
    deleteProperty: function(target, propertyKey){
      var desc = getOwnDescriptor(assertObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    },
    // 26.1.5 Reflect.enumerate(target)
    enumerate: function(target){
      return new Enumerate(assertObject(target));
    },
    // 26.1.6 Reflect.get(target, propertyKey [, receiver])
    get: reflectGet,
    // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
    getOwnPropertyDescriptor: function(target, propertyKey){
      return getOwnDescriptor(assertObject(target), propertyKey);
    },
    // 26.1.8 Reflect.getPrototypeOf(target)
    getPrototypeOf: function(target){
      return getPrototypeOf(assertObject(target));
    },
    // 26.1.9 Reflect.has(target, propertyKey)
    has: function(target, propertyKey){
      return propertyKey in target;
    },
    // 26.1.10 Reflect.isExtensible(target)
    isExtensible: function(target){
      return !!isExtensible(assertObject(target));
    },
    // 26.1.11 Reflect.ownKeys(target)
    ownKeys: ownKeys,
    // 26.1.12 Reflect.preventExtensions(target)
    preventExtensions: wrap(Object.preventExtensions || returnIt),
    // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
    set: reflectSet
  }
  // 26.1.14 Reflect.setPrototypeOf(target, proto)
  if(setPrototypeOf)reflect.setPrototypeOf = function(target, proto){
    return setPrototypeOf(assertObject(target), proto), true;
  };
  
  $define(GLOBAL, {Reflect: {}});
  $define(STATIC, 'Reflect', reflect);
}();

/******************************************************************************
 * Module : es7.proposals                                                     *
 ******************************************************************************/

!function(){
  $define(PROTO, ARRAY, {
    // https://github.com/domenic/Array.prototype.includes
    includes: createArrayContains(true)
  });
  $define(PROTO, STRING, {
    // https://github.com/mathiasbynens/String.prototype.at
    at: createPointAt(true)
  });
  
  function createObjectToArray(isEntries){
    return function(object){
      var O      = toObject(object)
        , keys   = getKeys(object)
        , length = keys.length
        , i      = 0
        , result = Array(length)
        , key;
      if(isEntries)while(length > i)result[i] = [key = keys[i++], O[key]];
      else while(length > i)result[i] = O[keys[i++]];
      return result;
    }
  }
  $define(STATIC, OBJECT, {
    // https://gist.github.com/WebReflection/9353781
    getOwnPropertyDescriptors: function(object){
      var O      = toObject(object)
        , result = {};
      forEach.call(ownKeys(O), function(key){
        defineProperty(result, key, descriptor(0, getOwnDescriptor(O, key)));
      });
      return result;
    },
    // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues
    values:  createObjectToArray(false),
    entries: createObjectToArray(true)
  });
  $define(STATIC, REGEXP, {
    // https://gist.github.com/kangax/9698100
    escape: createReplacer(/([\\\-[\]{}()*+?.,^$|])/g, '\\$1', true)
  });
}();

/******************************************************************************
 * Module : es7.abstract-refs                                                 *
 ******************************************************************************/

// https://github.com/zenparsing/es-abstract-refs
!function(REFERENCE){
  REFERENCE_GET = getWellKnownSymbol(REFERENCE+'Get', true);
  var REFERENCE_SET = getWellKnownSymbol(REFERENCE+SET, true)
    , REFERENCE_DELETE = getWellKnownSymbol(REFERENCE+'Delete', true);
  
  $define(STATIC, SYMBOL, {
    referenceGet: REFERENCE_GET,
    referenceSet: REFERENCE_SET,
    referenceDelete: REFERENCE_DELETE
  });
  
  hidden(FunctionProto, REFERENCE_GET, returnThis);
  
  function setMapMethods(Constructor){
    if(Constructor){
      var MapProto = Constructor[PROTOTYPE];
      hidden(MapProto, REFERENCE_GET, MapProto.get);
      hidden(MapProto, REFERENCE_SET, MapProto.set);
      hidden(MapProto, REFERENCE_DELETE, MapProto['delete']);
    }
  }
  setMapMethods(Map);
  setMapMethods(WeakMap);
}('reference');

/******************************************************************************
 * Module : js.array.statics                                                  *
 ******************************************************************************/

// JavaScript 1.6 / Strawman array statics shim
!function(arrayStatics){
  function setArrayStatics(keys, length){
    forEach.call(array(keys), function(key){
      if(key in ArrayProto)arrayStatics[key] = ctx(call, ArrayProto[key], length);
    });
  }
  setArrayStatics('pop,reverse,shift,keys,values,entries', 1);
  setArrayStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setArrayStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' +
                  'reduce,reduceRight,copyWithin,fill,turn');
  $define(STATIC, ARRAY, arrayStatics);
}({});

/******************************************************************************
 * Module : web.dom.itarable                                                  *
 ******************************************************************************/

!function(NodeList){
  if(framework && NodeList && !(SYMBOL_ITERATOR in NodeList[PROTOTYPE])){
    hidden(NodeList[PROTOTYPE], SYMBOL_ITERATOR, Iterators[ARRAY]);
  }
  Iterators.NodeList = Iterators[ARRAY];
}(global.NodeList);
}(typeof self != 'undefined' && self.Math === Math ? self : Function('return this')(), true);
},{}],4:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var iteratorSymbol =
    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    return new Generator(innerFn, outerFn, self || null, tryLocsList || []);
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = "GeneratorFunction";

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    genFun.__proto__ = GeneratorFunctionPrototype;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    return new Promise(function(resolve, reject) {
      var generator = wrap(innerFn, outerFn, self, tryLocsList);
      var callNext = step.bind(generator.next);
      var callThrow = step.bind(generator["throw"]);

      function step(arg) {
        var record = tryCatch(this, null, arg);
        if (record.type === "throw") {
          reject(record.arg);
          return;
        }

        var info = record.arg;
        if (info.done) {
          resolve(info.value);
        } else {
          Promise.resolve(info.value).then(callNext, callThrow);
        }
      }

      callNext();
    });
  };

  function Generator(innerFn, outerFn, self, tryLocsList) {
    var generator = outerFn ? Object.create(outerFn.prototype) : this;
    var context = new Context(tryLocsList);
    var state = GenStateSuspendedStart;

    function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;

            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedStart &&
              typeof arg !== "undefined") {
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            throw new TypeError(
              "attempt to send " + JSON.stringify(arg) + " to newborn generator"
            );
          }

          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;

          if (method === "next") {
            context.dispatchException(record.arg);
          } else {
            arg = record.arg;
          }
        }
      }
    }

    generator.next = invoke.bind(generator, "next");
    generator["throw"] = invoke.bind(generator, "throw");
    generator["return"] = invoke.bind(generator, "return");

    return generator;
  }

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset();
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function() {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName;
           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
           ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg < finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          return this.complete(entry.completion, entry.afterLoc);
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],5:[function(require,module,exports){
'use strict'

module.exports = boxIntersectWrapper

var pool = require('typedarray-pool')
var sweep = require('./lib/sweep')
var boxIntersectIter = require('./lib/intersect')

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}


var RESULT

function appendItem(i,j) {
  RESULT.push([i,j])
}

function intersectFullArray(x) {
  RESULT = []
  boxIntersect(x, x, appendItem, true)
  return RESULT
}

function intersectBipartiteArray(x, y) {
  RESULT = []
  boxIntersect(x, y, appendItem, false)
  return RESULT
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      return intersectFullArray(arg0)
    case 2:
      if(typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true)
      } else {
        return intersectBipartiteArray(arg0, arg1)
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}
},{"./lib/intersect":7,"./lib/sweep":11,"typedarray-pool":14}],6:[function(require,module,exports){
'use strict'

var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)
},{}],7:[function(require,module,exports){
'use strict'

module.exports = boxIntersectIter

var pool = require('typedarray-pool')
var bits = require('bit-twiddle')
var bruteForce = require('./brute')
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = require('./sweep')
var findMedian = require('./median')
var genPartition = require('./partition')

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}
},{"./brute":6,"./median":8,"./partition":9,"./sweep":11,"bit-twiddle":12,"typedarray-pool":14}],8:[function(require,module,exports){
'use strict'

module.exports = findMedian

var genPartition = require('./partition')

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}
},{"./partition":9}],9:[function(require,module,exports){
'use strict'

module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}
},{}],10:[function(require,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}
},{}],11:[function(require,module,exports){
'use strict'

module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = require('typedarray-pool')
var bits  = require('bit-twiddle')
var isort = require('./sort')

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}
},{"./sort":10,"bit-twiddle":12,"typedarray-pool":14}],12:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],13:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],14:[function(require,module,exports){
(function (global,Buffer){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"bit-twiddle":12,"buffer":16,"dup":13}],15:[function(require,module,exports){

},{}],16:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":17,"ieee754":18,"is-array":19}],17:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],18:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],19:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],20:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],21:[function(require,module,exports){
'use strict';

module.exports = earcut;

function earcut(points) {

    var outerNode = linkedList(points[0], true),
        node, minX, minY, maxX, maxY, x, y, size,
        len = 0,
        threshold = 80;

    for (var i = 0; len < threshold && i < points.length; i++) len += points[i].length;

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (len >= threshold) {
        node = outerNode.next;
        minX = maxX = node.p[0];
        minY = maxY = node.p[1];
        do {
            x = node.p[0];
            y = node.p[1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            node = node.next;
        } while (node !== outerNode);

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    if (points.length > 1) outerNode = eliminateHoles(points, outerNode);

    var triangles = [];
    if (outerNode) earcutLinked(outerNode, triangles, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(points, clockwise) {
    var sum = 0,
        len = points.length,
        i, j, last;

    // calculate original winding order of a polygon ring
    for (i = 0, j = len - 1; i < len; j = i++) {
        var p1 = points[i],
            p2 = points[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }

    // link points into circular doubly-linked list in the specified winding order
    if (clockwise === (sum > 0)) {
        for (i = 0; i < len; i++) last = insertNode(points[i], last);
    } else {
        for (i = len - 1; i >= 0; i--) last = insertNode(points[i], last);
    }

    return last;
}

function filterPoints(start) {
    // eliminate colinear or duplicate points
    var node = start,
        again;
    do {
        again = false;

        if (equals(node.p, node.next.p) || orient(node.prev.p, node.p, node.next.p) === 0) {

            node.prev.next = node.next;
            node.next.prev = node.prev;

            if (node.prevZ) node.prevZ.nextZ = node.nextZ;
            if (node.nextZ) node.nextZ.prevZ = node.prevZ;

            node = start = node.prev;

            if (node === node.next) return null;
            again = true;

        } else {
            node = node.next;
        }
    } while (again || node !== start);

    return start;
}

function earcutLinked(ear, triangles, minX, minY, size, secondPass) {
    ear = filterPoints(ear);
    if (!ear) return;

    if (!secondPass && minX !== undefined) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (isEar(ear, minX, minY, size)) {
            triangles.push(prev.p, ear.p, next.p);

            next.prev = prev;
            prev.next = next;

            if (ear.prevZ) ear.prevZ.nextZ = ear.nextZ;
            if (ear.nextZ) ear.nextZ.prevZ = ear.prevZ;

            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        if (ear === stop) {
            // if we can't find any more ears, try filtering points and cutting again
            if (!secondPass) earcutLinked(ear, triangles, minX, minY, size, true);
            // if this didn't work, try splitting the remaining polygon into two
            else splitEarcut(ear, triangles, minX, minY, size);
            break;
        }
    }
}

function isEar(ear, minX, minY, size) {

    var a = ear.prev.p,
        b = ear.p,
        c = ear.next.p,

        ax = a[0], bx = b[0], cx = c[0],
        ay = a[1], by = b[1], cy = c[1],

        abd = ax * by - ay * bx,
        acd = ax * cy - ay * cx,
        cbd = cx * by - cy * bx,
        A = abd - acd - cbd;

    if (A <= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear

    var cay = cy - ay,
        acx = ax - cx,
        aby = ay - by,
        bax = bx - ax,
        p, px, py, s, t, k, node;

    // if we use z-order curve hashing, iterate through the curve
    if (minX !== undefined) {

        // triangle bbox; min & max are calculated like this for speed
        var minTX = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
            minTY = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
            maxTX = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
            maxTY = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy),

            // z-order range for the current triangle bbox;
            minZ = zOrder(minTX, minTY, minX, minY, size),
            maxZ = zOrder(maxTX, maxTY, minX, minY, size);

        // first look for points inside the triangle in increasing z-order
        node = ear.nextZ;

        while (node && node.z <= maxZ) {
            p = node.p;
            node = node.nextZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

        // then look for points in decreasing z-order
        node = ear.prevZ;

        while (node && node.z >= minZ) {
            p = node.p;
            node = node.prevZ;
            if (p === a || p === c) continue;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }

    // if we don't use z-order curve hash, simply iterate through all other points
    } else {
        node = ear.next.next;

        while (node !== ear.prev) {
            p = node.p;
            node = node.next;

            px = p[0];
            py = p[1];

            s = cay * px + acx * py - acd;
            if (s >= 0) {
                t = aby * px + bax * py + abd;
                if (t >= 0) {
                    k = A - s - t;
                    if ((k >= 0) && ((s && t) || (s && k) || (t && k))) return false;
                }
            }
        }
    }

    return true;
}

function splitEarcut(start, triangles, minX, minY, size) {
    // find a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // run earcut on each half
                earcutLinked(a, triangles, minX, minY, size);
                earcutLinked(c, triangles, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

function eliminateHoles(points, outerNode) {
    var len = points.length;

    var queue = [];
    for (var i = 1; i < len; i++) {
        var list = filterPoints(linkedList(points[i], false));
        if (list) queue.push(getLeftmost(list));
    }
    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode);
    }

    return outerNode;
}

function eliminateHole(holeNode, outerNode) {
    outerNode = findHoleBridge(holeNode, outerNode);
    if (outerNode) splitPolygon(holeNode, outerNode);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(holeNode, outerNode) {
    var node = outerNode,
        p = holeNode.p,
        px = p[0],
        py = p[1],
        qMax = -Infinity,
        mNode, a, b;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        a = node.p;
        b = node.next.p;

        if (py <= a[1] && py >= b[1]) {
            var qx = a[0] + (py - a[1]) * (b[0] - a[0]) / (b[1] - a[1]);
            if (qx <= px && qx > qMax) {
                qMax = qx;
                mNode = a[0] < b[0] ? node : node.next;
            }
        }
        node = node.next;
    } while (node !== outerNode);

    if (!mNode) return null;

    // look for points strictly inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var bx = mNode.p[0],
        by = mNode.p[1],
        pbd = px * by - py * bx,
        pcd = px * py - py * qMax,
        cpy = py - py,
        pcx = px - qMax,
        pby = py - by,
        bpx = bx - px,
        A = pbd - pcd - (qMax * by - py * bx),
        sign = A <= 0 ? -1 : 1,
        stop = mNode,
        tanMin = Infinity,
        mx, my, amx, s, t, tan;

    node = mNode.next;

    while (node !== stop) {

        mx = node.p[0];
        my = node.p[1];
        amx = px - mx;

        if (amx >= 0 && mx >= bx) {
            s = (cpy * mx + pcx * my - pcd) * sign;
            if (s >= 0) {
                t = (pby * mx + bpx * my + pbd) * sign;

                if (t >= 0 && A * sign - s - t >= 0) {
                    tan = Math.abs(py - my) / amx; // tangential
                    if (tan < tanMin && locallyInside(node, holeNode)) {
                        mNode = node;
                        tanMin = tan;
                    }
                }
            }
        }

        node = node.next;
    }

    return mNode;
}

function indexCurve(start, minX, minY, size) {
    var node = start;

    do {
        node.z = node.z || zOrder(node.p[0], node.p[1], minX, minY, size);
        node.prevZ = node.prev;
        node.nextZ = node.next;
        node = node.next;
    } while (node !== start);

    node.prevZ.nextZ = null;
    node.prevZ = null;

    sortLinked(node);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    while (true) {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;

        if (numMerges <= 1) return list;

        inSize *= 2;
    }
}

// z-order of a point given coords and bbox
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into (0..1000) integer range
    x = 1000 * (x - minX) / size;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = 1000 * (y - minY) / size;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

function getLeftmost(start) {
    var node = start,
        leftmost = start;
    do {
        if (node.p[0] < leftmost.p[0]) leftmost = node;
        node = node.next;
    } while (node !== start);

    return leftmost;
}

function isValidDiagonal(a, b) {
    return !intersectsPolygon(a, a.p, b.p) &&
           locallyInside(a, b) && locallyInside(b, a) &&
           middleInside(a, a.p, b.p);
}

// winding order of triangle formed by 3 given points
function orient(p, q, r) {
    var o = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    return o > 0 ? 1 :
           o < 0 ? -1 : 0;
}

function equals(p1, p2) {
    return p1[0] === p2[0] && p1[1] === p2[1];
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    return orient(p1, q1, p2) !== orient(p1, q1, q2) &&
           orient(p2, q2, p1) !== orient(p2, q2, q1);
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(start, a, b) {
    var node = start;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (p1 !== a && p2 !== a && p1 !== b && p2 !== b && intersects(p1, p2, a, b)) return true;

        node = node.next;
    } while (node !== start);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return orient(a.prev.p, a.p, a.next.p) === -1 ?
        orient(a.p, b.p, a.next.p) !== -1 && orient(a.p, a.prev.p, b.p) !== -1 :
        orient(a.p, b.p, a.prev.p) === -1 || orient(a.p, a.next.p, b.p) === -1;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(start, a, b) {
    var node = start,
        inside = false,
        px = (a[0] + b[0]) / 2,
        py = (a[1] + b[1]) / 2;
    do {
        var p1 = node.p,
            p2 = node.next.p;

        if (((p1[1] > py) !== (p2[1] > py)) &&
            (px < (p2[0] - p1[0]) * (py - p1[1]) / (p2[1] - p1[1]) + p1[0])) inside = !inside;

        node = node.next;
    } while (node !== start);

    return inside;
}

function compareX(a, b) {
    return a.p[0] - b.p[0];
}

// split the polygon vertices circular doubly-linked linked list into two
function splitPolygon(a, b) {
    var a2 = new Node(a.p),
        b2 = new Node(b.p),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return a2;
}

function insertNode(point, last) {
    var node = new Node(point);

    if (!last) {
        node.prev = node;
        node.next = node;

    } else {
        node.next = last.next;
        node.prev = last;
        last.next.prev = node;
        last.next = node;
    }
    return node;
}

function Node(p) {
    this.p = p;
    this.prev = null;
    this.next = null;

    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
}

},{}],22:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.1
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) {
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matricies
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/*
* Rotate a 3D vector around the x-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/*
* Rotate a 3D vector around the y-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/*
* Rotate a 3D vector around the z-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[7]-m[5])*fRoot;
        out[1] = (m[2]-m[6])*fRoot;
        out[2] = (m[3]-m[1])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);

},{}],23:[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":24}],24:[function(require,module,exports){
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');

// Deprecared schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":26,"./js-yaml/exception":27,"./js-yaml/loader":28,"./js-yaml/schema":30,"./js-yaml/schema/core":31,"./js-yaml/schema/default_full":32,"./js-yaml/schema/default_safe":33,"./js-yaml/schema/failsafe":34,"./js-yaml/schema/json":35,"./js-yaml/type":36}],25:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (undefined === subject) || (null === subject);
}


function isObject(subject) {
  return ('object' === typeof subject) && (null !== subject);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) {
    return sequence;
  } else if (isNothing(sequence)) {
    return [];
  } else {
    return [ sequence ];
  }
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],26:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');


var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */


var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';


var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];


function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (null === map) {
    return {};
  }

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if ('!!' === tag.slice(0, 2)) {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap[tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}


function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


function State(options) {
  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent      = Math.max(1, (options['indent'] || 2));
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}


function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

function writeScalar(state, object) {
  var isQuoted, checkpoint, position, length, character, first;

  state.dump = '';
  isQuoted = false;
  checkpoint = 0;
  first = object.charCodeAt(0) || 0;

  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
    // Ensure compatibility with YAML 1.0/1.1 loaders.
    isQuoted = true;
  } else if (0 === object.length) {
    // Quote empty string
    isQuoted = true;
  } else if (CHAR_SPACE    === first ||
             CHAR_SPACE    === object.charCodeAt(object.length - 1)) {
    isQuoted = true;
  } else if (CHAR_MINUS    === first ||
             CHAR_QUESTION === first) {
    // Don't check second symbol for simplicity
    isQuoted = true;
  }

  for (position = 0, length = object.length; position < length; position += 1) {
    character = object.charCodeAt(position);

    if (!isQuoted) {
      if (CHAR_TAB                  === character ||
          CHAR_LINE_FEED            === character ||
          CHAR_CARRIAGE_RETURN      === character ||
          CHAR_COMMA                === character ||
          CHAR_LEFT_SQUARE_BRACKET  === character ||
          CHAR_RIGHT_SQUARE_BRACKET === character ||
          CHAR_LEFT_CURLY_BRACKET   === character ||
          CHAR_RIGHT_CURLY_BRACKET  === character ||
          CHAR_SHARP                === character ||
          CHAR_AMPERSAND            === character ||
          CHAR_ASTERISK             === character ||
          CHAR_EXCLAMATION          === character ||
          CHAR_VERTICAL_LINE        === character ||
          CHAR_GREATER_THAN         === character ||
          CHAR_SINGLE_QUOTE         === character ||
          CHAR_DOUBLE_QUOTE         === character ||
          CHAR_PERCENT              === character ||
          CHAR_COMMERCIAL_AT        === character ||
          CHAR_COLON                === character ||
          CHAR_GRAVE_ACCENT         === character) {
        isQuoted = true;
      }
    }

    if (ESCAPE_SEQUENCES[character] ||
        !((0x00020 <= character && character <= 0x00007E) ||
          (0x00085 === character)                         ||
          (0x000A0 <= character && character <= 0x00D7FF) ||
          (0x0E000 <= character && character <= 0x00FFFD) ||
          (0x10000 <= character && character <= 0x10FFFF))) {
      state.dump += object.slice(checkpoint, position);
      state.dump += ESCAPE_SEQUENCES[character] || encodeHex(character);
      checkpoint = position + 1;
      isQuoted = true;
    }
  }

  if (checkpoint < position) {
    state.dump += object.slice(checkpoint, position);
  }

  if (!isQuoted && testImplicitResolving(state, state.dump)) {
    isQuoted = true;
  }

  if (isQuoted) {
    state.dump = '"' + state.dump + '"';
  }
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (0 !== index) {
        _result += ', ';
      }
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || 0 !== index) {
        _result += generateNextLine(state, level);
      }
      _result += '- ' + state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (0 !== index) {
      pairBuffer += ', ';
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) {
      pairBuffer += '? ';
    }

    pairBuffer += state.dump + ': ';

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || 0 !== index) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (null !== state.tag && '?' !== state.tag) ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if ('[object Function]' === _toString.call(type.represent)) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (0 > state.flowLevel || state.flowLevel > level);
  }

  if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
    compact = false;
  }

  var objectOrArray = '[object Object]' === type || '[object Array]' === type,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if ('[object Object]' === type) {
      if (block && (0 !== Object.keys(state.dump).length)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object Array]' === type) {
      if (block && (0 !== state.dump.length)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object String]' === type) {
      if ('?' !== state.tag) {
        writeScalar(state, state.dump);
      }
    } else if (state.skipInvalid) {
      return false;
    } else {
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (null !== state.tag && '?' !== state.tag) {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var type = _toString.call(object),
      objectKeyList,
      index,
      length;

  if (null !== object && 'object' === typeof object) {
    index = objects.indexOf(object);
    if (-1 !== index) {
      if (-1 === duplicatesIndexes.indexOf(index)) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
    
      if(Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) {
    return state.dump + '\n';
  } else {
    return '';
  }
}


function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":25,"./exception":27,"./schema/default_full":32,"./schema/default_safe":33}],27:[function(require,module,exports){
'use strict';


function YAMLException(reason, mark) {
  this.name    = 'YAMLException';
  this.reason  = reason;
  this.mark    = mark;
  this.message = this.toString(false);
}


YAMLException.prototype.toString = function toString(compact) {
  var result;

  result = 'JS-YAML: ' + (this.reason || '(unknown reason)');

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],28:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return 0x2C/* , */ === c ||
         0x5B/* [ */ === c ||
         0x5D/* ] */ === c ||
         0x7B/* { */ === c ||
         0x7D/* } */ === c;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  lc = c | 0x20;
  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
 return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  var error = generateError(state, message);

  if (state.onWarning) {
    state.onWarning.call(null, error);
  } else {
    throw error;
  }
}


var directiveHandlers = {

  'YAML': function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (null !== state.version) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (1 !== args.length) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (null === match) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (1 !== major) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (1 !== minor && 2 !== minor) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

  'TAG': function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (2 !== args.length) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length;
           _position < _length;
           _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(0x09 === _character ||
              0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
    }
  }
}

function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
  var index, quantity;

  keyNode = String(keyNode);

  if (null === _result) {
    _result = {};
  }

  if ('tag:yaml.org,2002:merge' === keyTag) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index]);
      }
    } else {
      mergeMappings(state, _result, valueNode);
    }
  } else {
    _result[keyNode] = valueNode;
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (0x0A/* LF */ === ch) {
    state.position++;
  } else if (0x0D/* CR */ === ch) {
    state.position++;
    if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && 0x23/* # */ === ch) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (0x20/* Space */ === ch) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (state.lineIndent < checkIndent) {
        throwWarning(state, 'deficient indentation');
      }
    } else {
      break;
    }
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&
      state.input.charCodeAt(_position + 1) === ch &&
      state.input.charCodeAt(_position+ 2) === ch) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (1 === count) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)             ||
      is_FLOW_INDICATOR(ch)        ||
      0x23/* # */           === ch ||
      0x26/* & */           === ch ||
      0x2A/* * */           === ch ||
      0x21/* ! */           === ch ||
      0x7C/* | */           === ch ||
      0x3E/* > */           === ch ||
      0x27/* ' */           === ch ||
      0x22/* " */           === ch ||
      0x25/* % */           === ch ||
      0x40/* @ */           === ch ||
      0x60/* ` */           === ch) {
    return false;
  }

  if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (0 !== ch) {
    if (0x3A/* : */ === ch) {
      following = state.input.charCodeAt(state.position+1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (0x23/* # */ === ch) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  } else {
    state.kind = _kind;
    state.result = _result;
    return false;
  }
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (0x27/* ' */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x27/* ' */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (0x27/* ' */ === ch) {
        captureStart = captureEnd = state.position;
        state.position++;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp, tmpEsc,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x22/* " */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x22/* " */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (0x5C/* \ */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        //TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += String.fromCharCode(hexResult);
        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D/* ] */;
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D/* } */;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (0 !== ch) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (0x3F/* ? */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (0x2C/* , */ === ch) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (0 !== ch) {
    ch = state.input.charCodeAt(++state.position);

    if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (0x23/* # */ === ch) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (0 !== ch));
    }
  }

  while (0 !== ch) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (0x20/* Space */ === ch)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (detectedIndent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', emptyLines + 1);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (0 === emptyLines) {
        if (detectedIndent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {

      // If current line isn't the first one - count line break from the last content line.
      if (detectedIndent) {
        state.result += common.repeat('\n', emptyLines + 1);

      // In case of the first content line - count only empty lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }
    }

    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (0 !== ch))
    { ch = state.input.charCodeAt(++state.position); }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {

    if (0x2D/* - */ !== ch) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  } else {
    return false;
  }
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {

      if (0x3F/* ? */ === ch) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (0x3A/* : */ === ch) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (0 !== ch)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x21/* ! */ !== ch) {
    return false;
  }

  if (null !== state.tag) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (0x3C/* < */ === ch) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (0x21/* ! */ === ch) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (0 !== ch && 0x3E/* > */ !== ch);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (0 !== ch && !is_WS_OR_EOL(ch)) {

      if (0x21/* ! */ === ch) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if ('!' === tagHandle) {
    state.tag = '!' + tagName;

  } else if ('!!' === tagHandle) {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x26/* & */ !== ch) {
    return false;
  }

  if (null !== state.anchor) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      len = state.length,
      input = state.input,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x2A/* * */ !== ch) {
    return false;
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      atNewLine  = false,
      isIndented = true,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent,
      _result;

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent === parentIndent) {
        isIndented = false;

      } else if (state.lineIndent > parentIndent) {
        isIndented = true;

      } else {
        return false;
      }
    }
  }

  if (isIndented) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          isIndented = true;
          allowBlockCollections = allowBlockStyles;

        } else if (state.lineIndent === parentIndent) {
          isIndented = false;
          allowBlockCollections = allowBlockStyles;

        } else {
          return true;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (isIndented || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (isIndented) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (null !== state.tag || null !== state.anchor) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (null === state.tag) {
            state.tag = '?';
          }
        }

        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (null !== state.tag && '!' !== state.tag) {
    if ('?' === state.tag) {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
           typeIndex < typeQuantity;
           typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (null !== state.anchor) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
      type = state.typeMap[state.tag];

      if (null !== state.result && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwWarning(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  return null !== state.tag || null !== state.anchor || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || 0x25/* % */ !== ch) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (0 !== ch && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (0 !== ch) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (0x23/* # */ === ch) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (0 !== ch && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) {
        break;
      }

      _position = state.position;

      while (0 !== ch && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (0 !== ch) {
      readLineBreak(state);
    }

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (0 === state.lineIndent &&
      0x2D/* - */ === state.input.charCodeAt(state.position) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (0 !== input.length &&
      0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&
      0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
    input += '\n';
  }

  var state = new State(input, options);

  if (PATTERN_NON_PRINTABLE.test(state.input)) {
    throwError(state, 'the stream contains non-printable characters');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options), index, length;

  if (0 === documents.length) {
    return undefined;
  } else if (1 === documents.length) {
    return documents[0];
  } else {
    throw new YAMLException('expected a single document in the stream, but found more');
  }
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":25,"./exception":27,"./mark":29,"./schema/default_full":32,"./schema/default_safe":33}],29:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) {
    return null;
  }

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":25}],30:[function(require,module,exports){
'use strict';


var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return -1 === exclude.indexOf(index);
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && 'scalar' !== type.loadKind) {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
  case 1:
    schemas = Schema.DEFAULT;
    types = arguments[0];
    break;

  case 2:
    schemas = arguments[0];
    types = arguments[1];
    break;

  default:
    throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":25,"./exception":27,"./type":36}],31:[function(require,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":30,"./json":35}],32:[function(require,module,exports){
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.


'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":30,"../type/js/function":41,"../type/js/regexp":42,"../type/js/undefined":43,"./default_safe":33}],33:[function(require,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":30,"../type/binary":37,"../type/merge":45,"../type/omap":47,"../type/pairs":48,"../type/set":50,"../type/timestamp":52,"./core":31}],34:[function(require,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":30,"../type/map":44,"../type/seq":49,"../type/str":51}],35:[function(require,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":30,"../type/bool":38,"../type/float":39,"../type/int":40,"../type/null":46,"./failsafe":34}],36:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (null !== map) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":27}],37:[function(require,module,exports){
'use strict';


// A trick for browserified version.
// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
var NodeBuffer = require('buffer').Buffer;
var Type       = require('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx ++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) { continue; }

    // Fail on illegal characters
    if (code < 0) { return false; }

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var code, idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4)*6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    return new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":36,"buffer":15}],38:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return '[object Boolean]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":36}],39:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  var value, sign, base, digits;

  if (!YAML_FLOAT_PATTERN.test(data)) {
    return false;
  }
  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('.inf' === value) {
    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if ('.nan' === value) {
    return NaN;

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  } else {
    return sign * parseFloat(value, 10);
  }
}

function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
    case 'lowercase':
      return '.nan';
    case 'uppercase':
      return '.NAN';
    case 'camelcase':
      return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '.inf';
    case 'uppercase':
      return '.INF';
    case 'camelcase':
      return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '-.inf';
    case 'uppercase':
      return '-.INF';
    case 'camelcase':
      return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  } else {
    return object.toString(10);
  }
}

function isFloat(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 !== object % 1 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":25,"../type":36}],40:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) { return false; }

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index+1 === max) { return true; }
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (ch !== '0' && ch !== '1') {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (!isHexCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') { continue; }
      if (!isOctCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    return hasDigits;
  }

  // base 10 (except 0) or base 60

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') { continue; }
    if (ch === ':') { break; }
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  if (!hasDigits) { return false; }

  // if !base60 - done;
  if (ch !== ':') { return true; }

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') { sign = -1; }
    value = value.slice(1);
    ch = value[0];
  }

  if ('0' === value) {
    return 0;
  }

  if (ch === '0') {
    if (value[1] === 'b') {
      return sign * parseInt(value.slice(2), 2);
    }
    if (value[1] === 'x') {
      return sign * parseInt(value, 16);
    }
    return sign * parseInt(value, 8);

  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 === object % 1 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":25,"../type":36}],41:[function(require,module,exports){
'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  esprima = require('esprima');
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') { esprima = window.esprima; }
}

var Type = require('../../type');

function resolveJavascriptFunction(data) {
  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if ('Program'             !== ast.type         ||
        1                     !== ast.body.length  ||
        'ExpressionStatement' !== ast.body[0].type ||
        'FunctionExpression'  !== ast.body[0].expression.type) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if ('Program'             !== ast.type         ||
      1                     !== ast.body.length  ||
      'ExpressionStatement' !== ast.body[0].type ||
      'FunctionExpression'  !== ast.body[0].expression.type) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  return new Function(params, source.slice(body[0]+1, body[1]-1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return '[object Function]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":36,"esprima":53}],42:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }

    if (modifiers.length > 3) { return false; }
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') { return false; }

    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  try {
    var dummy = new RegExp(regexp, modifiers);
    return true;
  } catch (error) {
    return false;
  }
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) {
    result += 'g';
  }

  if (object.multiline) {
    result += 'm';
  }

  if (object.ignoreCase) {
    result += 'i';
  }

  return result;
}

function isRegExp(object) {
  return '[object RegExp]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":36}],43:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return 'undefined' === typeof object;
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":36}],44:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping'
});

},{"../type":36}],45:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return '<<' === data;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge,
});

},{"../type":36}],46:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return null === object;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":36}],47:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) {
          pairHasKey = true;
        } else {
          return false;
        }
      }
    }

    if (!pairHasKey) {
      return false;
    }

    if (-1 === objectKeys.indexOf(pairKey)) {
      objectKeys.push(pairKey);
    } else {
      return false;
    }
  }

  return true;
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap
});

},{"../type":36}],48:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    keys = Object.keys(pair);

    if (1 !== keys.length) {
      return false;
    }

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":36}],49:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence'
});

},{"../type":36}],50:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (null !== object[key]) {
        return false;
      }
    }
  }

  return true;
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet
});

},{"../type":36}],51:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar'
});

},{"../type":36}],52:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

function resolveYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    return false;
  }

  return true;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    throw new Error('Date resolve error');
  }

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if ('-' === match[9]) {
      delta = -delta;
    }
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) {
    date.setTime(date.getTime() - delta);
  }

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":36}],53:[function(require,module,exports){
/*
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint bitwise:true plusplus:true */
/*global esprima:true, define:true, exports:true, window: true,
throwError: true, createLiteral: true, generateStatement: true,
parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseLeftHandSideExpression: true,
parseStatement: true, parseSourceElement: true */

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        buffer,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnexpectedNumber:  'Unexpected number',
        UnexpectedString:  'Unexpected string',
        UnexpectedIdentifier:  'Unexpected identifier',
        UnexpectedReserved:  'Unexpected reserved word',
        UnexpectedEOS:  'Unexpected end of input',
        NewlineAfterThrow:  'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp:  'Invalid regular expression: missing /',
        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally:  'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith:  'Strict mode code may not include a with statement',
        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord:  'Use of future reserved word in strict mode'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function sliceSource(from, to) {
        return source.slice(from, to);
    }

    if (typeof 'esprima'[0] === 'undefined') {
        sliceSource = function sliceArraySource(from, to) {
            return source.slice(from, to).join('');
        };
    }

    function isDecimalDigit(ch) {
        return '0123456789'.indexOf(ch) >= 0;
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === ' ') || (ch === '\u0009') || (ch === '\u000B') ||
            (ch === '\u000C') || (ch === '\u00A0') ||
            (ch.charCodeAt(0) >= 0x1680 &&
             '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === '\n' || ch === '\r' || ch === '\u2028' || ch === '\u2029');
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === '$') || (ch === '_') || (ch === '\\') ||
            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierStart.test(ch));
    }

    function isIdentifierPart(ch) {
        return (ch === '$') || (ch === '_') || (ch === '\\') ||
            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
            ((ch >= '0') && (ch <= '9')) ||
            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {

        // Future reserved words.
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        }

        return false;
    }

    function isStrictModeReservedWord(id) {
        switch (id) {

        // Strict Mode reserved words.
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        }

        return false;
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        var keyword = false;
        switch (id.length) {
        case 2:
            keyword = (id === 'if') || (id === 'in') || (id === 'do');
            break;
        case 3:
            keyword = (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
            break;
        case 4:
            keyword = (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with');
            break;
        case 5:
            keyword = (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw');
            break;
        case 6:
            keyword = (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch');
            break;
        case 7:
            keyword = (id === 'default') || (id === 'finally');
            break;
        case 8:
            keyword = (id === 'function') || (id === 'continue') || (id === 'debugger');
            break;
        case 10:
            keyword = (id === 'instanceof');
            break;
        }

        if (keyword) {
            return true;
        }

        switch (id) {
        // Future reserved words.
        // 'const' is specialized as Keyword in V8.
        case 'const':
            return true;

        // For compatiblity to SpiderMonkey and ES.next
        case 'yield':
        case 'let':
            return true;
        }

        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        return isFutureReservedWord(id);
    }

    // 7.4 Comments

    function skipComment() {
        var ch, blockComment, lineComment;

        blockComment = false;
        lineComment = false;

        while (index < length) {
            ch = source[index];

            if (lineComment) {
                ch = source[index++];
                if (isLineTerminator(ch)) {
                    lineComment = false;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                }
            } else if (blockComment) {
                if (isLineTerminator(ch)) {
                    if (ch === '\r' && source[index + 1] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    ch = source[index++];
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    if (ch === '*') {
                        ch = source[index];
                        if (ch === '/') {
                            ++index;
                            blockComment = false;
                        }
                    }
                }
            } else if (ch === '/') {
                ch = source[index + 1];
                if (ch === '/') {
                    index += 2;
                    lineComment = true;
                } else if (ch === '*') {
                    index += 2;
                    blockComment = true;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    break;
                }
            } else if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch ===  '\r' && source[index] === '\n') {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanIdentifier() {
        var ch, start, id, restore;

        ch = source[index];
        if (!isIdentifierStart(ch)) {
            return;
        }

        start = index;
        if (ch === '\\') {
            ++index;
            if (source[index] !== 'u') {
                return;
            }
            ++index;
            restore = index;
            ch = scanHexEscape('u');
            if (ch) {
                if (ch === '\\' || !isIdentifierStart(ch)) {
                    return;
                }
                id = ch;
            } else {
                index = restore;
                id = 'u';
            }
        } else {
            id = source[index++];
        }

        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch)) {
                break;
            }
            if (ch === '\\') {
                ++index;
                if (source[index] !== 'u') {
                    return;
                }
                ++index;
                restore = index;
                ch = scanHexEscape('u');
                if (ch) {
                    if (ch === '\\' || !isIdentifierPart(ch)) {
                        return;
                    }
                    id += ch;
                } else {
                    index = restore;
                    id += 'u';
                }
            } else {
                id += source[index++];
            }
        }

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            return {
                type: Token.Identifier,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (isKeyword(id)) {
            return {
                type: Token.Keyword,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // 7.8.1 Null Literals

        if (id === 'null') {
            return {
                type: Token.NullLiteral,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // 7.8.2 Boolean Literals

        if (id === 'true' || id === 'false') {
            return {
                type: Token.BooleanLiteral,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        return {
            type: Token.Identifier,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        // Check for most common single-character punctuators.

        if (ch1 === ';' || ch1 === '{' || ch1 === '}') {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === ',' || ch1 === '(' || ch1 === ')') {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Dot (.) can also start a floating-point number, hence the need
        // to check the next character.

        ch2 = source[index + 1];
        if (ch1 === '.' && !isDecimalDigit(ch2)) {
            return {
                type: Token.Punctuator,
                value: source[index++],
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Peek more characters.

        ch3 = source[index + 2];
        ch4 = source[index + 3];

        // 4-character punctuator: >>>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            if (ch4 === '=') {
                index += 4;
                return {
                    type: Token.Punctuator,
                    value: '>>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // 3-character punctuators: === !== >>> <<= >>=

        if (ch1 === '=' && ch2 === '=' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '===',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '!' && ch2 === '=' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '!==',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '<<=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // 2-character punctuators: <= >= == != ++ -- << >> && ||
        // += -= *= %= &= |= ^= /=

        if (ch2 === '=') {
            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {
            if ('+-<>&|'.indexOf(ch2) >= 0) {
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // The remaining 1-character punctuators.

        if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {
            return {
                type: Token.Punctuator,
                value: source[index++],
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    }

    // 7.8.3 Numeric Literals

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    number += source[index++];
                    while (index < length) {
                        ch = source[index];
                        if (!isHexDigit(ch)) {
                            break;
                        }
                        number += source[index++];
                    }

                    if (number.length <= 2) {
                        // only 0x
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }

                    if (index < length) {
                        ch = source[index];
                        if (isIdentifierStart(ch)) {
                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                        }
                    }
                    return {
                        type: Token.NumericLiteral,
                        value: parseInt(number, 16),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                } else if (isOctalDigit(ch)) {
                    number += source[index++];
                    while (index < length) {
                        ch = source[index];
                        if (!isOctalDigit(ch)) {
                            break;
                        }
                        number += source[index++];
                    }

                    if (index < length) {
                        ch = source[index];
                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                        }
                    }
                    return {
                        type: Token.NumericLiteral,
                        value: parseInt(number, 8),
                        octal: true,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                }

                // decimal number starts with '0' such as '09' is illegal.
                if (isDecimalDigit(ch)) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (index < length) {
                ch = source[index];
                if (!isDecimalDigit(ch)) {
                    break;
                }
                number += source[index++];
            }
        }

        if (ch === '.') {
            number += source[index++];
            while (index < length) {
                ch = source[index];
                if (!isDecimalDigit(ch)) {
                    break;
                }
                number += source[index++];
            }
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }

            ch = source[index];
            if (isDecimalDigit(ch)) {
                number += source[index++];
                while (index < length) {
                    ch = source[index];
                    if (!isDecimalDigit(ch)) {
                        break;
                    }
                    number += source[index++];
                }
            } else {
                ch = 'character ' + ch;
                if (index >= length) {
                    ch = '<end>';
                }
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (index < length) {
            ch = source[index];
            if (isIdentifierStart(ch)) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch)) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'u':
                    case 'x':
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            str += unescaped;
                        } else {
                            index = restore;
                            str += ch;
                        }
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch)) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanRegExp() {
        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;

        buffer = null;
        skipComment();

        start = index;
        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch)) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                } else if (isLineTerminator(ch)) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        pattern = str.substr(1, str.length - 2);

        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch)) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        str += '\\u';
                        for (; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                } else {
                    str += '\\';
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }

        return {
            literal: str,
            value: value,
            range: [start, index]
        };
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advance() {
        var ch, token;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [index, index]
            };
        }

        token = scanPunctuator();
        if (typeof token !== 'undefined') {
            return token;
        }

        ch = source[index];

        if (ch === '\'' || ch === '"') {
            return scanStringLiteral();
        }

        if (ch === '.' || isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        token = scanIdentifier();
        if (typeof token !== 'undefined') {
            return token;
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    function lex() {
        var token;

        if (buffer) {
            index = buffer.range[1];
            lineNumber = buffer.lineNumber;
            lineStart = buffer.lineStart;
            token = buffer;
            buffer = null;
            return token;
        }

        buffer = null;
        return advance();
    }

    function lookahead() {
        var pos, line, start;

        if (buffer !== null) {
            return buffer;
        }

        pos = index;
        line = lineNumber;
        start = lineStart;
        buffer = advance();
        index = pos;
        lineNumber = line;
        lineStart = start;

        return buffer;
    }

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    return args[index] || '';
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.range[0];
            error.lineNumber = token.lineNumber;
            error.column = token.range[0] - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        var token = lookahead();
        return token.type === Token.Punctuator && token.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        var token = lookahead();
        return token.type === Token.Keyword && token.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var token = lookahead(),
            op = token.value;

        if (token.type !== Token.Punctuator) {
            return false;
        }
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var token, line;

        // Catch the very common case first.
        if (source[index] === ';') {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            return;
        }

        if (match(';')) {
            lex();
            return;
        }

        token = lookahead();
        if (token.type !== Token.EOF && !match('}')) {
            throwUnexpected(token);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [];

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        expect(']');

        return {
            type: Syntax.ArrayExpression,
            elements: elements
        };
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body;

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;

        return {
            type: Syntax.FunctionExpression,
            id: null,
            params: param,
            defaults: [],
            body: body,
            rest: null,
            generator: false,
            expression: false
        };
    }

    function parseObjectPropertyKey() {
        var token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return createLiteral(token);
        }

        return {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    function parseObjectProperty() {
        var token, key, id, param;

        token = lookahead();

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                return {
                    type: Syntax.Property,
                    key: key,
                    value: parsePropertyFunction([]),
                    kind: 'get'
                };
            } else if (token.value === 'set' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead();
                if (token.type !== Token.Identifier) {
                    expect(')');
                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                    return {
                        type: Syntax.Property,
                        key: key,
                        value: parsePropertyFunction([]),
                        kind: 'set'
                    };
                } else {
                    param = [ parseVariableIdentifier() ];
                    expect(')');
                    return {
                        type: Syntax.Property,
                        key: key,
                        value: parsePropertyFunction(param, token),
                        kind: 'set'
                    };
                }
            } else {
                expect(':');
                return {
                    type: Syntax.Property,
                    key: id,
                    value: parseAssignmentExpression(),
                    kind: 'init'
                };
            }
        } else if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        } else {
            key = parseObjectPropertyKey();
            expect(':');
            return {
                type: Syntax.Property,
                key: key,
                value: parseAssignmentExpression(),
                kind: 'init'
            };
        }
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, kind, map = {}, toString = String;

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;
            if (Object.prototype.hasOwnProperty.call(map, name)) {
                if (map[name] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[name] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[name] |= kind;
            } else {
                map[name] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return {
            type: Syntax.ObjectExpression,
            properties: properties
        };
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var token = lookahead(),
            type = token.type;

        if (type === Token.Identifier) {
            return {
                type: Syntax.Identifier,
                name: lex().value
            };
        }

        if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return createLiteral(lex());
        }

        if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                lex();
                return {
                    type: Syntax.ThisExpression
                };
            }

            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
        }

        if (type === Token.BooleanLiteral) {
            lex();
            token.value = (token.value === 'true');
            return createLiteral(token);
        }

        if (type === Token.NullLiteral) {
            lex();
            token.value = null;
            return createLiteral(token);
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('/') || match('/=')) {
            return createLiteral(scanRegExp());
        }

        return throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var expr;

        expectKeyword('new');

        expr = {
            type: Syntax.NewExpression,
            callee: parseLeftHandSideExpression(),
            'arguments': []
        };

        if (match('(')) {
            expr['arguments'] = parseArguments();
        }

        return expr;
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(')) {
            if (match('(')) {
                expr = {
                    type: Syntax.CallExpression,
                    callee: expr,
                    'arguments': parseArguments()
                };
            } else if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
            }
        }

        return expr;
    }


    function parseLeftHandSideExpression() {
        var expr;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[')) {
            if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr = parseLeftHandSideExpressionAllowCall(), token;

        token = lookahead();
        if (token.type !== Token.Punctuator) {
            return expr;
        }

        if ((match('++') || match('--')) && !peekLineTerminator()) {
            // 11.3.1, 11.3.2
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPostfix);
            }
            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            expr = {
                type: Syntax.UpdateExpression,
                operator: lex().value,
                argument: expr,
                prefix: false
            };
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr;

        token = lookahead();
        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return parsePostfixExpression();
        }

        if (match('++') || match('--')) {
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            expr = {
                type: Syntax.UpdateExpression,
                operator: token.value,
                argument: expr,
                prefix: true
            };
            return expr;
        }

        if (match('+') || match('-') || match('~') || match('!')) {
            expr = {
                type: Syntax.UnaryExpression,
                operator: lex().value,
                argument: parseUnaryExpression(),
                prefix: true
            };
            return expr;
        }

        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            expr = {
                type: Syntax.UnaryExpression,
                operator: lex().value,
                argument: parseUnaryExpression(),
                prefix: true
            };
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
            return expr;
        }

        return parsePostfixExpression();
    }

    // 11.5 Multiplicative Operators

    function parseMultiplicativeExpression() {
        var expr = parseUnaryExpression();

        while (match('*') || match('/') || match('%')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseUnaryExpression()
            };
        }

        return expr;
    }

    // 11.6 Additive Operators

    function parseAdditiveExpression() {
        var expr = parseMultiplicativeExpression();

        while (match('+') || match('-')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseMultiplicativeExpression()
            };
        }

        return expr;
    }

    // 11.7 Bitwise Shift Operators

    function parseShiftExpression() {
        var expr = parseAdditiveExpression();

        while (match('<<') || match('>>') || match('>>>')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseAdditiveExpression()
            };
        }

        return expr;
    }
    // 11.8 Relational Operators

    function parseRelationalExpression() {
        var expr, previousAllowIn;

        previousAllowIn = state.allowIn;
        state.allowIn = true;

        expr = parseShiftExpression();

        while (match('<') || match('>') || match('<=') || match('>=') || (previousAllowIn && matchKeyword('in')) || matchKeyword('instanceof')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseShiftExpression()
            };
        }

        state.allowIn = previousAllowIn;
        return expr;
    }

    // 11.9 Equality Operators

    function parseEqualityExpression() {
        var expr = parseRelationalExpression();

        while (match('==') || match('!=') || match('===') || match('!==')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseRelationalExpression()
            };
        }

        return expr;
    }

    // 11.10 Binary Bitwise Operators

    function parseBitwiseANDExpression() {
        var expr = parseEqualityExpression();

        while (match('&')) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: '&',
                left: expr,
                right: parseEqualityExpression()
            };
        }

        return expr;
    }

    function parseBitwiseXORExpression() {
        var expr = parseBitwiseANDExpression();

        while (match('^')) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: '^',
                left: expr,
                right: parseBitwiseANDExpression()
            };
        }

        return expr;
    }

    function parseBitwiseORExpression() {
        var expr = parseBitwiseXORExpression();

        while (match('|')) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: '|',
                left: expr,
                right: parseBitwiseXORExpression()
            };
        }

        return expr;
    }

    // 11.11 Binary Logical Operators

    function parseLogicalANDExpression() {
        var expr = parseBitwiseORExpression();

        while (match('&&')) {
            lex();
            expr = {
                type: Syntax.LogicalExpression,
                operator: '&&',
                left: expr,
                right: parseBitwiseORExpression()
            };
        }

        return expr;
    }

    function parseLogicalORExpression() {
        var expr = parseLogicalANDExpression();

        while (match('||')) {
            lex();
            expr = {
                type: Syntax.LogicalExpression,
                operator: '||',
                left: expr,
                right: parseLogicalANDExpression()
            };
        }

        return expr;
    }

    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent;

        expr = parseLogicalORExpression();

        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');

            expr = {
                type: Syntax.ConditionalExpression,
                test: expr,
                consequent: consequent,
                alternate: parseAssignmentExpression()
            };
        }

        return expr;
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var token, expr;

        token = lookahead();
        expr = parseConditionalExpression();

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            expr = {
                type: Syntax.AssignmentExpression,
                operator: lex().value,
                left: expr,
                right: parseAssignmentExpression()
            };
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr = parseAssignmentExpression();

        if (match(',')) {
            expr = {
                type: Syntax.SequenceExpression,
                expressions: [ expr ]
            };

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expr.expressions.push(parseAssignmentExpression());
            }

        }
        return expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block;

        expect('{');

        block = parseStatementList();

        expect('}');

        return {
            type: Syntax.BlockStatement,
            body: block
        };
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    function parseVariableDeclaration(kind) {
        var id = parseVariableIdentifier(),
            init = null;

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return {
            type: Syntax.VariableDeclarator,
            id: id,
            init: init
        };
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement() {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return {
            type: Syntax.VariableDeclaration,
            declarations: declarations,
            kind: 'var'
        };
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations;

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return {
            type: Syntax.VariableDeclaration,
            declarations: declarations,
            kind: kind
        };
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        expect(';');

        return {
            type: Syntax.EmptyStatement
        };
    }

    // 12.4 Expression Statement

    function parseExpressionStatement() {
        var expr = parseExpression();

        consumeSemicolon();

        return {
            type: Syntax.ExpressionStatement,
            expression: expr
        };
    }

    // 12.5 If statement

    function parseIfStatement() {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return {
            type: Syntax.IfStatement,
            test: test,
            consequent: consequent,
            alternate: alternate
        };
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement() {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return {
            type: Syntax.DoWhileStatement,
            body: body,
            test: test
        };
    }

    function parseWhileStatement() {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return {
            type: Syntax.WhileStatement,
            test: test,
            body: body
        };
    }

    function parseForVariableDeclaration() {
        var token = lex();

        return {
            type: Syntax.VariableDeclaration,
            declarations: parseVariableDeclarationList(),
            kind: token.value
        };
    }

    function parseForStatement() {
        var init, test, update, left, right, body, oldInIteration;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = true;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = true;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        if (typeof left === 'undefined') {
            return {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        }

        return {
            type: Syntax.ForInStatement,
            left: left,
            right: right,
            body: body,
            each: false
        };
    }

    // 12.7 The continue statement

    function parseContinueStatement() {
        var token, label = null;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source[index] === ';') {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return {
                type: Syntax.ContinueStatement,
                label: null
            };
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return {
                type: Syntax.ContinueStatement,
                label: null
            };
        }

        token = lookahead();
        if (token.type === Token.Identifier) {
            label = parseVariableIdentifier();

            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return {
            type: Syntax.ContinueStatement,
            label: label
        };
    }

    // 12.8 The break statement

    function parseBreakStatement() {
        var token, label = null;

        expectKeyword('break');

        // Optimize the most common form: 'break;'.
        if (source[index] === ';') {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return {
                type: Syntax.BreakStatement,
                label: null
            };
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return {
                type: Syntax.BreakStatement,
                label: null
            };
        }

        token = lookahead();
        if (token.type === Token.Identifier) {
            label = parseVariableIdentifier();

            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return {
            type: Syntax.BreakStatement,
            label: label
        };
    }

    // 12.9 The return statement

    function parseReturnStatement() {
        var token, argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source[index] === ' ') {
            if (isIdentifierStart(source[index + 1])) {
                argument = parseExpression();
                consumeSemicolon();
                return {
                    type: Syntax.ReturnStatement,
                    argument: argument
                };
            }
        }

        if (peekLineTerminator()) {
            return {
                type: Syntax.ReturnStatement,
                argument: null
            };
        }

        if (!match(';')) {
            token = lookahead();
            if (!match('}') && token.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return {
            type: Syntax.ReturnStatement,
            argument: argument
        };
    }

    // 12.10 The with statement

    function parseWithStatement() {
        var object, body;

        if (strict) {
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return {
            type: Syntax.WithStatement,
            object: object,
            body: body
        };
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test,
            consequent = [],
            statement;

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            if (typeof statement === 'undefined') {
                break;
            }
            consequent.push(statement);
        }

        return {
            type: Syntax.SwitchCase,
            test: test,
            consequent: consequent
        };
    }

    function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return {
                type: Syntax.SwitchStatement,
                discriminant: discriminant,
                cases: cases
            };
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return {
            type: Syntax.SwitchStatement,
            discriminant: discriminant,
            cases: cases
        };
    }

    // 12.13 The throw statement

    function parseThrowStatement() {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return {
            type: Syntax.ThrowStatement,
            argument: argument
        };
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param;

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead());
        }

        param = parseVariableIdentifier();
        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }

        expect(')');

        return {
            type: Syntax.CatchClause,
            param: param,
            body: parseBlock()
        };
    }

    function parseTryStatement() {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return {
            type: Syntax.TryStatement,
            block: block,
            guardedHandlers: [],
            handlers: handlers,
            finalizer: finalizer
        };
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement() {
        expectKeyword('debugger');

        consumeSemicolon();

        return {
            type: Syntax.DebuggerStatement
        };
    }

    // 12 Statements

    function parseStatement() {
        var token = lookahead(),
            expr,
            labeledBody;

        if (token.type === Token.EOF) {
            throwUnexpected(token);
        }

        if (token.type === Token.Punctuator) {
            switch (token.value) {
            case ';':
                return parseEmptyStatement();
            case '{':
                return parseBlock();
            case '(':
                return parseExpressionStatement();
            default:
                break;
            }
        }

        if (token.type === Token.Keyword) {
            switch (token.value) {
            case 'break':
                return parseBreakStatement();
            case 'continue':
                return parseContinueStatement();
            case 'debugger':
                return parseDebuggerStatement();
            case 'do':
                return parseDoWhileStatement();
            case 'for':
                return parseForStatement();
            case 'function':
                return parseFunctionDeclaration();
            case 'if':
                return parseIfStatement();
            case 'return':
                return parseReturnStatement();
            case 'switch':
                return parseSwitchStatement();
            case 'throw':
                return parseThrowStatement();
            case 'try':
                return parseTryStatement();
            case 'var':
                return parseVariableStatement();
            case 'while':
                return parseWhileStatement();
            case 'with':
                return parseWithStatement();
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[expr.name] = true;
            labeledBody = parseStatement();
            delete state.labelSet[expr.name];

            return {
                type: Syntax.LabeledStatement,
                label: expr,
                body: labeledBody
            };
        }

        consumeSemicolon();

        return {
            type: Syntax.ExpressionStatement,
            expression: expr
        };
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;

        expect('{');

        while (index < length) {
            token = lookahead();
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return {
            type: Syntax.BlockStatement,
            body: sourceElements
        };
    }

    function parseFunctionDeclaration() {
        var id, param, params = [], body, token, stricted, firstRestricted, message, previousStrict, paramSet;

        expectKeyword('function');
        token = lookahead();
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        expect('(');

        if (!match(')')) {
            paramSet = {};
            while (index < length) {
                token = lookahead();
                param = parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[param.name] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return {
            type: Syntax.FunctionDeclaration,
            id: id,
            params: params,
            defaults: [],
            body: body,
            rest: null,
            generator: false,
            expression: false
        };
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, param, params = [], body, previousStrict, paramSet;

        expectKeyword('function');

        if (!match('(')) {
            token = lookahead();
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        expect('(');

        if (!match(')')) {
            paramSet = {};
            while (index < length) {
                token = lookahead();
                param = parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[param.name] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return {
            type: Syntax.FunctionExpression,
            id: id,
            params: params,
            defaults: [],
            body: body,
            rest: null,
            generator: false,
            expression: false
        };
    }

    // 14 Program

    function parseSourceElement() {
        var token = lookahead();

        if (token.type === Token.Keyword) {
            switch (token.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(token.value);
            case 'function':
                return parseFunctionDeclaration();
            default:
                return parseStatement();
            }
        }

        if (token.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead();
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var program;
        strict = false;
        program = {
            type: Syntax.Program,
            body: parseSourceElements()
        };
        return program;
    }

    // The following functions are needed only when the option to preserve
    // the comments is active.

    function addComment(type, value, start, end, loc) {
        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (extra.comments.length > 0) {
            if (extra.comments[extra.comments.length - 1].range[1] > start) {
                return;
            }
        }

        extra.comments.push({
            type: type,
            value: value,
            range: [start, end],
            loc: loc
        });
    }

    function scanComment() {
        var comment, ch, loc, start, blockComment, lineComment;

        comment = '';
        blockComment = false;
        lineComment = false;

        while (index < length) {
            ch = source[index];

            if (lineComment) {
                ch = source[index++];
                if (isLineTerminator(ch)) {
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    lineComment = false;
                    addComment('Line', comment, start, index - 1, loc);
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    comment = '';
                } else if (index >= length) {
                    lineComment = false;
                    comment += ch;
                    loc.end = {
                        line: lineNumber,
                        column: length - lineStart
                    };
                    addComment('Line', comment, start, length, loc);
                } else {
                    comment += ch;
                }
            } else if (blockComment) {
                if (isLineTerminator(ch)) {
                    if (ch === '\r' && source[index + 1] === '\n') {
                        ++index;
                        comment += '\r\n';
                    } else {
                        comment += ch;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    ch = source[index++];
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    comment += ch;
                    if (ch === '*') {
                        ch = source[index];
                        if (ch === '/') {
                            comment = comment.substr(0, comment.length - 1);
                            blockComment = false;
                            ++index;
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            addComment('Block', comment, start, index, loc);
                            comment = '';
                        }
                    }
                }
            } else if (ch === '/') {
                ch = source[index + 1];
                if (ch === '/') {
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart
                        }
                    };
                    start = index;
                    index += 2;
                    lineComment = true;
                    if (index >= length) {
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        lineComment = false;
                        addComment('Line', comment, start, index, loc);
                    }
                } else if (ch === '*') {
                    start = index;
                    index += 2;
                    blockComment = true;
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart - 2
                        }
                    };
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    break;
                }
            } else if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch ===  '\r' && source[index] === '\n') {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else {
                break;
            }
        }
    }

    function filterCommentLocation() {
        var i, entry, comment, comments = [];

        for (i = 0; i < extra.comments.length; ++i) {
            entry = extra.comments[i];
            comment = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                comment.range = entry.range;
            }
            if (extra.loc) {
                comment.loc = entry.loc;
            }
            comments.push(comment);
        }

        extra.comments = comments;
    }

    function collectToken() {
        var start, loc, token, range, value;

        skipComment();
        start = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = extra.advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            range = [token.range[0], token.range[1]];
            value = sliceSource(token.range[0], token.range[1]);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: range,
                loc: loc
            });
        }

        return token;
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = extra.scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        // Pop the previous token, which is likely '/' or '/='
        if (extra.tokens.length > 0) {
            token = extra.tokens[extra.tokens.length - 1];
            if (token.range[0] === pos && token.type === 'Punctuator') {
                if (token.value === '/' || token.value === '/=') {
                    extra.tokens.pop();
                }
            }
        }

        extra.tokens.push({
            type: 'RegularExpression',
            value: regex.literal,
            range: [pos, index],
            loc: loc
        });

        return regex;
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function createLiteral(token) {
        return {
            type: Syntax.Literal,
            value: token.value
        };
    }

    function createRawLiteral(token) {
        return {
            type: Syntax.Literal,
            value: token.value,
            raw: sliceSource(token.range[0], token.range[1])
        };
    }

    function createLocationMarker() {
        var marker = {};

        marker.range = [index, index];
        marker.loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            },
            end: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        marker.end = function () {
            this.range[1] = index;
            this.loc.end.line = lineNumber;
            this.loc.end.column = index - lineStart;
        };

        marker.applyGroup = function (node) {
            if (extra.range) {
                node.groupRange = [this.range[0], this.range[1]];
            }
            if (extra.loc) {
                node.groupLoc = {
                    start: {
                        line: this.loc.start.line,
                        column: this.loc.start.column
                    },
                    end: {
                        line: this.loc.end.line,
                        column: this.loc.end.column
                    }
                };
            }
        };

        marker.apply = function (node) {
            if (extra.range) {
                node.range = [this.range[0], this.range[1]];
            }
            if (extra.loc) {
                node.loc = {
                    start: {
                        line: this.loc.start.line,
                        column: this.loc.start.column
                    },
                    end: {
                        line: this.loc.end.line,
                        column: this.loc.end.column
                    }
                };
            }
        };

        return marker;
    }

    function trackGroupExpression() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();
        expect('(');

        expr = parseExpression();

        expect(')');

        marker.end();
        marker.applyGroup(expr);

        return expr;
    }

    function trackLeftHandSideExpression() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[')) {
            if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
                marker.end();
                marker.apply(expr);
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function trackLeftHandSideExpressionAllowCall() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(')) {
            if (match('(')) {
                expr = {
                    type: Syntax.CallExpression,
                    callee: expr,
                    'arguments': parseArguments()
                };
                marker.end();
                marker.apply(expr);
            } else if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
                marker.end();
                marker.apply(expr);
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function filterGroup(node) {
        var n, i, entry;

        n = (Object.prototype.toString.apply(node) === '[object Array]') ? [] : {};
        for (i in node) {
            if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {
                entry = node[i];
                if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {
                    n[i] = entry;
                } else {
                    n[i] = filterGroup(entry);
                }
            }
        }
        return n;
    }

    function wrapTrackingFunction(range, loc) {

        return function (parseFunction) {

            function isBinary(node) {
                return node.type === Syntax.LogicalExpression ||
                    node.type === Syntax.BinaryExpression;
            }

            function visit(node) {
                var start, end;

                if (isBinary(node.left)) {
                    visit(node.left);
                }
                if (isBinary(node.right)) {
                    visit(node.right);
                }

                if (range) {
                    if (node.left.groupRange || node.right.groupRange) {
                        start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];
                        end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];
                        node.range = [start, end];
                    } else if (typeof node.range === 'undefined') {
                        start = node.left.range[0];
                        end = node.right.range[1];
                        node.range = [start, end];
                    }
                }
                if (loc) {
                    if (node.left.groupLoc || node.right.groupLoc) {
                        start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;
                        end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;
                        node.loc = {
                            start: start,
                            end: end
                        };
                    } else if (typeof node.loc === 'undefined') {
                        node.loc = {
                            start: node.left.loc.start,
                            end: node.right.loc.end
                        };
                    }
                }
            }

            return function () {
                var marker, node;

                skipComment();

                marker = createLocationMarker();
                node = parseFunction.apply(null, arguments);
                marker.end();

                if (range && typeof node.range === 'undefined') {
                    marker.apply(node);
                }

                if (loc && typeof node.loc === 'undefined') {
                    marker.apply(node);
                }

                if (isBinary(node)) {
                    visit(node);
                }

                return node;
            };
        };
    }

    function patch() {

        var wrapTracking;

        if (extra.comments) {
            extra.skipComment = skipComment;
            skipComment = scanComment;
        }

        if (extra.raw) {
            extra.createLiteral = createLiteral;
            createLiteral = createRawLiteral;
        }

        if (extra.range || extra.loc) {

            extra.parseGroupExpression = parseGroupExpression;
            extra.parseLeftHandSideExpression = parseLeftHandSideExpression;
            extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;
            parseGroupExpression = trackGroupExpression;
            parseLeftHandSideExpression = trackLeftHandSideExpression;
            parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;

            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);

            extra.parseAdditiveExpression = parseAdditiveExpression;
            extra.parseAssignmentExpression = parseAssignmentExpression;
            extra.parseBitwiseANDExpression = parseBitwiseANDExpression;
            extra.parseBitwiseORExpression = parseBitwiseORExpression;
            extra.parseBitwiseXORExpression = parseBitwiseXORExpression;
            extra.parseBlock = parseBlock;
            extra.parseFunctionSourceElements = parseFunctionSourceElements;
            extra.parseCatchClause = parseCatchClause;
            extra.parseComputedMember = parseComputedMember;
            extra.parseConditionalExpression = parseConditionalExpression;
            extra.parseConstLetDeclaration = parseConstLetDeclaration;
            extra.parseEqualityExpression = parseEqualityExpression;
            extra.parseExpression = parseExpression;
            extra.parseForVariableDeclaration = parseForVariableDeclaration;
            extra.parseFunctionDeclaration = parseFunctionDeclaration;
            extra.parseFunctionExpression = parseFunctionExpression;
            extra.parseLogicalANDExpression = parseLogicalANDExpression;
            extra.parseLogicalORExpression = parseLogicalORExpression;
            extra.parseMultiplicativeExpression = parseMultiplicativeExpression;
            extra.parseNewExpression = parseNewExpression;
            extra.parseNonComputedProperty = parseNonComputedProperty;
            extra.parseObjectProperty = parseObjectProperty;
            extra.parseObjectPropertyKey = parseObjectPropertyKey;
            extra.parsePostfixExpression = parsePostfixExpression;
            extra.parsePrimaryExpression = parsePrimaryExpression;
            extra.parseProgram = parseProgram;
            extra.parsePropertyFunction = parsePropertyFunction;
            extra.parseRelationalExpression = parseRelationalExpression;
            extra.parseStatement = parseStatement;
            extra.parseShiftExpression = parseShiftExpression;
            extra.parseSwitchCase = parseSwitchCase;
            extra.parseUnaryExpression = parseUnaryExpression;
            extra.parseVariableDeclaration = parseVariableDeclaration;
            extra.parseVariableIdentifier = parseVariableIdentifier;

            parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);
            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);
            parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);
            parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);
            parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);
            parseBlock = wrapTracking(extra.parseBlock);
            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);
            parseCatchClause = wrapTracking(extra.parseCatchClause);
            parseComputedMember = wrapTracking(extra.parseComputedMember);
            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);
            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);
            parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);
            parseExpression = wrapTracking(extra.parseExpression);
            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);
            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);
            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);
            parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);
            parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);
            parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);
            parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);
            parseNewExpression = wrapTracking(extra.parseNewExpression);
            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);
            parseObjectProperty = wrapTracking(extra.parseObjectProperty);
            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);
            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);
            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);
            parseProgram = wrapTracking(extra.parseProgram);
            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);
            parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);
            parseStatement = wrapTracking(extra.parseStatement);
            parseShiftExpression = wrapTracking(extra.parseShiftExpression);
            parseSwitchCase = wrapTracking(extra.parseSwitchCase);
            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);
            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);
            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);
        }

        if (typeof extra.tokens !== 'undefined') {
            extra.advance = advance;
            extra.scanRegExp = scanRegExp;

            advance = collectToken;
            scanRegExp = collectRegex;
        }
    }

    function unpatch() {
        if (typeof extra.skipComment === 'function') {
            skipComment = extra.skipComment;
        }

        if (extra.raw) {
            createLiteral = extra.createLiteral;
        }

        if (extra.range || extra.loc) {
            parseAdditiveExpression = extra.parseAdditiveExpression;
            parseAssignmentExpression = extra.parseAssignmentExpression;
            parseBitwiseANDExpression = extra.parseBitwiseANDExpression;
            parseBitwiseORExpression = extra.parseBitwiseORExpression;
            parseBitwiseXORExpression = extra.parseBitwiseXORExpression;
            parseBlock = extra.parseBlock;
            parseFunctionSourceElements = extra.parseFunctionSourceElements;
            parseCatchClause = extra.parseCatchClause;
            parseComputedMember = extra.parseComputedMember;
            parseConditionalExpression = extra.parseConditionalExpression;
            parseConstLetDeclaration = extra.parseConstLetDeclaration;
            parseEqualityExpression = extra.parseEqualityExpression;
            parseExpression = extra.parseExpression;
            parseForVariableDeclaration = extra.parseForVariableDeclaration;
            parseFunctionDeclaration = extra.parseFunctionDeclaration;
            parseFunctionExpression = extra.parseFunctionExpression;
            parseGroupExpression = extra.parseGroupExpression;
            parseLeftHandSideExpression = extra.parseLeftHandSideExpression;
            parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;
            parseLogicalANDExpression = extra.parseLogicalANDExpression;
            parseLogicalORExpression = extra.parseLogicalORExpression;
            parseMultiplicativeExpression = extra.parseMultiplicativeExpression;
            parseNewExpression = extra.parseNewExpression;
            parseNonComputedProperty = extra.parseNonComputedProperty;
            parseObjectProperty = extra.parseObjectProperty;
            parseObjectPropertyKey = extra.parseObjectPropertyKey;
            parsePrimaryExpression = extra.parsePrimaryExpression;
            parsePostfixExpression = extra.parsePostfixExpression;
            parseProgram = extra.parseProgram;
            parsePropertyFunction = extra.parsePropertyFunction;
            parseRelationalExpression = extra.parseRelationalExpression;
            parseStatement = extra.parseStatement;
            parseShiftExpression = extra.parseShiftExpression;
            parseSwitchCase = extra.parseSwitchCase;
            parseUnaryExpression = extra.parseUnaryExpression;
            parseVariableDeclaration = extra.parseVariableDeclaration;
            parseVariableIdentifier = extra.parseVariableIdentifier;
        }

        if (typeof extra.scanRegExp === 'function') {
            advance = extra.advance;
            scanRegExp = extra.scanRegExp;
        }
    }

    function stringToArray(str) {
        var length = str.length,
            result = [],
            i;
        for (i = 0; i < length; ++i) {
            result[i] = str.charAt(i);
        }
        return result;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        buffer = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.raw = (typeof options.raw === 'boolean') && options.raw;
            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
        }

        if (length > 0) {
            if (typeof source[0] === 'undefined') {
                // Try first to convert to a string. This is good as fast path
                // for old IE which understands string indexing for string
                // literals only and not for string object.
                if (code instanceof String) {
                    source = code.valueOf();
                }

                // Force accessing the characters via an array.
                if (typeof source[0] === 'undefined') {
                    source = stringToArray(code);
                }
            }
        }

        patch();
        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                filterCommentLocation();
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
            if (extra.range || extra.loc) {
                program.body = filterGroup(program.body);
            }
        } catch (e) {
            throw e;
        } finally {
            unpatch();
            extra = {};
        }

        return program;
    }

    // Sync with package.json.
    exports.version = '1.0.4';

    exports.parse = parse;

    // Deep copy.
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],54:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    if (typeof module === 'object' && module.exports && typeof require === 'function') {
        module.exports = definition();
    } else if (typeof define === 'function' && typeof define.amd === 'object') {
        define(definition);
    } else {
        root.log = definition();
    }
}(this, function () {
    var self = {};
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    function enableLoggingWhenConsoleArrives(methodName, level) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods(level);
                self[methodName].apply(self, arguments);
            }
        };
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function replaceLoggingMethods(level) {
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            self[methodName] = (i < level) ? noop : self.methodFactory(methodName, level);
        }
    }

    function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

        // Use localStorage if available
        try {
            window.localStorage['loglevel'] = levelName;
            return;
        } catch (ignore) {}

        // Use session cookie as fallback
        try {
            window.document.cookie = "loglevel=" + levelName + ";";
        } catch (ignore) {}
    }

    function loadPersistedLevel() {
        var storedLevel;

        try {
            storedLevel = window.localStorage['loglevel'];
        } catch (ignore) {}

        if (typeof storedLevel === undefinedType) {
            try {
                storedLevel = /loglevel=([^;]+)/.exec(window.document.cookie)[1];
            } catch (ignore) {}
        }
        
        if (self.levels[storedLevel] === undefined) {
            storedLevel = "WARN";
        }

        self.setLevel(self.levels[storedLevel]);
    }

    /*
     *
     * Public API
     *
     */

    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
        "ERROR": 4, "SILENT": 5};

    self.methodFactory = function (methodName, level) {
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives(methodName, level);
    };

    self.setLevel = function (level) {
        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
            level = self.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            persistLevelIfPossible(level);
            replaceLoggingMethods(level);
            if (typeof console === undefinedType && level < self.levels.SILENT) {
                return "No console available for logging";
            }
        } else {
            throw "log.setLevel() called with invalid level: " + level;
        }
    };

    self.enableAll = function() {
        self.setLevel(self.levels.TRACE);
    };

    self.disableAll = function() {
        self.setLevel(self.levels.SILENT);
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    self.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === self) {
            window.log = _log;
        }

        return self;
    };

    loadPersistedLevel();
    return self;
}));

},{}],55:[function(require,module,exports){
'use strict';

var whiteList = ['not', 'any', 'all', 'none'];


function notNull(x)  { return x != null; }
function toString(x) { return x.toString(); }
function wrap(x)     { return '(' + x + ')';}

function maybeQuote(value) {
    if (typeof value === 'string') {
        return '"' + value + '"';
    }
    return value;
}

function lookUp(key) {
    if (key.lastIndexOf('$') === 0) {
        return 'context.' + key.substring(1);
    }
    return 'context.feature.properties.' + key;
}

function nullValue(key, value) {
    return {
        type: 'nullValue',
        key: key,
        toString: function () {
            return ' true ';
        }
    };
}

function propertyEqual(key, value) {
    return {
        type: 'propertyEqual',
        opt: '===' ,
        key: key,
        value: value,
        toString: function () {
            return wrap(maybeQuote(this.value) + ' ' + this.opt + ' ' + lookUp(key));
        }
    };
}

function propertyOr(key, values) {
    return {
        type: 'propertyOr',
        key: key,
        values: values.map(function (x) { return propertyEqual(key, x); }),
        toString: function () {
            return wrap(this.values.map(toString).join(' || '));
        }
    };
}

function not(key, value) {
    return {
        type: 'notProperty',
        key: key,
        value: parseFilter(value),
        toString: function () {
            return '!' + wrap(this.value.toString());
        }
    };
}

function none(key, values) {
    return {
        type: 'none',
        values: any(null, values),
        toString: function () {
            return '!' + wrap(this.values.toString());
        }
    };
}

function printNested(values, joiner) {
    return wrap(values.filter(notNull).map(function (x) {
        return wrap(x.join(' && '));
    }).join(' ' + joiner + ' '));
}

function any(_, values) {
    return {
        type: 'any',
        values: values.map(parseFilter),
        toString: function () {
            return printNested(this.values, '||');
        }
    };
}

function all(_, values) {
    return {
        type: 'all',
        values: values.filter(notNull).map(parseFilter),
        toString: function () {
            return printNested(this.values, '&&');
        }
    };
}

function propertyMatchesBoolean(key, value) {
    return {
        type: 'propertyMatchesBoolean',
        key: key,
        value: value,
        toString: function () {
            return wrap(lookUp(this.key) + (this.value ? ' != ' : ' == ')  + 'null');
        }
    };
}

function rangeMatch(key, values) {
    return {
        type: 'rangeMatch',
        key: key,
        values: values,
        toString: function () {
            var expressions = [];

            if (this.values.max) {
                expressions.push('' + lookUp(key) + ' < ' + this.values.max);
            }

            if (this.values.min) {
                expressions.push('' + lookUp(key) + ' >= ' + this.values.min);
            }

            return wrap(expressions.join(' && '));
        }
    };
}

function parseFilter(filter) {
    var filterAST = [];

    // Function filter
    if (typeof filter === 'function') {
        filterAST.push(wrap(filter.toString() + '(context)'));
        return filterAST;
    }

    // Object filter
    var keys = Object.keys(filter);
    keys.forEach(function (key, idx) {

        var value = filter[key],
            type  = typeof value;
        if (type === 'string' || type === 'number') {
            filterAST.push(propertyEqual(key, value));
        } else if (type === 'boolean') {
            filterAST.push(propertyMatchesBoolean(key, value));
        } else if (value == null) {
            filterAST.push(nullValue(key, value));
        } else if (whiteList.indexOf(key) >= 0) {
            switch (key) {
            case 'not':
                filterAST.push(not(key, value));
                break;
            case 'any':
                filterAST.push(any(key, value));
                break;
            case 'all':
                filterAST.push(all(key, value));
                break;
            case 'none':
                filterAST.push(none(key, value));
                break;
            default:
                throw new Error('Unhandled WhiteListed property: ' + key);
            }
        } else if (Array.isArray(value)) {
            filterAST.push(propertyOr(key, value));
        } else if (type === 'object' && value != null) {
            if (value.max || value.min) {
                filterAST.push(rangeMatch(key, value));
            }
        } else {
            throw new Error('Unknown Query sytnax: ' + value);
        }
    });

    return keys.length === 0 ? ['true'] : filterAST;
}

function filterToString(filterAST) {
    return wrap(filterAST.join(' && '));
}

function match(filter) {
    if (filter == null) { return function () { return true; }; }
    // jshint evil: true
    return new Function('context', 'return ' + filterToString(parseFilter(filter)) + ';');
}

module.exports = {
    match: match,
    filterToString: filterToString,
    parseFilter: parseFilter
};

},{}],56:[function(require,module,exports){
'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

module.exports = Buffer;

var ieee754 = require('ieee754');

var BufferMethods;

function Buffer(length) {
    var arr;
    if (length && length.length) {
        arr = length;
        length = arr.length;
    }
    var buf = new Uint8Array(length || 0);
    if (arr) buf.set(arr);

    buf.readUInt32LE = BufferMethods.readUInt32LE;
    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
    buf.readInt32LE = BufferMethods.readInt32LE;
    buf.writeInt32LE = BufferMethods.writeInt32LE;
    buf.readFloatLE = BufferMethods.readFloatLE;
    buf.writeFloatLE = BufferMethods.writeFloatLE;
    buf.readDoubleLE = BufferMethods.readDoubleLE;
    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
    buf.toString = BufferMethods.toString;
    buf.write = BufferMethods.write;
    buf.slice = BufferMethods.slice;
    buf.copy = BufferMethods.copy;

    buf._isBuffer = true;
    return buf;
}

var lastStr, lastStrEncoded;

BufferMethods = {
    readUInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] * 0x1000000);
    },

    writeUInt32LE: function(val, pos) {
        this[pos] = val;
        this[pos + 1] = (val >>> 8);
        this[pos + 2] = (val >>> 16);
        this[pos + 3] = (val >>> 24);
    },

    readInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] << 24);
    },

    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

    toString: function(encoding, start, end) {
        var str = '',
            tmp = '';

        start = start || 0;
        end = Math.min(this.length, end || this.length);

        for (var i = start; i < end; i++) {
            var ch = this[i];
            if (ch <= 0x7F) {
                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                tmp = '';
            } else {
                tmp += '%' + ch.toString(16);
            }
        }

        str += decodeURIComponent(tmp);

        return str;
    },

    write: function(str, pos) {
        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
        for (var i = 0; i < bytes.length; i++) {
            this[pos + i] = bytes[i];
        }
    },

    slice: function(start, end) {
        return this.subarray(start, end);
    },

    copy: function(buf, pos) {
        pos = pos || 0;
        for (var i = 0; i < this.length; i++) {
            buf[pos + i] = this[i];
        }
    }
};

BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

Buffer.byteLength = function(str) {
    lastStr = str;
    lastStrEncoded = encodeString(str);
    return lastStrEncoded.length;
};

Buffer.isBuffer = function(buf) {
    return !!(buf && buf._isBuffer);
};

function encodeString(str) {
    var length = str.length,
        bytes = [];

    for (var i = 0, c, lead; i < length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {

            if (lead) {
                if (c < 0xDC00) {
                    bytes.push(0xEF, 0xBF, 0xBD);
                    lead = c;
                    continue;

                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }

            } else {
                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                else lead = c;

                continue;
            }

        } else if (lead) {
            bytes.push(0xEF, 0xBF, 0xBD);
            lead = null;
        }

        if (c < 0x80) bytes.push(c);
        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
    }
    return bytes;
}

},{"ieee754":58}],57:[function(require,module,exports){
(function (global){
'use strict';

module.exports = Pbf;

var Buffer = global.Buffer || require('./buffer');

function Pbf(buf) {
    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
    this.pos = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
    POW_2_63 = Math.pow(2, 63);

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
    },

    readVarint: function() {
        var buf = this.buf,
            val, b, b0, b1, b2, b3;

        b0 = buf[this.pos++]; if (b0 < 0x80) return b0;                 b0 = b0 & 0x7f;
        b1 = buf[this.pos++]; if (b1 < 0x80) return b0 | b1 << 7;       b1 = (b1 & 0x7f) << 7;
        b2 = buf[this.pos++]; if (b2 < 0x80) return b0 | b1 | b2 << 14; b2 = (b2 & 0x7f) << 14;
        b3 = buf[this.pos++]; if (b3 < 0x80) return b0 | b1 | b2 | b3 << 21;

        val = b0 | b1 | b2 | (b3 & 0x7f) << 21;

        b = buf[this.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
        b = buf[this.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

        throw new Error('Expected varint not more than 10 bytes');
    },

    readVarint64: function() {
        var startPos = this.pos,
            val = this.readVarint();

        if (val < POW_2_63) return val;

        var pos = this.pos - 2;
        while (this.buf[pos] === 0xff) pos--;
        if (pos < startPos) pos = startPos;

        val = 0;
        for (var i = 0; i < pos - startPos + 1; i++) {
            var b = ~this.buf[startPos + i] & 0x7f;
            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
        }

        return -val - 1;
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = this.buf.toString('utf8', this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.slice(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readVarint());
        return arr;
    },
    readPackedSVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Buffer(length);
            this.buf.copy(buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.slice(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        this.buf.writeUInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        this.buf.writeInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val;

        if (val <= 0x7f) {
            this.realloc(1);
            this.buf[this.pos++] = val;

        } else if (val <= 0x3fff) {
            this.realloc(2);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f);

        } else if (val <= 0x1fffff) {
            this.realloc(3);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f);

        } else if (val <= 0xfffffff) {
            this.realloc(4);
            this.buf[this.pos++] = ((val >>> 0) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 7) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 14) & 0x7f) | 0x80;
            this.buf[this.pos++] = ((val >>> 21) & 0x7f);

        } else {
            var pos = this.pos;
            while (val >= 0x80) {
                this.realloc(1);
                this.buf[this.pos++] = (val & 0xff) | 0x80;
                val /= 0x80;
            }
            this.realloc(1);
            this.buf[this.pos++] = val | 0;
            if (this.pos - pos > 10) throw new Error('Given varint doesn\'t fit into 10 bytes');
        }
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        var bytes = Buffer.byteLength(str);
        this.writeVarint(bytes);
        this.realloc(bytes);
        this.buf.write(str, this.pos);
        this.pos += bytes;
    },

    writeFloat: function(val) {
        this.realloc(4);
        this.buf.writeFloatLE(val, this.pos);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        this.buf.writeDoubleLE(val, this.pos);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);

        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        var varintLen =
            len <= 0x7f ? 1 :
            len <= 0x3fff ? 2 :
            len <= 0x1fffff ? 3 :
            len <= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

        // if 1 byte isn't enough for encoding message length, shift the data to the right
        if (varintLen > 1) {
            this.realloc(varintLen - 1);
            for (var i = this.pos - 1; i >= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
        }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./buffer":56}],58:[function(require,module,exports){
module.exports=require(18)
},{"d:\\work\\tangram\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\ieee754\\index.js":18}],59:[function(require,module,exports){
/*!
 * strip-comments <https://github.com/jonschlinkert/strip-comments>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */

'use stric';

var reBlock = '\\/\\*';
var reBlockIgnore = '\\/\\*(?!\\*?\\!)';
var reBlockEnd = '(.|[\\r\\n]|\\n)*?\\*\\/\\n?\\n?';
var reLine = /(^|[^\S\n])(?:\/\/)([\s\S]+?)$/gm;
var reLineIgnore = /(^|[^\S\n])(?:\/\/[^!])([\s\S]+?)$/gm;


/**
 * Strip all comments
 *
 * {%= docs("strip") %}
 *
 * @param   {String} `str`  file contents or string to strip.
 * @param   {Object} `opts`  options are passed to `.block`, and `.line`
 * @return  {String} String without comments.
 * @api public
 */

var strip = module.exports = function(str, opts) {
  return str ? strip.block(strip.line(str, opts), opts) : '';
};


/**
 * Strip only block comments, optionally leaving protected comments
 * (e.g. `/*!`) intact.
 *
 * {%= docs("block") %}
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip only comments that do not start with `/*!` or `/**!`
 * @return  {String} String without block comments.
 * @api public
 */

strip.block = function(str, opts) {
  opts = opts || {};
  var re = new RegExp(reBlock + reBlockEnd, 'gm');
  if(opts.safe) {
    re = new RegExp(reBlockIgnore + reBlockEnd, 'gm');
  }
  return str ? str.replace(re, '') : '';
};


/**
 * Strip only line comments
 *
 * {%= docs("line") %}
 *
 * @param   {String} `str`  file content or string to strip to
 * @param   {Object} `opts`  if `safe:true`, strip all that not starts with `//!`
 * @return  {String} String without line comments.
 * @api public
 */

strip.line = function(str, opts) {
  opts = opts || {};
  var re = reLine;
  if(opts.safe) {
    re = reLineIgnore;
  }
  return str ? str.replace(re, '') : '';
};

},{}],60:[function(require,module,exports){
module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":61,"./lib/vectortilefeature.js":62,"./lib/vectortilelayer.js":63}],61:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}


},{"./vectortilelayer":63}],62:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature._id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {
            line.push(line[0].clone()); // closePolygon

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type];

    for (var i = 0; i < coords.length; i++) {
        var line = coords[i];
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    if (type === 'Point' && coords.length === 1) {
        coords = coords[0][0];
    } else if (type === 'Point') {
        coords = coords[0];
        type = 'MultiPoint';
    } else if (type === 'LineString' && coords.length === 1) {
        coords = coords[0];
    } else if (type === 'LineString') {
        type = 'MultiLineString';
    }

    return {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };
};

},{"point-geometry":64}],63:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":62}],64:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(Î¸) for Î¸.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],65:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Camera */

var Geo = _interopRequire(require("./geo"));

var Utils = _interopRequire(require("./utils/utils"));

var ShaderProgram = _interopRequire(require("./gl/shader_program"));

var glMatrix = _interopRequire(require("gl-matrix"));

var mat4 = glMatrix.mat4;
var vec3 = glMatrix.vec3;

// Abstract base class

var Camera = (function () {
    function Camera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Camera);

        this.scene = scene;
        this.position = options.position;
        this.zoom = options.zoom;
        // this.updateScene();
    }

    _createClass(Camera, {
        update: {

            // Update method called once per frame

            value: function update() {}
        },
        setupProgram: {

            // Called once per frame per program (e.g. for main render pass, then for each additional pass for feature selection, etc.)

            value: function setupProgram(program) {}
        },
        updateScene: {

            /**
                Sync camera position and/or zoom to scene
                position: [lat, lng] or [lat, lng, zoom]
                zoom: zoom
            */

            value: function updateScene() {
                if (this.position || this.zoom) {
                    var view = {};
                    if (this.position) {
                        view = { lng: this.position[0], lat: this.position[1], zoom: this.position[2] };
                    }
                    if (this.zoom) {
                        view.zoom = this.zoom;
                    }
                    this.scene.setView(view);
                }
            }
        }
    }, {
        create: {

            // Create a camera by type name, factory-style

            value: function create(name, scene, config) {
                switch (config.type) {
                    case "isometric":
                        return new IsometricCamera(name, scene, config);
                    case "flat":
                        return new FlatCamera(name, scene, config);
                    case "perspective":
                    /* falls through */
                    default:
                        return new PerspectiveCamera(name, scene, config);
                }
            }
        }
    });

    return Camera;
})();

module.exports = Camera;

/**
    Perspective matrix projection

    This is a specialized perspective camera that, given a desired camera focal length (which can also vary by zoom level),
    constrains the camera height above the ground plane such that the displayed ground area of the map matches that of
    a traditional web mercator map. This means you can set the camera location by [lat, lng, zoom] as you would a typical
    web mercator map, then adjust the focal length as needed.

    Vanishing point can also be adjusted to achieve different "viewing angles", e.g. instead of looking straight down into
    the center of the viewport, the camera appears to be tilted at an angle. For example:

    [0, 0] = looking towards center of viewport
    [-250, -250] = looking 250 pixels from the viewport center to the lower-left corner
    [400, 0] = looking 400 pixels to the right of the viewport center
*/

var PerspectiveCamera = (function (_Camera) {
    function PerspectiveCamera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, PerspectiveCamera);

        _get(Object.getPrototypeOf(PerspectiveCamera.prototype), "constructor", this).call(this, name, scene, options);
        this.type = "perspective";

        // a single scalar, or pairs of stops mapping zoom levels, e.g. [zoom, focal length]
        this.focal_length = options.focal_length;
        this.fov = options.fov;
        if (!this.focal_length && !this.fov) {
            // Default focal length ranges by zoom
            this.focal_length = [[16, 2], [17, 2.5], [18, 3], [19, 4], [20, 6]];
        }

        this.vanishing_point = options.vanishing_point || [0, 0]; // [x, y]
        this.vanishing_point_skew = [];

        this.position_meters = null;
        this.viewMatrix = new Float64Array(16);
        this.projectionMatrix = new Float32Array(16);

        // 'camera' is the name of the shader block, e.g. determines where in the shader this code is injected
        ShaderProgram.replaceBlock("camera", "\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n            }");
    }

    _inherits(PerspectiveCamera, _Camera);

    _createClass(PerspectiveCamera, {
        constrainCamera: {

            // Constrains the camera so that the viewable area matches given the viewport height
            // (in world space, e.g. meters), given either a camera focal length or field-of-view
            // (focal length is used if both are passed).

            value: function constrainCamera(_ref) {
                var view_height = _ref.view_height;
                var height = _ref.height;
                var focal_length = _ref.focal_length;
                var fov = _ref.fov;

                // Solve for camera height
                if (!height) {
                    // We have focal length, calculate FOV
                    if (focal_length) {
                        fov = Math.atan(1 / focal_length) * 2;
                    }
                    // We have FOV, calculate focal length
                    else if (fov) {
                        fov = fov * Math.PI / 180; // convert FOV degrees to radians
                        focal_length = 1 / Math.tan(fov / 2);
                    }

                    // Distance that camera should be from ground such that it fits the field of view expected
                    // for a conventional web mercator map at the current zoom level and camera focal length
                    height = view_height / 2 * focal_length;
                }
                // Solve for camera focal length / field-of-view
                else {
                    focal_length = 2 * height / view_height;
                    fov = Math.atan(1 / focal_length) * 2;
                }

                return { view_height: view_height, height: height, focal_length: focal_length, fov: fov };
            }
        },
        updateMatrices: {
            value: function updateMatrices() {
                // TODO: only re-calculate these vars when necessary

                // Height of the viewport in meters at current zoom
                var viewport_height = this.scene.css_size.height * Geo.metersPerPixel(this.scene.zoom);

                // Compute camera properties to fit desired view

                var _constrainCamera = this.constrainCamera({
                    view_height: viewport_height,
                    focal_length: Utils.interpolate(this.scene.zoom, this.focal_length),
                    fov: Utils.interpolate(this.scene.zoom, this.fov)
                });

                var height = _constrainCamera.height;
                var fov = _constrainCamera.fov;

                // View matrix
                var position = [this.scene.center_meters.x, this.scene.center_meters.y, height];
                this.position_meters = position;

                // mat4.lookAt(this.viewMatrix,
                //     vec3.fromValues(...position),
                //     vec3.fromValues(position[0], position[1], height - 1),
                //     vec3.fromValues(0, 1, 0));
                // Exclude camera height from view matrix
                mat4.lookAt(this.viewMatrix, vec3.fromValues(position[0], position[1], 0), vec3.fromValues(position[0], position[1], -1), vec3.fromValues(0, 1, 0));

                // Projection matrix
                mat4.perspective(this.projectionMatrix, fov, this.scene.view_aspect, 1, height * 2);

                // Convert vanishing point from pixels to viewport space
                this.vanishing_point_skew[0] = this.vanishing_point[0] / this.scene.css_size.width;
                this.vanishing_point_skew[1] = this.vanishing_point[1] / this.scene.css_size.height;

                // Adjust projection matrix to include vanishing point skew
                this.projectionMatrix[8] = -this.vanishing_point_skew[0]; // z column of x row, e.g. amount z skews x
                this.projectionMatrix[9] = -this.vanishing_point_skew[1]; // z column of y row, e.g. amount z skews y

                // Translate geometry into the distance so that camera is appropriate height above ground
                // Additionally, adjust xy to compensate for any vanishing point skew, e.g. move geometry so that the displayed g
                // plane of the map matches that expected by a traditional web mercator map at this [lat, lng, zoom].
                mat4.translate(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(viewport_height / 2 * this.scene.view_aspect * -this.vanishing_point_skew[0], viewport_height / 2 * -this.vanishing_point_skew[1], 0));

                // Include camera height in projection matrix
                mat4.translate(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(0, 0, -height));
            }
        },
        update: {
            value: function update() {
                _get(Object.getPrototypeOf(PerspectiveCamera.prototype), "update", this).call(this);
                this.updateMatrices();
            }
        },
        setupProgram: {
            value: function setupProgram(program) {
                program.uniform("Matrix4fv", "u_projection", false, this.projectionMatrix);
                program.uniform("3f", "u_eye", 0, 0, this.position_meters[2]);
                program.uniform("2fv", "u_vanishing_point", this.vanishing_point_skew);
            }
        }
    });

    return PerspectiveCamera;
})(Camera);

// Isometric-style projection
// Note: this is actually an "axonometric" projection, but I'm using the colloquial term isometric because it is more recognizable.
// An isometric projection is a specific subset of axonometric projections.
// 'axis' determines the xy skew applied to a vertex based on its z coordinate, e.g. [0, 1] axis causes buildings to be drawn
// straight upwards on screen at their true height, [0, .5] would draw them up at half-height, [1, 0] would be sideways, etc.

var IsometricCamera = (function (_Camera2) {
    function IsometricCamera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, IsometricCamera);

        _get(Object.getPrototypeOf(IsometricCamera.prototype), "constructor", this).call(this, name, scene, options);
        this.type = "isometric";
        this.axis = options.axis || { x: 0, y: 1 };
        if (this.axis.length === 2) {
            this.axis = { x: this.axis[0], y: this.axis[1] }; // allow axis to also be passed as 2-elem array
        }

        this.position_meters = null;
        this.viewport_height = null;

        this.viewMatrix = new Float64Array(16);
        this.projectionMatrix = new Float32Array(16);

        // 'camera' is the name of the shader block, e.g. determines where in the shader this code is injected
        ShaderProgram.replaceBlock("camera", "\n            uniform mat4 u_projection;\n            uniform vec3 u_eye;\n            uniform vec2 u_vanishing_point;\n\n            void cameraProjection (inout vec4 position) {\n                position = u_projection * position;\n                // position.xy += position.z * u_isometric_axis;\n\n                // Reverse z for depth buffer so up is negative,\n                // and scale down values so objects higher than one screen height will not get clipped\n                // pull forward slightly to avoid going past far clipping plane\n                position.z = -position.z / 100. + 1. - 0.001;\n            }");
    }

    _inherits(IsometricCamera, _Camera2);

    _createClass(IsometricCamera, {
        update: {
            value: function update() {
                _get(Object.getPrototypeOf(IsometricCamera.prototype), "update", this).call(this);

                this.viewport_height = this.scene.css_size.height * Geo.metersPerPixel(this.scene.zoom);
                var position = [this.scene.center_meters.x, this.scene.center_meters.y, this.viewport_height];
                this.position_meters = position;

                // View
                mat4.identity(this.viewMatrix);
                mat4.translate(this.viewMatrix, this.viewMatrix, vec3.fromValues(-position[0], -position[1], 0));

                // Projection
                mat4.identity(this.projectionMatrix);

                // apply isometric skew
                this.projectionMatrix[8] = this.axis.x / this.scene.view_aspect; // z column of x row, e.g. amount z skews x
                this.projectionMatrix[9] = this.axis.y; // z column of x row, e.g. amount z skews y

                // convert meters to viewport
                mat4.scale(this.projectionMatrix, this.projectionMatrix, vec3.fromValues(2 / this.scene.viewport_meters.x, 2 / this.scene.viewport_meters.y, 2 / this.scene.viewport_meters.y));
            }
        },
        setupProgram: {
            value: function setupProgram(program) {
                program.uniform("Matrix4fv", "u_projection", false, this.projectionMatrix);

                program.uniform("3f", "u_eye", 0, 0, this.viewport_height);
                // program.uniform('3f', 'u_eye', this.viewport_height * this.axis.x, this.viewport_height * this.axis.y, this.viewport_height);
                program.uniform("2f", "u_vanishing_point", 0, 0);
            }
        }
    });

    return IsometricCamera;
})(Camera);

// Flat projection (e.g. just top-down, no perspective) - a degenerate isometric camera

var FlatCamera = (function (_IsometricCamera) {
    function FlatCamera(name, scene) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, FlatCamera);

        _get(Object.getPrototypeOf(FlatCamera.prototype), "constructor", this).call(this, name, scene, options);
        this.type = "flat";
    }

    _inherits(FlatCamera, _IsometricCamera);

    _createClass(FlatCamera, {
        update: {
            value: function update() {
                // Axis is fixed to (0, 0) for flat camera
                this.axis.x = 0;
                this.axis.y = 0;

                _get(Object.getPrototypeOf(FlatCamera.prototype), "update", this).call(this);
            }
        }
    });

    return FlatCamera;
})(IsometricCamera);

// this.updateScene();

},{"./geo":67,"./gl/shader_program":71,"./utils/utils":101,"gl-matrix":22}],66:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
/*jshint worker: true */
/*globals DataSource, topojson */

var Geo = _interopRequire(require("./geo"));

var MethodNotImplemented = require("./utils/errors").MethodNotImplemented;

var Utils = _interopRequire(require("./utils/utils"));

var log = _interopRequire(require("loglevel"));

var DataSource = (function () {
    function DataSource(source) {
        _classCallCheck(this, DataSource);

        this.id = source.id;
        this.name = source.name;
        this.url = source.url;
        // overzoom will apply for zooms higher than this
        this.max_zoom = source.max_zoom || Geo.max_zoom;
    }

    _createClass(DataSource, {
        load: {
            value: function load(dest) {
                throw new MethodNotImplemented("load");
            }
        }
    }, {
        create: {

            // Create a tile source by type, factory-style

            value: function create(source) {
                if (DataSource.types[source.type]) {
                    return new DataSource.types[source.type](source);
                }
            }
        },
        projectData: {

            // Mercator projection

            value: function projectData(source) {
                var timer = +new Date();
                for (var t in source.layers) {
                    var num_features = source.layers[t].features.length;
                    for (var f = 0; f < num_features; f++) {
                        var feature = source.layers[t].features[f];
                        Geo.transformGeometry(feature.geometry, function (coord) {
                            var _Geo$latLngToMeters = Geo.latLngToMeters(coord);

                            var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                            var x = _Geo$latLngToMeters2[0];
                            var y = _Geo$latLngToMeters2[1];

                            coord[0] = x;
                            coord[1] = y;
                        });
                    }
                }

                if (source.debug !== undefined) {
                    source.debug.projection = +new Date() - timer;
                }
            }
        },
        scaleData: {

            /**
             Re-scale geometries within each source to the range [0, scale]
             TODO: clip vertices at edges? right now vertices can have
             values outside [0, scale] (over or under bounds); this would
             pose a problem if we wanted to binary encode the vertices in
             fewer bits (e.g. 12 bits each for scale of 4096)
            */

            value: function scaleData(source, _ref) {
                var z = _ref.coords.z;
                var min = _ref.min;

                for (var t in source.layers) {
                    var num_features = source.layers[t].features.length;
                    for (var f = 0; f < num_features; f++) {
                        var feature = source.layers[t].features[f];
                        Geo.transformGeometry(feature.geometry, function (coord) {
                            coord[0] = (coord[0] - min.x) * Geo.units_per_meter[z];
                            // TODO: this will create negative y-coords, force positive as below instead? or, if later storing positive coords in bit-packed values, flip to negative in post-processing?
                            coord[1] = (coord[1] - min.y) * Geo.units_per_meter[z];
                            // coord[1] = (coord[1] - tile.max.y) * Geo.units_per_meter[tile.coords.z]; // alternate to force y-coords to be positive, subtract tile max instead of min
                        });
                    }
                }
            }
        },
        register: {

            // Register a new data source type

            value: function register(type_class) {
                if (!type_class || !type_class.type) {
                    return;
                }

                DataSource.types[type_class.type] = type_class;
            }
        }
    });

    return DataSource;
})();

exports["default"] = DataSource;

DataSource.types = {}; // set of supported data source classes, referenced by type name

/*** Generic network loading source - abstract class ***/

var NetworkSource = exports.NetworkSource = (function (_DataSource) {
    function NetworkSource(source) {
        _classCallCheck(this, NetworkSource);

        _get(Object.getPrototypeOf(NetworkSource.prototype), "constructor", this).call(this, source);
        this.response_type = ""; // use to set explicit XHR type
    }

    _inherits(NetworkSource, _DataSource);

    _createClass(NetworkSource, {
        load: {
            value: function load(dest) {
                var _this = this;

                var url = this.formatUrl(dest);

                if (dest.sources == null) {
                    dest.sources = {};
                }

                var source = dest.sources[this.name] = {};

                source.url = url;
                source.debug = {};
                source.debug.network = +new Date();

                return new Promise(function (resolve, reject) {
                    source.error = null;
                    // For testing network errors
                    // var promise = Utils.io(url, 60 * 100, this.response_type);
                    // if (Math.random() < .7) {
                    //     promise = Promise.reject(Error('fake data source error'));
                    // }
                    // promise.then((body) => {
                    var promise = Utils.io(url, 60 * 1000, _this.response_type);
                    source.request = promise.request;

                    promise.then(function (body) {
                        source.debug.response_size = body.length || body.byteLength;
                        source.debug.network = +new Date() - source.debug.network;
                        source.debug.parsing = +new Date();
                        _this.parseSourceData(dest, source, body);
                        source.debug.parsing = +new Date() - source.debug.parsing;
                        resolve(dest);
                    })["catch"](function (error) {
                        source.error = error.toString();
                        resolve(dest); // resolve request but pass along error
                    });
                });
            }
        },
        formatUrl: {

            // Sub-classes must implement:

            value: function formatUrl(dest) {
                throw new MethodNotImplemented("formatUrl");
            }
        },
        parseSourceData: {
            value: function parseSourceData(dest, source, reponse) {
                throw new MethodNotImplemented("parseSourceData");
            }
        }
    });

    return NetworkSource;
})(DataSource);

/*** Generic network tile loading - abstract class ***/

var NetworkTileSource = exports.NetworkTileSource = (function (_NetworkSource) {
    function NetworkTileSource(source) {
        _classCallCheck(this, NetworkTileSource);

        _get(Object.getPrototypeOf(NetworkTileSource.prototype), "constructor", this).call(this, source);

        this.tiled = true;
        this.url_hosts = null;
        var host_match = this.url.match(/{s:\[([^}+]+)\]}/);
        if (host_match != null && host_match.length > 1) {
            this.url_hosts = host_match[1].split(",");
            this.next_host = 0;
        }
    }

    _inherits(NetworkTileSource, _NetworkSource);

    _createClass(NetworkTileSource, {
        formatUrl: {
            value: function formatUrl(tile) {
                var url = this.url.replace("{x}", tile.coords.x).replace("{y}", tile.coords.y).replace("{z}", tile.coords.z);

                if (this.url_hosts != null) {
                    url = url.replace(/{s:\[([^}+]+)\]}/, this.url_hosts[this.next_host]);
                    this.next_host = (this.next_host + 1) % this.url_hosts.length;
                }
                return url;
            }
        }
    });

    return NetworkTileSource;
})(NetworkSource);

/**
 GeoJSON standalone (non-tiled) source
*/

var GeoJSONSource = exports.GeoJSONSource = (function (_NetworkSource2) {
    function GeoJSONSource() {
        _classCallCheck(this, GeoJSONSource);

        if (_NetworkSource2 != null) {
            _NetworkSource2.apply(this, arguments);
        }
    }

    _inherits(GeoJSONSource, _NetworkSource2);

    _createClass(GeoJSONSource, {
        formatUrl: {
            value: function formatUrl(dest) {
                return this.url;
            }
        },
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                source.layers = { _default: JSON.parse(response) };
                DataSource.projectData(source); // mercator projection
            }
        }
    });

    return GeoJSONSource;
})(NetworkSource);

GeoJSONSource.type = "GeoJSON";
DataSource.register(GeoJSONSource);

/**
 Mapzen/OSM.US-style GeoJSON vector tiles
 @class GeoJSONTileSource
*/

var GeoJSONTileSource = exports.GeoJSONTileSource = (function (_NetworkTileSource) {
    function GeoJSONTileSource() {
        _classCallCheck(this, GeoJSONTileSource);

        if (_NetworkTileSource != null) {
            _NetworkTileSource.apply(this, arguments);
        }
    }

    _inherits(GeoJSONTileSource, _NetworkTileSource);

    _createClass(GeoJSONTileSource, {
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                var data = JSON.parse(response);

                // Single layer or multi-layers?
                if (data.type === "Feature" || data.type === "FeatureCollection") {
                    source.layers = { _default: data };
                } else {
                    source.layers = data;
                }

                DataSource.projectData(source); // mercator projection
                DataSource.scaleData(source, tile); // re-scale from meters to local tile coords
            }
        }
    });

    return GeoJSONTileSource;
})(NetworkTileSource);

GeoJSONTileSource.type = "GeoJSONTiles";
DataSource.register(GeoJSONTileSource);

/*** Mapzen/OSM.US-style TopoJSON vector tiles ***/

var TopoJSONTileSource = exports.TopoJSONTileSource = (function (_NetworkTileSource2) {
    function TopoJSONTileSource(source) {
        _classCallCheck(this, TopoJSONTileSource);

        _get(Object.getPrototypeOf(TopoJSONTileSource.prototype), "constructor", this).call(this, source);

        // Loads TopoJSON library from official D3 source on demand
        // Not including in base library to avoid the extra weight
        // Only loaded in worker since that is where data is processed
        if (Utils.isWorkerThread && typeof topojson === "undefined") {
            try {
                importScripts("http://d3js.org/topojson.v1.min.js");
                log.info("TopoJSONTileSource: loaded topojson library");
            } catch (e) {
                log.error("TopoJSONTileSource: failed to load TopoJSON library!");
            }
        }
    }

    _inherits(TopoJSONTileSource, _NetworkTileSource2);

    _createClass(TopoJSONTileSource, {
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                if (typeof topojson === "undefined") {
                    tile.layers = {};
                    return;
                }

                source.layers = JSON.parse(response);

                // Single layer
                if (source.layers.objects.vectiles != null) {
                    source.layers = { _default: topojson.feature(source.layers, source.layers.objects.vectiles) };
                }
                // Multiple layers
                else {
                    var layers = {};
                    for (var t in source.layers.objects) {
                        layers[t] = topojson.feature(source.layers, source.layers.objects[t]);
                    }
                    source.layers = layers;
                }

                DataSource.projectData(source); // mercator projection
                DataSource.scaleData(source, tile); // re-scale from meters to local tile coords
            }
        }
    });

    return TopoJSONTileSource;
})(NetworkTileSource);

TopoJSONTileSource.type = "TopoJSONTiles";
DataSource.register(TopoJSONTileSource);

/*** Mapbox vector tiles ***/

var MVTSource = exports.MVTSource = (function (_NetworkTileSource3) {
    function MVTSource(source) {
        _classCallCheck(this, MVTSource);

        _get(Object.getPrototypeOf(MVTSource.prototype), "constructor", this).call(this, source);
        this.response_type = "arraybuffer"; // binary data
        this.Protobuf = require("pbf");
        this.VectorTile = require("vector-tile").VectorTile; // Mapbox vector tile lib
        this.VectorTileFeature = require("vector-tile").VectorTileFeature;

        this.pad_scale = source.pad_scale || 0.001; // scale tile up by this factor (0.1%) to cover seams
    }

    _inherits(MVTSource, _NetworkTileSource3);

    _createClass(MVTSource, {
        parseSourceData: {
            value: function parseSourceData(tile, source, response) {
                var _this = this;

                // Convert Mapbox vector tile to GeoJSON
                var data = new Uint8Array(response);
                var buffer = new this.Protobuf(data);
                source.data = new this.VectorTile(buffer);
                source.layers = this.toGeoJSON(source.data);
                delete source.data; // comment out to save raw data for debugging

                // Post-processing
                for (var t in source.layers) {
                    var num_features = source.layers[t].features.length;
                    for (var f = 0; f < num_features; f++) {
                        var feature = source.layers[t].features[f];

                        // Copy OSM id
                        Geo.transformGeometry(feature.geometry, function (coord) {
                            // Slightly scale up tile to cover seams
                            coord[0] = Math.round(coord[0] * (1 + _this.pad_scale) - 4096 * _this.pad_scale / 2);
                            coord[1] = Math.round(coord[1] * (1 + _this.pad_scale) - 4096 * _this.pad_scale / 2);

                            // Flip Y coord
                            coord[1] = -coord[1];
                        });
                    }
                }
            }
        },
        toGeoJSON: {

            // Loop through layers/features using Mapbox lib API, convert to GeoJSON features
            // Returns an object with keys for each layer, e.g. { layer: geojson }

            value: function toGeoJSON(tile) {
                var layers = {};
                for (var l in tile.layers) {
                    var layer = tile.layers[l];
                    var layer_geojson = {
                        type: "FeatureCollection",
                        features: []
                    };

                    for (var f = 0; f < layer.length; f++) {
                        var feature = layer.feature(f);
                        var feature_geojson = {
                            type: "Feature",
                            geometry: {},
                            properties: feature.properties
                        };

                        var geometry = feature_geojson.geometry;
                        var coordinates = feature.loadGeometry();
                        for (var r = 0; r < coordinates.length; r++) {
                            var ring = coordinates[r];
                            for (var c = 0; c < ring.length; c++) {
                                ring[c] = [ring[c].x, ring[c].y];
                            }
                        }
                        geometry.coordinates = coordinates;

                        if (this.VectorTileFeature.types[feature.type] === "Point") {
                            geometry.type = "Point";
                            geometry.coordinates = geometry.coordinates[0][0];
                        } else if (this.VectorTileFeature.types[feature.type] === "LineString") {
                            if (coordinates.length === 1) {
                                geometry.type = "LineString";
                                geometry.coordinates = geometry.coordinates[0];
                            } else {
                                geometry.type = "MultiLineString";
                            }
                        } else if (this.VectorTileFeature.types[feature.type] === "Polygon") {
                            geometry.type = "Polygon";
                        }

                        layer_geojson.features.push(feature_geojson);
                    }
                    layers[l] = layer_geojson;
                }
                return layers;
            }
        }
    });

    return MVTSource;
})(NetworkTileSource);

MVTSource.type = "MVT";
DataSource.register(MVTSource);

},{"./geo":67,"./utils/errors":99,"./utils/utils":101,"loglevel":54,"pbf":57,"vector-tile":60}],67:[function(require,module,exports){
"use strict";

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

// Miscellaneous geo functions

var Geo;
module.exports = Geo = {};

// Projection constants
Geo.tile_size = 256;
Geo.half_circumference_meters = 20037508.342789244;
Geo.min_zoom_meters_per_pixel = Geo.half_circumference_meters * 2 / Geo.tile_size; // min zoom draws world as 2 tiles wide
Geo.meters_per_pixel = [];
Geo.max_zoom = 20;
for (var z = 0; z <= Geo.max_zoom; z++) {
    Geo.meters_per_pixel[z] = Geo.min_zoom_meters_per_pixel / Math.pow(2, z);
}

Geo.metersPerPixel = function (zoom) {
    return Geo.min_zoom_meters_per_pixel / Math.pow(2, zoom);
};

// Conversion functions based on an defined tile scale
Geo.units_per_meter = [];
Geo.setTileScale = function (scale) {
    Geo.tile_scale = scale;
    Geo.units_per_pixel = Geo.tile_scale / Geo.tile_size;

    for (var z = 0; z <= Geo.max_zoom; z++) {
        Geo.units_per_meter[z] = Geo.tile_scale / (Geo.tile_size * Geo.meters_per_pixel[z]);
    }
};

// Convert tile location to mercator meters - multiply by pixels per tile, then by meters per pixel, adjust for map origin
Geo.metersForTile = function (tile) {
    return {
        x: tile.x * Geo.half_circumference_meters * 2 / Math.pow(2, tile.z) - Geo.half_circumference_meters,
        y: -(tile.y * Geo.half_circumference_meters * 2 / Math.pow(2, tile.z) - Geo.half_circumference_meters)
    };
};

/**
   Given a point in mercator meters and a zoom level, return the tile X/Y/Z that the point lies in
*/
Geo.tileForMeters = function (_ref, zoom) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    return {
        x: Math.floor((x + Geo.half_circumference_meters) / (Geo.half_circumference_meters * 2 / Math.pow(2, zoom))),
        y: Math.floor((-y + Geo.half_circumference_meters) / (Geo.half_circumference_meters * 2 / Math.pow(2, zoom))),
        z: zoom
    };
};

/**
   Convert mercator meters to lat-lng
*/
Geo.metersToLatLng = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    x /= Geo.half_circumference_meters;
    y /= Geo.half_circumference_meters;

    y = (2 * Math.atan(Math.exp(y * Math.PI)) - Math.PI / 2) / Math.PI;

    x *= 180;
    y *= 180;

    return [x, y];
};

/**
  Convert lat-lng to mercator meters
*/
Geo.latLngToMeters = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    // Latitude
    y = Math.log(Math.tan(y * Math.PI / 360 + Math.PI / 4)) / Math.PI;
    y *= Geo.half_circumference_meters;

    // Longitude
    x *= Geo.half_circumference_meters / 180;

    return [x, y];
};

// Run an in-place transform function on each cooordinate in a GeoJSON geometry
Geo.transformGeometry = function (geometry, transform) {
    if (geometry.type === "Point") {
        transform(geometry.coordinates);
    } else if (geometry.type === "LineString" || geometry.type === "MultiPoint") {
        geometry.coordinates.forEach(transform);
    } else if (geometry.type === "Polygon" || geometry.type === "MultiLineString") {
        geometry.coordinates.forEach(function (coordinates) {
            return coordinates.forEach(transform);
        });
    } else if (geometry.type === "MultiPolygon") {
        geometry.coordinates.forEach(function (polygon) {
            polygon.forEach(function (coordinates) {
                return coordinates.forEach(transform);
            });
        });
    }
    // TODO: support GeometryCollection
};

Geo.boxIntersect = function (b1, b2) {
    return !(b2.sw.x > b1.ne.x || b2.ne.x < b1.sw.x || b2.sw.y > b1.ne.y || b2.ne.y < b1.sw.y);
};

// Finds the axis-aligned bounding box for a polygon
Geo.findBoundingBox = function (polygon) {
    var min_x = Infinity,
        max_x = -Infinity,
        min_y = Infinity,
        max_y = -Infinity;

    // Only need to examine outer ring (polygon[0])
    var num_coords = polygon[0].length;
    for (var c = 0; c < num_coords; c++) {
        var coord = polygon[0][c];

        if (coord[0] < min_x) {
            min_x = coord[0];
        }
        if (coord[1] < min_y) {
            min_y = coord[1];
        }
        if (coord[0] > max_x) {
            max_x = coord[0];
        }
        if (coord[1] > max_y) {
            max_y = coord[1];
        }
    }

    return [min_x, min_y, max_x, max_y];
};

// Convert geometry type to one of: 'point', 'line', 'polygon'
Geo.geometryType = function (type) {
    if (type === "Polygon" || type === "MultiPolygon") {
        return "polygon";
    } else if (type === "LineString" || type === "MultiLineString") {
        return "line";
    }
    if (type === "Point" || type === "MultiPoint") {
        return "point";
    }
};

},{}],68:[function(require,module,exports){
"use strict";

// WebGL constants - need to import these separately to make them available in the web worker

var gl;
module.exports = gl = {};

/* DataType */
gl.BYTE = 5120;
gl.UNSIGNED_BYTE = 5121;
gl.SHORT = 5122;
gl.UNSIGNED_SHORT = 5123;
gl.INT = 5124;
gl.UNSIGNED_INT = 5125;
gl.FLOAT = 5126;

},{}],69:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

// WebGL context wrapper

var log = _interopRequire(require("loglevel"));

var Context;
module.exports = Context = {};

// Setup a WebGL context
// If no canvas element is provided, one is created and added to the document body
Context.getContext = function getContext(canvas, options) {

    var fullscreen = false;
    if (canvas == null) {
        canvas = document.createElement("canvas");
        canvas.style.position = "absolute";
        canvas.style.top = 0;
        canvas.style.left = 0;
        canvas.style.zIndex = -1;
        document.body.appendChild(canvas);
        fullscreen = true;
    }

    var gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
    if (!gl) {
        log.error("Couldn't create WebGL context. Your browser probably doesn't support WebGL or it's turned off?");
        alert("Couldn't create WebGL context. Your browser probably doesn't support WebGL or it's turned off?");
        throw "Couldn't create WebGL context";
    }

    Context.resize(gl, window.innerWidth, window.innerHeight);
    if (fullscreen === true) {
        window.addEventListener("resize", function () {
            Context.resize(gl, window.innerWidth, window.innerHeight);
        });
    }

    return gl;
};

Context.resize = function (gl, width, height) {
    var device_pixel_ratio = window.devicePixelRatio || 1;
    gl.canvas.style.width = width + "px";
    gl.canvas.style.height = height + "px";
    gl.canvas.width = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.canvas.height = Math.round(gl.canvas.style.width * device_pixel_ratio);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
};

},{"loglevel":54}],70:[function(require,module,exports){
"use strict";

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var GLSL = {};
module.exports = GLSL;

/**
    Parse uniforms from a JS object, infers types and returns an array of objects with the
    necessary information to set uniform values on a GL program. Each object in the returned
    array has the form:
    { type, method, name, value }

    type: the GL uniform type, such as 'vec3', 'float', etc.
    method: the GL uniform setter method to use, such as '1f', '3fv', etc.
    name: the fully qualified name of the GL uniform location, e.g. 'array[0].field', etc.
    value: the value to be passed to the GL uniform setter for that type, e.g. [1, 2, 3] for a vec3

    Textures have special behavior: uniforms with string values are treated as textures, and
    the string is used as a unique texture 'key' to be interpreted by the caller (which is responsible
    for actually setting the uniforms). For example, this could be used as a key into a dictionary of
    known texture names, or it could simply be used as a URL to dynamically load the texture from.
*/
GLSL.parseUniforms = function (uniforms) {
    var prefix = arguments[1] === undefined ? null : arguments[1];

    var parsed = [];

    for (var name in uniforms) {
        var uniform = uniforms[name];
        var u;

        if (prefix) {
            name = prefix + "." + name;
        }

        // Single float
        if (typeof uniform === "number") {
            parsed.push({
                type: "float",
                method: "1f",
                name: name, value: uniform
            });
        }
        // Array: vector, array of floats, array of textures, or array of structs
        else if (Array.isArray(uniform)) {
            // Numeric values
            if (typeof uniform[0] === "number") {
                // float vectors (vec2, vec3, vec4)
                if (uniform.length >= 2 && uniform.length <= 4) {
                    parsed.push({
                        type: "vec" + uniform.length,
                        method: uniform.length + "fv",
                        name: name,
                        value: uniform
                    });
                }
                // float array
                else if (uniform.length > 4) {
                    parsed.push({
                        type: "float[]",
                        method: "1fv",
                        name: name + "[0]",
                        value: uniform
                    });
                }
                // TODO: assume matrix for (typeof == Float32Array && length == 16)?
            }
            // Array of textures
            else if (typeof uniform[0] === "string") {
                for (u = 0; u < uniform.length; u++) {
                    parsed.push({
                        type: "sampler2D",
                        method: "1i",
                        name: name + "[" + u + "]",
                        value: uniform[u]
                    });
                }
            }
            // Array of arrays - but only arrays of vectors are allowed in this case
            else if (Array.isArray(uniform[0]) && typeof uniform[0][0] === "number") {
                // float vectors (vec2, vec3, vec4)
                if (uniform[0].length >= 2 && uniform[0].length <= 4) {
                    // Set each vector in the array
                    for (u = 0; u < uniform.length; u++) {
                        parsed.push({
                            type: "vec" + uniform[0].length,
                            method: uniform[u].length + "fv",
                            name: name + "[" + u + "]",
                            value: uniform[u]
                        });
                    }
                }
                // else error?
            }
            // Array of structures
            else if (typeof uniform[0] === "object") {
                for (u = 0; u < uniform.length; u++) {
                    // Set each struct in the array
                    parsed.push.apply(parsed, _toConsumableArray(GLSL.parseUniforms(uniform[u], name + "[" + u + "]")));
                }
            }
        }
        // Boolean
        else if (typeof uniform === "boolean") {
            parsed.push({
                type: "bool",
                method: "1i",
                name: name,
                value: uniform
            });
        }
        // Texture
        else if (typeof uniform === "string") {
            parsed.push({
                type: "sampler2D",
                method: "1i",
                name: name,
                value: uniform
            });
        }
        // Structure
        else if (typeof uniform === "object") {
            // Set each field in the struct
            parsed.push.apply(parsed, _toConsumableArray(GLSL.parseUniforms(uniform, name)));
        }

        // TODO: support other non-float types? (int, etc.)
    }

    return parsed;
};

/**
    Generate a GLSL variable definition from a JS object
*/
GLSL.defineVariable = function (name, value) {
    var prefix = arguments[2] === undefined ? null : arguments[2];

    var type, array;
    var structs = "";
    prefix = prefix ? prefix + "_" + name : name;

    // Single float
    if (typeof value === "number") {
        type = "float";
    }
    // Multiple floats - vector or array
    else if (Array.isArray(value)) {
        // Numeric values
        if (typeof value[0] === "number") {
            // float vectors (vec2, vec3, vec4)
            if (value.length >= 2 && value.length <= 4) {
                type = "vec" + value.length;
            }
            // float array
            else {
                //if (value.length > 4) {
                type = "float";
                array = value.length;
            }
            // TODO: assume matrix for (typeof == Float32Array && length == 16)?
        }
        // Array of textures
        else if (typeof value[0] === "string") {
            type = "sampler2D";
            array = value.length;
        }
        // Array of arrays - but only arrays of vectors are allowed in this case
        else if (Array.isArray(value[0]) && typeof value[0][0] === "number") {
            // float vectors (vec2, vec3, vec4)
            if (value[0].length >= 2 && value[0].length <= 4) {
                type = "vec" + value[0].length;
            }
            // else error?
            array = value[0].length;
        }
        // Array of structures
        else if (typeof value[0] === "object") {
            type = "_type_" + prefix; // custom struct name
            array = value.length;
            structs += GLSL.defineStruct(type, value[0], prefix) + "\n"; // build & add to list of dependent structs
        }
    }
    // Boolean
    else if (typeof value === "boolean") {
        type = "bool";
    }
    // Texture
    else if (typeof value === "string") {
        type = "sampler2D";
    }
    // Structure
    else if (typeof value === "object") {
        type = "_type_" + prefix; // custom struct name
        structs += GLSL.defineStruct(type, value, prefix) + "\n"; // build & add to list of dependent structs
    }

    // Construct variable definition
    var variable = "";
    variable += "" + type + " " + name;
    if (array) {
        variable += "[" + array + "]";
    }
    variable += ";\n";

    // Return the variable definition itself, and any dependent struct definitions
    return { variable: variable, structs: structs };
};

/**
    Generate a GLSL structure definition from a JS object
*/
GLSL.defineStruct = function (type, value) {
    var prefix = arguments[2] === undefined ? null : arguments[2];

    var struct = "struct " + type + " {\n";
    var dependents = "";
    for (var field in value) {
        var subvar = GLSL.defineVariable(field, value[field], prefix);
        struct += "    " + subvar.variable;
        dependents += subvar.structs;
    }
    struct += "};\n";
    struct = dependents + struct;
    return struct;
};

/**
    Generate a GLSL uniform definition from a JS object
*/
GLSL.defineUniform = function (name, value) {
    var def = GLSL.defineVariable(name, value);
    def = def.structs + "uniform " + def.variable;
    return def;
};

/**
    Check for a uniform definition of 'name' in the provided GLSL source
    Simple regex check for 'uniform' keyword and var name, does not attempt to parse/extract GLSL
    NOTE: assumes comments have been stripped from source
*/
GLSL.isUniformDefined = function (name, source) {
    // Match, in order:
    // - the keyword 'uniform'
    // - at least one character that is anything except a semicolon, ;
    // - optionally, anything enclosed in curly braces, { ... } (an inline structure definition can go here)
    // - optionally, any # of characters that is not a semicolon, ;
    // - the name of the uniform

    var re = new RegExp("uniform[^;]+(?:{[\\s\\S]*})?[^;]*\\b" + name + "\\b", "g");
    if (source.match(re)) {
        return true;
    }
    return false;
};

/**
    Check that a symbol is referenced in the GLSL source
    NOTE: assumes comments have been stripped from source
*/
GLSL.isSymbolReferenced = function (name, source) {
    var re = new RegExp("\\b" + name + "\\b", "g");
    if (source.search(re) >= 0) {
        return true;
    }
    return false;
};

/**
    Expand a single value or 2-element array into a 3-element array, with the last ( z )
    coordinate defaulting to 1 (with option to specify). Also runs parseFloat to try to maintain
    data integrity. Returns null if input couldn't be parsed.
*/
GLSL.expandVec3 = function (v) {
    var z = arguments[1] === undefined ? 1 : arguments[1];

    var x = undefined;
    if (Array.isArray(v) && v.length === 2) {
        x = [].concat(_toConsumableArray(v), [z]).map(parseFloat);
    } else {
        x = [v, v, v].map(parseFloat);
    }

    if (x && x.every(function (n) {
        return typeof n === "number" && !isNaN(n);
    })) {
        return x;
    }
};

/**
    Expand a single value or 3-element array into a 4-element array, with the last (e.g. w or a)
    coordinate defaulting to 1 (with option to specify). Also runs parseFloat to try to maintain
    data integrity. Returns null if input couldn't be parsed.
*/
GLSL.expandVec4 = function (v) {
    var w = arguments[1] === undefined ? 1 : arguments[1];

    var x = undefined;
    if (Array.isArray(v) && v.length === 3) {
        x = [].concat(_toConsumableArray(v), [w]).map(parseFloat);
    } else {
        x = [v, v, v, w].map(parseFloat);
    }

    if (x && x.every(function (n) {
        return typeof n === "number" && !isNaN(n);
    })) {
        return x;
    }
};

},{}],71:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global ShaderProgram */
// GL program wrapper to cache uniform locations/values, do compile-time pre-processing
// (injecting #defines and #pragma blocks into shaders), etc.

var GLSL = _interopRequire(require("./glsl"));

var Texture = _interopRequire(require("./texture"));

var log = _interopRequire(require("loglevel"));

var strip = _interopRequire(require("strip-comments"));

var ShaderProgram = (function () {
    function ShaderProgram(gl, vertex_source, fragment_source, options) {
        _classCallCheck(this, ShaderProgram);

        options = options || {};

        this.gl = gl;
        this.program = null;
        this.compiled = false;
        this.compiling = false;
        this.error = null;

        // key/values inserted as #defines into shaders at compile-time
        this.defines = Object.assign({}, options.defines || {});

        // key/values for blocks that can be injected into shaders at compile-time
        this.blocks = Object.assign({}, options.blocks || {});

        // JS-object uniforms that are expected by this program
        // If they are not found in the existing shader source, their types will be inferred and definitions
        // for each will be injected.
        this.dependent_uniforms = options.uniforms;

        this.uniforms = {}; // program locations of uniforms, lazily added as each uniform is set
        this.attribs = {}; // program locations of vertex attributes, lazily added as each attribute is accessed

        this.vertex_source = vertex_source;
        this.fragment_source = fragment_source;

        this.id = ShaderProgram.id++;
        ShaderProgram.programs[this.id] = this;
        this.name = options.name; // can provide a program name (useful for debugging)
    }

    _createClass(ShaderProgram, {
        destroy: {
            value: function destroy() {
                this.gl.useProgram(null);
                this.gl.deleteProgram(this.program);
                this.program = null;
                this.uniforms = {};
                this.attribs = {};
                delete ShaderProgram.programs[this.id];
                this.compiled = false;
            }
        },
        use: {

            // Use program wrapper with simple state cache

            value: function use() {
                if (!this.compiled) {
                    return;
                }

                if (ShaderProgram.current !== this) {
                    this.gl.useProgram(this.program);
                }
                ShaderProgram.current = this;
            }
        },
        compile: {
            value: function compile() {
                if (this.compiling) {
                    throw new Error("ShaderProgram.compile(): skipping for " + this.id + " (" + this.name + ") because already compiling");
                }
                this.compiling = true;
                this.compiled = false;
                this.error = null;

                // Copy sources from pre-modified template
                this.computed_vertex_source = this.vertex_source;
                this.computed_fragment_source = this.fragment_source;

                // Make list of defines to be injected later
                var defines = this.buildDefineList();

                // Inject user-defined blocks (arbitrary code points matching named #pragmas)
                // Replace according to this pattern:
                // #pragma tangram: [key]
                // e.g. #pragma tangram: global

                // Gather all block code snippets
                var blocks = this.buildShaderBlockList();
                var regexp;

                for (var key in blocks) {
                    var block = blocks[key];
                    if (!block || Array.isArray(block) && block.length === 0) {
                        continue;
                    }

                    // First find code replace points in shaders
                    regexp = new RegExp("^\\s*#pragma\\s+tangram:\\s+" + key + "\\s*$", "m");
                    var inject_vertex = this.computed_vertex_source.match(regexp);
                    var inject_fragment = this.computed_fragment_source.match(regexp);

                    // Avoid network request if nothing to replace
                    if (inject_vertex == null && inject_fragment == null) {
                        continue;
                    }

                    // Each key can be a single string or array of strings
                    var source = "\n" + block + "\n";
                    if (Array.isArray(block)) {
                        // Combine all blocks into one string
                        source = block.reduce(function (prev, cur) {
                            return "\n" + prev + "\n" + cur + "\n";
                        });
                    }

                    // Inject
                    if (inject_vertex != null) {
                        this.computed_vertex_source = this.computed_vertex_source.replace(regexp, source);
                    }
                    if (inject_fragment != null) {
                        this.computed_fragment_source = this.computed_fragment_source.replace(regexp, source);
                    }

                    // Add a #define for this injection point
                    defines["TANGRAM_BLOCK_" + key.replace(/[\s-]+/g, "_").toUpperCase()] = true;
                }

                // Clean-up any #pragmas that weren't replaced (to prevent compiler warnings)
                regexp = new RegExp("^\\s*#pragma.*$", "gm");
                this.computed_vertex_source = this.computed_vertex_source.replace(regexp, "");
                this.computed_fragment_source = this.computed_fragment_source.replace(regexp, "");

                // Build & inject defines
                // This is done *after* code injection so that we can add defines for which code points were injected
                defines.TANGRAM_VERTEX_SHADER = true;
                defines.TANGRAM_FRAGMENT_SHADER = false;
                this.computed_vertex_source = ShaderProgram.buildDefineString(defines) + this.computed_vertex_source;

                defines.TANGRAM_VERTEX_SHADER = false;
                defines.TANGRAM_FRAGMENT_SHADER = true;
                this.computed_fragment_source = ShaderProgram.buildDefineString(defines) + this.computed_fragment_source;

                // Detect uniform definitions, inject any missing ones
                this.ensureUniforms(this.dependent_uniforms);

                // Include program info useful for debugging
                var info = this.name ? this.name + " / id " + this.id : "id " + this.id;
                this.computed_vertex_source = "// Program: " + info + "\n" + this.computed_vertex_source;
                this.computed_fragment_source = "// Program: " + info + "\n" + this.computed_fragment_source;

                // Compile & set uniforms to cached values
                try {
                    this.program = ShaderProgram.updateProgram(this.gl, this.program, this.computed_vertex_source, this.computed_fragment_source);
                    this.compiled = true;
                    this.compiling = false;
                } catch (error) {
                    this.program = null;
                    this.compiled = false;
                    this.compiling = false;
                    this.error = error;
                    throw new Error("ShaderProgram.compile(): program " + this.id + " (" + this.name + ") error:", error);
                }

                this.use();
                this.refreshUniforms();
                this.refreshAttributes();
            }
        },
        buildDefineList: {

            // Make list of defines (global, then program-specific)

            value: function buildDefineList() {
                var d,
                    defines = {};
                for (d in ShaderProgram.defines) {
                    defines[d] = ShaderProgram.defines[d];
                }
                for (d in this.defines) {
                    defines[d] = this.defines[d];
                }
                return defines;
            }
        },
        buildShaderBlockList: {

            // Make list of shader blocks (global, then program-specific)

            value: function buildShaderBlockList() {
                var d,
                    blocks = {};
                for (d in ShaderProgram.blocks) {
                    blocks[d] = [];

                    if (Array.isArray(ShaderProgram.blocks[d])) {
                        var _blocks$d;

                        (_blocks$d = blocks[d]).push.apply(_blocks$d, _toConsumableArray(ShaderProgram.blocks[d]));
                    } else {
                        blocks[d] = [ShaderProgram.blocks[d]];
                    }
                }
                for (d in this.blocks) {
                    blocks[d] = blocks[d] || [];

                    if (Array.isArray(this.blocks[d])) {
                        var _blocks$d2;

                        (_blocks$d2 = blocks[d]).push.apply(_blocks$d2, _toConsumableArray(this.blocks[d]));
                    } else {
                        blocks[d].push(this.blocks[d]);
                    }
                }
                return blocks;
            }
        },
        ensureUniforms: {

            // Detect uniform definitions, inject any missing ones

            value: function ensureUniforms(uniforms) {
                if (!uniforms) {
                    return;
                }

                var vs = strip(this.computed_vertex_source);
                var fs = strip(this.computed_fragment_source);
                var inject,
                    vs_injections = [],
                    fs_injections = [];

                // Check for missing uniform definitions
                for (var name in uniforms) {
                    inject = null;

                    // Check vertex shader
                    if (!GLSL.isUniformDefined(name, vs) && GLSL.isSymbolReferenced(name, vs)) {
                        if (!inject) {
                            inject = GLSL.defineUniform(name, uniforms[name]);
                        }
                        log.trace("Program " + this.name + ": " + name + " not defined in vertex shader, injecting: '" + inject + "'");
                        vs_injections.push(inject);
                    }
                    // Check fragment shader
                    if (!GLSL.isUniformDefined(name, fs) && GLSL.isSymbolReferenced(name, fs)) {
                        if (!inject) {
                            inject = GLSL.defineUniform(name, uniforms[name]);
                        }
                        log.trace("Program " + this.name + ": " + name + " not defined in fragment shader, injecting: '" + inject + "'");
                        fs_injections.push(inject);
                    }
                }

                // Inject missing uniforms
                // NOTE: these are injected at the very top of the shaders, even before any #defines or #pragmas are added
                // this could cause some issues with certain #pragmas, or other functions that might expect #defines
                if (vs_injections.length > 0) {
                    this.computed_vertex_source = vs_injections.join("\n") + this.computed_vertex_source;
                }

                if (fs_injections.length > 0) {
                    this.computed_fragment_source = fs_injections.join("\n") + this.computed_fragment_source;
                }
            }
        },
        setUniforms: {

            // Set uniforms from a JS object, with inferred types

            value: function setUniforms(uniforms) {
                var reset_texture_unit = arguments[1] === undefined ? true : arguments[1];

                if (!this.compiled) {
                    return;
                }

                // TODO: only update uniforms when changed

                // Texture units must be tracked and incremented each time a texture sampler uniform is set.
                // By default, the texture unit is reset to 0 each time setUniforms is called, but they can
                // also be preserved, for example in cases where multiple calls to setUniforms are expected
                // (e.g. program-specific uniforms followed by mesh-specific ones).
                if (reset_texture_unit) {
                    this.texture_unit = 0;
                }

                // Parse uniform types and values from the JS object
                var parsed = GLSL.parseUniforms(uniforms);

                // Set each uniform
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = parsed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var uniform = _step.value;

                        if (uniform.type === "sampler2D") {
                            // For textures, we need to track texture units, so we have a special setter
                            this.setTextureUniform(uniform.name, uniform.value);
                        } else {
                            this.uniform(uniform.method, uniform.name, uniform.value);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        saveUniforms: {

            // Cache some or all uniform values so they can be restored

            value: function saveUniforms(subset) {
                var uniforms = subset || this.uniforms;
                for (var u in uniforms) {
                    var uniform = this.uniforms[u];
                    if (uniform) {
                        uniform.saved_value = uniform.value;
                    }
                }
                this.saved_texture_unit = this.texture_unit || 0;
            }
        },
        restoreUniforms: {

            // Restore some or all uniforms to saved values

            value: function restoreUniforms(subset) {
                var uniforms = subset || this.uniforms;
                for (var u in uniforms) {
                    var uniform = this.uniforms[u];
                    if (uniform && uniform.saved_value) {
                        uniform.value = uniform.saved_value;
                        this.updateUniform(u);
                    }
                }
                this.texture_unit = this.saved_texture_unit || 0;
            }
        },
        setTextureUniform: {

            // Set a texture uniform, finds texture by name or creates a new one

            value: function setTextureUniform(uniform_name, texture_name) {
                var texture = Texture.textures[texture_name];
                if (texture == null) {
                    texture = new Texture(this.gl, texture_name);
                    texture.load(texture_name);
                }

                texture.bind(this.texture_unit);
                this.uniform("1i", uniform_name, this.texture_unit);
                this.texture_unit++; // TODO: track max texture units and log/throw errors
            }
        },
        uniform: {

            // ex: program.uniform('3f', 'position', x, y, z);
            // TODO: only update uniforms when changed

            value: function uniform(method, name) {
                for (var _len = arguments.length, value = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                    value[_key - 2] = arguments[_key];
                }

                // 'value' is a method-appropriate arguments list
                if (!this.compiled) {
                    return;
                }

                this.uniforms[name] = this.uniforms[name] || {};
                var uniform = this.uniforms[name];
                uniform.name = name;
                if (uniform.location === undefined) {
                    uniform.location = this.gl.getUniformLocation(this.program, name);
                }
                uniform.method = "uniform" + method;
                uniform.value = value;
                this.updateUniform(name);
            }
        },
        updateUniform: {

            // Set a single uniform

            value: function updateUniform(name) {
                if (!this.compiled) {
                    return;
                }

                var uniform = this.uniforms[name];
                if (!uniform || uniform.location == null) {
                    return;
                }

                this.use();
                this.gl[uniform.method].apply(this.gl, [uniform.location].concat(uniform.value)); // call appropriate GL uniform method and pass through arguments
            }
        },
        refreshUniforms: {

            // Refresh uniform locations and set to last cached values

            value: function refreshUniforms() {
                if (!this.compiled) {
                    return;
                }

                for (var u in this.uniforms) {
                    this.uniforms[u].location = this.gl.getUniformLocation(this.program, u);
                    this.updateUniform(u);
                }
            }
        },
        refreshAttributes: {
            value: function refreshAttributes() {
                // var len = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);
                // for (var i=0; i < len; i++) {
                //     var a = this.gl.getActiveAttrib(this.program, i);
                // }
                this.attribs = {};
            }
        },
        attribute: {

            // Get the location of a vertex attribute

            value: function attribute(name) {
                if (!this.compiled) {
                    return;
                }

                var attrib = this.attribs[name] = this.attribs[name] || {};
                if (attrib.location != null) {
                    return attrib;
                }

                attrib.name = name;
                attrib.location = this.gl.getAttribLocation(this.program, name);

                // var info = this.gl.getActiveAttrib(this.program, attrib.location);
                // attrib.type = info.type;
                // attrib.size = info.size;

                return attrib;
            }
        }
    });

    return ShaderProgram;
})();

module.exports = ShaderProgram;

// Static methods and state

ShaderProgram.id = 0; // assign each program a unique id
ShaderProgram.programs = {}; // programs, by id
ShaderProgram.current = null; // currently bound program

// Global config applied to all programs (duplicate properties for a specific program will take precedence)
ShaderProgram.defines = {};
ShaderProgram.blocks = {};

// Turn an object of key/value pairs into single string of #define statements
ShaderProgram.buildDefineString = function (defines) {
    var define_str = "";
    for (var d in defines) {
        if (defines[d] === false) {
            continue;
        } else if (typeof defines[d] === "boolean" && defines[d] === true) {
            // booleans are simple defines with no value
            define_str += "#define " + d + "\n";
        } else if (typeof defines[d] === "number" && Math.floor(defines[d]) === defines[d]) {
            // int to float conversion to satisfy GLSL floats
            define_str += "#define " + d + " " + defines[d].toFixed(1) + "\n";
        } else {
            // any other float or string value
            define_str += "#define " + d + " " + defines[d] + "\n";
        }
    }
    return define_str;
};

ShaderProgram.addBlock = function (key) {
    var _ShaderProgram$blocks$key;

    for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        blocks[_key - 1] = arguments[_key];
    }

    ShaderProgram.blocks[key] = ShaderProgram.blocks[key] || [];
    (_ShaderProgram$blocks$key = ShaderProgram.blocks[key]).push.apply(_ShaderProgram$blocks$key, blocks);
};

// Remove all global shader blocks for a given key
ShaderProgram.removeBlock = function (key) {
    ShaderProgram.blocks[key] = [];
};

ShaderProgram.replaceBlock = function (key) {
    for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        blocks[_key - 1] = arguments[_key];
    }

    ShaderProgram.removeBlock(key);
    ShaderProgram.addBlock.apply(ShaderProgram, [key].concat(blocks));
};

// Compile & link a WebGL program from provided vertex and fragment shader sources
// update a program if one is passed in. Create one if not. Alert and don't update anything if the shaders don't compile.
ShaderProgram.updateProgram = function (gl, program, vertex_shader_source, fragment_shader_source) {
    try {
        var vertex_shader = ShaderProgram.createShader(gl, vertex_shader_source, gl.VERTEX_SHADER);
        var fragment_shader = ShaderProgram.createShader(gl, "#ifdef GL_ES\nprecision highp float;\n#endif\n\n" + fragment_shader_source, gl.FRAGMENT_SHADER);
    } catch (err) {
        log.error(err);
        throw err;
    }

    gl.useProgram(null);
    if (program != null) {
        var old_shaders = gl.getAttachedShaders(program);
        for (var i = 0; i < old_shaders.length; i++) {
            gl.detachShader(program, old_shaders[i]);
        }
    } else {
        program = gl.createProgram();
    }

    if (vertex_shader == null || fragment_shader == null) {
        return program;
    }

    gl.attachShader(program, vertex_shader);
    gl.attachShader(program, fragment_shader);

    gl.deleteShader(vertex_shader);
    gl.deleteShader(fragment_shader);

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var program_error = new Error("WebGL program error:\n            VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n            ERROR: " + gl.getError() + "\n            --- Vertex Shader ---\n            " + vertex_shader_source + "\n            --- Fragment Shader ---\n            " + fragment_shader_source);
        log.error(program_error);
        throw program_error;
    }

    return program;
};

// Compile a vertex or fragment shader from provided source
ShaderProgram.createShader = function (gl, source, type) {
    var shader = gl.createShader(type);

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var shader_error = "WebGL shader error:\n" + (type === gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader);
        throw shader_error;
    }

    return shader;
};

},{"./glsl":70,"./texture":73,"loglevel":54,"strip-comments":59}],72:[function(require,module,exports){
"use strict";

// Generated from GLSL files, don't edit!
var shaderSources = {};

shaderSources["gl/shaders/ambientLight"] = "/*\n" + "\n" + "Expected globals:\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct AmbientLight {\n" + "    vec4 ambient;\n" + "};\n" + "\n" + "void calculateLight(in AmbientLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "    light_accumulator_ambient += _light.ambient;\n" + "}\n" + "";

shaderSources["gl/shaders/directionalLight"] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct DirectionalLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec3 direction;\n" + "};\n" + "\n" + "void calculateLight(in DirectionalLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    light_accumulator_ambient += _light.ambient;\n" + "\n" + "    float nDotVP = clamp(dot(_normal, -normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(normalize(_light.direction), _normal);\n" + "            float eyeDotR = max(dot(normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "        light_accumulator_specular += _light.specular * pf;\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/layer_order"] = "// Apply layer ordering to avoid z-fighting\n" + "void applyLayerOrder (float layer, inout vec4 position) {\n" + "    position.z -= layer * TANGRAM_LAYER_DELTA * position.w;\n" + "}\n" + "";

shaderSources["gl/shaders/material"] = "/*\n" + "\n" + "Defines globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "\n" + "// MATERIALS\n" + "//\n" + "struct Material {\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION\n" + "        vec4 emission;\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "            vec3 emissionScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT\n" + "        vec4 ambient;\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "            vec3 ambientScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        vec4 diffuse;\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "            vec3 diffuseScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        vec4 specular;\n" + "        float shininess;\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "            vec3 specularScale;\n" + "        #endif\n" + "    #endif\n" + "\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "        vec3 normalScale;\n" + "        float normalAmount;\n" + "    #endif\n" + "};\n" + "\n" + "// Note: uniform is copied to a global instance to allow modification\n" + "uniform Material u_material;\n" + "Material material = u_material;\n" + "\n" + "#ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "uniform sampler2D u_material_emission_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "uniform sampler2D u_material_ambient_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "uniform sampler2D u_material_diffuse_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "uniform sampler2D u_material_specular_texture;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "uniform sampler2D u_material_normal_texture;\n" + "#endif\n" + "\n" + "// Global light accumulators for each property\n" + "vec4 light_accumulator_ambient = vec4(0.0);\n" + "vec4 light_accumulator_diffuse = vec4(0.0);\n" + "#ifdef TANGRAM_MATERIAL_SPECULAR\n" + "    vec4 light_accumulator_specular = vec4(0.0);\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_SPHEREMAP\n" + "vec4 getSphereMap (in sampler2D _tex, in vec3 _eyeToPoint, in vec3 _normal, in vec2 _skew) {\n" + "    vec3 eye = normalize(_eyeToPoint);\n" + "    eye.xy -= _skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    vec3 r = reflect(eye, _normal);\n" + "    r.z += 1.0;\n" + "    float m = 2. * length(r);\n" + "    vec2 uv = r.xy / m + .5;\n" + "    return texture2D(_tex, uv);\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_TRIPLANAR\n" + "vec3 getTriPlanarBlend (in vec3 _normal) {\n" + "    vec3 blending = abs(_normal);\n" + "    blending = normalize(max(blending, 0.00001));\n" + "    float b = (blending.x + blending.y + blending.z);\n" + "    return blending / b;\n" + "}\n" + "\n" + "vec4 getTriPlanar (in sampler2D _tex, in vec3 _pos, in vec3 _normal, in vec3 _scale) {\n" + "    vec3 blending = getTriPlanarBlend(_normal);\n" + "    vec4 xaxis = texture2D(_tex, fract(_pos.yz * _scale.x));\n" + "    vec4 yaxis = texture2D(_tex, fract(_pos.xz * _scale.y));\n" + "    vec4 zaxis = texture2D(_tex, fract(_pos.xy * _scale.z));\n" + "    return  xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_TEXTURE_PLANAR\n" + "vec4 getPlanar (in sampler2D _tex, in vec3 _pos, in vec2 _scale) {\n" + "    return texture2D( _tex, fract(_pos.xy * _scale.x) );\n" + "}\n" + "#endif\n" + "\n" + "\n" + "#ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "void calculateNormal (inout vec3 _normal) {\n" + "    // Get NORMALMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_UV\n" + "    _normal += texture2D(u_material_normal_texture, fract(v_texcoord*material.normalScale.xy)).rgb*2.0-1.0;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_PLANAR\n" + "    vec3 normalTex = getPlanar(u_material_normal_texture, v_world_position.xyz, material.normalScale.xy).rgb*2.0-1.0;\n" + "    _normal += normalTex;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE_TRIPLANAR\n" + "    vec3 normalTex = getTriPlanar(u_material_normal_texture, v_world_position.xyz, _normal, material.normalScale).rgb*2.0-1.0;\n" + "    _normal += normalTex;\n" + "    #endif\n" + "\n" + "    _normal = normalize(_normal);\n" + "}\n" + "#endif\n" + "\n" + "void calculateMaterial (in vec3 _eyeToPoint, inout vec3 _normal) {\n" + "    // get EMISSION TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_UV\n" + "        material.emission *= texture2D(u_material_emission_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_PLANAR\n" + "        material.emission *= getPlanar(u_material_emission_texture, v_world_position.xyz, material.emissionScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_TRIPLANAR\n" + "        material.emission *= getTriPlanar(u_material_emission_texture, v_world_position.xyz, _normal, material.emissionScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_EMISSION_TEXTURE_SPHEREMAP\n" + "        material.emission *= getSphereMap(u_material_emission_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get AMBIENT TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_UV\n" + "        material.ambient *= texture2D(u_material_ambient_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_PLANAR\n" + "        material.ambient *= getPlanar(u_material_ambient_texture, v_world_position.xyz, material.ambientScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_TRIPLANAR\n" + "        material.ambient *= getTriPlanar(u_material_ambient_texture, v_world_position.xyz, _normal, material.ambientScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_AMBIENT_TEXTURE_SPHEREMAP\n" + "        material.ambient *= getSphereMap(u_material_ambient_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get DIFFUSE TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_UV\n" + "        material.diffuse *= texture2D(u_material_diffuse_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_PLANAR\n" + "        material.diffuse *= getPlanar(u_material_diffuse_texture, v_world_position.xyz, material.diffuseScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_TRIPLANAR\n" + "        material.diffuse *= getTriPlanar(u_material_diffuse_texture, v_world_position.xyz, _normal, material.diffuseScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_DIFFUSE_TEXTURE_SPHEREMAP\n" + "        material.diffuse *= getSphereMap(u_material_diffuse_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // get SPECULAR TEXTUREMAP\n" + "    //------------------------------------------------\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_UV\n" + "        material.specular *= texture2D(u_material_specular_texture,v_texcoord);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_PLANAR\n" + "        material.specular *= getPlanar(u_material_specular_texture, v_world_position.xyz, material.specularScale.xy);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_TRIPLANAR\n" + "        material.specular *= getTriPlanar(u_material_specular_texture, v_world_position.xyz, _normal, material.specularScale);\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_MATERIAL_SPECULAR_TEXTURE_SPHEREMAP\n" + "        material.specular *= getSphereMap(u_material_specular_texture, _eyeToPoint, _normal, u_vanishing_point);\n" + "        #endif\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/pointLight"] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct PointLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "};\n" + "\n" + "void calculateLight(in PointLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // Normalize the vector from surface to light position\n" + "    float nDotVP = clamp(dot(VP, _normal), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // Computer accumulators\n" + "    light_accumulator_ambient += _light.ambient * attenuation;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        float pf = 0.0; // power factor for shiny speculars\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(0.0, dot(-normalize(_eyeToPoint), reflectVector));\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "\n" + "        light_accumulator_specular += _light.specular * pf * attenuation;\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/selection_fragment"] = "// Fragment shader for feature selection passes\n" + "// Renders in silhouette according to selection (picking) color, or black if none defined\n" + "\n" + "#ifdef TANGRAM_FEATURE_SELECTION\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "\n" + "void main (void) {\n" + "    #ifdef TANGRAM_FEATURE_SELECTION\n" + "        gl_FragColor = v_selection_color;\n" + "    #else\n" + "        gl_FragColor = vec4(0., 0., 0., 1.);\n" + "    #endif\n" + "}\n" + "";

shaderSources["gl/shaders/selection_globals"] = "// Vertex attribute + varying for feature selection\n" + "#if defined(TANGRAM_FEATURE_SELECTION) && defined(TANGRAM_VERTEX_SHADER)\n" + "    attribute vec4 a_selection_color;\n" + "    varying vec4 v_selection_color;\n" + "#endif\n" + "";

shaderSources["gl/shaders/selection_vertex"] = "// Selection pass-specific rendering\n" + "#if defined(TANGRAM_FEATURE_SELECTION) && defined(TANGRAM_VERTEX_SHADER)\n" + "    if (a_selection_color.rgb == vec3(0.)) {\n" + "        // Discard by forcing invalid triangle if we're in the feature\n" + "        // selection pass but have no selection info\n" + "        // TODO: in some cases we may actually want non-selectable features to occlude selectable ones?\n" + "        gl_Position = vec4(0., 0., 0., 1.);\n" + "        return;\n" + "    }\n" + "    v_selection_color = a_selection_color;\n" + "#endif\n" + "";

shaderSources["gl/shaders/spherical_environment_map"] = "// Spherical environment map\n" + "// Based on: http://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader\n" + "\n" + "// view: location of camera\n" + "// position: location of current point on surface\n" + "// normal: normal of current point on surface\n" + "// skew: skewing factor (used to compensate for altered vanishing point)\n" + "// envmap: spherical environment map texture\n" + "\n" + "vec4 sphericalEnvironmentMap(vec3 view, vec3 position, vec3 normal, vec2 skew, sampler2D envmap) {\n" + "    // Normalized vector from camera to surface\n" + "    vec3 eye = normalize(position.xyz - view.xyz);\n" + "\n" + "    // Skew\n" + "    eye.xy -= skew;\n" + "    eye = normalize(eye);\n" + "\n" + "    // Reflection of eye off of surface normal\n" + "    vec3 r = reflect(eye, normal);\n" + "\n" + "    // Map reflected vector onto the surface of a sphere\n" + "    r.z += 1.;\n" + "    float m = 2. * length(r);\n" + "\n" + "    // Adjust xy to account for spherical shape, and center in middle of texture\n" + "    vec2 uv = r.xy / m + .5;\n" + "\n" + "    // Sample the environment map\n" + "    return texture2D(envmap, uv);\n" + "}\n" + "";

shaderSources["gl/shaders/spotLight"] = "/*\n" + "\n" + "Expected globals:\n" + "material\n" + "light_accumulator_*\n" + "\n" + "*/\n" + "\n" + "struct SpotLight {\n" + "    vec4 ambient;\n" + "    vec4 diffuse;\n" + "    vec4 specular;\n" + "    vec4 position;\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "    float attenuationExponent;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "    float innerRadius;\n" + "#endif\n" + "\n" + "#ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "    float outerRadius;\n" + "#endif\n" + "\n" + "    vec3 direction;\n" + "    float spotCosCutoff;\n" + "    float spotExponent;\n" + "};\n" + "\n" + "void calculateLight(in SpotLight _light, in vec3 _eyeToPoint, in vec3 _normal) {\n" + "\n" + "    float dist = length(_light.position.xyz - _eyeToPoint);\n" + "\n" + "    // Compute vector from surface to light position\n" + "    vec3 VP = (_light.position.xyz - _eyeToPoint) / dist;\n" + "\n" + "    // normal . light direction\n" + "    float nDotVP = clamp(dot(_normal, VP), 0.0, 1.0);\n" + "\n" + "    // Attenuation defaults\n" + "    float attenuation = 1.0;\n" + "    #ifdef TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT\n" + "        float Rin = 1.0;\n" + "        float e = _light.attenuationExponent;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "        #endif\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "            float Rdiff = _light.outerRadius-Rin;\n" + "            float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "            attenuation = 1.0-(pow(d,e));\n" + "        #else\n" + "            // If no outer is provide behaves like:\n" + "            // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "            float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "            attenuation = clamp(1.0/(pow(d,e)), 0.0, 1.0);\n" + "        #endif\n" + "    #else\n" + "        float Rin = 0.0;\n" + "\n" + "        #ifdef TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS\n" + "            Rin = _light.innerRadius;\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float Rdiff = _light.outerRadius-Rin;\n" + "                float d = clamp(max(0.0,dist-Rin)/Rdiff, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                // If no outer is provide behaves like:\n" + "                // https://imdoingitwrong.wordpress.com/2011/01/31/light-attenuation/\n" + "                float d = max(0.0,dist-Rin)/Rin+1.0;\n" + "                attenuation = clamp(1.0/d, 0.0, 1.0);\n" + "            #endif\n" + "        #else\n" + "            #ifdef TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS\n" + "                float d = clamp(dist/_light.outerRadius, 0.0, 1.0);\n" + "                attenuation = 1.0-d*d;\n" + "            #else\n" + "                attenuation = 1.0;\n" + "            #endif\n" + "        #endif\n" + "    #endif\n" + "\n" + "    // spotlight attenuation factor\n" + "    float spotAttenuation = 0.0;\n" + "\n" + "    // See if point on surface is inside cone of illumination\n" + "    float spotDot = clamp(dot(-VP, normalize(_light.direction)), 0.0, 1.0);\n" + "\n" + "    if (spotDot >= _light.spotCosCutoff) {\n" + "        spotAttenuation = pow(spotDot, _light.spotExponent);\n" + "    }\n" + "\n" + "    light_accumulator_ambient += _light.ambient * attenuation * spotAttenuation;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_DIFFUSE\n" + "        light_accumulator_diffuse += _light.diffuse * nDotVP * attenuation * spotAttenuation;\n" + "    #endif\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_SPECULAR\n" + "        // Power factor for shiny speculars\n" + "        float pf = 0.0;\n" + "        if (nDotVP > 0.0) {\n" + "            vec3 reflectVector = reflect(-VP, _normal);\n" + "            float eyeDotR = max(dot(-normalize(_eyeToPoint), reflectVector), 0.0);\n" + "            pf = pow(eyeDotR, material.shininess);\n" + "        }\n" + "        light_accumulator_specular += _light.specular * pf * attenuation * spotAttenuation;\n" + "    #endif\n" + "}\n" + "";

shaderSources["styles/points/points_fragment"] = "uniform vec2 u_resolution;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "\n" + "uniform sampler2D u_texture;\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "\n" + "// Alpha discard threshold (substitute for alpha blending)\n" + "#ifndef TANGRAM_ALPHA_DISCARD\n" + "#define TANGRAM_ALPHA_DISCARD 0.5\n" + "#endif\n" + "\n" + "// Alpha fade range for edges of points\n" + "#ifndef TANGRAM_FADE_RANGE\n" + "#define TANGRAM_FADE_RANGE .15\n" + "#endif\n" + "#define TANGRAM_FADE_START (1. - TANGRAM_FADE_RANGE)\n" + "\n" + "#pragma tangram: global\n" + "\n" + "void main (void) {\n" + "    vec4 color = v_color;\n" + "\n" + "    // Apply a texture\n" + "    #ifdef TANGRAM_POINT_TEXTURE\n" + "        color *= texture2D(u_texture, v_texcoord);\n" + "    // Draw a point\n" + "    #else\n" + "        // Fade alpha near circle edge\n" + "        vec2 uv = v_texcoord * 2. - 1.;\n" + "        float dist = length(uv);\n" + "        color.a = clamp(1. - (smoothstep(0., TANGRAM_FADE_RANGE, (dist - TANGRAM_FADE_START)) / TANGRAM_FADE_RANGE), 0., 1.);\n" + "    #endif\n" + "\n" + "    // If blending is off, use alpha discard as a lower-quality substitute\n" + "    #ifndef TANGRAM_BLEND_OVERLAY\n" + "        if (color.a < TANGRAM_ALPHA_DISCARD) {\n" + "            discard;\n" + "        }\n" + "    #endif\n" + "\n" + "    #pragma tangram: color\n" + "    #pragma tangram: filter\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";

shaderSources["styles/points/points_vertex"] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "\n" + "attribute vec3 a_position;\n" + "attribute vec4 a_shape;\n" + "attribute vec4 a_color;\n" + "attribute vec2 a_texcoord;\n" + "#ifdef TANGRAM_ORDER_ATTRIBUTE\n" + "    attribute float a_layer;\n" + "#endif\n" + "\n" + "varying vec4 v_color;\n" + "varying vec2 v_texcoord;\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: global\n" + "\n" + "vec2 rotate2D(vec2 _st, float _angle) {\n" + "    return mat2(cos(_angle),-sin(_angle),\n" + "                sin(_angle),cos(_angle)) * _st;\n" + "}\n" + "\n" + "void main() {\n" + "    // Adds vertex shader support for feature selection\n" + "    #pragma tangram: feature-selection-vertex\n" + "\n" + "    v_color = a_color;\n" + "    v_texcoord = a_texcoord;\n" + "\n" + "    // Position\n" + "    vec4 position = u_modelView * vec4(a_position, 1.);\n" + "    vec4 shape = a_shape;\n" + "\n" + "    #pragma tangram: position\n" + "\n" + "    cameraProjection(position);\n" + "\n" + "    #ifdef TANGRAM_ORDER_ATTRIBUTE\n" + "        applyLayerOrder(a_layer, position);\n" + "    #endif\n" + "\n" + "    // Apply scaling in screen space\n" + "    float zscale = fract(u_map_position.z) * (shape.w * 256. - 1.) + 1.;\n" + "    // float zscale = log(fract(u_map_position.z) + 1.) / log(2.) * (shape.w - 1.) + 1.;\n" + "    position.xy += rotate2D(shape.xy * 256. * zscale, radians(shape.z * 360.)) * 2. * position.w / u_resolution;\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";

shaderSources["styles/polygons/polygons_fragment"] = "uniform vec2 u_resolution;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "#ifdef TANGRAM_TEXTURE_COORDS\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "// Define a wrap value for world coordinates (allows more precision at higher zooms)\n" + "// e.g. at wrap 1000, the world space will wrap every 1000 meters\n" + "#if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "    vec2 world_position_anchor = vec2(floor(u_tile_origin / TANGRAM_WORLD_POSITION_WRAP) * TANGRAM_WORLD_POSITION_WRAP);\n" + "\n" + "    // Convert back to absolute world position if needed\n" + "    vec4 absoluteWorldPosition () {\n" + "        return vec4(v_world_position.xy + world_position_anchor, v_world_position.z, v_world_position.w);\n" + "    }\n" + "#else\n" + "    vec4 absoluteWorldPosition () {\n" + "        return v_world_position;\n" + "    }\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main (void) {\n" + "    vec4 color = v_color;\n" + "    vec3 normal = v_normal;\n" + "\n" + "    #ifdef TANGRAM_MATERIAL_NORMAL_TEXTURE\n" + "        calculateNormal(normal);\n" + "    #endif\n" + "\n" + "    // Modify normal before lighting\n" + "    #pragma tangram: normal\n" + "\n" + "    // Modify color and material properties before lighting\n" + "    #if !defined(TANGRAM_LIGHTING_VERTEX)\n" + "    #pragma tangram: color\n" + "    #endif\n" + "\n" + "    #if defined(TANGRAM_LIGHTING_FRAGMENT)\n" + "        color = calculateLighting(v_position.xyz - u_eye, normal, color);\n" + "    #elif defined(TANGRAM_LIGHTING_VERTEX)\n" + "        color = v_lighting;\n" + "    #endif\n" + "\n" + "    // Modify color after lighting (filter-like effects that don't require a additional render passes)\n" + "    #pragma tangram: filter\n" + "\n" + "    gl_FragColor = color;\n" + "}\n" + "";

shaderSources["styles/polygons/polygons_vertex"] = "uniform vec2 u_resolution;\n" + "uniform float u_time;\n" + "uniform vec3 u_map_position;\n" + "uniform vec3 u_tile_origin;\n" + "uniform float u_meters_per_pixel;\n" + "uniform float u_device_pixel_ratio;\n" + "\n" + "uniform mat4 u_model;\n" + "uniform mat4 u_modelView;\n" + "uniform mat3 u_normalMatrix;\n" + "\n" + "attribute vec3 a_position;\n" + "attribute vec4 a_color;\n" + "attribute float a_layer;\n" + "\n" + "// Optional normal attribute, otherwise default to up\n" + "#ifdef TANGRAM_NORMAL_ATTRIBUTE\n" + "    attribute vec3 a_normal;\n" + "    #define TANGRAM_NORMAL a_normal\n" + "#else\n" + "    #define TANGRAM_NORMAL vec3(0., 0., 1.)\n" + "#endif\n" + "\n" + "// Optional dynamic line extrusion\n" + "#ifdef TANGRAM_EXTRUDE_LINES\n" + "    attribute vec3 a_extrude;\n" + "    attribute vec2 a_scale;\n" + "#endif\n" + "\n" + "varying vec4 v_position;\n" + "varying vec3 v_normal;\n" + "varying vec4 v_color;\n" + "varying vec4 v_world_position;\n" + "\n" + "// Optional texture UVs\n" + "#ifdef TANGRAM_TEXTURE_COORDS\n" + "    attribute vec2 a_texcoord;\n" + "    varying vec2 v_texcoord;\n" + "#endif\n" + "\n" + "// Define a wrap value for world coordinates (allows more precision at higher zooms)\n" + "// e.g. at wrap 1000, the world space will wrap every 1000 meters\n" + "#if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "    vec2 world_position_anchor = vec2(floor(u_tile_origin / TANGRAM_WORLD_POSITION_WRAP) * TANGRAM_WORLD_POSITION_WRAP);\n" + "\n" + "    // Convert back to absolute world position if needed\n" + "    vec4 absoluteWorldPosition () {\n" + "        return vec4(v_world_position.xy + world_position_anchor, v_world_position.z, v_world_position.w);\n" + "    }\n" + "#else\n" + "    vec4 absoluteWorldPosition () {\n" + "        return v_world_position;\n" + "    }\n" + "#endif\n" + "\n" + "#if defined(TANGRAM_LIGHTING_VERTEX)\n" + "    varying vec4 v_lighting;\n" + "#endif\n" + "\n" + "#pragma tangram: camera\n" + "#pragma tangram: material\n" + "#pragma tangram: lighting\n" + "#pragma tangram: global\n" + "\n" + "void main() {\n" + "    // Adds vertex shader support for feature selection\n" + "    #pragma tangram: feature-selection-vertex\n" + "\n" + "    // Texture UVs\n" + "    #ifdef TANGRAM_TEXTURE_COORDS\n" + "        v_texcoord = a_texcoord;\n" + "    #endif\n" + "\n" + "    // Position\n" + "    vec4 position = vec4(a_position, 1.);\n" + "\n" + "    #ifdef TANGRAM_EXTRUDE_LINES\n" + "        vec2 extrude = a_extrude.xy;\n" + "        float width = a_extrude.z;\n" + "\n" + "        // Keep line width constant in screen-space\n" + "        float zscale = u_tile_origin.z - u_map_position.z;\n" + "        width *= pow(2., zscale);\n" + "\n" + "        // Smoothly interpolate line width between zooms\n" + "        if (zscale >= 0.) {\n" + "            width = mix(width, width * a_scale.x * 256., zscale);\n" + "        }\n" + "        else {\n" + "            width = mix(width, width * a_scale.y * 256., -zscale);\n" + "        }\n" + "\n" + "        // Modify line width before extrusion\n" + "        #pragma tangram: width\n" + "\n" + "        position.xy += extrude * width;\n" + "    #endif\n" + "\n" + "    // World coordinates for 3d procedural textures\n" + "    v_world_position = u_model * position;\n" + "    #if defined(TANGRAM_WORLD_POSITION_WRAP)\n" + "        v_world_position.xy -= world_position_anchor;\n" + "    #endif\n" + "\n" + "    // Adjust for tile and view position\n" + "    position = u_modelView * position;\n" + "\n" + "    // Modify position before camera projection\n" + "    #pragma tangram: position\n" + "\n" + "    // Setup varyings\n" + "    v_position = position;\n" + "    v_normal = normalize(u_normalMatrix * TANGRAM_NORMAL);\n" + "    v_color = a_color;\n" + "\n" + "    // Vertex lighting\n" + "    #if defined(TANGRAM_LIGHTING_VERTEX)\n" + "        vec4 color = a_color;\n" + "        vec3 normal = TANGRAM_NORMAL;\n" + "\n" + "        // Modify normal before lighting\n" + "        #pragma tangram: normal\n" + "\n" + "        // Modify color and material properties before lighting\n" + "        #pragma tangram: color\n" + "\n" + "        v_lighting = calculateLighting(position.xyz, normal, color);\n" + "        v_color = color;\n" + "    #endif\n" + "\n" + "    // Camera\n" + "    cameraProjection(position);\n" + "    applyLayerOrder(a_layer, position);\n" + "\n" + "    gl_Position = position;\n" + "}\n" + "";

module.exports = shaderSources;

},{}],73:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Texture */
// Texture management

var Utils = _interopRequire(require("../utils/utils"));

var subscribeMixin = _interopRequire(require("../utils/subscribe"));

var WorkerBroker = _interopRequire(require("../utils/worker_broker"));

var Builders = _interopRequire(require("../styles/builders"));

var log = _interopRequire(require("loglevel"));

// GL texture wrapper object for keeping track of a global set of textures, keyed by a unique user-defined name

var Texture = (function () {
    function Texture(gl, name) {
        var options = arguments[2] === undefined ? {} : arguments[2];

        _classCallCheck(this, Texture);

        this.gl = gl;
        this.texture = gl.createTexture();
        if (this.texture) {
            this.valid = true;
        }
        this.bind();
        this.image = null; // an Image object/element that is the source for this texture
        this.canvas = null; // a Canvas object/element that is the source for this texture
        this.loading = null; // a Promise object to track the loading state of this texture

        // Default to a 1-pixel black texture so we can safely render while we wait for an image to load
        // See: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
        this.setData(1, 1, new Uint8Array([0, 0, 0, 255]), { filtering: "nearest" });

        // TODO: better support for non-URL sources: canvas/video elements, raw pixel buffers

        this.name = name;
        this.filtering = options.filtering;

        // Destroy previous texture if present
        if (Texture.textures[this.name]) {
            Texture.textures[this.name].destroy();
        }

        Texture.textures[this.name] = this;

        this.sprites = options.sprites;
        this.texcoords = {};
    }

    _createClass(Texture, {
        destroy: {

            // Destroy a single texture instance

            value: function destroy() {
                if (!this.valid) {
                    return;
                }
                this.gl.deleteTexture(this.texture);
                this.texture = null;
                delete this.data;
                this.data = null;
                delete Texture.textures[this.name];
                this.valid = false;
            }
        },
        bind: {
            value: function bind(unit) {
                if (!this.valid) {
                    return;
                }
                if (typeof unit === "number") {
                    this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                }
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
            }
        },
        unbind: {
            value: function unbind() {
                this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            }
        },
        load: {

            // Loads a texture from a URL

            value: function load(url) {
                var _this = this;

                var options = arguments[1] === undefined ? {} : arguments[1];

                if (!this.valid) {
                    return;
                }

                this.loading = new Promise(function (resolve, reject) {
                    _this.image = new Image();
                    _this.image.onload = function () {
                        _this.update(options);
                        _this.setTextureFiltering(options);
                        _this.calculateSprites();

                        _this.canvas = null; // mutually exclusive with other types
                        _this.data = null;

                        resolve(_this);
                    };
                    _this.image.src = url;
                    // TODO: error/promise reject
                });
                return this.loading;
            }
        },
        setData: {

            // Sets texture to a raw image buffer

            value: function setData(width, height, data) {
                var options = arguments[3] === undefined ? {} : arguments[3];

                this.width = width;
                this.height = height;
                this.data = data;

                this.image = null; // mutually exclusive with other types
                this.canvas = null;

                this.update(options);
                this.setTextureFiltering(options);
            }
        },
        setCanvas: {

            // Sets the texture to track a canvas element

            value: function setCanvas(canvas, options) {
                this.canvas = canvas;
                this.update(options);
                this.setTextureFiltering(options);

                this.image = null; // mutually exclusive with other types
                this.data = null;
            }
        },
        update: {

            // Uploads current image or buffer to the GPU (can be used to update animated textures on the fly)

            value: function update() {
                var options = arguments[0] === undefined ? {} : arguments[0];

                if (!this.valid) {
                    return;
                }

                this.bind();
                this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, options.UNPACK_FLIP_Y_WEBGL === false ? false : true);
                this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.UNPACK_PREMULTIPLY_ALPHA_WEBGL || false);

                // Image element
                if (this.image && this.image.complete) {
                    this.width = this.image.width;
                    this.height = this.image.height;
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);
                }
                // Canvas element
                else if (this.canvas) {
                    this.width = this.canvas.width;
                    this.height = this.canvas.height;
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.canvas);
                }
                // Raw image buffer
                else if (this.width && this.height) {
                    // NOTE: this.data can be null, to zero out texture
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.data);
                }

                Texture.trigger("update", this);
            }
        },
        setTextureFiltering: {

            // Determines appropriate filtering mode

            value: function setTextureFiltering() {
                var options = arguments[0] === undefined ? {} : arguments[0];

                if (!this.valid) {
                    return;
                }

                options.filtering = options.filtering || this.filtering || "linear"; // default to mipmaps for power-of-2 textures

                var gl = this.gl;
                this.bind();

                // For power-of-2 textures, the following presets are available:
                // mipmap: linear blend from nearest mip
                // linear: linear blend from original image (no mips)
                // nearest: nearest pixel from original image (no mips, 'blocky' look)
                if (Utils.isPowerOf2(this.width) && Utils.isPowerOf2(this.height)) {
                    this.power_of_2 = true;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || options.repeat && gl.REPEAT || gl.CLAMP_TO_EDGE);

                    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.TEXTURE_WRAP_S || gl.REPEAT);
                    // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.TEXTURE_WRAP_T || gl.REPEAT);

                    if (options.filtering === "mipmap") {
                        log.trace("power-of-2 MIPMAP");
                        this.filtering = "mipmap";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR); // TODO: use trilinear filtering by defualt instead?
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } else if (options.filtering === "linear") {
                        log.trace("power-of-2 LINEAR");
                        this.filtering = "linear";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    } else if (options.filtering === "nearest") {
                        log.trace("power-of-2 NEAREST");
                        this.filtering = "nearest";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    }
                } else {
                    // WebGL has strict requirements on non-power-of-2 textures:
                    // No mipmaps and must clamp to edge
                    this.power_of_2 = false;
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                    if (options.filtering === "nearest") {
                        log.trace("power-of-2 NEAREST");
                        this.filtering = "nearest";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    } else {
                        // default to linear for non-power-of-2 textures
                        log.trace("power-of-2 LINEAR");
                        this.filtering = "linear";
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    }
                }

                this.unbind();
                Texture.trigger("update", this);
            }
        },
        calculateSprites: {

            // Pre-calc sprite regions for a texture sprite in UV [0, 1] space

            value: function calculateSprites() {
                if (this.sprites) {
                    for (var s in this.sprites) {
                        var sprite = this.sprites[s];

                        // Map [0, 0] to [1, 1] coords to the appropriate sprite sub-area of the texture
                        this.texcoords[s] = Builders.getTexcoordsForSprite([sprite[0], sprite[1]], [sprite[2], sprite[3]], [this.width, this.height]);
                    }
                }
            }
        }
    });

    return Texture;
})();

module.exports = Texture;

// Static/class methods and state

// Destroy all texture instances for a given GL context
Texture.destroy = function (gl) {
    var textures = Object.keys(Texture.textures);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var t = _step.value;

            var texture = Texture.textures[t];
            if (texture.gl === gl) {
                log.trace("destroying Texture " + texture.name);
                texture.destroy();
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
};

// Get sprite sub-area to use for texture coordinates (default is [0, 1])
Texture.getSpriteTexcoords = function (texname, sprite) {
    var texture = Texture.textures[texname];
    return texture && texture.texcoords[sprite];
};

// Create a set of textures keyed in an object
// Optionally load each if it has a URL specified
Texture.createFromObject = function (gl, textures) {
    var loading = [];
    if (textures) {
        for (var texname in textures) {
            var config = textures[texname];
            if (!Texture.textures[texname]) {
                var texture = new Texture(gl, texname, config);
                if (config.url) {
                    loading.push(texture.load(config.url, config));
                }
            }
        }
    }
    return Promise.all(loading);
};

// Get metadata for a texture by name
// Returns via promise, in case texture is still loading
// Can be called on main thread from worker, to sync texture info to worker
Texture.getInfo = function (name) {
    // Get info for all textures by default
    if (!name) {
        name = Object.keys(Texture.textures);
    }

    // Get multiple textures
    if (Array.isArray(name)) {
        return Promise.all(name.map(function (n) {
            return Texture.getInfo(n);
        }));
    }

    // Get single texture
    var tex = Texture.textures[name];
    if (tex) {
        // Wait for this texture to finish loading, or return immediately
        var loading = tex.loading || Promise.resolve(tex);
        return loading.then(function () {
            // Return a subset of texture info
            // (compatible w/structured cloning, suitable for passing to a worker)
            return {
                name: tex.name,
                width: tex.width,
                height: tex.height,
                sprites: tex.sprites,
                texcoords: tex.texcoords,
                filtering: tex.filtering,
                power_of_2: tex.power_of_2,
                valid: tex.valid
            };
        });
    } else {
        // No texture found
        return Promise.resolve(null);
    }
};

// Sync texture info to worker
// Called from worker, gets info on one or more textures info from main thread via remote call, then stores it
// locally in worker. 'textures' can be an array of texture names to sync, or if null, all textures are synced.
Texture.syncTexturesToWorker = function (names) {
    return WorkerBroker.postMessage("Texture", "getInfo", names).then(function (textures) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var tex = _step.value;

                Texture.textures[tex.name] = tex;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return Texture.textures;
    });
};

// Global set of textures, by name
Texture.textures = {};

subscribeMixin(Texture);

},{"../styles/builders":85,"../utils/subscribe":100,"../utils/utils":101,"../utils/worker_broker":102,"loglevel":54}],74:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

// Creates a Vertex Array Object if the extension is available, or falls back on standard attribute calls

var log = _interopRequire(require("loglevel"));

var VertexArrayObject;
module.exports = VertexArrayObject = {};

VertexArrayObject.disabled = false; // set to true to disable VAOs even if extension is available
VertexArrayObject.bound_vao = null; // currently bound VAO

VertexArrayObject.init = function (gl) {
    if (VertexArrayObject.ext == null) {
        if (VertexArrayObject.disabled !== true) {
            VertexArrayObject.ext = gl.getExtension("OES_vertex_array_object");
        }

        if (VertexArrayObject.ext != null) {
            log.info("Vertex Array Object extension available");
        } else if (VertexArrayObject.disabled !== true) {
            log.warn("Vertex Array Object extension NOT available");
        } else {
            log.warn("Vertex Array Object extension force disabled");
        }
    }
};

VertexArrayObject.create = function (setup, teardown) {
    var vao = {};
    vao.setup = setup;
    vao.teardown = teardown;

    var ext = VertexArrayObject.ext;
    if (ext != null) {
        vao._vao = ext.createVertexArrayOES();
        ext.bindVertexArrayOES(vao._vao);
        vao.setup();
    } else {
        vao.setup();
    }

    return vao;
};

VertexArrayObject.bind = function (vao) {
    var ext = VertexArrayObject.ext;
    if (vao != null) {
        if (ext != null && vao._vao != null) {
            ext.bindVertexArrayOES(vao._vao);
            VertexArrayObject.bound_vao = vao;
        } else {
            vao.setup();
        }
    } else {
        if (ext != null) {
            ext.bindVertexArrayOES(null);
        } else if (VertexArrayObject.bound_vao != null && typeof VertexArrayObject.bound_vao.teardown === "function") {
            VertexArrayObject.bound_vao.teardown();
        }
        VertexArrayObject.bound_vao = null;
    }
};

},{"loglevel":54}],75:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global VBOMesh */
// Manage rendering for primitives

var GLSL = _interopRequire(require("./glsl"));

var ShaderProgram = _interopRequire(require("./shader_program"));

var Texture = _interopRequire(require("./texture"));

var VertexArrayObject = _interopRequire(require("./vao"));

var log = _interopRequire(require("loglevel"));

// A single mesh/VBO, described by a vertex layout, that can be drawn with one or more programs

var VBOMesh = (function () {
    function VBOMesh(gl, vertex_data, vertex_layout, options) {
        _classCallCheck(this, VBOMesh);

        options = options || {};

        this.gl = gl;
        this.vertex_data = vertex_data; // typed array
        this.vertex_layout = vertex_layout;
        this.buffer = this.gl.createBuffer();
        this.draw_mode = options.draw_mode || this.gl.TRIANGLES;
        this.data_usage = options.data_usage || this.gl.STATIC_DRAW;
        this.vertices_per_geometry = 3; // TODO: support lines, strip, fan, etc.
        this.uniforms = options.uniforms;
        this.retain = options.retain || false; // whether to retain mesh data in CPU after uploading to GPU

        this.vertex_count = this.vertex_data.byteLength / this.vertex_layout.stride;
        this.geometry_count = this.vertex_count / this.vertices_per_geometry;
        this.vaos = new Map(); // map of VertexArrayObjects, keyed by program

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertex_data, this.data_usage);

        if (!this.retain) {
            delete this.vertex_data;
        }
        this.valid = true;
    }

    _createClass(VBOMesh, {
        render: {

            // Render, by default with currently bound program, or otherwise with optionally provided one

            value: function render() {
                var options = arguments[0] === undefined ? {} : arguments[0];

                if (!this.valid) {
                    return false;
                }

                if (typeof this._render_setup === "function") {
                    this._render_setup();
                }

                var program = options.program || ShaderProgram.current;
                program.use();

                if (this.uniforms) {
                    program.saveUniforms(this.uniforms);
                    program.setUniforms(this.uniforms, false); // don't reset texture unit
                }

                this.bind(program);

                // TODO: support element array mode
                this.gl.drawArrays(this.draw_mode, 0, this.vertex_count);
                VertexArrayObject.bind(null);

                if (this.uniforms) {
                    program.restoreUniforms(this.uniforms);
                }

                return true;
            }
        },
        bind: {

            // Bind buffers and vertex attributes to prepare for rendering

            value: function bind(program) {
                var _this = this;

                // Bind VAO for this progam, or create one
                var vao = this.vaos.get(program);
                if (vao) {
                    VertexArrayObject.bind(vao);
                } else {
                    this.vaos.set(program, VertexArrayObject.create(function () {
                        _this.gl.bindBuffer(_this.gl.ARRAY_BUFFER, _this.buffer);
                        _this.vertex_layout.enable(_this.gl, program);
                    }));
                }
            }
        },
        destroy: {
            value: function destroy() {
                if (!this.valid) {
                    return false;
                }
                this.valid = false;

                log.trace("VBOMesh.destroy: delete buffer" + (this.vertex_data ? " of size " + this.vertex_data.byteLength : ""));

                this.gl.deleteBuffer(this.buffer);
                this.buffer = null;
                delete this.vertex_data;

                // Free texture uniforms that are owned by this mesh
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = GLSL.parseUniforms(this.uniforms)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _step.value;
                        var type = _step$value.type;
                        var value = _step$value.value;

                        if (type === "sampler2D" && Texture.textures[value]) {
                            Texture.textures[value].destroy();
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return true;
            }
        }
    });

    return VBOMesh;
})();

module.exports = VBOMesh;

},{"./glsl":70,"./shader_program":71,"./texture":73,"./vao":74,"loglevel":54}],76:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _defineProperty = function (obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global VertexData */

var gl = _interopRequire(require("./constants"));

// web workers don't have access to GL context, so import all GL constants

var log = require("../utils/utils").log;

// Maps GL types to JS array types
var array_types = (function () {
    var _array_types = {};

    _defineProperty(_array_types, gl.FLOAT, Float32Array);

    _defineProperty(_array_types, gl.BYTE, Int8Array);

    _defineProperty(_array_types, gl.UNSIGNED_BYTE, Uint8Array);

    _defineProperty(_array_types, gl.INT, Int32Array);

    _defineProperty(_array_types, gl.UNSIGNED_INT, Uint32Array);

    _defineProperty(_array_types, gl.SHORT, Int16Array);

    _defineProperty(_array_types, gl.UNSIGNED_SHORT, Uint16Array);

    return _array_types;
})();

// An intermediary object that holds vertex data in typed arrays, according to a given vertex layout
// Used to construct a mesh/VBO for rendering

var VertexData = (function () {
    function VertexData(vertex_layout) {
        var _ref = arguments[1] === undefined ? {} : arguments[1];

        var prealloc = _ref.prealloc;

        _classCallCheck(this, VertexData);

        this.vertex_layout = vertex_layout;
        this.buffer_size = prealloc || 500; // # of vertices to allocate
        this.buffer_offset = 0; // byte offset into currently allocated buffer
        this.buffer = new ArrayBuffer(this.vertex_layout.stride * this.buffer_size);
        this.components = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = this.vertex_layout.components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var component = _step.value;

                this.components.push([].concat(_toConsumableArray(component)));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        this.vertex_count = 0;
        this.realloc_count = 0;
        this.setBufferViews();
    }

    _createClass(VertexData, {
        setBufferViews: {

            // (Re-)allocate typed views into the main buffer - only create the types we need for this layout

            value: function setBufferViews() {
                this.buffer_views = {};
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.vertex_layout.attribs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var attrib = _step.value;

                        // Need view for this type?
                        if (this.buffer_views[attrib.type] == null) {
                            var array_type = array_types[attrib.type];
                            this.buffer_views[attrib.type] = new array_type(this.buffer);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Update component buffer pointers
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = this.components[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var component = _step2.value;

                        component[1] = this.buffer_views[component[0]];
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                            _iterator2["return"]();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
        },
        checkBufferSize: {

            // Check allocated buffer size, expand/realloc buffer if needed

            value: function checkBufferSize() {
                if (this.buffer_offset + this.vertex_layout.stride > this.buffer.byteLength) {
                    this.buffer_size = Math.floor(this.buffer_size * 1.5);
                    this.buffer_size -= this.buffer_size % 4;
                    var new_block = new ArrayBuffer(this.vertex_layout.stride * this.buffer_size);
                    var new_view = new Uint8Array(new_block);
                    new_view.set(new Uint8Array(this.buffer)); // copy existing data to new buffer

                    this.buffer = new_block;
                    this.setBufferViews();
                    this.realloc_count++;
                    // log.info(`VertexData: expanded vertex block to ${this.buffer_size} vertices`);
                }
            }
        },
        addVertex: {

            // Add a vertex, copied from a plain JS array of elements matching the order of the vertex layout.
            // Note: uses pre-calculated info about each attribute, including pointer to appropriate typed array
            // view and offset into it. This was the fastest method profiled so far for filling a mixed-type
            // vertex layout (though still slower than the previous method that only supported Float32Array attributes).

            value: function addVertex(vertex) {
                this.checkBufferSize();
                var i = 0;

                var clen = this.components.length;
                for (var c = 0; c < clen; c++) {
                    var component = this.components[c];
                    component[1][(this.buffer_offset >> component[2]) + component[3]] = vertex[i++];
                }

                this.buffer_offset += this.vertex_layout.stride;
                this.vertex_count++;
            }
        },
        end: {

            // Finalize vertex buffer for use in constructing a mesh

            value: function end() {
                // Clip the allocated block to free unused memory
                if (this.buffer_offset < this.buffer.byteLength) {
                    var new_block = new ArrayBuffer(this.buffer_offset);
                    var new_view = new Uint8Array(new_block);
                    new_view.set(new Uint8Array(this.buffer, 0, this.buffer_offset));
                    this.buffer = new_block;
                    this.buffer_views = null;
                    this.components = null;
                }
                log("trace", "VertexData: " + this.buffer_size + " vertices total, realloc count " + this.realloc_count);
                return this;
            }
        }
    });

    return VertexData;
})();

module.exports = VertexData;

},{"../utils/utils":101,"./constants":68}],77:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* global VertexLayout */

var gl = _interopRequire(require("./constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexData = _interopRequire(require("./vertex_data"));

// Describes a vertex layout that can be used with many different GL programs.

var VertexLayout = (function () {
    // Attribs are an array, in layout order, of: name, size, type, normalized
    // ex: { name: 'position', size: 3, type: gl.FLOAT, normalized: false }

    function VertexLayout(attribs) {
        _classCallCheck(this, VertexLayout);

        this.attribs = attribs; // dictionary of attributes, specified as standard GL attrib options
        this.components = []; // list of type and offset info about each attribute component
        this.index = {}; // linear buffer index of each attribute component, e.g. this.index.position.x

        // Calc vertex stride
        this.stride = 0;

        var count = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = this.attribs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var attrib = _step.value;

                attrib.offset = this.stride;
                attrib.byte_size = attrib.size;
                var shift = 0;

                switch (attrib.type) {
                    case gl.FLOAT:
                    case gl.INT:
                    case gl.UNSIGNED_INT:
                        attrib.byte_size *= 4;
                        shift = 2;
                        break;
                    case gl.SHORT:
                    case gl.UNSIGNED_SHORT:
                        attrib.byte_size *= 2;
                        shift = 1;
                        break;
                }

                // Force 4-byte alignment on attributes
                this.stride += attrib.byte_size;
                if (this.stride & 3) {
                    // pad to multiple of 4 bytes
                    this.stride += 4 - (this.stride & 3);
                }

                // Add info to list of attribute components
                // Used to build the vertex data, provides pointers and offsets into each typed array view
                // Each component is an array of:
                // [GL attrib type, pointer to typed array view, bits to shift right to determine buffer offset, additional buffer offset for the component]
                var offset_typed = attrib.offset >> shift;
                if (attrib.size > 1) {
                    for (var a = 0; a < attrib.size; a++) {
                        this.components.push([attrib.type, null, shift, offset_typed++]);
                    }
                } else {
                    this.components.push([attrib.type, null, shift, offset_typed]);
                }

                // Provide an index into the vertex data buffer for each attribute component
                this.index[attrib.name] = count;
                count += attrib.size;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }

    _createClass(VertexLayout, {
        enable: {

            // Setup a vertex layout for a specific GL program
            // Assumes that the desired vertex buffer (VBO) is already bound
            // If a given program doesn't include all attributes, it can still use the vertex layout
            // to read those attribs that it does recognize, using the attrib offsets to skip others.

            value: function enable(gl, program) {
                var attrib, location;

                // Enable all attributes for this layout
                for (var a = 0; a < this.attribs.length; a++) {
                    attrib = this.attribs[a];
                    location = program.attribute(attrib.name).location;

                    if (location !== -1) {
                        gl.enableVertexAttribArray(location);
                        gl.vertexAttribPointer(location, attrib.size, attrib.type, attrib.normalized, this.stride, attrib.offset);
                        VertexLayout.enabled_attribs[location] = program;
                    }
                }

                // Disable any previously bound attributes that aren't for this layout
                for (location in VertexLayout.enabled_attribs) {
                    this.disableUnusedAttribute(gl, location, program);
                }
            }
        },
        disableUnusedAttribute: {

            // Disable an attribute if it was not enabled for the specified program
            // NOTE: this was moved out of the inner loop in enable() to assist w/VM optimization

            value: function disableUnusedAttribute(gl, location, program) {
                if (VertexLayout.enabled_attribs[location] !== program) {
                    gl.disableVertexAttribArray(location);
                    delete VertexLayout.enabled_attribs[location];
                }
            }
        },
        createVertexData: {
            value: function createVertexData() {
                return new VertexData(this);
            }
        }
    });

    return VertexLayout;
})();

module.exports = VertexLayout;

// Track currently enabled attribs, by the program they are bound to
// Static class property to reflect global GL state
VertexLayout.enabled_attribs = {};

},{"./constants":68,"./vertex_data":76}],78:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

exports.leafletLayer = leafletLayer;
Object.defineProperty(exports, "__esModule", {
    value: true
});

var Utils = _interopRequire(require("./utils/utils"));

var Scene = _interopRequire(require("./scene"));

var log = _interopRequire(require("loglevel"));

// Exports must appear outside a function, but will only be defined in main thread (below)
var LeafletLayer;
exports.LeafletLayer = LeafletLayer;

function leafletLayer(options) {
    return new LeafletLayer(options);
}

// Leaflet layer functionality is only defined in main thread
if (Utils.isMainThread) {
    (function () {

        // Determine if we are extending the leaflet 0.7.x TileLayer class, or the newer
        // leaflet 1.x GridLayer class.
        var layerBaseClass = L.GridLayer ? L.GridLayer : L.TileLayer;
        var leafletVersion = layerBaseClass === L.GridLayer ? "1.x" : "0.7.x";
        var layerClassConfig = {};

        // If extending leaflet 0.7.x TileLayer, make add/remove tile no ops
        if (layerBaseClass === L.TileLayer) {
            layerClassConfig._addTile = function () {};
            layerClassConfig._removeTile = function () {};
        }

        // Define custom layer methods
        Object.assign(layerClassConfig, {

            initialize: function initialize(options) {
                // Defaults
                options.showDebug = !options.showDebug ? false : true;

                L.setOptions(this, options);
                this.createScene();
                this.hooks = {};
                this._updating_tangram = false;

                // Force leaflet zoom animations off
                this._zoomAnimated = false;
            },

            createScene: function createScene() {
                this.scene = Scene.create(this.options.scene, {
                    numWorkers: this.options.numWorkers,
                    preUpdate: this.options.preUpdate,
                    postUpdate: this.options.postUpdate,
                    continuousZoom: LeafletLayer.leafletVersion === "1.x",
                    highDensityDisplay: this.options.highDensityDisplay,
                    logLevel: this.options.logLevel,
                    // advanced option, app will have to manually called scene.update() per frame
                    disableRenderLoop: this.options.disableRenderLoop,
                    // advanced option, will require library to be served as same host as page
                    allowCrossDomainWorkers: this.options.allowCrossDomainWorkers
                });
            },

            // Finish initializing scene and setup events when layer is added to map
            onAdd: function onAdd(map) {
                var _this = this;

                if (!this.scene) {
                    this.createScene();
                }

                layerBaseClass.prototype.onAdd.apply(this, arguments);

                this.hooks.resize = function () {
                    _this._updating_tangram = true;
                    var size = map.getSize();
                    _this.scene.resizeMap(size.x, size.y);
                    _this._updating_tangram = false;
                };
                map.on("resize", this.hooks.resize);

                this.hooks.move = function () {
                    if (_this._updating_tangram) {
                        return;
                    }

                    _this._updating_tangram = true;
                    var view = map.getCenter();
                    view.zoom = map.getZoom();

                    var changed = _this.scene.setView(view);
                    if (changed) {
                        _this.scene.immediateRedraw();
                    }
                    _this._updating_tangram = false;
                };
                map.on("move", this.hooks.move);

                this.hooks.zoomstart = function () {
                    if (_this._updating_tangram) {
                        return;
                    }

                    _this._updating_tangram = true;
                    _this.scene.startZoom();
                    _this._updating_tangram = false;
                };
                map.on("zoomstart", this.hooks.zoomstart);

                this.hooks.dragstart = function () {
                    _this.scene.panning = true;
                };
                map.on("dragstart", this.hooks.dragstart);

                this.hooks.dragend = function () {
                    _this.scene.panning = false;
                };
                map.on("dragend", this.hooks.dragend);

                // Force leaflet zoom animations off
                map._zoomAnimated = false;

                // Canvas element will be inserted after map container (leaflet transforms shouldn't be applied to the GL canvas)
                // TODO: find a better way to deal with this? right now GL map only renders correctly as the bottom layer
                this.scene.container = map.getContainer();

                // Initial view
                var view = map.getCenter();
                view.zoom = map.getZoom();
                this.scene.setView(view);

                // Subscribe to tangram events
                this.scene.subscribe({
                    move: this.onTangramViewUpdate.bind(this)
                });

                // Use leaflet's existing event system as the callback mechanism
                this.scene.init().then(function () {
                    log.debug("Scene.init() succeeded");
                    _this.fire("init");
                }, function (error) {
                    log.error("Scene.init() failed with error:", error);
                    throw error;
                });
            },

            onRemove: function onRemove(map) {
                layerBaseClass.prototype.onRemove.apply(this, arguments);

                map.off("resize", this.hooks.resize);
                map.off("move", this.hooks.move);
                map.off("zoomstart", this.hooks.zoomstart);
                map.off("dragstart", this.hooks.dragstart);
                map.off("dragend", this.hooks.dragend);
                this.hooks = {};

                if (this.scene) {
                    this.scene.destroy();
                    this.scene = null;
                }
            },

            createTile: function createTile(coords) {
                var key = coords.x + "/" + coords.y + "/" + coords.z;
                var div = document.createElement("div");
                div.setAttribute("data-tile-key", key);
                div.style.width = "256px";
                div.style.height = "256px";

                if (this.options.showDebug) {
                    var debug_overlay = document.createElement("div");
                    debug_overlay.textContent = key;
                    debug_overlay.style.position = "absolute";
                    debug_overlay.style.left = 0;
                    debug_overlay.style.top = 0;
                    debug_overlay.style.color = "white";
                    debug_overlay.style.fontSize = "16px";
                    debug_overlay.style.textOutline = "1px #000000";
                    debug_overlay.style.padding = "8px";

                    div.appendChild(debug_overlay);
                    div.style.borderStyle = "solid";
                    div.style.borderColor = "white";
                    div.style.borderWidth = "1px";
                }

                return div;
            },

            onTangramViewUpdate: function onTangramViewUpdate() {
                if (!this._map || this._updating_tangram) {
                    return;
                }
                this._updating_tangram = true;
                this._map.setView([this.scene.center.lat, this.scene.center.lng], this.scene.zoom, { animate: false });
                this._updating_tangram = false;
            },

            render: function render() {
                if (!this.scene) {
                    return;
                }
                this.scene.update();
            }

        });

        // Create the layer class
        LeafletLayer = exports.LeafletLayer = layerBaseClass.extend(layerClassConfig);

        // Polyfill some 1.0 methods
        if (typeof LeafletLayer.remove !== "function") {
            LeafletLayer.prototype.remove = function () {
                if (this._map) {
                    this._map.removeLayer(this);
                }
                this.fire("remove");
            };
        }

        LeafletLayer.layerBaseClass = layerBaseClass;
        LeafletLayer.leafletVersion = leafletVersion;
    })();
}

},{"./scene":82,"./utils/utils":101,"loglevel":54}],79:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Light */

var ShaderProgram = _interopRequire(require("./gl/shader_program"));

var shaderSources = _interopRequire(require("./gl/shader_sources"));

// built-in shaders

var GLSL = _interopRequire(require("./gl/glsl"));

var Geo = _interopRequire(require("./geo"));

var StyleParser = require("./styles/style_parser").StyleParser;

// Abstract light

var Light = (function () {
    function Light(scene, config) {
        _classCallCheck(this, Light);

        this.name = config.name;
        this.scene = scene;

        if (config.ambient == null || typeof config.ambient === "number") {
            this.ambient = GLSL.expandVec4(config.ambient || 0);
        } else {
            this.ambient = StyleParser.parseColor(config.ambient);
        }

        if (config.diffuse == null || typeof config.diffuse === "number") {
            this.diffuse = GLSL.expandVec4(config.diffuse != null ? config.diffuse : 1);
        } else {
            this.diffuse = StyleParser.parseColor(config.diffuse);
        }

        if (config.specular == null || typeof config.specular === "number") {
            this.specular = GLSL.expandVec4(config.specular || 0);
        } else {
            this.specular = StyleParser.parseColor(config.specular);
        }
    }

    _createClass(Light, {
        inject: {

            // Common instance definition

            value: function inject() {
                var instance = "\n            uniform " + this.struct_name + " u_" + this.name + ";\n            " + this.struct_name + " " + this.name + " = u_" + this.name + ";\n";

                ShaderProgram.addBlock(Light.block, instance);
            }
        },
        update: {

            // Update method called once per frame

            value: function update() {}
        },
        setupProgram: {

            // Called once per frame per program (e.g. for main render pass, then for each additional
            // pass for feature selection, etc.)

            value: function setupProgram(_program) {
                //  Three common light properties
                _program.uniform("4fv", "u_" + this.name + ".ambient", this.ambient);
                _program.uniform("4fv", "u_" + this.name + ".diffuse", this.diffuse);
                _program.uniform("4fv", "u_" + this.name + ".specular", this.specular);
            }
        }
    }, {
        create: {

            // Create a light by type name, factory-style
            // 'config' must include 'name' and 'type', along with any other type-specific properties

            value: function create(scene, config) {
                if (Light.types[config.type]) {
                    return new Light.types[config.type](scene, config);
                }
            }
        },
        setMode: {

            // Set light for a style: fragment lighting, vertex lighting, or none

            value: function setMode(mode, style) {
                mode = Light.enabled && (mode != null ? mode : "fragment"); // default to fragment lighting
                style.defines.TANGRAM_LIGHTING_FRAGMENT = mode === "fragment";
                style.defines.TANGRAM_LIGHTING_VERTEX = mode === "vertex";
            }
        },
        inject: {

            // Inject all provided light definitions, and calculate cumulative light function

            value: function inject(lights) {
                // Clear previous injections
                ShaderProgram.removeBlock(Light.block);

                // If lighting is globally disabled, nothing is injected (mostly for debugging or live editing)
                if (!Light.enabled) {
                    return;
                }

                // Construct code to calculate each light instance
                var calculateLights = "";
                if (lights && Object.keys(lights).length > 0) {
                    // Collect uniques types of lights
                    var types = {};
                    for (var light_name in lights) {
                        types[lights[light_name].type] = true;
                    }

                    // Inject each type of light
                    for (var type in types) {
                        Light.types[type].inject();
                    }

                    // Inject per-instance blocks and construct the list of functions to calculate each light
                    for (var light_name in lights) {
                        // Define instance
                        lights[light_name].inject();

                        // Add the calculation function to the list
                        calculateLights += "calculateLight(" + light_name + ", _eyeToPoint, _normal);\n";
                    }
                } else {
                    // If no light is defined, use 100% omnidirectional diffuse light
                    calculateLights = "\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    light_accumulator_diffuse = vec4(1.);\n                #endif\n            ";
                }

                // Glue together the final lighting function that sums all the lights
                var calculateFunction = "\n            vec4 calculateLighting(in vec3 _eyeToPoint, in vec3 _normal, in vec4 _color) {\n\n                // Do initial material calculations over normal, emission, ambient, diffuse and specular values\n                calculateMaterial(_eyeToPoint,_normal);\n\n                // Un roll the loop of individual ligths to calculate\n                " + calculateLights + "\n\n                //  Final light intensity calculation\n                vec4 color = vec4(0.0);\n\n                #ifdef TANGRAM_MATERIAL_EMISSION\n                    color = material.emission;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_AMBIENT\n                    color += light_accumulator_ambient * _color * material.ambient;\n                #else\n                    #ifdef TANGRAM_MATERIAL_DIFFUSE\n                        color += light_accumulator_ambient * _color * material.diffuse;\n                    #endif\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_DIFFUSE\n                    color += light_accumulator_diffuse * _color * material.diffuse;\n                #endif\n\n                #ifdef TANGRAM_MATERIAL_SPECULAR\n                    color += light_accumulator_specular * material.specular;\n                #endif\n\n                // Clamp final color\n                color = clamp(color, 0.0, 1.0);\n\n                return color;\n            }";

                ShaderProgram.addBlock(Light.block, calculateFunction);
            }
        }
    });

    return Light;
})();

module.exports = Light;

Light.types = {}; // references to subclasses by short name
Light.block = "lighting"; // shader block name
Light.enabled = true; // lighting can be globally enabled/disabled

// Light subclasses

var AmbientLight = (function (_Light) {
    function AmbientLight(scene, config) {
        _classCallCheck(this, AmbientLight);

        _get(Object.getPrototypeOf(AmbientLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "ambient";
        this.struct_name = "AmbientLight";
    }

    _inherits(AmbientLight, _Light);

    _createClass(AmbientLight, {
        setupProgram: {
            value: function setupProgram(_program) {
                _program.uniform("4fv", "u_" + this.name + ".ambient", this.ambient);
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/ambientLight"]);
            }
        }
    });

    return AmbientLight;
})(Light);

Light.types.ambient = AmbientLight;

var DirectionalLight = (function (_Light2) {
    function DirectionalLight(scene, config) {
        _classCallCheck(this, DirectionalLight);

        _get(Object.getPrototypeOf(DirectionalLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "directional";
        this.struct_name = "DirectionalLight";

        this.direction = (config.direction || [0.2, 0.7, -0.5]).map(parseFloat); // [x, y, z]
    }

    _inherits(DirectionalLight, _Light2);

    _createClass(DirectionalLight, {
        setupProgram: {
            value: function setupProgram(_program) {
                _get(Object.getPrototypeOf(DirectionalLight.prototype), "setupProgram", this).call(this, _program);
                _program.uniform("3fv", "u_" + this.name + ".direction", this.direction);
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/directionalLight"]);
            }
        }
    });

    return DirectionalLight;
})(Light);

Light.types.directional = DirectionalLight;

var PointLight = (function (_Light3) {
    function PointLight(scene, config) {
        _classCallCheck(this, PointLight);

        _get(Object.getPrototypeOf(PointLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "point";
        this.struct_name = "PointLight";

        this.position = config.position || [0, 0, 0];
        this.position_eye = []; // position in eyespace
        this.origin = config.origin || "world";
        this.attenuation = !isNaN(parseFloat(config.attenuation)) ? parseFloat(config.attenuation) : 0;

        if (config.radius) {
            if (Array.isArray(config.radius) && config.radius.length === 2) {
                this.radius = config.radius;
            } else {
                this.radius = [null, config.radius];
            }
        } else {
            this.radius = null;
        }
    }

    _inherits(PointLight, _Light3);

    _createClass(PointLight, {
        inject: {

            // Inject isntance-specific settings

            value: function inject() {
                _get(Object.getPrototypeOf(PointLight.prototype), "inject", this).call(this);

                ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT = this.attenuation !== 0;
                ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS = this.radius != null && this.radius[0] != null;
                ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS = this.radius != null;
            }
        },
        update: {
            value: function update() {
                this.updateEyePosition();
            }
        },
        updateEyePosition: {
            value: function updateEyePosition() {
                if (this.origin === "world") {
                    // For world origin, format is: [longitude, latitude, meters (default) or pixels w/px units]

                    // Move light's world position into camera space

                    var _Geo$latLngToMeters = Geo.latLngToMeters(this.position);

                    var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                    var x = _Geo$latLngToMeters2[0];
                    var y = _Geo$latLngToMeters2[1];

                    this.position_eye[0] = x - this.scene.camera.position_meters[0];
                    this.position_eye[1] = y - this.scene.camera.position_meters[1];

                    this.position_eye[2] = StyleParser.convertUnits(this.position[2], { zoom: this.scene.zoom });
                    this.position_eye[2] = this.position_eye[2] - this.scene.camera.position_meters[2];
                }
                if (this.origin === "ground" || this.origin === "camera") {
                    // For camera or ground origin, format is: [x, y, z] in meters (default) or pixels w/px units

                    // Light is in camera space by default
                    this.position_eye = StyleParser.convertUnits(this.position, { zoom: this.scene.zoom });

                    if (this.origin === "ground") {
                        // Leave light's xy in camera space, but z needs to be moved relative to ground plane
                        this.position_eye[2] = this.position_eye[2] - this.scene.camera.position_meters[2];
                    }
                }
            }
        },
        setupProgram: {
            value: function setupProgram(_program) {
                _get(Object.getPrototypeOf(PointLight.prototype), "setupProgram", this).call(this, _program);

                _program.uniform("4f", "u_" + this.name + ".position", this.position_eye[0], this.position_eye[1], this.position_eye[2], 1);

                if (ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_EXPONENT) {
                    _program.uniform("1f", "u_" + this.name + ".attenuationExponent", this.attenuation);
                }

                if (ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_INNER_RADIUS) {
                    _program.uniform("1f", "u_" + this.name + ".innerRadius", StyleParser.convertUnits(this.radius[0], { zoom: this.scene.zoom }));
                }

                if (ShaderProgram.defines.TANGRAM_POINTLIGHT_ATTENUATION_OUTER_RADIUS) {
                    _program.uniform("1f", "u_" + this.name + ".outerRadius", StyleParser.convertUnits(this.radius[1], { zoom: this.scene.zoom }));
                }
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/pointLight"]);
            }
        }
    });

    return PointLight;
})(Light);

Light.types.point = PointLight;

var SpotLight = (function (_PointLight) {
    function SpotLight(scene, config) {
        _classCallCheck(this, SpotLight);

        _get(Object.getPrototypeOf(SpotLight.prototype), "constructor", this).call(this, scene, config);
        this.type = "spotlight";
        this.struct_name = "SpotLight";

        this.direction = (config.direction || [0, 0, -1]).map(parseFloat); // [x, y, z]
        this.exponent = config.exponent ? parseFloat(config.exponent) : 0.2;
        this.angle = config.angle ? parseFloat(config.angle) : 20;
    }

    _inherits(SpotLight, _PointLight);

    _createClass(SpotLight, {
        setupProgram: {
            value: function setupProgram(_program) {
                _get(Object.getPrototypeOf(SpotLight.prototype), "setupProgram", this).call(this, _program);

                _program.uniform("3fv", "u_" + this.name + ".direction", this.direction);
                _program.uniform("1f", "u_" + this.name + ".spotCosCutoff", Math.cos(this.angle * 3.14159 / 180));
                _program.uniform("1f", "u_" + this.name + ".spotExponent", this.exponent);
            }
        }
    }, {
        inject: {

            // Inject struct and calculate function

            value: function inject() {
                ShaderProgram.addBlock(Light.block, shaderSources["gl/shaders/spotLight"]);
            }
        }
    });

    return SpotLight;
})(PointLight);

Light.types.spotlight = SpotLight;

},{"./geo":67,"./gl/glsl":70,"./gl/shader_program":71,"./gl/shader_sources":72,"./styles/style_parser":92}],80:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Material */

var shaderSources = _interopRequire(require("./gl/shader_sources"));

// built-in shaders

var GLSL = _interopRequire(require("./gl/glsl"));

var StyleParser = require("./styles/style_parser").StyleParser;

var Material = (function () {
    function Material(config) {
        _classCallCheck(this, Material);

        config = config || {};

        // These properties all have the same defaults, so they can be set in bulk
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = ["emission", "ambient", "diffuse", "specular"][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var prop = _step.value;

                if (config[prop] != null) {
                    if (config[prop].texture) {
                        this[prop] = {
                            texture: config[prop].texture,
                            mapping: config[prop].mapping || "spheremap",
                            scale: GLSL.expandVec3(config[prop].scale != null ? config[prop].scale : 1),
                            amount: GLSL.expandVec4(config[prop].amount != null ? config[prop].amount : 1)
                        };
                    } else if (typeof config[prop] === "number") {
                        this[prop] = { amount: GLSL.expandVec4(config[prop]) };
                    } else if (typeof config[prop] === "string") {
                        this[prop] = { amount: StyleParser.parseColor(config[prop]) };
                    } else {
                        this[prop] = config[prop];
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        // Extra specular props
        if (this.specular) {
            this.specular.shininess = config.shininess ? parseFloat(config.shininess) : 0.2;
        }

        // Normal mapping
        if (config.normal != null) {
            this.normal = {
                texture: config.normal.texture,
                mapping: config.normal.mapping || "triplanar",
                scale: GLSL.expandVec3(config.normal.scale != null ? config.normal.scale : 1),
                amount: config.normal.amount != null ? config.normal.amount : 1
            };
        }
    }

    _createClass(Material, {
        inject: {
            value: function inject(style) {
                // For each property, sets defines to configure texture mapping, with a pattern like:
                //   TANGRAM_MATERIAL_DIFFUSE, TANGRAM_MATERIAL_DIFFUSE_TEXTURE, TANGRAM_MATERIAL_DIFFUSE_TEXTURE_SPHEREMAP
                // Also sets flags to keep track of each unique mapping type being used, e.g.:
                //   TANGRAM_MATERIAL_TEXTURE_SPHEREMAP
                // Enables texture coordinates if needed and not already on
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = ["emission", "ambient", "diffuse", "specular"][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var prop = _step.value;

                        var def = "TANGRAM_MATERIAL_" + prop.toUpperCase();
                        var texdef = def + "_TEXTURE";
                        style.defines[def] = this[prop] != null;
                        if (this[prop] && this[prop].texture) {
                            style.defines[texdef] = true;
                            style.defines[texdef + "_" + this[prop].mapping.toUpperCase()] = true;
                            style.defines["TANGRAM_MATERIAL_TEXTURE_" + this[prop].mapping.toUpperCase()] = true;
                            style.texcoords = style.texcoords || this[prop].mapping === "uv";
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Normal mapping
                // As anove, sets flags to keep track of each unique mapping type being used, e.g.:
                //   TANGRAM_MATERIAL_TEXTURE_SPHEREMAP
                if (this.normal && this.normal.texture) {
                    style.defines.TANGRAM_MATERIAL_NORMAL_TEXTURE = true;
                    style.defines["TANGRAM_MATERIAL_NORMAL_TEXTURE_" + this.normal.mapping.toUpperCase()] = true;
                    style.defines["TANGRAM_MATERIAL_TEXTURE_" + this.normal.mapping.toUpperCase()] = true;
                    style.texcoords = style.texcoords || this.normal.mapping === "uv";
                }

                style.replaceShaderBlock(Material.block, shaderSources["gl/shaders/material"]);
            }
        },
        setupProgram: {
            value: function setupProgram(_program) {
                // For each property, sets uniforms in the pattern:
                // u_material.diffuse, u_material.diffuseScale u_material_diffuse_texture
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = ["emission", "ambient", "diffuse", "specular"][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var prop = _step.value;

                        if (this[prop]) {
                            if (this[prop].texture) {
                                _program.setTextureUniform("u_material_" + prop + "_texture", this[prop].texture);
                                _program.uniform("3fv", "u_material." + prop + "Scale", this[prop].scale);
                                _program.uniform("4fv", "u_material." + prop, this[prop].amount);
                            } else if (this[prop].amount) {
                                _program.uniform("4fv", "u_material." + prop, this[prop].amount);
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Extra specular props
                if (this.specular) {
                    _program.uniform("1f", "u_material.shininess", this.specular.shininess);
                }

                // Normal mapping
                if (this.normal && this.normal.texture) {
                    _program.setTextureUniform("u_material_normal_texture", this.normal.texture);
                    _program.uniform("3fv", "u_material.normalScale", this.normal.scale);
                    _program.uniform("1f", "u_material.normalAmount", this.normal.amount);
                }
            }
        }
    }, {
        isValid: {

            // Determine if a material config block has sufficient properties to create a material

            value: function isValid(config) {
                if (config == null) {
                    return false;
                }

                if (config.emission == null && config.ambient == null && config.diffuse == null && config.specular == null) {
                    return false;
                }

                return true;
            }
        }
    });

    return Material;
})();

module.exports = Material;

Material.block = "material";

},{"./gl/glsl":70,"./gl/shader_sources":72,"./styles/style_parser":92}],81:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

/*jshint worker: true*/

// Modules and dependencies to expose in the public Tangram module

var Utils = _interopRequire(require("./utils/utils"));

// The leaflet layer plugin is currently the primary public API

var _leaflet_layer = require("./leaflet_layer");

var LeafletLayer = _leaflet_layer.LeafletLayer;
var leafletLayer = _leaflet_layer.leafletLayer;

// The scene worker is only activated when a worker thread is instantiated, but must always be loaded

var SceneWorker = require("../src/scene_worker").SceneWorker;

// Additional modules are exposed for debugging

var log = _interopRequire(require("loglevel"));

var Geo = _interopRequire(require("./geo"));

var DataSource = _interopRequire(require("./data_source"));

var GLSL = _interopRequire(require("./gl/glsl"));

var ShaderProgram = _interopRequire(require("./gl/shader_program"));

var Texture = _interopRequire(require("./gl/texture"));

var Material = _interopRequire(require("./material"));

var Light = _interopRequire(require("./light"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var ruleCache = require("./styles/rule").ruleCache;

var StyleManager = require("./styles/style_manager").StyleManager;

var StyleParser = require("./styles/style_parser").StyleParser;

var FeatureSelection = _interopRequire(require("./selection"));

var glMatrix = _interopRequire(require("gl-matrix"));

// Default to 64-bit because we need the extra precision when multiplying matrices w/mercator projected values
glMatrix.glMatrix.setMatrixArrayType(Float64Array);

// Make some modules accessible for debugging
var debug = {
    log: log,
    Utils: Utils,
    Geo: Geo,
    DataSource: DataSource,
    GLSL: GLSL,
    ShaderProgram: ShaderProgram,
    Texture: Texture,
    Material: Material,
    Light: Light,
    SceneWorker: SceneWorker,
    WorkerBroker: WorkerBroker,
    ruleCache: ruleCache,
    StyleManager: StyleManager,
    StyleParser: StyleParser,
    FeatureSelection: FeatureSelection
};

// Window can only be set in main thread
if (Utils.isMainThread) {
    // Main thread objects that can be called from workers
    WorkerBroker.addTarget("Texture", Texture);

    window.Tangram = module.exports = {
        LeafletLayer: LeafletLayer,
        leafletLayer: leafletLayer,
        debug: debug
    };
}

if (Utils.isWorkerThread) {
    self.Tangram = {
        debug: debug
    };
}

if (Utils.isMainThread) {
    Utils.requestAnimationFramePolyfill();
}

},{"../src/scene_worker":83,"./data_source":66,"./geo":67,"./gl/glsl":70,"./gl/shader_program":71,"./gl/texture":73,"./leaflet_layer":78,"./light":79,"./material":80,"./selection":84,"./styles/rule":89,"./styles/style_manager":91,"./styles/style_parser":92,"./utils/utils":101,"./utils/worker_broker":102,"gl-matrix":22,"loglevel":54}],82:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Scene */

var Geo = _interopRequire(require("./geo"));

var Utils = _interopRequire(require("./utils/utils"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var subscribeMixin = _interopRequire(require("./utils/subscribe"));

var Context = _interopRequire(require("./gl/context"));

var Builders = _interopRequire(require("./styles/builders"));

var ShaderProgram = _interopRequire(require("./gl/shader_program"));

var Texture = _interopRequire(require("./gl/texture"));

var VertexArrayObject = _interopRequire(require("./gl/vao"));

var StyleManager = require("./styles/style_manager").StyleManager;

var StyleParser = require("./styles/style_parser").StyleParser;

var Camera = _interopRequire(require("./camera"));

var Light = _interopRequire(require("./light"));

var Tile = _interopRequire(require("./tile"));

var DataSource = _interopRequire(require("./data_source"));

var FeatureSelection = _interopRequire(require("./selection"));

var log = _interopRequire(require("loglevel"));

var glMatrix = _interopRequire(require("gl-matrix"));

var mat4 = glMatrix.mat4;
var mat3 = glMatrix.mat3;
var vec3 = glMatrix.vec3;

// Load scene definition: pass an object directly, or a URL as string to load remotely

var Scene = (function () {
    function Scene(config_source, options) {
        _classCallCheck(this, Scene);

        options = options || {};
        subscribeMixin(this);

        this.initialized = false;
        this.initializing = false;
        this.sources = {};

        this.tiles = {};
        this.visible_tiles = {};
        this.queued_tiles = [];
        this.num_workers = options.numWorkers || 2;
        this.continuous_zoom = typeof options.continuousZoom === "boolean" ? options.continuousZoom : true;
        this.allow_cross_domain_workers = options.allowCrossDomainWorkers === false ? false : true;
        this.worker_url = options.workerUrl;
        if (options.disableVertexArrayObjects === true) {
            VertexArrayObject.disabled = true;
        }

        Utils.use_high_density_display = options.highDensityDisplay !== undefined ? options.highDensityDisplay : true;
        Utils.updateDevicePixelRatio();

        this.config = null;
        this.config_source = config_source;
        this.config_serialized = null;

        this.styles = null;
        this.active_styles = {};

        this.building = null; // tracks current scene building state (tiles being built, etc.)
        this.dirty = true; // request a redraw
        this.animated = false; // request redraw every frame
        this.preUpdate = options.preUpdate; // optional pre-render loop hook
        this.postUpdate = options.postUpdate; // optional post-render loop hook
        this.render_loop = !options.disableRenderLoop; // disable render loop - app will have to manually call Scene.render() per frame
        this.frame = 0;
        this.resetTime();

        this.zoom = null;
        this.center = null;

        this.zooming = false;
        this.preserve_tiles_within_zoom = 2;
        this.panning = false;
        this.container = options.container;

        this.camera = null;
        this.lights = null;
        this.background = null;

        // Model-view matrices
        // 64-bit versions are for CPU calcuations
        // 32-bit versions are downsampled and sent to GPU
        this.modelMatrix = new Float64Array(16);
        this.modelMatrix32 = new Float32Array(16);
        this.modelViewMatrix = new Float64Array(16);
        this.modelViewMatrix32 = new Float32Array(16);
        this.normalMatrix = new Float64Array(9);
        this.normalMatrix32 = new Float32Array(9);

        this.selection = null;
        this.texture_listener = null;

        // Debug config
        this.debug = {
            profile: {
                geometry_build: false
            }
        };

        this.logLevel = options.logLevel || "info";
        log.setLevel(this.logLevel);
    }

    _createClass(Scene, {
        init: {
            value: function init() {
                var _this = this;

                if (this.initialized) {
                    return Promise.resolve();
                }
                this.initializing = true;

                // Load scene definition (sources, styles, etc.), then create styles & workers
                return new Promise(function (resolve, reject) {
                    _this.loadScene().then(function () {

                        _this.createWorkers().then(function () {
                            _this.createCanvas();
                            _this.selection = new FeatureSelection(_this.gl, _this.workers);

                            _this.texture_listener = { update: function () {
                                    return _this.dirty = true;
                                } };
                            Texture.subscribe(_this.texture_listener);

                            // Loads rendering styles from config, sets GL context and compiles programs
                            _this.updateConfig();

                            _this.initializing = false;
                            _this.initialized = true;
                            resolve();

                            if (_this.render_loop !== false) {
                                _this.setupRenderLoop();
                            }
                        })["catch"](function (e) {
                            throw e;
                        });
                    })["catch"](function (e) {
                        reject(e);
                    });
                });
            }
        },
        destroy: {
            value: function destroy() {
                this.initialized = false;
                this.renderLoop = function () {}; // set to no-op because a null can cause requestAnimationFrame to throw

                this.unsubscribeAll(); // clear all event listeners

                Texture.unsubscribe(this.texture_listener);
                this.texture_listener = null;

                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                    this.canvas = null;
                }
                this.container = null;

                if (this.gl) {
                    this.gl.deleteFramebuffer(this.fbo);
                    this.fbo = null;

                    Texture.destroy(this.gl);
                    StyleManager.destroy(this.gl);
                    this.styles = {};

                    this.gl = null;
                }

                if (Array.isArray(this.workers)) {
                    this.workers.forEach(function (worker) {
                        worker.terminate();
                    });
                    this.workers = null;
                }
                this.sources = {};
                this.tiles = {}; // TODO: probably destroy each tile separately too
            }
        },
        createCanvas: {
            value: function createCanvas() {
                this.container = this.container || document.body;
                this.canvas = document.createElement("canvas");
                this.canvas.style.position = "absolute";
                this.canvas.style.top = 0;
                this.canvas.style.left = 0;
                this.canvas.style.zIndex = -1;
                this.container.appendChild(this.canvas);

                this.gl = Context.getContext(this.canvas, { alpha: false /*premultipliedAlpha: false*/ });
                this.resizeMap(this.container.clientWidth, this.container.clientHeight);
                VertexArrayObject.init(this.gl);
            }
        },
        createObjectURL: {
            value: function createObjectURL() {
                return window.URL && window.URL.createObjectURL || window.webkitURL && window.webkitURL.createObjectURL;
            }
        },
        loadWorkerUrl: {
            value: function loadWorkerUrl(scene) {
                var worker_url = scene.worker_url || Utils.findCurrentURL("tangram.debug.js", "tangram.min.js"),
                    createObjectURL = scene.createObjectURL();

                return new Promise(function (resolve, reject) {
                    if (!worker_url) {
                        reject(new Error("Can't load worker because couldn't find base URL that library was loaded from"));
                        return;
                    }

                    if (createObjectURL && scene.allow_cross_domain_workers) {
                        var body = "importScripts('" + worker_url + "');";
                        var worker_local_url = createObjectURL(new Blob([body], { type: "application/javascript" }));
                        resolve(worker_local_url);
                    } else {
                        resolve(worker_url);
                    }
                });
            }
        },
        createWorkers: {

            // Web workers handle heavy duty tile construction: networking, geometry processing, etc.

            value: function createWorkers() {
                var _this = this;

                return new Promise(function (resolve, reject) {
                    _this.loadWorkerUrl(_this).then(function (worker_url) {
                        _this.makeWorkers(worker_url).then(resolve, reject);
                    });
                });
            }
        },
        makeWorkers: {

            // Instantiate workers from URL, init event handlers

            value: function makeWorkers(url) {
                var _this = this;

                var queue = [];

                this.workers = [];
                for (var id = 0; id < this.num_workers; id++) {
                    var worker;

                    (function () {
                        worker = new Worker(url);

                        _this.workers[id] = worker;

                        worker.addEventListener("message", _this.workerLogMessage.bind(_this));
                        WorkerBroker.addWorker(worker);

                        log.debug("Scene.makeWorkers: initializing worker " + id);
                        var _id = id;
                        queue.push(WorkerBroker.postMessage(worker, "init", id, _this.num_workers, Utils.device_pixel_ratio).then(function (id) {
                            log.debug("Scene.makeWorkers: initialized worker " + id);
                            return id;
                        }, function (error) {
                            log.error("Scene.makeWorkers: failed to initialize worker " + _id + ":", error);
                            return Promise.reject(error);
                        }));
                    })();
                }

                this.next_worker = 0;
                this.selection_map_worker_size = {};

                return Promise.all(queue);
            }
        },
        nextWorker: {

            // Round robin selection of next worker

            value: function nextWorker() {
                var worker = this.workers[this.next_worker];
                this.next_worker = (this.next_worker + 1) % this.workers.length;
                return worker;
            }
        },
        setView: {

            /**
                Set the map view, can be passed an object with lat/lng and/or zoom
            */

            value: function setView() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var lng = _ref.lng;
                var lat = _ref.lat;
                var zoom = _ref.zoom;

                var changed = false;

                // Set center
                if (lng && lat) {
                    changed = changed || !this.center || lng !== this.center.lng || lat !== this.center.lat;
                    this.center = { lng: lng, lat: lat };
                }

                // Set zoom
                if (zoom) {
                    changed = changed || zoom !== this.zoom;
                    this.setZoom(zoom);
                }

                if (changed) {
                    this.updateBounds();
                }
                return changed;
            }
        },
        startZoom: {
            value: function startZoom() {
                this.last_zoom = this.zoom;
                this.zooming = true;
            }
        },
        baseZoom: {

            // Choose the base zoom level to use for a given fractional zoom

            value: function baseZoom(zoom) {
                return Math.round(zoom);
            }
        },
        setZoom: {
            value: function setZoom(zoom) {
                var _this = this;

                this.zooming = false;
                var base = this.baseZoom(zoom);

                if (!this.continuous_zoom) {
                    zoom = base;
                }

                if (base !== this.baseZoom(this.last_zoom)) {
                    // Remove tiles outside a given range above and below current zoom
                    var below = base;
                    var above = base;

                    log.trace("scene.last_zoom: " + this.last_zoom);
                    if (Math.abs(zoom - this.last_zoom) <= this.preserve_tiles_within_zoom) {
                        below -= this.preserve_tiles_within_zoom;
                        above += this.preserve_tiles_within_zoom;
                    }

                    log.trace("removing tiles outside range [" + below + ", " + above + "]");
                    this.removeTilesOutsideZoomRange(below, above);

                    // Remove tiles outside current zoom that are still loading
                    this.removeTiles(function (tile) {
                        if (tile.loading && _this.baseZoom(tile.coords.z) !== base) {
                            log.trace("removed " + tile.key + " (was loading, but outside current zoom)");
                            return true;
                        }
                    });
                }

                this.last_zoom = this.zoom;
                this.zoom = zoom;

                this.updateBounds();

                this.dirty = true;
            }
        },
        viewReady: {
            value: function viewReady() {
                if (this.css_size == null || this.center == null || this.zoom == null || Object.keys(this.sources).length === 0) {
                    return false;
                }
                return true;
            }
        },
        updateBounds: {

            // Calculate viewport bounds based on current center and zoom

            value: function updateBounds() {
                // TODO: better concept of "readiness" state?
                if (!this.viewReady()) {
                    return;
                }

                this.meters_per_pixel = Geo.metersPerPixel(this.zoom);

                // Size of the half-viewport in meters at current zoom
                this.viewport_meters = {
                    x: this.css_size.width * this.meters_per_pixel,
                    y: this.css_size.height * this.meters_per_pixel
                };

                // Center of viewport in meters, and tile

                var _Geo$latLngToMeters = Geo.latLngToMeters([this.center.lng, this.center.lat]);

                var _Geo$latLngToMeters2 = _slicedToArray(_Geo$latLngToMeters, 2);

                var x = _Geo$latLngToMeters2[0];
                var y = _Geo$latLngToMeters2[1];

                this.center_meters = { x: x, y: y };

                var z = this.baseZoom(this.zoom);
                var max_zoom = this.findMaxZoom();
                if (z > max_zoom) {
                    z = max_zoom;
                }
                this.center_tile = Geo.tileForMeters([this.center_meters.x, this.center_meters.y], z);

                this.bounds_meters = {
                    sw: {
                        x: this.center_meters.x - this.viewport_meters.x / 2,
                        y: this.center_meters.y - this.viewport_meters.y / 2
                    },
                    ne: {
                        x: this.center_meters.x + this.viewport_meters.x / 2,
                        y: this.center_meters.y + this.viewport_meters.y / 2
                    }
                };

                // Find visible tiles and load new ones
                this.visible_tiles = this.findVisibleTiles();
                for (var key in this.visible_tiles) {
                    this.loadTile(this.visible_tiles[key]);
                }

                // Update tile visible flags
                for (var key in this.tiles) {
                    this.tiles[key].update(this);
                }

                this.trigger("move");
                this.dirty = true;
            }
        },
        findVisibleTiles: {
            value: function findVisibleTiles() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var buffer = _ref.buffer;

                var z = this.baseZoom(this.zoom);
                var max_zoom = this.findMaxZoom();
                if (z > max_zoom) {
                    z = max_zoom;
                }

                var sw = Geo.tileForMeters([this.bounds_meters.sw.x, this.bounds_meters.sw.y], z);
                var ne = Geo.tileForMeters([this.bounds_meters.ne.x, this.bounds_meters.ne.y], z);
                buffer = buffer || 0;

                var tiles = {};
                for (var x = sw.x - buffer; x <= ne.x + buffer; x++) {
                    for (var y = ne.y - buffer; y <= sw.y + buffer; y++) {
                        var coords = { x: x, y: y, z: z };
                        tiles[Tile.key(coords)] = coords;
                    }
                }
                return tiles;
            }
        },
        removeTilesOutsideZoomRange: {
            value: function removeTilesOutsideZoomRange(below, above) {
                below = Math.min(below, this.findMaxZoom() || below);
                above = Math.min(above, this.findMaxZoom() || above);

                this.removeTiles(function (tile) {
                    if (tile.coords.z < below || tile.coords.z > above) {
                        log.trace("removed " + tile.key + " (outside range [" + below + ", " + above + "])");
                        return true;
                    }
                });
            }
        },
        removeTiles: {
            value: function removeTiles(filter) {
                var remove_tiles = [];
                for (var t in this.tiles) {
                    var tile = this.tiles[t];
                    if (filter(tile)) {
                        remove_tiles.push(t);
                    }
                }
                for (var r = 0; r < remove_tiles.length; r++) {
                    var key = remove_tiles[r];
                    this.removeTile(key);
                }
            }
        },
        resizeMap: {
            value: function resizeMap(width, height) {
                this.dirty = true;

                this.css_size = { width: width, height: height };
                this.device_size = {
                    width: Math.round(this.css_size.width * Utils.device_pixel_ratio),
                    height: Math.round(this.css_size.height * Utils.device_pixel_ratio)
                };
                this.view_aspect = this.css_size.width / this.css_size.height;
                this.updateBounds();

                if (this.canvas) {
                    this.canvas.style.width = this.css_size.width + "px";
                    this.canvas.style.height = this.css_size.height + "px";
                    this.canvas.width = this.device_size.width;
                    this.canvas.height = this.device_size.height;

                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }
            }
        },
        requestRedraw: {

            // Request scene be redrawn at next animation loop

            value: function requestRedraw() {
                this.dirty = true;
            }
        },
        immediateRedraw: {

            // Redraw scene immediately - don't wait for animation loop
            // Use sparingly, but for cases where you need the closest possible sync with other UI elements,
            // such as other, non-WebGL map layers (e.g. Leaflet raster layers, markers, etc.)

            value: function immediateRedraw() {
                this.dirty = true;
                this.render();
            }
        },
        setupRenderLoop: {

            // Setup the render loop

            value: function setupRenderLoop() {
                var _this = this;

                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var pre_render = _ref.pre_render;
                var post_render = _ref.post_render;

                this.renderLoop = function () {
                    if (_this.initialized) {
                        // Render the scene
                        _this.update();
                    }

                    // Request the next frame
                    window.requestAnimationFrame(_this.renderLoop);
                };
                setTimeout(function () {
                    _this.renderLoop();
                }, 0); // delay start by one tick
            }
        },
        update: {
            value: function update() {
                this.loadQueuedTiles();

                // Render on demand
                var will_render = !(this.dirty === false || this.initialized === false || this.viewReady() === false);

                // Pre-render loop hook
                if (typeof this.preUpdate === "function") {
                    this.preUpdate(will_render);
                }

                // Bail if no need to render
                if (!will_render) {
                    return false;
                }
                this.dirty = false; // subclasses can set this back to true when animation is needed

                // Render the scene
                this.render();

                // Post-render loop hook
                if (typeof this.postUpdate === "function") {
                    this.postUpdate(will_render);
                }

                // Redraw every frame if animating
                if (this.animated === true) {
                    this.dirty = true;
                }

                this.frame++;
                log.trace("Scene.render()");
                return true;
            }
        },
        render: {
            value: function render() {
                var _this = this;

                var gl = this.gl;

                // Map transforms
                if (!this.center_meters) {
                    return;
                }

                // Update styles, camera, lights
                this.camera.update();
                Object.keys(this.active_styles).forEach(function (i) {
                    return _this.styles[i].update();
                });
                Object.keys(this.lights).forEach(function (i) {
                    return _this.lights[i].update();
                });

                // Renderable tile list
                this.renderable_tiles = [];
                for (var t in this.tiles) {
                    var tile = this.tiles[t];
                    if (tile.visible && tile.loaded) {
                        this.renderable_tiles.push(tile);
                    }
                }
                this.renderable_tiles_count = this.renderable_tiles.length;

                // Render main pass
                this.render_count = this.renderPass();

                // Render selection pass (if needed)
                if (this.selection.pendingRequests()) {
                    if (this.panning) {
                        return;
                    }

                    this.selection.bind(); // switch to FBO
                    this.renderPass("selection_program", // render w/alternate program
                    { allow_alpha_blend: false });
                    this.selection.read(); // read results from selection buffer

                    // Reset to screen buffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                }

                if (this.render_count !== this.last_render_count) {
                    log.info("Scene: rendered " + this.render_count + " primitives");
                }
                this.last_render_count = this.render_count;

                return true;
            }
        },
        renderPass: {

            // Render all active styles, grouped by blend/depth type (opaque, overlay, etc.) and by program (style)
            // Called both for main render pass, and for secondary passes like selection buffer

            value: function renderPass() {
                var _this = this;

                var program_key = arguments[0] === undefined ? "program" : arguments[0];

                var _ref = arguments[1] === undefined ? {} : arguments[1];

                var allow_alpha_blend = _ref.allow_alpha_blend;

                var styles = undefined;
                var count = 0; // how many primitives were rendered

                // optionally force alpha off (e.g. for selection pass)
                allow_alpha_blend = allow_alpha_blend == null ? true : allow_alpha_blend;

                this.clearFrame({ clear_color: true, clear_depth: true });

                // Opaque styles: depth test on, depth write on, blending off
                styles = Object.keys(this.active_styles).filter(function (s) {
                    return _this.styles[s].blend === "opaque";
                });
                this.setRenderState({ depth_test: true, depth_write: true, alpha_blend: false });
                count += this.renderStyles(styles, program_key);

                // Transparent styles: depth test off, depth write on, custom blending
                styles = Object.keys(this.active_styles).filter(function (s) {
                    return _this.styles[s].blend === "add";
                });
                this.setRenderState({ depth_test: true, depth_write: false, alpha_blend: allow_alpha_blend && "add" });
                count += this.renderStyles(styles, program_key);

                styles = Object.keys(this.active_styles).filter(function (s) {
                    return _this.styles[s].blend === "multiply";
                });
                this.setRenderState({ depth_test: true, depth_write: false, alpha_blend: allow_alpha_blend && "multiply" });
                count += this.renderStyles(styles, program_key);

                // Overlay styles: depth test off, depth write off, blending on
                styles = Object.keys(this.styles).filter(function (s) {
                    return _this.styles[s].blend === "overlay";
                });
                this.setRenderState({ depth_test: false, depth_write: false, alpha_blend: allow_alpha_blend });
                count += this.renderStyles(styles, program_key);

                return count;
            }
        },
        renderStyles: {
            value: function renderStyles(styles, program_key) {
                var count = 0;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = styles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var style = _step.value;

                        var program = this.styles[style][program_key];
                        if (!program || !program.compiled) {
                            continue;
                        }
                        count += this.renderStyle(style, program);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return count;
            }
        },
        renderStyle: {
            value: function renderStyle(style, program) {
                var first_for_style = true;
                var render_count = 0;

                // Render tile GL geometries
                for (var t in this.renderable_tiles) {
                    var tile = this.renderable_tiles[t];

                    if (tile.meshes[style] != null) {
                        // Setup style if encountering for first time this frame
                        // (lazy init, not all styles will be used in all screen views; some styles might be defined but never used)
                        if (first_for_style === true) {
                            first_for_style = false;

                            program.use();
                            this.styles[style].setup();

                            // TODO: don't set uniforms when they haven't changed
                            program.uniform("2f", "u_resolution", this.device_size.width, this.device_size.height);
                            program.uniform("1f", "u_time", (+new Date() - this.start_time) / 1000);
                            program.uniform("3f", "u_map_position", this.center_meters.x, this.center_meters.y, this.zoom);
                            // Math.floor(this.zoom) + (Math.log((this.zoom % 1) + 1) / Math.LN2 // scale fractional zoom by log
                            program.uniform("1f", "u_meters_per_pixel", this.meters_per_pixel);
                            program.uniform("1f", "u_device_pixel_ratio", Utils.device_pixel_ratio);

                            this.camera.setupProgram(program);
                            for (var i in this.lights) {
                                this.lights[i].setupProgram(program);
                            }
                        }

                        // TODO: calc these once per tile (currently being needlessly re-calculated per-tile-per-style)

                        // Tile origin
                        program.uniform("3f", "u_tile_origin", tile.min.x, tile.min.y, tile.coords.z);

                        // Model matrix - transform tile space into world space (meters, absolute mercator position)
                        mat4.identity(this.modelMatrix);
                        mat4.translate(this.modelMatrix, this.modelMatrix, vec3.fromValues(tile.min.x, tile.min.y, 0));
                        mat4.scale(this.modelMatrix, this.modelMatrix, vec3.fromValues(tile.span.x / Scene.tile_scale, -1 * tile.span.y / Scene.tile_scale, 1)); // scale tile local coords to meters
                        mat4.copy(this.modelMatrix32, this.modelMatrix);
                        program.uniform("Matrix4fv", "u_model", false, this.modelMatrix32);

                        // Model view matrix - transform tile space into view space (meters, relative to camera)
                        mat4.multiply(this.modelViewMatrix32, this.camera.viewMatrix, this.modelMatrix);
                        program.uniform("Matrix4fv", "u_modelView", false, this.modelViewMatrix32);

                        // Normal matrix - transforms surface normals into view space
                        mat3.normalFromMat4(this.normalMatrix32, this.modelViewMatrix32);
                        program.uniform("Matrix3fv", "u_normalMatrix", false, this.normalMatrix32);

                        // Render tile
                        tile.meshes[style].render();
                        render_count += tile.meshes[style].geometry_count;
                    }
                }

                return render_count;
            }
        },
        clearFrame: {
            value: function clearFrame() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var clear_color = _ref.clear_color;
                var clear_depth = _ref.clear_depth;

                if (!this.initialized) {
                    return;
                }

                // Defaults
                clear_color = clear_color === false ? false : true; // default true
                clear_depth = clear_depth === false ? false : true; // default true

                // Reset frame state
                var gl = this.gl;

                if (clear_color) {
                    gl.clearColor.apply(gl, _toConsumableArray(this.background.color));
                }

                if (clear_depth) {
                    gl.depthMask(true); // always clear depth if requested, even if depth write will be turned off
                }

                if (clear_color || clear_depth) {
                    var mask = (clear_color && gl.COLOR_BUFFER_BIT) | (clear_depth && gl.DEPTH_BUFFER_BIT);
                    gl.clear(mask);
                }
            }
        },
        setRenderState: {
            value: function setRenderState() {
                var _ref = arguments[0] === undefined ? {} : arguments[0];

                var depth_test = _ref.depth_test;
                var depth_write = _ref.depth_write;
                var cull_face = _ref.cull_face;
                var alpha_blend = _ref.alpha_blend;

                if (!this.initialized) {
                    return;
                }

                // Defaults
                // TODO: when we abstract out support for multiple render passes, these can be per-pass config options
                depth_test = depth_test === false ? false : true; // default true
                depth_write = depth_write === false ? false : true; // default true
                cull_face = cull_face === false ? false : true; // default true
                alpha_blend = alpha_blend != null ? alpha_blend : false; // default false

                // Reset frame state
                var gl = this.gl;

                if (depth_test) {
                    gl.enable(gl.DEPTH_TEST);
                    gl.depthFunc(gl.LEQUAL);
                } else {
                    gl.disable(gl.DEPTH_TEST);
                }

                gl.depthMask(depth_write);

                if (cull_face) {
                    gl.enable(gl.CULL_FACE);
                    gl.cullFace(gl.BACK);
                } else {
                    gl.disable(gl.CULL_FACE);
                }

                if (alpha_blend) {
                    gl.enable(gl.BLEND);

                    // Traditional blending
                    if (alpha_blend === true) {
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    }
                    // Additive blending
                    else if (alpha_blend === "add") {
                        gl.blendFunc(gl.ONE, gl.ONE);
                    }
                    // Multiplicative blending
                    else if (alpha_blend === "multiply") {
                        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                    }
                } else {
                    gl.disable(gl.BLEND);
                }
            }
        },
        getFeatureAt: {

            // Request feature selection at given pixel. Runs async and returns results via a promise.

            value: function getFeatureAt(pixel) {
                if (!this.initialized) {
                    return Promise.reject(new Error("Scene.getFeatureAt() called before scene was initialized"));
                }

                // Point scaled to [0..1] range
                var point = {
                    x: pixel.x * Utils.device_pixel_ratio / this.device_size.width,
                    y: pixel.y * Utils.device_pixel_ratio / this.device_size.height
                };

                this.dirty = true; // need to make sure the scene re-renders for these to be processed
                return this.selection.getFeatureAt(point);
            }
        },
        loadTile: {

            // Queue a tile for load

            value: function loadTile(coords) {
                this.queued_tiles[this.queued_tiles.length] = coords;
            }
        },
        loadQueuedTiles: {

            // Load all queued tiles

            value: function loadQueuedTiles() {
                var _this = this;

                if (!this.initialized) {
                    return;
                }

                if (this.queued_tiles.length === 0) {
                    return;
                }

                // Sort queued tiles from center tile
                this.queued_tiles.sort(function (a, b) {
                    var ad = Math.abs(_this.center_tile.x - a.x) + Math.abs(_this.center_tile.y - a.y);
                    var bd = Math.abs(_this.center_tile.x - b.x) + Math.abs(_this.center_tile.y - b.y);
                    return bd > ad ? -1 : bd === ad ? 0 : 1;
                });
                this.queued_tiles.forEach(function (coords) {
                    return _this._loadTile(coords);
                });
                this.queued_tiles = [];
            }
        },
        _loadTile: {

            // Load a single tile

            value: function _loadTile(coords) {
                // Skip if not at current scene zoom
                if (coords.z !== this.center_tile.z) {
                    return;
                }

                var key = Tile.key(coords);
                var tile = undefined;
                if (!this.hasTile(key)) {
                    tile = Tile.create({
                        coords: coords,
                        max_zoom: this.findMaxZoom(),
                        worker: this.nextWorker()
                    });

                    this.cacheTile(tile);
                    tile.load(this);
                } else {
                    tile = this.tiles[key];
                }
                return tile;
            }
        },
        cacheTile: {

            // tile manager

            value: function cacheTile(tile) {
                this.tiles[tile.key] = tile;
            }
        },
        hasTile: {
            value: function hasTile(key) {
                return this.tiles[key] !== undefined;
            }
        },
        forgetTile: {
            value: function forgetTile(key) {
                delete this.tiles[key];

                if (this.building && this.building.tiles) {
                    delete this.building.tiles[key];
                }
            }
        },
        findMaxZoom: {
            value: function findMaxZoom() {
                var max_zoom = this.max_zoom || Geo.max_zoom;

                for (var name in this.sources) {
                    var source = this.sources[name];
                    if (source.max_zoom < max_zoom) {
                        max_zoom = source.max_zoom;
                    }
                }
                return max_zoom;
            }
        },
        rebuild: {

            // TODO: detect which elements need to be refreshed/rebuilt (stylesheet changes, etc.)

            value: function rebuild() {
                return this.rebuildGeometry();
            }
        },
        rebuildGeometry: {

            // Rebuild all tiles

            value: function rebuildGeometry() {
                var _this = this;

                if (!this.initialized) {
                    return Promise.reject(new Error("Scene.rebuildGeometry: scene is not initialized"));
                }

                return new Promise(function (resolve, reject) {
                    // Skip rebuild if already in progress
                    if (_this.building) {
                        // Queue up to one rebuild call at a time, only save last request
                        if (_this.building.queued && _this.building.queued.reject) {
                            // notify previous request that it did not complete
                            log.debug("Scene.rebuildGeometry: request superceded by a newer call");
                            _this.building.queued.resolve(false); // false flag indicates rebuild request was superceded
                        }

                        // Save queued request
                        _this.building.queued = { resolve: resolve, reject: reject };
                        log.trace("Scene.rebuildGeometry(): queuing request");
                        return;
                    }

                    // Track tile build state
                    _this.building = { resolve: resolve, reject: reject, tiles: {} };

                    // Profiling
                    if (_this.debug.profile.geometry_build) {
                        _this._profile("rebuildGeometry");
                    }

                    // Update config (in case JS objects were manipulated directly)
                    _this.syncConfigToWorker();
                    StyleManager.compile(_this.updateActiveStyles()); // only recompile newly active styles
                    _this.resetFeatureSelection();
                    _this.resetTime();

                    // Rebuild visible tiles, sorted from center
                    var build = [];
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Utils.values(_this.tiles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var tile = _step.value;

                            if (tile.visible) {
                                build.push(tile);
                            } else {
                                _this.removeTile(tile.key);
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator["return"]) {
                                _iterator["return"]();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    Tile.sort(build).forEach(function (tile) {
                        return tile.build(_this);
                    });

                    // Edge case: if nothing is being rebuilt, immediately resolve promise and don't lock further rebuilds
                    if (_this.building && Object.keys(_this.building.tiles).length === 0) {
                        resolve(false);

                        // Another rebuild queued?
                        var queued = _this.building.queued;
                        _this.building = null;
                        if (queued) {
                            log.debug("Scene: starting queued rebuildGeometry() request");
                            _this.rebuildGeometry().then(queued.resolve, queued.reject);
                        }
                    }
                }).then(function () {
                    // Profiling
                    if (_this.debug.profile.geometry_build) {
                        _this._profileEnd("rebuildGeometry");
                    }
                });
            }
        },
        buildTileCompleted: {

            // TODO: move to Tile class
            // Called on main thread when a web worker completes processing for a single tile (initial load, or rebuild)

            value: function buildTileCompleted(_ref) {
                var tile = _ref.tile;
                var worker_id = _ref.worker_id;
                var selection_map_size = _ref.selection_map_size;

                // Track selection map size (for stats/debug) - update per worker and sum across workers
                this.selection_map_worker_size[worker_id] = selection_map_size;
                this.selection_map_size = 0;
                for (var wid in this.selection_map_worker_size) {
                    this.selection_map_size += this.selection_map_worker_size[wid];
                }

                // Removed this tile during load?
                if (this.tiles[tile.key] == null) {
                    log.trace("discarded tile " + tile.key + " in Scene.buildTileCompleted because previously removed");
                    Tile.abortBuild(tile);
                } else {
                    var cached = this.tiles[tile.key];

                    // Update tile with properties from worker
                    if (cached) {
                        tile = cached.merge(tile);
                    }

                    if (!tile.error) {
                        tile.finalizeBuild(this.styles);
                        this.dirty = true;
                    } else {
                        log.error("main thread tile load error for " + tile.key + ": " + tile.error);
                    }
                    tile.printDebug();
                }

                this.trackTileSetLoadStop();
                this.trackTileBuildStop(tile.key);
            }
        },
        trackTileBuildStart: {

            // Track tile build state

            value: function trackTileBuildStart(key) {
                if (!this.building) {
                    this.building = {
                        tiles: {}
                    };
                }
                this.building.tiles[key] = true;
                log.trace("trackTileBuildStart for " + key + ": " + Object.keys(this.building.tiles).length);
            }
        },
        trackTileBuildStop: {
            value: function trackTileBuildStop(key) {
                // Done building?
                if (this.building) {
                    log.trace("trackTileBuildStop for " + key + ": " + Object.keys(this.building.tiles).length);
                    delete this.building.tiles[key];
                    if (Object.keys(this.building.tiles).length === 0) {
                        log.info("Scene: build geometry finished");
                        log.debug("Scene: updated selection map: " + this.selection_map_size + " features");

                        if (this.building.resolve) {
                            this.building.resolve(true);
                        }

                        // Another rebuild queued?
                        var queued = this.building.queued;
                        this.building = null;
                        if (queued) {
                            log.debug("Scene: starting queued rebuildGeometry() request");
                            this.rebuildGeometry().then(queued.resolve, queued.reject);
                        }
                    }
                }
            }
        },
        removeTile: {
            value: function removeTile(key) {
                if (!this.initialized) {
                    return;
                }
                log.trace("tile unload for " + key);

                var tile = this.tiles[key];

                if (tile != null) {
                    tile.destroy();
                }

                this.forgetTile(tile.key);
                this.dirty = true;
            }
        },
        loadScene: {

            /**
               Load (or reload) the scene config
               @return {Promise}
            */

            value: function loadScene() {
                var _this = this;

                return Utils.loadResource(this.config_source).then(function (config) {
                    _this.config = config;
                    return _this.preProcessConfig().then(function () {
                        _this.trigger("loadScene", _this.config);
                    });
                })["catch"](function (e) {
                    throw e;
                });
            }
        },
        reload: {

            // Reload scene config and rebuild tiles

            value: function reload() {
                var _this = this;

                if (!this.initialized) {
                    return Promise.resolve(this);
                }

                return this.loadScene().then(function () {
                    _this.updateStyles();
                    _this.syncConfigToWorker();
                    return _this.rebuildGeometry();
                }, function (error) {
                    throw error;
                });
            }
        },
        loadDataSources: {
            value: function loadDataSources() {
                for (var name in this.config.sources) {
                    var source = this.config.sources[name];
                    source.url = Utils.addBaseURL(source.url);
                    this.sources[name] = DataSource.create(Object.assign({}, source, { name: name }));
                }
                this.updateBounds();
            }
        },
        setSourceMax: {
            value: function setSourceMax() {
                var max_zoom = this.findMaxZoom();

                for (var name in this.sources) {
                    var source = this.sources[name];
                    source.max_zoom = max_zoom;
                }
                return max_zoom;
            }
        },
        preProcessConfig: {

            // Normalize some settings that may not have been explicitly specified in the scene definition

            value: function preProcessConfig() {
                // Assign ids to data sources
                var source_id = 0;
                for (var source in this.config.sources) {
                    this.config.sources[source].id = source_id++;
                }

                // If only one camera specified, set it as default
                this.config.cameras = this.config.cameras || {};
                if (this.config.camera) {
                    this.config.cameras["default"] = this.config.camera;
                }
                var camera_names = Object.keys(this.config.cameras);
                if (camera_names.length === 0) {
                    this.config.cameras["default"] = { active: true };
                } else if (!this._active_camera) {
                    // If no camera set as active, use first one
                    this.config.cameras[camera_names[0]].active = true;
                }

                this.config.lights = this.config.lights || {}; // ensure lights object
                this.config.styles = this.config.styles || {}; // ensure styles object

                return StyleManager.preload(this.config.styles);
            }
        },
        loadTextures: {

            // Load all textures in the scene definition

            value: function loadTextures() {
                this.normalizeTextures();
                return Texture.createFromObject(this.gl, this.config.textures);
            }
        },
        normalizeTextures: {

            // Handle single or multi-texture syntax, for stylesheet convenience

            value: function normalizeTextures() {
                if (!this.config.styles) {
                    return;
                }

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Utils.entries(this.config.styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _step$value = _slicedToArray(_step.value, 2);

                        var style_name = _step$value[0];
                        var style = _step$value[1];

                        // If style has a single 'texture' object, move it to the global scene texture set
                        // and give it a default name
                        if (style.texture && typeof style.texture === "object") {
                            var texture_name = "__" + style_name;
                            this.config.textures = this.config.textures || {};
                            this.config.textures[texture_name] = style.texture;
                            style.texture = texture_name; // point stlye to location of texture
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        },
        updateStyles: {

            // Called (currently manually) after styles are updated in stylesheet

            value: function updateStyles() {
                if (!this.initialized && !this.initializing) {
                    throw new Error("Scene.updateStyles() called before scene was initialized");
                }

                // (Re)build styles from config
                StyleManager.init();
                this.styles = StyleManager.build(this.config.styles, this);

                // Optionally set GL context (used when initializing or re-initializing GL resources)
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Utils.values(this.styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var style = _step.value;

                        style.setGL(this.gl);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // Find & compile active styles
                this.updateActiveStyles();
                StyleManager.compile(Object.keys(this.active_styles));

                this.dirty = true;
            }
        },
        updateActiveStyles: {
            value: function updateActiveStyles() {
                // Make a set of currently active styles (used in a draw rule)
                // Note: doesn't actually check if any geometry matches the rule, just that the style is potentially renderable
                var prev_styles = Object.keys(this.active_styles || {});
                this.active_styles = {};
                var animated = false; // is any active style animated?
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Utils.recurseValues(this.config.layers)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var rule = _step.value;

                        if (rule.draw) {
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = Utils.entries(rule.draw)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var _step2$value = _slicedToArray(_step2.value, 2);

                                    var _name = _step2$value[0];
                                    var group = _step2$value[1];

                                    // TODO: warn on non-object draw group
                                    if (typeof group === "object" && group.visible !== false) {
                                        var style_name = group.style || _name;
                                        var style = this.styles[style_name];
                                        if (style) {
                                            this.active_styles[style_name] = true;
                                            if (style.animated) {
                                                animated = true;
                                            }
                                        }
                                    }
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                        _iterator2["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                this.animated = animated;

                // Compile newly active styles
                return Object.keys(this.active_styles).filter(function (s) {
                    return prev_styles.indexOf(s) === -1;
                });
            }
        },
        createCamera: {

            // Create camera

            value: function createCamera() {
                this.camera = Camera.create(this._active_camera, this, this.config.cameras[this._active_camera]);

                // TODO: replace this and move all position info to camera
                this.camera.updateScene();
            }
        },
        getActiveCamera: {

            // Get active camera - for public API

            value: function getActiveCamera() {
                return this._active_camera;
            }
        },
        setActiveCamera: {

            // Set active camera and recompile - for public API

            value: function setActiveCamera(name) {
                this._active_camera = name;
                this.updateConfig();
                return this._active_camera;
            }
        },
        _active_camera: {

            // Internal management of active camera

            get: function () {
                for (var name in this.config.cameras) {
                    if (this.config.cameras[name].active) {
                        return name;
                    }
                }
            },
            set: function (name) {
                var prev = this._active_camera;

                // Set new active camera
                if (this.config.cameras[name]) {
                    this.config.cameras[name].active = true;

                    // Clear previously active camera
                    if (prev && prev !== name && this.config.cameras[prev]) {
                        delete this.config.cameras[prev].active;
                    }
                }
            }
        },
        createLights: {

            // Create lighting

            value: function createLights() {
                this.lights = {};
                for (var i in this.config.lights) {
                    this.config.lights[i].name = i;
                    this.config.lights[i].visible = this.config.lights[i].visible === false ? false : true;
                    if (this.config.lights[i].visible) {
                        this.lights[i] = Light.create(this, this.config.lights[i]);
                    }
                }
                Light.inject(this.lights);
            }
        },
        setBackground: {

            // Set background color

            value: function setBackground() {
                var bg = this.config.background;
                this.background = {};
                if (bg && bg.color) {
                    this.background.color = StyleParser.parseColor(bg.color);
                }
                if (!this.background.color) {
                    this.background.color = [0, 0, 0, 1]; // default background to black
                }
            }
        },
        updateConfig: {

            // Update scene config

            value: function updateConfig() {
                this.createCamera();
                this.createLights();
                this.loadDataSources();
                this.setSourceMax();
                this.loadTextures();
                this.setBackground();

                // TODO: detect changes to styles? already (currently) need to recompile anyway when camera or lights change
                this.updateStyles();
                this.syncConfigToWorker();
            }
        },
        syncConfigToWorker: {

            // Serialize config and send to worker

            value: function syncConfigToWorker() {
                var _this = this;

                this.config_serialized = Utils.serializeWithFunctions(this.config);
                this.selection_map_worker_size = {};
                // Tell workers we're about to rebuild (so they can update styles, etc.)
                this.workers.forEach(function (worker) {
                    WorkerBroker.postMessage(worker, "updateConfig", {
                        config: _this.config_serialized
                    });
                });
            }
        },
        resetFeatureSelection: {
            value: function resetFeatureSelection() {
                this.workers.forEach(function (worker) {
                    return WorkerBroker.postMessage(worker, "resetFeatureSelection");
                });
            }
        },
        resetTime: {

            // Reset internal clock, mostly useful for consistent experience when changing styles/debugging

            value: function resetTime() {
                this.start_time = +new Date();
            }
        },
        trackTileSetLoadStart: {

            // Stats/debug/profiling methods

            // Profiling methods used to track when sets of tiles start/stop loading together
            // e.g. initial page load is one set of tiles, new sets of tile loads are then initiated by a map pan or zoom

            value: function trackTileSetLoadStart() {
                // Start tracking new tile set if no other tiles already loading
                if (this.tile_set_loading == null) {
                    this.tile_set_loading = +new Date();
                    log.info("Scene: tile set load start");
                }
            }
        },
        trackTileSetLoadStop: {
            value: function trackTileSetLoadStop() {
                // No more tiles actively loading?
                if (this.tile_set_loading != null) {
                    var end_tile_set = true;
                    for (var t in this.tiles) {
                        if (this.tiles[t].loading === true) {
                            end_tile_set = false;
                            break;
                        }
                    }

                    if (end_tile_set === true) {
                        this.last_tile_set_load = +new Date() - this.tile_set_loading;
                        this.tile_set_loading = null;
                        log.info("Scene: tile set load finished in " + this.last_tile_set_load + "ms");
                    }
                }
            }
        },
        getDebugSum: {

            // Sum of a debug property across tiles

            value: function getDebugSum(prop, filter) {
                var sum = 0;
                for (var t in this.tiles) {
                    if (this.tiles[t].debug[prop] != null && (typeof filter !== "function" || filter(this.tiles[t]) === true)) {
                        sum += this.tiles[t].debug[prop];
                    }
                }
                return sum;
            }
        },
        getDebugAverage: {

            // Average of a debug property across tiles

            value: function getDebugAverage(prop, filter) {
                return this.getDebugSum(prop, filter) / Object.keys(this.tiles).length;
            }
        },
        workerLogMessage: {

            // Log messages pass through from web workers

            value: function workerLogMessage(event) {
                if (event.data.type !== "log") {
                    return;
                }

                var _event$data = event.data;
                var worker_id = _event$data.worker_id;
                var level = _event$data.level;
                var msg = _event$data.msg;

                if (log[level]) {
                    log[level].apply(log, ["worker " + worker_id + ":"].concat(_toConsumableArray(msg)));
                } else {
                    log.error("Scene.workerLogMessage: unrecognized log level " + level);
                }
            }
        },
        _profile: {

            // Profile helpers, issues a profile on main thread & all workers

            value: function _profile(name) {
                console.profile("main thread: " + name);
                this.workers.forEach(function (w) {
                    return WorkerBroker.postMessage(w, "profile", name);
                });
            }
        },
        _profileEnd: {
            value: function _profileEnd(name) {
                console.profileEnd("main thread: " + name);
                this.workers.forEach(function (w) {
                    return WorkerBroker.postMessage(w, "profileEnd", name);
                });
            }
        }
    });

    return Scene;
})();

module.exports = Scene;

// Static methods/state

Scene.create = function (config) {
    var options = arguments[1] === undefined ? {} : arguments[1];

    return new Scene(config, options);
};

Scene.tile_scale = 4096; // coordinates are locally scaled to the range [0, tile_scale]
Geo.setTileScale(Scene.tile_scale);
Builders.setTileScale(Scene.tile_scale);
ShaderProgram.defines.TILE_SCALE = Scene.tile_scale;

},{"./camera":65,"./data_source":66,"./geo":67,"./gl/context":69,"./gl/shader_program":71,"./gl/texture":73,"./gl/vao":74,"./light":79,"./selection":84,"./styles/builders":85,"./styles/style_manager":91,"./styles/style_parser":92,"./tile":98,"./utils/subscribe":100,"./utils/utils":101,"./utils/worker_broker":102,"gl-matrix":22,"loglevel":54}],83:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
/*jshint worker: true*/

var Utils = _interopRequire(require("./utils/utils"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

// jshint ignore:line

var Scene = _interopRequire(require("./scene"));

var Tile = _interopRequire(require("./tile"));

var DataSource = _interopRequire(require("./data_source.js"));

var FeatureSelection = _interopRequire(require("./selection"));

var StyleParser = require("./styles/style_parser").StyleParser;

var StyleManager = require("./styles/style_manager").StyleManager;

var parseRules = require("./styles/rule").parseRules;

var Builders = _interopRequire(require("./styles/builders"));

var Texture = _interopRequire(require("./gl/texture"));

var SceneWorker = {
    sources: {
        tiles: {},
        objects: {}
    },
    styles: {},
    rules: {},
    layers: {},
    tiles: {},
    objects: {},
    config: {}
};

exports.SceneWorker = SceneWorker;
// Worker functionality will only be defined in worker thread

if (Utils.isWorkerThread) {

    SceneWorker.worker = self;

    // TODO: sync render style state between main thread and worker
    Builders.setTileScale(Scene.tile_scale);

    // Initialize worker
    SceneWorker.worker.init = function (worker_id, num_workers, device_pixel_ratio) {
        self._worker_id = worker_id;
        SceneWorker.num_workers = num_workers;
        Utils.device_pixel_ratio = device_pixel_ratio;
        FeatureSelection.setPrefix(self._worker_id);
        return worker_id;
    };

    // Starts a config refresh
    SceneWorker.worker.updateConfig = function (_ref) {
        var config = _ref.config;

        SceneWorker.config = null;
        SceneWorker.styles = null;
        config = JSON.parse(config);

        for (var name in config.sources) {
            var source = DataSource.create(Object.assign(config.sources[name], { name: name }));
            if (source.tiled) {
                SceneWorker.sources.tiles[name] = source;
            } else {
                // Distribute object sources across workers
                if (source.id % SceneWorker.num_workers === self._worker_id) {
                    // Load source if not cached
                    SceneWorker.sources.objects[name] = source;
                    if (!SceneWorker.objects[source.name]) {
                        SceneWorker.objects[source.name] = {};
                        source.load(SceneWorker.objects[source.name]);
                    }
                }
            }
        }

        // Data block functions are not macro'ed and wrapped like the rest of the style functions are
        // TODO: probably want a cleaner way to exclude these
        for (var layer in config.layers) {
            config.layers[layer].data = Utils.stringsToFunctions(config.layers[layer].data);
        }

        // Expand styles
        SceneWorker.config = Utils.stringsToFunctions(StyleParser.expandMacros(config), StyleParser.wrapFunction);
        SceneWorker.styles = StyleManager.build(SceneWorker.config.styles);

        // Parse each top-level layer as a separate rule tree
        // TODO: find a more graceful way to incorporate this

        SceneWorker.rules = parseRules(SceneWorker.config.layers);

        // Sync tetxure info from main thread
        SceneWorker.syncing_textures = SceneWorker.syncTextures();

        // Return promise for when config refresh finishes
        SceneWorker.configuring = SceneWorker.syncing_textures.then(function () {
            Utils.log("debug", "updated config");
        });
    };

    // Returns a promise that fulfills when config refresh is finished
    SceneWorker.awaitConfiguration = function () {
        return SceneWorker.configuring;
    };

    // Slice a subset of keys out of a tile
    // Includes a minimum set of pre-defined keys for load state, debug. etc.
    // We use this to send a subset of the tile back to the main thread, to minimize unnecessary data transfer
    // (e.g. very large items like feature geometry are not needed on the main thread)
    SceneWorker.sliceTile = function (tile, keys) {
        keys = keys || {};
        keys.key = true;
        keys.loading = true;
        keys.loaded = true;
        keys.order = true;
        keys.error = true;
        keys.debug = true;

        // Build the tile subset
        var tile_subset = {};
        for (var k in keys) {
            tile_subset[k] = tile[k];
        }

        return tile_subset;
    };

    // Build a tile: load from tile source if building for first time, otherwise rebuild with existing data
    SceneWorker.worker.buildTile = function (_ref) {
        var tile = _ref.tile;

        // Tile cached?
        if (SceneWorker.tiles[tile.key] != null) {
            // Already loading?
            if (SceneWorker.tiles[tile.key].loading === true) {
                return;
            }
        }

        // Update tile cache
        tile = SceneWorker.tiles[tile.key] = Object.assign(SceneWorker.tiles[tile.key] || {}, tile);

        // Update config (styles, etc.), then build tile
        return SceneWorker.awaitConfiguration().then(function () {
            // First time building the tile
            if (tile.loaded !== true) {

                return new Promise(function (resolve, reject) {

                    tile.loading = true;
                    tile.loaded = false;
                    tile.error = null;

                    Promise.all(Object.keys(SceneWorker.sources.tiles).map(function (x) {
                        return SceneWorker.sources.tiles[x].load(tile);
                    })).then(function () {
                        // Any errors? Warn and continue
                        var e = Object.keys(tile.sources).map(function (s) {
                            return tile.sources[s].error && "[source '" + s + "': " + tile.sources[s].error + "]";
                        }).filter(function (x) {
                            return x;
                        });
                        if (e.length > 0) {
                            Utils.log("warn", "tile load error(s) for " + tile.key + ": " + e.join(", "));
                        }

                        tile.loading = false;
                        tile.loaded = true;
                        Tile.buildGeometry(tile, SceneWorker.config.layers, SceneWorker.rules, SceneWorker.styles).then(function (keys) {
                            resolve({
                                tile: SceneWorker.sliceTile(tile, keys),
                                worker_id: self._worker_id,
                                selection_map_size: FeatureSelection.getMapSize()
                            });
                        });
                    })["catch"](function (error) {
                        tile.loading = false;
                        tile.loaded = false;
                        tile.error = error.toString();
                        Utils.log("error", "tile load error for " + tile.key + ": " + error.stack);

                        resolve({
                            tile: SceneWorker.sliceTile(tile),
                            worker_id: self._worker_id,
                            selection_map_size: FeatureSelection.getMapSize()
                        });
                    });
                });
            }
            // Tile already loaded, just rebuild
            else {
                Utils.log("trace", "used worker cache for tile " + tile.key);

                // Build geometry
                return Tile.buildGeometry(tile, SceneWorker.config.layers, SceneWorker.rules, SceneWorker.styles).then(function (keys) {
                    return {
                        tile: SceneWorker.sliceTile(tile, keys),
                        worker_id: self._worker_id,
                        selection_map_size: FeatureSelection.getMapSize()
                    };
                });
            }
        });
    };

    // Remove tile
    SceneWorker.worker.removeTile = function (key) {
        var tile = SceneWorker.tiles[key];

        if (tile != null) {
            // Cancel if loading
            if (tile.loading === true) {
                Utils.log("trace", "cancel tile load for " + key);
                tile.loading = false;
            }

            Tile.cancel(tile);

            // Remove from cache
            FeatureSelection.clearTile(key);
            delete SceneWorker.tiles[key];
            Utils.log("trace", "remove tile from cache for " + key);
        }
    };

    // Get a feature from the selection map
    SceneWorker.worker.getFeatureSelection = function () {
        var _ref = arguments[0] === undefined ? {} : arguments[0];

        var id = _ref.id;
        var key = _ref.key;

        var selection = FeatureSelection.map[key];

        return {
            id: id,
            feature: selection && selection.feature
        };
    };

    // Resets the feature selection state
    SceneWorker.worker.resetFeatureSelection = function () {
        FeatureSelection.reset();
    };

    // Texture info needs to be synced from main thread
    SceneWorker.syncTextures = function () {
        // We're only syncing the textures that have sprites defined, since these are (currently) the only ones we
        // need info about for geometry construction (e.g. width/height, which we only know after the texture loads)
        var textures = [];
        if (SceneWorker.config.textures) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Utils.entries(SceneWorker.config.textures)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = _slicedToArray(_step.value, 2);

                    var texname = _step$value[0];
                    var texture = _step$value[1];

                    if (texture.sprites) {
                        textures.push(texname);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

        Utils.log("trace", "sync textures to worker:", textures);
        if (textures.length > 0) {
            return Texture.syncTexturesToWorker(textures);
        }
        return Promise.resolve();
    };

    // Profiling helpers
    SceneWorker.worker.profile = function (name) {
        console.profile("worker " + self._worker_id + ": " + name);
    };

    SceneWorker.worker.profileEnd = function (name) {
        console.profileEnd("worker " + self._worker_id + ": " + name);
    };
}

},{"./data_source.js":66,"./gl/texture":73,"./scene":82,"./selection":84,"./styles/builders":85,"./styles/rule":89,"./styles/style_manager":91,"./styles/style_parser":92,"./tile":98,"./utils/utils":101,"./utils/worker_broker":102}],84:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Texture = _interopRequire(require("./gl/texture"));

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var FeatureSelection = (function () {
    function FeatureSelection(gl, workers) {
        _classCallCheck(this, FeatureSelection);

        this.gl = gl;
        this.workers = workers; // pool of workers to request feature look-ups from, keyed by id
        this.init();
    }

    _createClass(FeatureSelection, {
        init: {
            value: function init() {
                // Selection state tracking
                this.requests = {}; // pending selection requests
                this.feature = null; // currently selected feature
                this.read_delay = 5; // delay time from selection render to framebuffer sample, to avoid CPU/GPU sync lock
                this.read_delay_timer = null; // current timer (setTimeout) for delayed selection reads

                this.pixel = new Uint8Array(4);
                this.pixel32 = new Float32Array(this.pixel.buffer);

                // Frame buffer for selection
                // TODO: initiate lazily in case we don't need to do any selection
                this.fbo = this.gl.createFramebuffer();
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
                this.fbo_size = { width: 256, height: 256 }; // TODO: make configurable / adaptive based on canvas size
                this.fbo_size.aspect = this.fbo_size.width / this.fbo_size.height;

                // Texture for the FBO color attachment
                var fbo_texture = new Texture(this.gl, "selection_fbo");
                fbo_texture.setData(this.fbo_size.width, this.fbo_size.height, null, { filtering: "nearest" });
                this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, fbo_texture.texture, 0);

                // Renderbuffer for the FBO depth attachment
                var fbo_depth_rb = this.gl.createRenderbuffer();
                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, fbo_depth_rb);
                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this.fbo_size.width, this.fbo_size.height);
                this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, fbo_depth_rb);

                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            }
        },
        bind: {
            value: function bind() {
                // Switch to FBO
                this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);
                this.gl.viewport(0, 0, this.fbo_size.width, this.fbo_size.height);
            }
        },
        getFeatureAt: {

            // Request feature selection
            // Runs asynchronously, schedules selection buffer to be updated

            value: function getFeatureAt(point) {
                var _this = this;

                return new Promise(function (resolve, reject) {
                    // Queue requests for feature selection, and they will be picked up by the render loop
                    _this.selection_request_id = _this.selection_request_id + 1 || 0;
                    _this.requests[_this.selection_request_id] = {
                        type: "point",
                        id: _this.selection_request_id,
                        point: point,
                        resolve: resolve
                    };
                });
            }
        },
        pendingRequests: {

            // Any pending selection requests

            value: function pendingRequests() {
                return this.requests;
            }
        },
        read: {

            // Read pending results from the selection buffer. Called after rendering to selection buffer.

            value: function read() {
                var _this = this;

                // Delay reading the pixel result from the selection buffer to avoid CPU/GPU sync lock.
                // Calling readPixels synchronously caused a massive performance hit, presumably since it
                // forced this function to wait for the GPU to finish rendering and retrieve the texture contents.
                if (this.read_delay_timer != null) {
                    clearTimeout(this.read_delay_timer);
                }
                this.read_delay_timer = setTimeout(function () {
                    var gl = _this.gl;

                    gl.bindFramebuffer(gl.FRAMEBUFFER, _this.fbo);

                    for (var r in _this.requests) {
                        var request = _this.requests[r];

                        // This request was already sent to the worker, we're just awaiting its reply
                        if (request.sent) {
                            continue;
                        }

                        // TODO: support other selection types, such as features within a box
                        if (request.type !== "point") {
                            continue;
                        }

                        // Check selection map against FBO
                        gl.readPixels(Math.floor(request.point.x * _this.fbo_size.width), Math.floor((1 - request.point.y) * _this.fbo_size.height), 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, _this.pixel);
                        var feature_key = _this.pixel[0] + (_this.pixel[1] << 8) + (_this.pixel[2] << 16) + (_this.pixel[3] << 24) >>> 0;

                        // If feature found, ask appropriate web worker to lookup feature
                        var worker_id = _this.pixel[3];
                        if (worker_id !== 255) {
                            // 255 indicates an empty selection buffer pixel
                            if (_this.workers[worker_id] != null) {
                                WorkerBroker.postMessage(_this.workers[worker_id], "getFeatureSelection", { id: request.id, key: feature_key }).then(function (message) {
                                    _this.finishRead(message);
                                });
                            }
                        }
                        // No feature found, but still need to resolve promise
                        else {
                            _this.finishRead({ id: request.id, feature: null });
                        }

                        request.sent = true;
                    }

                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }, this.read_delay);
            }
        },
        finishRead: {

            // Called on main thread when a web worker finds a feature in the selection buffer

            value: function finishRead(message) {
                var request = this.requests[message.id];
                if (!request) {
                    throw new Error("FeatureSelection.finishRead() called without any message");
                }

                var feature = message.feature;
                var changed = false;
                if (feature != null && this.feature == null || feature == null && this.feature != null || feature != null && this.feature != null && feature.id !== this.feature.id) {
                    changed = true;
                }

                this.feature = feature; // store the most recently selected feature

                // Resolve the request
                request.resolve({ feature: feature, changed: changed, request: request });
                delete this.requests[message.id]; // done processing this request
            }
        }
    }, {
        makeEntry: {

            // Selection map generation
            // Each worker will create its own independent, 'local' selection map

            // Create a unique 32-bit color to identify a feature
            // Workers independently create/modify selection colors in their own threads, but we also
            // need the main thread to know where each feature color originated. To accomplish this,
            // we partition the map by setting the 4th component (alpha channel) to the worker's id.

            value: function makeEntry(tile) {
                // 32-bit color key
                this.map_size++;
                var ir = this.map_size & 255;
                var ig = this.map_size >> 8 & 255;
                var ib = this.map_size >> 16 & 255;
                var ia = this.map_prefix;
                var r = ir / 255;
                var g = ig / 255;
                var b = ib / 255;
                var a = ia / 255;
                var key = ir + (ig << 8) + (ib << 16) + (ia << 24) >>> 0; // need unsigned right shift to convert to positive #

                this.map[key] = {
                    color: [r, g, b, a] };

                this.tiles[tile.key] = this.tiles[tile.key] || [];
                this.tiles[tile.key].push(key);

                return this.map[key];
            }
        },
        makeColor: {
            value: function makeColor(feature, tile) {
                var selector = this.makeEntry(tile);
                selector.feature = {
                    id: feature.id,
                    properties: feature.properties,
                    tile: tile.key
                };

                return selector.color;
            }
        },
        reset: {
            value: function reset() {
                this.map = {};
                this.map_size = 1;
            }
        },
        clearTile: {
            value: function clearTile(key) {
                var _this = this;

                if (Array.isArray(this.tiles[key])) {
                    this.tiles[key].forEach(function (k) {
                        return delete _this.map[k];
                    });
                    delete this.tiles[key];
                }
            }
        },
        getMapSize: {
            value: function getMapSize() {
                return Object.keys(this.map).length;
            }
        },
        setPrefix: {
            value: function setPrefix(prefix) {
                this.map_prefix = prefix;
            }
        }
    });

    return FeatureSelection;
})();

module.exports = FeatureSelection;

// Static properties
FeatureSelection.map = {}; // this will be unique per module instance (so unique per worker)
FeatureSelection.tiles = {}; // selection keys, by tile
FeatureSelection.map_size = 1; // start at 1 since 1 will be divided by this
FeatureSelection.map_prefix = 0; // set by worker to worker id #
FeatureSelection.defaultColor = [0, 0, 0, 1];

},{"./gl/texture":73,"./utils/worker_broker":102}],85:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

// Geometry building functions

var Vector = _interopRequire(require("../vector"));

var Geo = _interopRequire(require("../geo"));

var earcut = _interopRequire(require("earcut"));

var Builders;
module.exports = Builders = {};

Builders.debug = false;

// Re-scale UVs from [0, 1] range to a smaller area within the image
Builders.scaleTexcoordsToSprite = function (uv, area_origin, area_size, tex_size) {
    var area_origin_y = tex_size[1] - area_origin[1] - area_size[1];
    var suv = [];
    suv[0] = (uv[0] * area_size[0] + area_origin[0]) / tex_size[0];
    suv[1] = (uv[1] * area_size[1] + area_origin_y) / tex_size[1];
    return suv;
};

Builders.getTexcoordsForSprite = function (area_origin, area_size, tex_size) {
    return [Builders.scaleTexcoordsToSprite([0, 0], area_origin, area_size, tex_size), Builders.scaleTexcoordsToSprite([1, 1], area_origin, area_size, tex_size)];
};

// Tesselate a flat 2D polygon
// x & y coordinates will be set as first two elements of provided vertex_template
Builders.buildPolygons = function (polygons, vertex_data, vertex_template, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;

    var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

    var _ref22 = _slicedToArray(_ref2, 2);

    var _ref22$0 = _slicedToArray(_ref22[0], 2);

    var min_u = _ref22$0[0];
    var min_v = _ref22$0[1];

    var _ref22$1 = _slicedToArray(_ref22[1], 2);

    var max_u = _ref22$1[0];
    var max_v = _ref22$1[1];

    var num_polygons = polygons.length;
    for (var p = 0; p < num_polygons; p++) {
        var polygon = polygons[p];

        // Find polygon extents to calculate UVs, fit them to the axis-aligned bounding box
        if (texcoord_index) {
            var _Geo$findBoundingBox = Geo.findBoundingBox(polygon);

            var _Geo$findBoundingBox2 = _slicedToArray(_Geo$findBoundingBox, 4);

            var min_x = _Geo$findBoundingBox2[0];
            var min_y = _Geo$findBoundingBox2[1];
            var max_x = _Geo$findBoundingBox2[2];
            var max_y = _Geo$findBoundingBox2[3];

            var span_x = max_x - min_x;
            var span_y = max_y - min_y;
            var scale_u = (max_u - min_u) / span_x;
            var scale_v = (max_v - min_v) / span_y;
        }

        // Tessellate
        var vertices = Builders.triangulatePolygon(polygon);

        // Add vertex data
        var num_vertices = vertices.length;
        for (var v = 0; v < num_vertices; v++) {
            var vertex = vertices[v];
            vertex_template[0] = vertex[0];
            vertex_template[1] = vertex[1];

            // Add UVs
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = (vertex[0] - min_x) * scale_u + min_u;
                vertex_template[texcoord_index + 1] = (vertex[1] - min_y) * scale_v + min_v;
            }

            vertex_data.addVertex(vertex_template);
        }
    }
};

// Tesselate and extrude a flat 2D polygon into a simple 3D model with fixed height and add to GL vertex buffer
Builders.buildExtrudedPolygons = function (polygons, z, height, min_height, vertex_data, vertex_template, normal_index, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;

    // Top
    var min_z = z + (min_height || 0);
    var max_z = z + height;
    vertex_template[2] = max_z;
    Builders.buildPolygons(polygons, vertex_data, vertex_template, { texcoord_index: texcoord_index });

    // Walls
    // Fit UVs to wall quad

    var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

    var _ref22 = _slicedToArray(_ref2, 2);

    var _ref22$0 = _slicedToArray(_ref22[0], 2);

    var min_u = _ref22$0[0];
    var min_v = _ref22$0[1];

    var _ref22$1 = _slicedToArray(_ref22[1], 2);

    var max_u = _ref22$1[0];
    var max_v = _ref22$1[1];

    if (texcoord_index) {
        var texcoords = [[min_u, max_v], [min_u, min_v], [max_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_polygons = polygons.length;
    for (var p = 0; p < num_polygons; p++) {
        var polygon = polygons[p];

        for (var q = 0; q < polygon.length; q++) {
            var contour = polygon[q];

            for (var w = 0; w < contour.length - 1; w++) {
                // Two triangles for the quad formed by each vertex pair, going from bottom to top height
                var wall_vertices = [
                // Triangle
                [contour[w + 1][0], contour[w + 1][1], max_z], [contour[w + 1][0], contour[w + 1][1], min_z], [contour[w][0], contour[w][1], min_z],
                // Triangle
                [contour[w][0], contour[w][1], min_z], [contour[w][0], contour[w][1], max_z], [contour[w + 1][0], contour[w + 1][1], max_z]];

                // Calc the normal of the wall from up vector and one segment of the wall triangles
                var normal = Vector.cross([0, 0, 1], Vector.normalize([contour[w + 1][0] - contour[w][0], contour[w + 1][1] - contour[w][1], 0]));

                // Update vertex template with current surface normal
                vertex_template[normal_index + 0] = normal[0];
                vertex_template[normal_index + 1] = normal[1];
                vertex_template[normal_index + 2] = normal[2];

                for (var wv = 0; wv < wall_vertices.length; wv++) {
                    vertex_template[0] = wall_vertices[wv][0];
                    vertex_template[1] = wall_vertices[wv][1];
                    vertex_template[2] = wall_vertices[wv][2];

                    if (texcoord_index) {
                        vertex_template[texcoord_index + 0] = texcoords[wv][0];
                        vertex_template[texcoord_index + 1] = texcoords[wv][1];
                    }

                    vertex_data.addVertex(vertex_template);
                }
            }
        }
    }
};

// Build tessellated triangles for a polyline
Builders.buildPolylines = function (lines, width, vertex_data, vertex_template, _ref) {
    var closed_polygon = _ref.closed_polygon;
    var remove_tile_edges = _ref.remove_tile_edges;
    var tile_edge_tolerance = _ref.tile_edge_tolerance;
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;
    var scaling_index = _ref.scaling_index;
    var join = _ref.join;
    var cap = _ref.cap;

    var cornersOnCap = cap === "square" ? 2 : cap === "round" ? 4 : 0; // Butt is the implicit default
    var trianglesOnJoin = join === "bevel" ? 1 : join === "round" ? 5 : 0; // Miter is the implicit default

    // Build variables

    var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

    var _ref22 = _slicedToArray(_ref2, 2);

    var _ref22$0 = _slicedToArray(_ref22[0], 2);

    var min_u = _ref22$0[0];
    var min_v = _ref22$0[1];

    var _ref22$1 = _slicedToArray(_ref22[1], 2);

    var max_u = _ref22$1[0];
    var max_v = _ref22$1[1];

    // Values that are constant for each line and are passed to helper functions
    var constants = {
        vertex_data: vertex_data,
        vertex_template: vertex_template,
        halfWidth: width / 2,
        vertices: [],
        scaling_index: scaling_index,
        scalingVecs: scaling_index && [],
        texcoord_index: texcoord_index,
        texcoords: texcoord_index && [],
        min_u: min_u, min_v: min_v, max_u: max_u, max_v: max_v,
        nPairs: 0
    };

    for (var ln = 0; ln < lines.length; ln++) {
        var line = lines[ln];
        var lineSize = line.length;

        // Ignore non-lines
        if (lineSize < 2) {
            continue;
        }

        //  Initialize variables
        var coordPrev = [0, 0],
            // Previous point coordinates
        coordCurr = [0, 0],
            // Current point coordinates
        coordNext = [0, 0]; // Next point coordinates

        var normPrev = [0, 0],
            // Right normal to segment between previous and current m_points
        normCurr = [0, 0],
            // Right normal at current point, scaled for miter joint
        normNext = [0, 0]; // Right normal to segment between current and next m_points

        var isPrev = false,
            isNext = true;

        // Add vertices to buffer acording their index
        indexPairs(constants);

        // Do this with the rest (except the last one)
        for (var i = 0; i < lineSize; i++) {

            // There is a next one?
            isNext = i + 1 < lineSize;

            if (isPrev) {
                // If there is a previus one, copy the current (previous) values on *Prev
                coordPrev = coordCurr;
                normPrev = Vector.normalize(Vector.perp(coordPrev, line[i]));
            } else if (i === 0 && closed_polygon === true) {
                // If is the first point and is a close polygon

                var needToClose = true;
                if (remove_tile_edges) {
                    if (Builders.isOnTileEdge(line[i], line[lineSize - 2], { tile_edge_tolerance: tile_edge_tolerance })) {
                        needToClose = false;
                    }
                }

                if (needToClose) {
                    coordPrev = line[lineSize - 2];
                    normPrev = Vector.normalize(Vector.perp(coordPrev, line[i]));
                    isPrev = true;
                }
            }

            // Assign current coordinate
            coordCurr = line[i];

            if (isNext) {
                coordNext = line[i + 1];
            } else if (closed_polygon === true) {
                // If is the last point a close polygon
                coordNext = line[1];
                isNext = true;
            }

            if (isNext) {
                // If is not the last one get next coordinates and calculate the right normal

                normNext = Vector.normalize(Vector.perp(coordCurr, coordNext));
                if (remove_tile_edges) {
                    if (Builders.isOnTileEdge(coordCurr, coordNext, { tile_edge_tolerance: tile_edge_tolerance })) {
                        normCurr = Vector.normalize(Vector.perp(coordPrev, coordCurr));
                        if (isPrev) {
                            addVertexPair(coordCurr, normCurr, i / lineSize, constants);
                            constants.nPairs++;

                            // Add vertices to buffer acording their index
                            indexPairs(constants);
                        }
                        isPrev = false;
                        continue;
                    }
                }
            }

            //  Compute current normal
            if (isPrev) {
                //  If there is a PREVIUS ...
                if (isNext) {
                    // ... and a NEXT ONE, compute previus and next normals (scaled by the angle with the last prev)
                    normCurr = Vector.normalize(Vector.add(normPrev, normNext));
                    var scale = 2 / (1 + Math.abs(Vector.dot(normPrev, normCurr)));
                    normCurr = Vector.mult(normCurr, scale * scale);
                } else {
                    // ... and there is NOT a NEXT ONE, copy the previus next one (which is the current one)
                    normCurr = Vector.normalize(Vector.perp(coordPrev, coordCurr));
                }
            } else {
                // If is NOT a PREVIUS ...
                if (isNext) {
                    // ... and a NEXT ONE,
                    normNext = Vector.normalize(Vector.perp(coordCurr, coordNext));
                    normCurr = normNext;
                } else {
                    // ... and NOT a NEXT ONE, nothing to do (without prev or next one this is just a point)
                    continue;
                }
            }

            if (isPrev || isNext) {
                // If is the BEGINING of a LINE
                if (i === 0 && !isPrev && !closed_polygon) {
                    addCap(coordCurr, normCurr, cornersOnCap, true, constants);
                }

                // If is a JOIN
                if (trianglesOnJoin !== 0 && isPrev && isNext) {
                    addJoin([coordPrev, coordCurr, coordNext], [normPrev, normCurr, normNext], i / lineSize, trianglesOnJoin, constants);
                } else {
                    addVertexPair(coordCurr, normCurr, i / (lineSize - 1), constants);
                }

                if (isNext) {
                    constants.nPairs++;
                }

                isPrev = true;
            }
        }

        // Add vertices to buffer acording their index
        indexPairs(constants);

        // If is the END OF a LINE
        if (!closed_polygon) {
            addCap(coordCurr, normCurr, cornersOnCap, false, constants);
        }
    }
};

// Add to equidistant pairs of vertices (internal method for polyline builder)
function addVertex(coord, normal, uv, _ref) {
    var halfWidth = _ref.halfWidth;
    var vertices = _ref.vertices;
    var scalingVecs = _ref.scalingVecs;
    var texcoords = _ref.texcoords;

    if (scalingVecs) {
        //  a. If scaling is on add the vertex (the currCoord) and the scaling Vecs (normals pointing where to extrude the vertexes)
        vertices.push(coord);
        scalingVecs.push(normal);
    } else {
        //  b. Add the extruded vertexes
        vertices.push([coord[0] + normal[0] * halfWidth, coord[1] + normal[1] * halfWidth]);
    }

    // c) Add uv's if they are enable
    if (texcoords) {
        texcoords.push(uv);
    }
}

//  Add to equidistant pairs of vertices (internal method for polyline builder)
function addVertexPair(coord, normal, v_pct, constants) {
    addVertex(coord, normal, [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
    addVertex(coord, Vector.neg(normal), [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v], constants);
}

//  Tessalate a FAN geometry between points A       B
//  using their normals from a center        \ . . /
//  and interpolating their UVs               \ p /
//                                             \./
//                                              C
function addFan(coord, nA, nC, nB, uA, uC, uB, signed, numTriangles, constants) {

    if (numTriangles < 1) {
        return;
    }

    // Add previus vertices to buffer and clean the buffers and index pairs
    // Because we are going to add more triangles.
    indexPairs(constants);

    var normCurr = Vector.set(nA);
    var normPrev = [0, 0];

    var angle_delta = Vector.dot(nA, nB);
    if (angle_delta < -1) {
        angle_delta = -1;
    }
    angle_delta = Math.acos(angle_delta) / numTriangles;

    if (!signed) {
        angle_delta *= -1;
    }

    var uvCurr = Vector.set(uA);
    var uv_delta = Vector.div(Vector.sub(uB, uA), numTriangles);

    //  Add the first and CENTER vertex
    //  The triangles will be composed on FAN style arround it
    addVertex(coord, nC, uC, constants);

    //  Add first corner
    addVertex(coord, normCurr, uA, constants);

    // Iterate through the rest of the coorners
    for (var t = 0; t < numTriangles; t++) {
        normPrev = Vector.normalize(normCurr);
        normCurr = Vector.rot(Vector.normalize(normCurr), angle_delta); //  Rotate the extrusion normal

        if (numTriangles === 4 && (t === 0 || t === numTriangles - 2)) {
            var scale = 2 / (1 + Math.abs(Vector.dot(normPrev, normCurr)));
            normCurr = Vector.mult(normCurr, scale * scale);
        }

        uvCurr = Vector.add(uvCurr, uv_delta);

        addVertex(coord, normCurr, uvCurr, constants); //  Add computed corner
    }

    for (var i = 0; i < numTriangles; i++) {
        if (signed) {
            addIndex(i + 2, constants);
            addIndex(0, constants);
            addIndex(i + 1, constants);
        } else {
            addIndex(i + 1, constants);
            addIndex(0, constants);
            addIndex(i + 2, constants);
        }
    }

    // Clean the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

//  Add speccials joins (not miter) tipes that require FAN tessalations
//  Using this ( http://www.codeproject.com/Articles/226569/Drawing-polylines-by-tessellation ) as reference
function addJoin(coords, normals, v_pct, nTriangles, constants) {

    var T = [Vector.set(normals[0]), Vector.set(normals[1]), Vector.set(normals[2])];
    var signed = Vector.signed_area(coords[0], coords[1], coords[2]) > 0;

    var nA = T[0],
        // normal to point A (aT)
    nC = Vector.neg(T[1]),
        // normal to center (-vP)
    nB = T[2]; // normal to point B (bT)

    var uA = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
        uC = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v],
        uB = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];

    if (signed) {
        addVertex(coords[1], nA, uA, constants);
        addVertex(coords[1], nC, uC, constants);
    } else {
        nA = Vector.neg(T[0]);
        nC = T[1];
        nB = Vector.neg(T[2]);
        uA = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        uC = [constants.max_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        uB = [constants.min_u, (1 - v_pct) * constants.min_v + v_pct * constants.max_v];
        addVertex(coords[1], nC, uC, constants);
        addVertex(coords[1], nA, uA, constants);
    }

    addFan(coords[1], nA, nC, nB, uA, uC, uB, signed, nTriangles, constants);

    if (signed) {
        addVertex(coords[1], nB, uB, constants);
        addVertex(coords[1], nC, uC, constants);
    } else {
        addVertex(coords[1], nC, uC, constants);
        addVertex(coords[1], nB, uB, constants);
    }
}

//  Function to add the vertex need for line caps,
//  because re-use the buffers needs to be at the end
function addCap(coord, normal, numCorners, isBeginning, constants) {

    if (numCorners < 1) {
        return;
    }

    // UVs
    var uvA = [constants.min_u, constants.min_v],
        // Begining angle UVs
    uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.min_v],
        // center point UVs
    uvB = [constants.max_u, constants.min_v]; // Ending angle UVs

    if (!isBeginning) {
        uvA = [constants.min_u, constants.max_v], // Begining angle UVs
        uvC = [constants.min_u + (constants.max_u - constants.min_u) / 2, constants.max_v], // center point UVs
        uvB = [constants.max_u, constants.max_v];
    }

    addFan(coord, Vector.neg(normal), [0, 0], normal, uvA, uvC, uvB, isBeginning, numCorners * 2, constants);
}

// Add a vertex based on the index position into the VBO (internal method for polyline builder)
function addIndex(index, _ref) {
    var vertex_data = _ref.vertex_data;
    var vertex_template = _ref.vertex_template;
    var halfWidth = _ref.halfWidth;
    var vertices = _ref.vertices;
    var scaling_index = _ref.scaling_index;
    var scalingVecs = _ref.scalingVecs;
    var texcoord_index = _ref.texcoord_index;
    var texcoords = _ref.texcoords;

    // Prevent access to undefined vertices
    if (index >= vertices.length) {
        return;
    }

    // set vertex position
    vertex_template[0] = vertices[index][0];
    vertex_template[1] = vertices[index][1];

    // set UVs
    if (texcoord_index) {
        vertex_template[texcoord_index + 0] = texcoords[index][0];
        vertex_template[texcoord_index + 1] = texcoords[index][1];
    }

    // set Scaling vertex (X, Y normal direction + Z haltwidth as attribute)
    if (scaling_index) {
        vertex_template[scaling_index + 0] = scalingVecs[index][0];
        vertex_template[scaling_index + 1] = scalingVecs[index][1];
        vertex_template[scaling_index + 2] = halfWidth;
    }

    //  Add vertex to VBO
    vertex_data.addVertex(vertex_template);
}

// Add the index vertex to the VBO and clean the buffers
function indexPairs(constants) {
    // Add vertices to buffer acording their index
    for (var i = 0; i < constants.nPairs; i++) {
        addIndex(2 * i + 2, constants);
        addIndex(2 * i + 1, constants);
        addIndex(2 * i + 0, constants);

        addIndex(2 * i + 2, constants);
        addIndex(2 * i + 3, constants);
        addIndex(2 * i + 1, constants);
    }

    constants.nPairs = 0;

    // Clean the buffer
    constants.vertices = [];
    if (constants.scalingVecs) {
        constants.scalingVecs = [];
    }
    if (constants.texcoords) {
        constants.texcoords = [];
    }
}

// Build a quad centered on a point
Builders.buildQuadsForPoints = function (points, width, height, vertex_data, vertex_template, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;

    if (texcoord_index) {
        var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

        var _ref22 = _slicedToArray(_ref2, 2);

        var _ref22$0 = _slicedToArray(_ref22[0], 2);

        var min_u = _ref22$0[0];
        var min_v = _ref22$0[1];

        var _ref22$1 = _slicedToArray(_ref22[1], 2);

        var max_u = _ref22$1[0];
        var max_v = _ref22$1[1];

        var texcoords = [[min_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_points = points.length;
    for (var p = 0; p < num_points; p++) {
        var point = points[p];

        var positions = [[point[0] - width / 2, point[1] - height / 2], [point[0] + width / 2, point[1] - height / 2], [point[0] + width / 2, point[1] + height / 2], [point[0] - width / 2, point[1] - height / 2], [point[0] + width / 2, point[1] + height / 2], [point[0] - width / 2, point[1] + height / 2]];

        for (var pos = 0; pos < 6; pos++) {
            // Add texcoords
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = texcoords[pos][0];
                vertex_template[texcoord_index + 1] = texcoords[pos][1];
            }

            vertex_template[0] = positions[pos][0];
            vertex_template[1] = positions[pos][1];
            vertex_data.addVertex(vertex_template);
        }
    }
};

// Build a billboard sprite quad centered on a point. Sprites are intended to be drawn in screenspace, and have
// properties for width, height, angle, and a scale factor that can be used to interpolate the screenspace size
// of a sprite between two zoom levels.
Builders.buildSpriteQuadsForPoints = function (points, width, height, angle, scale, vertex_data, vertex_template, scaling_index, _ref) {
    var texcoord_index = _ref.texcoord_index;
    var texcoord_scale = _ref.texcoord_scale;

    var w2 = width / 2;
    var h2 = height / 2;
    var scaling = [[-w2, -h2], [w2, -h2], [w2, h2], [-w2, -h2], [w2, h2], [-w2, h2]];

    var _ref2 = texcoord_scale || [[0, 0], [1, 1]];

    var _ref22 = _slicedToArray(_ref2, 2);

    var _ref22$0 = _slicedToArray(_ref22[0], 2);

    var min_u = _ref22$0[0];
    var min_v = _ref22$0[1];

    var _ref22$1 = _slicedToArray(_ref22[1], 2);

    var max_u = _ref22$1[0];
    var max_v = _ref22$1[1];

    var texcoords = undefined;
    if (texcoord_index) {
        texcoords = [[min_u, min_v], [max_u, min_v], [max_u, max_v], [min_u, min_v], [max_u, max_v], [min_u, max_v]];
    }

    var num_points = points.length;
    for (var p = 0; p < num_points; p++) {
        var point = points[p];

        for (var pos = 0; pos < 6; pos++) {
            // Add texcoords
            if (texcoord_index) {
                vertex_template[texcoord_index + 0] = texcoords[pos][0];
                vertex_template[texcoord_index + 1] = texcoords[pos][1];
            }

            vertex_template[0] = point[0];
            vertex_template[1] = point[1];

            vertex_template[scaling_index + 0] = scaling[pos][0];
            vertex_template[scaling_index + 1] = scaling[pos][1];
            vertex_template[scaling_index + 2] = angle;
            vertex_template[scaling_index + 3] = scale;

            vertex_data.addVertex(vertex_template);
        }
    }
};

/* Utility functions */

// Triangulation using earcut
// https://github.com/mapbox/earcut
Builders.triangulatePolygon = function (contours) {
    return earcut(contours);
};

// Tests if a line segment (from point A to B) is nearly coincident with the edge of a tile
Builders.isOnTileEdge = function (pa, pb, options) {
    options = options || {};

    var tolerance_function = options.tolerance_function || Builders.valuesWithinTolerance;
    var tolerance = options.tolerance || 3; // tweak this adjust if catching too few/many line segments near tile edges
    // TODO: make tolerance configurable by source if necessary
    var tile_min = Builders.tile_bounds[0];
    var tile_max = Builders.tile_bounds[1];
    var edge = null;

    if (tolerance_function(pa[0], tile_min.x, tolerance) && tolerance_function(pb[0], tile_min.x, tolerance)) {
        edge = "left";
    } else if (tolerance_function(pa[0], tile_max.x, tolerance) && tolerance_function(pb[0], tile_max.x, tolerance)) {
        edge = "right";
    } else if (tolerance_function(pa[1], tile_min.y, tolerance) && tolerance_function(pb[1], tile_min.y, tolerance)) {
        edge = "top";
    } else if (tolerance_function(pa[1], tile_max.y, tolerance) && tolerance_function(pb[1], tile_max.y, tolerance)) {
        edge = "bottom";
    }
    return edge;
};

Builders.setTileScale = function (scale) {
    Builders.tile_bounds = [{ x: 0, y: 0 }, { x: scale, y: -scale } // TODO: correct for flipped y-axis?
    ];
};

Builders.valuesWithinTolerance = function (a, b, tolerance) {
    tolerance = tolerance || 1;
    return Math.abs(a - b) < tolerance;
};

// Build a zigzag line pattern for testing joins and caps
Builders.buildZigzagLineTestPattern = function () {
    var min = { x: 0, y: 0 }; //  tile.min;
    var max = { x: 4096, y: 4096 }; // tile.max;

    var g = {
        id: 123,
        geometry: {
            type: "LineString",
            coordinates: [[min.x * 0.75 + max.x * 0.25, min.y * 0.75 + max.y * 0.25], [min.x * 0.75 + max.x * 0.25, min.y * 0.5 + max.y * 0.5], [min.x * 0.25 + max.x * 0.75, min.y * 0.75 + max.y * 0.25], [min.x * 0.25 + max.x * 0.75, min.y * 0.25 + max.y * 0.75], [min.x * 0.4 + max.x * 0.6, min.y * 0.5 + max.y * 0.5], [min.x * 0.5 + max.x * 0.5, min.y * 0.25 + max.y * 0.75], [min.x * 0.75 + max.x * 0.25, min.y * 0.25 + max.y * 0.75], [min.x * 0.75 + max.x * 0.25, min.y * 0.4 + max.y * 0.6]]
        },
        properties: {
            kind: "debug"
        }
    };
    return g;
};

},{"../geo":67,"../vector":103,"earcut":21}],86:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Line rendering style

var Style = require("../style").Style;

var StyleParser = require("../style_parser").StyleParser;

var gl = _interopRequire(require("../../gl/constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexLayout = _interopRequire(require("../../gl/vertex_layout"));

var Builders = _interopRequire(require("../builders"));

var Utils = _interopRequire(require("../../utils/utils"));

var Lines = Object.create(Style);

exports.Lines = Lines;
Object.assign(Lines, {
    name: "lines",
    built_in: true,
    vertex_shader_key: "styles/polygons/polygons_vertex", // re-use polygon shaders
    fragment_shader_key: "styles/polygons/polygons_fragment",
    selection: true,

    init: function init() {
        Style.init.apply(this, arguments);

        // Default world coords to wrap every 100,000 meters, can turn off by setting this to 'false'
        this.defines.TANGRAM_WORLD_POSITION_WRAP = 100000;

        // Basic attributes, others can be added (see texture UVs below)
        var attribs = [{ name: "a_position", size: 3, type: gl.FLOAT, normalized: false }, { name: "a_extrude", size: 3, type: gl.FLOAT, normalized: false }, { name: "a_scale", size: 2, type: gl.SHORT, normalized: true }, { name: "a_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }, { name: "a_selection_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }, { name: "a_layer", size: 1, type: gl.FLOAT, normalized: false }];

        // Tell the shader we want an order attribute, and to extrude lines
        this.defines.TANGRAM_ORDER_ATTRIBUTE = true;
        this.defines.TANGRAM_EXTRUDE_LINES = true;

        // Optional texture UVs
        if (this.texcoords) {
            this.defines.TANGRAM_TEXTURE_COORDS = true;

            // Add vertex attribute for UVs only when needed
            attribs.push({ name: "a_texcoord", size: 2, type: gl.FLOAT, normalized: false });
        }

        this.vertex_layout = new VertexLayout(attribs);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        style.color = rule_style.color && StyleParser.parseColor(rule_style.color, context);
        style.width = rule_style.width && StyleParser.parseDistance(rule_style.width, context);

        // Smoothly interpolate line width between zooms: get scale factors to previous and next zooms
        // Adjust by factor of 2 because tile units are zoom-dependent (a given value is twice as
        // big in world space at the next zoom than at the previous)
        context.zoom--;
        style.prev_width = StyleParser.parseDistance(rule_style.width, context) / 2;
        style.prev_width = Utils.scaleInt16(style.prev_width / style.width, 256);
        context.zoom += 2;
        style.next_width = StyleParser.parseDistance(rule_style.width, context) * 2;
        style.next_width = Utils.scaleInt16(style.next_width / style.width, 256);
        context.zoom--;

        // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
        style.z = rule_style.z && StyleParser.parseDistance(rule_style.z || 0, context) || StyleParser.defaults.z;
        style.height = feature.properties.height || StyleParser.defaults.height;
        style.extrude = rule_style.extrude;
        if (style.extrude) {
            if (typeof style.extrude === "function") {
                style.extrude = style.extrude(context);
            }

            if (typeof style.extrude === "number") {
                style.height = style.extrude;
            } else if (Array.isArray(style.extrude)) {
                style.height = style.extrude[1];
            }
        }

        // Raise line height if extruded
        if (style.extrude && style.height) {
            style.z += style.height;
        }

        style.cap = rule_style.cap;
        style.join = rule_style.join;
        style.tile_edges = rule_style.tile_edges;

        style.outline = style.outline || {};
        if (rule_style.outline) {
            style.outline.color = StyleParser.parseColor(rule_style.outline.color, context);
            style.outline.width = StyleParser.parseDistance(rule_style.outline.width, context);
            style.outline.cap = rule_style.outline.cap || rule_style.cap;
            style.outline.join = rule_style.outline.join || rule_style.join;
        } else {
            style.outline.color = null;
            style.outline.width = null;
        }

        return style;
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        // Placeholder values
        var color = style.color || [0, 0, 0, 1];

        // Basic attributes, others can be added (see texture UVs below)
        var template = [
        // position - x & y coords will be filled in per-vertex below
        0, 0, style.z || 0,
        // extrusion vector
        0, 0, 0,
        // scaling to previous and next zoom
        style.prev_width, style.next_width,
        // color
        // TODO: automate multiplication for normalized attribs?
        color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255,
        // selection color
        style.selection_color[0] * 255, style.selection_color[1] * 255, style.selection_color[2] * 255, style.selection_color[3] * 255,
        // draw order
        style.order];

        // Add texture UVs to template only if needed
        if (this.texcoords) {
            template.push(0, 0);
        }

        return template;
    },

    buildLines: function buildLines(lines, style, vertex_data) {
        var options = arguments[3] === undefined ? {} : arguments[3];

        var vertex_template = this.makeVertexTemplate(style);

        // Main line
        if (style.color && style.width) {
            Builders.buildPolylines(lines, style.width, vertex_data, vertex_template, {
                cap: style.cap,
                join: style.join,
                scaling_index: this.vertex_layout.index.a_extrude,
                texcoord_index: this.vertex_layout.index.a_texcoord,
                texcoord_scale: this.texcoord_scale,
                closed_polygon: options.closed_polygon,
                remove_tile_edges: !style.tile_edges && options.remove_tile_edges
            });
        }

        // Outline
        // TODO: for now, outlines can be drawn with multiple draw groups, but can consider restoring
        // some outline capabilities in the future
        // if (style.outline && style.outline.color && style.outline.width) {
        //     // Replace color in vertex template
        //     var color_index = this.vertex_layout.index.a_color;
        //     vertex_template[color_index + 0] = style.outline.color[0] * 255;
        //     vertex_template[color_index + 1] = style.outline.color[1] * 255;
        //     vertex_template[color_index + 2] = style.outline.color[2] * 255;

        //     // Line outlines sit underneath current layer but above the one below
        //     vertex_template[this.vertex_layout.index.a_layer] -= 0.5;

        //     Builders.buildPolylines(
        //         lines,
        //         style.width + 2 * style.outline.width,
        //         vertex_data,
        //         vertex_template,
        //         {
        //             cap: style.outline.cap,
        //             join: style.outline.join,
        //             scaling_index: this.vertex_layout.index.a_extrude,
        //             texcoord_index: this.vertex_layout.index.a_texcoord,
        //             texcoord_scale: this.texcoord_scale,
        //             closed_polygon: options.closed_polygon,
        //             remove_tile_edges: !style.tile_edges && options.remove_tile_edges
        //         }
        //     );
        // }
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data) {
        // Render polygons as individual lines
        for (var p = 0; p < polygons.length; p++) {
            this.buildLines(polygons[p], style, vertex_data, { closed_polygon: true, remove_tile_edges: true });
        }
    }

});

},{"../../gl/constants":68,"../../gl/vertex_layout":77,"../../utils/utils":101,"../builders":85,"../style":90,"../style_parser":92}],87:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Point rendering style

var Style = require("../style").Style;

var StyleParser = require("../style_parser").StyleParser;

var gl = _interopRequire(require("../../gl/constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexLayout = _interopRequire(require("../../gl/vertex_layout"));

var Builders = _interopRequire(require("../builders"));

var Texture = _interopRequire(require("../../gl/texture"));

var Utils = _interopRequire(require("../../utils/utils"));

var log = _interopRequire(require("loglevel"));

var Points = Object.create(Style);

exports.Points = Points;
Object.assign(Points, {
    name: "points",
    built_in: true,
    selection: true,
    blend: "overlay", // overlays drawn on top of all other styles, with blending

    init: function init() {
        var options = arguments[0] === undefined ? {} : arguments[0];

        Style.init.apply(this, arguments);

        // Base shaders
        this.vertex_shader_key = "styles/points/points_vertex";
        this.fragment_shader_key = "styles/points/points_fragment";

        var attribs = [{ name: "a_position", size: 3, type: gl.FLOAT, normalized: false }, { name: "a_shape", size: 4, type: gl.SHORT, normalized: true }, { name: "a_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }, { name: "a_selection_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }, { name: "a_texcoord", size: 2, type: gl.FLOAT, normalized: false } // TODO: pack into shorts
        ];

        // If we're not rendering as overlay, we need a layer attribute
        if (this.blend !== "overlay") {
            this.defines.TANGRAM_ORDER_ATTRIBUTE = true;
            attribs.push({ name: "a_layer", size: 1, type: gl.FLOAT, normalized: false });
        }

        this.vertex_layout = new VertexLayout(attribs);

        if (this.texture) {
            this.defines.TANGRAM_POINT_TEXTURE = true;
            this.shaders.uniforms = this.shaders.uniforms || {};
            this.shaders.uniforms.u_texture = this.texture;
        }
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        var tile = context.tile.key;

        style.color = rule_style.color && StyleParser.parseColor(rule_style.color, context) || [1, 1, 1, 1];
        style.z = rule_style.z && StyleParser.parseDistance(rule_style.z || 0, context) || StyleParser.defaults.z;

        style.sprite = rule_style.sprite;
        if (typeof style.sprite === "function") {
            style.sprite = style.sprite(context);
        }

        // point style only supports sizes in pixel units, so unit conversion flag is off
        style.size = rule_style.size || [32, 32];
        style.size = StyleParser.parseDistance(style.size, context, false);

        // scale size to 16-bit signed int, with a max allowed width + height of 128 pixels
        style.size = [Math.min(style.size[0] || style.size, 256), Math.min(style.size[1] || style.size, 256)];

        style.size[0] *= Utils.device_pixel_ratio;
        style.size[1] *= Utils.device_pixel_ratio;

        style.angle = rule_style.angle || 0;
        if (typeof style.angle === "function") {
            style.angle = style.angle(context);
        }

        // factor by which point scales from current zoom level to next zoom level
        style.scale = rule_style.scale || 1;

        // to store bbox by tiles
        style.tile = tile;

        // polygons rendering as points will render each individual polygon point by default, but
        // rendering a single point at the polygon's centroid can be enabled
        style.centroid = rule_style.centroid;

        // Sets texcoord scale if needed (e.g. for sprite sub-area)
        if (this.texture && style.sprite) {
            this.texcoord_scale = Texture.getSpriteTexcoords(this.texture, style.sprite);
            if (!this.texcoord_scale) {
                log.warn("Style: in style '" + this.name + "', could not find sprite '" + style.sprite + "' for texture '" + this.texture + "'");
            }
        }

        return style;
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        // Basic attributes, others can be added (see texture UVs below)
        var template = [
        // position - (x, y) coords will be filled in per-vertex below
        0, 0, style.z || 0,
        // scaling vector - (x, y) components per pixel, z = angle, w = scaling factor
        0, 0, 0, 0,
        // color
        // TODO: automate multiplication for normalized attribs?
        style.color[0] * 255, style.color[1] * 255, style.color[2] * 255, style.color[3] * 255,
        // selection color
        style.selection_color[0] * 255, style.selection_color[1] * 255, style.selection_color[2] * 255, style.selection_color[3] * 255,
        // texture coords
        0, 0];

        // Add layer attribute if needed
        if (this.defines.TANGRAM_ORDER_ATTRIBUTE) {
            template.push(style.order);
        }

        return template;
    },

    buildPoints: function buildPoints(points, style, vertex_data) {
        if (!style.size) {
            return;
        }

        var vertex_template = this.makeVertexTemplate(style);

        var size = style.size;
        var angle = style.angle;

        Builders.buildSpriteQuadsForPoints(points, Utils.scaleInt16(size[0], 256), Utils.scaleInt16(size[1], 256), Utils.scaleInt16(Utils.radToDeg(angle), 360), Utils.scaleInt16(style.scale, 256), vertex_data, vertex_template, this.vertex_layout.index.a_shape, { texcoord_index: this.vertex_layout.index.a_texcoord, texcoord_scale: this.texcoord_scale });
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data) {
        // Render polygons as individual points, or centroid
        if (!style.centroid) {
            for (var poly = 0; poly < polygons.length; poly++) {
                var polygon = polygons[poly];
                for (var r = 0; r < polygon.length; r++) {
                    this.buildPoints(polygon[r], style, vertex_data);
                }
            }
        } else {
            var centroid = Utils.multiCentroid(polygons);
            this.buildPoints([centroid], style, vertex_data);
        }
    },

    buildLines: function buildLines(lines, style, vertex_data) {
        // Render lines as individual points
        for (var ln = 0; ln < lines.length; ln++) {
            this.buildPoints(lines[ln], style, vertex_data);
        }
    }

});

},{"../../gl/constants":68,"../../gl/texture":73,"../../gl/vertex_layout":77,"../../utils/utils":101,"../builders":85,"../style":90,"../style_parser":92,"loglevel":54}],88:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Polygon rendering style

var Style = require("../style").Style;

var StyleParser = require("../style_parser").StyleParser;

var gl = _interopRequire(require("../../gl/constants"));

// web workers don't have access to GL context, so import all GL constants

var VertexLayout = _interopRequire(require("../../gl/vertex_layout"));

var Builders = _interopRequire(require("../builders"));

var Polygons = Object.create(Style);

exports.Polygons = Polygons;
Object.assign(Polygons, {
    name: "polygons",
    built_in: true,

    init: function init() {
        Style.init.apply(this, arguments);

        // Base shaders
        this.vertex_shader_key = "styles/polygons/polygons_vertex";
        this.fragment_shader_key = "styles/polygons/polygons_fragment";

        // Default world coords to wrap every 100,000 meters, can turn off by setting this to 'false'
        this.defines.TANGRAM_WORLD_POSITION_WRAP = 100000;

        // Turn feature selection on
        this.selection = true;

        // Basic attributes, others can be added (see texture UVs below)
        var attribs = [{ name: "a_position", size: 3, type: gl.FLOAT, normalized: false }, { name: "a_normal", size: 3, type: gl.FLOAT, normalized: false },
        // { name: 'a_normal', size: 3, type: gl.BYTE, normalized: true }, // attrib isn't a multiple of 4!
        // { name: 'a_color', size: 3, type: gl.FLOAT, normalized: false },
        { name: "a_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true },
        // { name: 'a_selection_color', size: 4, type: gl.FLOAT, normalized: false },
        { name: "a_selection_color", size: 4, type: gl.UNSIGNED_BYTE, normalized: true }, { name: "a_layer", size: 1, type: gl.FLOAT, normalized: false }];

        // Tell the shader we have a normal and order attributes
        this.defines.TANGRAM_NORMAL_ATTRIBUTE = true;
        this.defines.TANGRAM_ORDER_ATTRIBUTE = true;

        // Optional texture UVs
        if (this.texcoords) {
            this.defines.TANGRAM_TEXTURE_COORDS = true;

            // Add vertex attribute for UVs only when needed
            attribs.push({ name: "a_texcoord", size: 2, type: gl.FLOAT, normalized: false });
        }

        this.vertex_layout = new VertexLayout(attribs);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var style = this.feature_style;

        style.color = rule_style.color && StyleParser.parseColor(rule_style.color, context);
        style.width = rule_style.width && StyleParser.parseDistance(rule_style.width, context);
        style.z = rule_style.z && StyleParser.parseDistance(rule_style.z || 0, context) || StyleParser.defaults.z;

        style.size = rule_style.size && StyleParser.parseDistance(rule_style.size, context);

        // height defaults to feature height, but extrude style can dynamically adjust height by returning a number or array (instead of a boolean)
        style.height = feature.properties.height || StyleParser.defaults.height;
        style.min_height = feature.properties.min_height || StyleParser.defaults.min_height;
        style.extrude = rule_style.extrude;
        if (style.extrude) {
            if (typeof style.extrude === "function") {
                style.extrude = style.extrude(context);
            }

            if (typeof style.extrude === "number") {
                style.height = style.extrude;
            } else if (Array.isArray(style.extrude)) {
                style.min_height = style.extrude[0];
                style.height = style.extrude[1];
            }
        }

        style.cap = rule_style.cap;
        style.join = rule_style.join;

        style.outline = style.outline || {};
        if (rule_style.outline) {
            style.outline.color = StyleParser.parseColor(rule_style.outline.color, context);
            style.outline.width = StyleParser.parseDistance(rule_style.outline.width, context);
            style.outline.tile_edges = rule_style.outline.tile_edges;
            style.outline.cap = rule_style.outline.cap || rule_style.cap;
            style.outline.join = rule_style.outline.join || rule_style.join;
        } else {
            style.outline.color = null;
            style.outline.width = null;
            style.outline.tile_edges = false;
        }

        return style;
    },

    /**
     * A "template" that sets constant attibutes for each vertex, which is then modified per vertex or per feature.
     * A plain JS array matching the order of the vertex layout.
     */
    makeVertexTemplate: function makeVertexTemplate(style) {
        // Placeholder values
        var color = style.color || [0, 0, 0, 1];

        // Basic attributes, others can be added (see texture UVs below)
        var template = [
        // position - x & y coords will be filled in per-vertex below
        0, 0, style.z || 0,
        // normal
        0, 0, 1,
        // color
        // TODO: automate multiplication for normalized attribs?
        color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255,
        // selection color
        style.selection_color[0] * 255, style.selection_color[1] * 255, style.selection_color[2] * 255, style.selection_color[3] * 255,
        // draw order
        style.order];

        // Add texture UVs to template only if needed
        if (this.texcoords) {
            template.push(0, 0);
        }

        return template;
    },

    buildPolygons: function buildPolygons(polygons, style, vertex_data) {
        var vertex_template = this.makeVertexTemplate(style);

        // Polygon fill
        if (style.color) {
            // Extruded polygons (e.g. 3D buildings)
            if (style.extrude && style.height) {
                Builders.buildExtrudedPolygons(polygons, style.z, style.height, style.min_height, vertex_data, vertex_template, this.vertex_layout.index.a_normal, { texcoord_index: this.vertex_layout.index.a_texcoord, texcoord_scale: this.texcoord_scale });
            }
            // Regular polygons
            else {
                Builders.buildPolygons(polygons, vertex_data, vertex_template, { texcoord_index: this.vertex_layout.index.a_texcoord, texcoord_scale: this.texcoord_scale });
            }
        }
    }

});

},{"../../gl/constants":68,"../../gl/vertex_layout":77,"../builders":85,"../style":90,"../style_parser":92}],89:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

exports.mergeTrees = mergeTrees;
exports.walkUp = walkUp;
exports.walkDown = walkDown;
exports.groupProps = groupProps;
exports.calculateDraw = calculateDraw;
exports.mergeObjects = mergeObjects;
exports.calculateOrder = calculateOrder;
exports.parseRuleTree = parseRuleTree;
exports.parseRules = parseRules;
exports.matchFeature = matchFeature;
Object.defineProperty(exports, "__esModule", {
    value: true
});

var match = require("match-feature").match;

var log = _interopRequire(require("loglevel"));

var whiteList = ["filter", "draw", "visible", "data", "properties"];

exports.whiteList = whiteList;
var ruleCache = {};

exports.ruleCache = ruleCache;
function cacheKey(rules) {
    return rules.map(function (r) {
        return r.id;
    }).join("/");
}

function mergeTrees(matchingTrees, key, context) {
    var draw = {},
        draws,
        order = [],
        order_draws = [],
        treeDepth = 0,
        i,
        x,
        t;

    // Visible by default
    draw.visible = true;

    // Find deepest tree
    for (t = 0; t < matchingTrees.length; t++) {
        if (matchingTrees[t].length > treeDepth) {
            treeDepth = matchingTrees[t].length;
        }
    }

    // No rules to parse
    if (treeDepth === 0) {
        return null;
    }

    // Iterate trees in parallel
    for (x = 0; x < treeDepth; x++) {
        draws = matchingTrees.map(function (tree) {
            return tree[x] && tree[x][key];
        });
        if (draws.length === 0) {
            continue;
        }

        // Property-specific logic
        for (i = 0; i < draws.length; i++) {
            if (!draws[i]) {
                continue;
            }

            // Collect unique orders (don't add the order multiple times for the smae draw rule)
            if (draws[i].order !== undefined) {
                if (order_draws.indexOf(draws[i]) === -1) {
                    order.push(draws[i].order);
                    order_draws.push(draws[i]);
                }
            }
        }

        // Merge remaining draw objects
        mergeObjects.apply(undefined, [draw].concat(_toConsumableArray(draws)));
    }

    // Short-circuit if not visible
    if (draw.visible === false) {
        return null;
    }

    // Sum all orders
    if (order.length > 0) {
        // Order can be cached if it is all numeric
        if (order.length === 1 && typeof order[0] === "number") {
            order = order[0];
        } else if (order.every(function (v) {
            return typeof v === "number";
        })) {
            order = calculateOrder(order, context); // TODO: use StyleParser.calculateOrder
        }
        draw.order = order;
    }

    return draw;
}

var Rule = (function () {
    function Rule(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, Rule);

        this.id = Rule.id++;
        this.parent = parent;
        this.name = name;
        this.draw = draw;
        this.filter = filter;
        this.visible = visible !== undefined ? visible : this.parent && this.parent.visible;
        this.properties = properties !== undefined ? properties : this.parent && this.parent.properties;

        // Denormalize properties to draw groups
        if (this.draw) {
            for (var group in this.draw) {
                if (this.properties !== undefined) {
                    this.draw[group].properties = this.properties;
                }
            }
        }

        this.buildFilter();
        this.buildDraw();
    }

    _createClass(Rule, {
        buildDraw: {
            value: function buildDraw() {
                this.calculatedDraw = calculateDraw(this);
            }
        },
        buildFilter: {
            value: function buildFilter() {
                var type = typeof this.filter;
                if (type === "object") {
                    this.filter = match(this.filter);
                }
            }
        },
        toJSON: {
            value: function toJSON() {
                return {
                    name: this.name,
                    draw: this.draw
                };
            }
        }
    });

    return Rule;
})();

Rule.id = 0;

var RuleLeaf = exports.RuleLeaf = (function (_Rule) {
    function RuleLeaf(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, RuleLeaf);

        _get(Object.getPrototypeOf(RuleLeaf.prototype), "constructor", this).call(this, { name: name, parent: parent, draw: draw, visible: visible, filter: filter, properties: properties });
    }

    _inherits(RuleLeaf, _Rule);

    return RuleLeaf;
})(Rule);

var RuleTree = exports.RuleTree = (function (_Rule2) {
    function RuleTree(_ref) {
        var name = _ref.name;
        var parent = _ref.parent;
        var draw = _ref.draw;
        var visible = _ref.visible;
        var rules = _ref.rules;
        var filter = _ref.filter;
        var properties = _ref.properties;

        _classCallCheck(this, RuleTree);

        _get(Object.getPrototypeOf(RuleTree.prototype), "constructor", this).call(this, { name: name, parent: parent, draw: draw, visible: visible, filter: filter, properties: properties });
        this.rules = rules || [];
    }

    _inherits(RuleTree, _Rule2);

    _createClass(RuleTree, {
        addRule: {
            value: function addRule(rule) {
                this.rules.push(rule);
            }
        },
        buildDrawGroups: {
            value: function buildDrawGroups(context) {
                var rules = [];
                //TODO, should this function take a RuleTree
                matchFeature(context, [this], rules);

                if (rules.length > 0) {
                    var cache_key = cacheKey(rules);

                    // Only evaluate each rule combination once (undefined means not yet evaluated,
                    // null means evaluated with no draw object)
                    if (ruleCache[cache_key] === undefined) {
                        // Visible?
                        if (rules.some(function (x) {
                            return x.visible === false;
                        })) {
                            ruleCache[cache_key] = null;
                        } else {
                            // Find all the unique draw blocks for this rule tree
                            var draw_rules = rules.map(function (x) {
                                return x && x.calculatedDraw;
                            });
                            var draw_keys = {};

                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = draw_rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var rule = _step.value;

                                    if (!rule) {
                                        continue;
                                    }
                                    var _iteratorNormalCompletion2 = true;
                                    var _didIteratorError2 = false;
                                    var _iteratorError2 = undefined;

                                    try {
                                        for (var _iterator2 = rule[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                            var group = _step2.value;

                                            for (var key in group) {
                                                draw_keys[key] = true;
                                            }
                                        }
                                    } catch (err) {
                                        _didIteratorError2 = true;
                                        _iteratorError2 = err;
                                    } finally {
                                        try {
                                            if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                                _iterator2["return"]();
                                            }
                                        } finally {
                                            if (_didIteratorError2) {
                                                throw _iteratorError2;
                                            }
                                        }
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                                        _iterator["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }

                            // Calculate each draw group
                            for (var draw_key in draw_keys) {
                                ruleCache[cache_key] = ruleCache[cache_key] || {};
                                ruleCache[cache_key][draw_key] = mergeTrees(draw_rules, draw_key, context);

                                // Only save the ones that weren't null
                                if (!ruleCache[cache_key][draw_key]) {
                                    delete ruleCache[cache_key][draw_key];
                                }
                            }

                            // No rules evaluated
                            if (ruleCache[cache_key] && Object.keys(ruleCache[cache_key]).length === 0) {
                                ruleCache[cache_key] = null;
                            }
                        }
                    }
                    return ruleCache[cache_key];
                }
            }
        }
    });

    return RuleTree;
})(Rule);

function isWhiteListed(key) {
    return whiteList.indexOf(key) > -1;
}

function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}

function walkUp(rule, cb) {

    if (rule.parent) {
        walkUp(rule.parent, cb);
    }

    cb(rule);
}

function walkDown(rule, cb) {

    if (rule.rules) {
        rule.rules.forEach(function (r) {
            walkDown(r, cb);
        });
    }

    cb(rule);
}

function groupProps(obj) {
    var whiteListed = {},
        nonWhiteListed = {};

    for (var key in obj) {
        if (isWhiteListed(key)) {
            whiteListed[key] = obj[key];
        } else {
            nonWhiteListed[key] = obj[key];
        }
    }
    return [whiteListed, nonWhiteListed];
}

function calculateDraw(rule) {

    var draw = [];

    if (rule.parent) {
        var cs = rule.parent.calculatedDraw || [];
        draw.push.apply(draw, _toConsumableArray(cs));
    }

    draw.push(rule.draw);
    return draw;
}

function mergeObjects(newObj) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {

        for (var _iterator = sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var source = _step.value;

            if (!source) {
                continue;
            }
            for (var key in source) {
                var value = source[key];
                if (typeof value === "object" && !Array.isArray(value)) {
                    newObj[key] = mergeObjects(newObj[key] || {}, value);
                } else {
                    newObj[key] = value;
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return newObj;
}

function calculateOrder(orders) {
    var context = arguments[1] === undefined ? null : arguments[1];
    var defaultOrder = arguments[2] === undefined ? 0 : arguments[2];

    var sum = defaultOrder;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = orders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var order = _step.value;

            if (typeof order === "function") {
                order = order(context);
            } else {
                order = parseFloat(order);
            }

            if (!order || isNaN(order)) {
                continue;
            }
            sum += order;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return sum;
}

function parseRuleTree(name, rule, parent) {

    var properties = { name: name, parent: parent };

    var _groupProps = groupProps(rule);

    var _groupProps2 = _slicedToArray(_groupProps, 2);

    var whiteListed = _groupProps2[0];
    var nonWhiteListed = _groupProps2[1];

    var empty = isEmpty(nonWhiteListed);
    var Create = undefined;

    if (empty && parent != null) {
        Create = RuleLeaf;
    } else {
        Create = RuleTree;
    }

    var r = new Create(Object.assign(properties, whiteListed));

    if (parent) {
        parent.addRule(r);
    }

    if (!empty) {
        for (var key in nonWhiteListed) {
            var property = nonWhiteListed[key];
            if (typeof property === "object") {
                parseRuleTree(key, property, r);
            } else {
                log.warn("Rule property must be an object: ", name, rule, property);
            }
        }
    }

    return r;
}

function parseRules(rules) {
    var ruleTrees = {};

    for (var key in rules) {
        var rule = rules[key];
        ruleTrees[key] = parseRuleTree(key, rule);
    }

    return ruleTrees;
}

function doesMatch(filter, context) {
    return typeof filter === "function" && filter(context) || filter == null;
}

function matchFeature(context, rules, collectedRules) {
    var matched = false;
    var childMatched = false;

    if (rules.length === 0) {
        return;
    }

    for (var r = 0; r < rules.length; r++) {
        var current = rules[r];
        context.properties = current.properties;

        if (current instanceof RuleLeaf) {

            if (doesMatch(current.filter, context)) {
                matched = true;
                collectedRules.push(current);
            }
        } else if (current instanceof RuleTree) {
            if (doesMatch(current.filter, context)) {
                matched = true;

                childMatched = matchFeature(context, current.rules, collectedRules);

                if (!childMatched) {
                    collectedRules.push(current);
                }
            }
        }

        context.properties = null;
    }

    return matched;
}

},{"loglevel":54,"match-feature":55}],90:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Rendering styles

var StyleParser = require("./style_parser").StyleParser;

var FeatureSelection = _interopRequire(require("../selection"));

var ShaderProgram = _interopRequire(require("../gl/shader_program"));

var VBOMesh = _interopRequire(require("../gl/vbo_mesh"));

var Material = _interopRequire(require("../material"));

var Light = _interopRequire(require("../light"));

var MethodNotImplemented = require("../utils/errors").MethodNotImplemented;

var shaderSources = _interopRequire(require("../gl/shader_sources"));

// built-in shaders

var log = _interopRequire(require("loglevel"));

// Base class

var Style = {
    init: function init() {
        if (!this.isBuiltIn()) {
            this.built_in = false; // explicitly set to false to avoid any confusion
        }

        this.defines = this.hasOwnProperty("defines") && this.defines || {}; // #defines to be injected into the shaders
        this.shaders = this.hasOwnProperty("shaders") && this.shaders || {}; // shader customization (uniforms, defines, blocks, etc.)
        this.selection = this.selection || false; // flag indicating if this style supports feature selection
        this.compiling = false; // programs are currently compiling
        this.compiled = false; // programs are finished compiling
        this.program = null; // GL program reference (for main render pass)
        this.selection_program = null; // GL program reference for feature selection render pass
        this.feature_style = {}; // style for feature currently being parsed, shared to lessen GC/memory thrash

        // Blending
        this.blend = this.blend || "opaque"; // default: opaque styles are drawn first, without blending
        this.defines["TANGRAM_BLEND_" + this.blend.toUpperCase()] = true;

        // If the style defines its own material, replace the inherited material instance
        if (!(this.material instanceof Material)) {
            if (!Material.isValid(this.material)) {
                this.material = StyleParser.defaults.material;
            }
            this.material = new Material(this.material);
        }
        this.material.inject(this);

        // Set lighting mode: fragment, vertex, or none (specified as 'false')
        Light.setMode(this.lighting, this);

        this.initialized = true;
    },

    destroy: function destroy() {
        if (this.program) {
            this.program.destroy();
            this.program = null;
        }

        if (this.selection_program) {
            this.selection_program.destroy();
            this.selection_program = null;
        }

        this.gl = null;
        this.initialized = false;
    },

    isBuiltIn: function isBuiltIn() {
        return this.hasOwnProperty("built_in") && this.built_in;
    },

    /*** Style parsing and geometry construction ***/

    // Returns an object to hold feature data (for a tile or other object)
    startData: function startData() {
        return {
            vertex_data: null,
            uniforms: null
        };
    },

    // Finalizes an object holding feature data (for a tile or other object)
    endData: function endData(tile_data) {
        if (tile_data.vertex_data) {
            // Only keep final byte buffer
            tile_data.vertex_data.end();
            tile_data.vertex_data = tile_data.vertex_data.buffer;
        }
        return Promise.resolve(tile_data);
    },

    addFeature: function addFeature(feature, rule, context, tile_data) {
        var style = this.parseFeature(feature, rule, context);

        // Skip feature?
        if (!style) {
            return;
        }

        // First feature in this render style?
        if (!tile_data.vertex_data) {
            tile_data.vertex_data = this.vertex_layout.createVertexData();
        }

        this.buildGeometry(feature.geometry, style, tile_data.vertex_data);
    },

    buildGeometry: function buildGeometry(geometry, style, vertex_data) {
        if (geometry.type === "Polygon") {
            this.buildPolygons([geometry.coordinates], style, vertex_data);
        } else if (geometry.type === "MultiPolygon") {
            this.buildPolygons(geometry.coordinates, style, vertex_data);
        } else if (geometry.type === "LineString") {
            this.buildLines([geometry.coordinates], style, vertex_data);
        } else if (geometry.type === "MultiLineString") {
            this.buildLines(geometry.coordinates, style, vertex_data);
        } else if (geometry.type === "Point") {
            this.buildPoints([geometry.coordinates], style, vertex_data);
        } else if (geometry.type === "MultiPoint") {
            this.buildPoints(geometry.coordinates, style, vertex_data);
        }
    },

    parseFeature: function parseFeature(feature, rule_style, context) {
        try {
            var style = this.feature_style;

            // Calculate order if it was not cached
            style.order = rule_style.order;
            if (typeof style.order !== "number") {
                style.order = StyleParser.calculateOrder(style.order, context);
            }

            // Feature selection (only if style supports it)
            var selectable = false;
            style.interactive = rule_style.interactive;
            if (this.selection) {
                if (typeof style.interactive === "function") {
                    selectable = style.interactive(context);
                } else {
                    selectable = style.interactive;
                }
            }

            // If feature is marked as selectable
            if (selectable) {
                style.selection_color = FeatureSelection.makeColor(feature, context.tile);
            } else {
                style.selection_color = FeatureSelection.defaultColor;
            }

            // Subclass implementation
            style = this._parseFeature(feature, rule_style, context);

            return style;
        } catch (error) {
            log.error("Style.parseFeature: style parsing error", feature, style, error);
        }
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        throw new MethodNotImplemented("_parseFeature");
    },

    // Build functions are no-ops until overriden
    buildPolygons: function buildPolygons() {},
    buildLines: function buildLines() {},
    buildPoints: function buildPoints() {},

    /*** GL state and rendering ***/

    setGL: function setGL(gl) {
        this.gl = gl;
    },

    makeMesh: function makeMesh(vertex_data) {
        var _ref = arguments[1] === undefined ? {} : arguments[1];

        var uniforms = _ref.uniforms;

        return new VBOMesh(this.gl, vertex_data, this.vertex_layout, { uniforms: uniforms });
    },

    compile: function compile() {
        if (!this.gl) {
            throw new Error("style.compile(): skipping for " + this.name + " because no GL context");
        }

        if (this.compiling) {
            throw new Error("style.compile(): skipping for " + this.name + " because style is already compiling");
        }
        this.compiling = true;
        this.compiled = false;

        // Build defines & for selection (need to create a new object since the first is stored as a reference by the program)
        var defines = this.buildDefineList();
        if (this.selection) {
            var selection_defines = Object.assign({}, defines);
            selection_defines.TANGRAM_FEATURE_SELECTION = true;
        }

        // Get any custom code blocks, uniform dependencies, etc.
        var blocks = this.shaders && this.shaders.blocks;
        var uniforms = this.shaders && this.shaders.uniforms;

        // Create shaders
        try {
            this.program = new ShaderProgram(this.gl, shaderSources[this.vertex_shader_key], shaderSources[this.fragment_shader_key], {
                name: this.name,
                defines: defines,
                uniforms: uniforms,
                blocks: blocks
            });
            this.program.compile();

            if (this.selection) {
                this.selection_program = new ShaderProgram(this.gl, shaderSources[this.vertex_shader_key], shaderSources["gl/shaders/selection_fragment"], {
                    name: this.name + " (selection)",
                    defines: selection_defines,
                    uniforms: uniforms,
                    blocks: blocks
                });
                this.selection_program.compile();
            } else {
                this.selection_program = null;
            }
        } catch (error) {
            this.compiling = false;
            this.compiled = false;
            throw new Error("style.compile(): style " + this.name + " error:", error);
        }

        this.compiling = false;
        this.compiled = true;
    },

    // Add a shader block
    addShaderBlock: function addShaderBlock(key) {
        var _shaders$blocks$key;

        for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            blocks[_key - 1] = arguments[_key];
        }

        this.shaders.blocks = this.shaders.blocks || {};
        this.shaders.blocks[key] = this.shaders.blocks[key] || [];
        (_shaders$blocks$key = this.shaders.blocks[key]).push.apply(_shaders$blocks$key, blocks);
    },

    // Remove all shader blocks for key
    removeShaderBlock: function removeShaderBlock(key) {
        if (this.shaders.blocks) {
            this.shaders.blocks[key] = null;
        }
    },

    replaceShaderBlock: function replaceShaderBlock(key) {
        var _ref;

        for (var _len = arguments.length, blocks = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            blocks[_key - 1] = arguments[_key];
        }

        this.removeShaderBlock(key);
        (_ref = this).addShaderBlock.apply(_ref, [key].concat(blocks));
    },

    /** TODO: could probably combine and generalize this with similar method in ShaderProgram
     * (list of define objects that inherit from each other)
     */
    buildDefineList: function buildDefineList() {
        // Add any custom defines to built-in style defines
        var defines = {}; // create a new object to avoid mutating a prototype value that may be shared with other styles
        if (this.defines != null) {
            for (var d in this.defines) {
                defines[d] = this.defines[d];
            }
        }
        if (this.shaders != null && this.shaders.defines != null) {
            for (d in this.shaders.defines) {
                defines[d] = this.shaders.defines[d];
            }
        }
        return defines;
    },

    // Setup any GL state for rendering
    setup: function setup() {
        this.setUniforms();
        this.material.setupProgram(ShaderProgram.current);
    },

    // Set style uniforms on currently bound program
    setUniforms: function setUniforms() {
        var program = ShaderProgram.current;
        if (!program) {
            return;
        }

        program.setUniforms(this.shaders && this.shaders.uniforms, true); // reset texture unit to 0
    },

    update: function update() {}
};
exports.Style = Style;

// Style-specific animation
// if (typeof this.animation === 'function') {
//     this.animation();
// }

},{"../gl/shader_program":71,"../gl/shader_sources":72,"../gl/vbo_mesh":75,"../light":79,"../material":80,"../selection":84,"../utils/errors":99,"./style_parser":92,"loglevel":54}],91:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Manage rendering styles

var Utils = _interopRequire(require("../utils/utils"));

var ShaderProgram = _interopRequire(require("../gl/shader_program"));

var shaderSources = _interopRequire(require("../gl/shader_sources"));

// built-in shaders

var Style = require("./style").Style;

var Polygons = require("./polygons/polygons").Polygons;

var Lines = require("./lines/lines").Lines;

var Points = require("./points/points").Points;

var TextStyle = require("./text/text").TextStyle;

var log = _interopRequire(require("loglevel"));

var StyleManager = {};
exports.StyleManager = StyleManager;
var Styles = {};
exports.Styles = Styles;
var BaseStyles = {};

exports.BaseStyles = BaseStyles;
// Set the base object used to instantiate styles
StyleManager.baseStyle = Style;

// Global configuration for all styles
StyleManager.init = function () {
    if (StyleManager.initialized) {
        return;
    }

    ShaderProgram.removeBlock("global");

    // Layer re-ordering function
    ShaderProgram.addBlock("global", shaderSources["gl/shaders/layer_order"]);

    // Feature selection global
    ShaderProgram.addBlock("global", shaderSources["gl/shaders/selection_globals"]);

    // Feature selection vertex shader support
    ShaderProgram.replaceBlock("feature-selection-vertex", shaderSources["gl/shaders/selection_vertex"]);

    // assume min 16-bit depth buffer, in practice uses 14-bits, 1 extra bit to handle virtual half-layers
    // for outlines (inserted in between layers), another extra bit to prevent precision loss
    ShaderProgram.defines.TANGRAM_LAYER_DELTA = 1 / (1 << 14);

    StyleManager.initialized = true;
};

// Destroy all styles for a given GL context
StyleManager.destroy = function (gl) {
    Object.keys(Styles).forEach(function (_name) {
        var style = Styles[_name];
        if (style.gl === gl) {
            log.trace("StyleManager.destroy: destroying render style " + style.name);

            if (!style.isBuiltIn()) {
                StyleManager.remove(style.name);
            }
            style.destroy();
        }
    });
};

// Register a style
StyleManager.register = function (style) {
    Styles[style.name] = style;
    BaseStyles[style.name] = style;
};

// Remove a style
StyleManager.remove = function (name) {
    delete Styles[name];
};

// Preloads network resources in the stylesheet (shaders, textures, etc.)
StyleManager.preload = function (styles) {
    // First load remote styles, then load shader blocks from remote URLs
    return StyleManager.loadRemoteStyles(styles).then(StyleManager.loadShaderBlocks);
};

// Load style definitions from external URLs
StyleManager.loadRemoteStyles = function (styles) {
    var _this = this;

    // Collect URLs and modes to import from them
    // This is done as a separate step becuase it is possible to import multiple modes from a single
    // URL, and we want to avoid duplicate calls for the same file.
    var urls = {};
    for (var name in styles) {
        var style = styles[name];
        if (style.url) {
            if (!urls[style.url]) {
                urls[style.url] = [];
            }

            // Make a list of the styles to import for this URL
            urls[style.url].push({
                target_name: name,
                source_name: style.name || name
            });
        }
    }

    // As each URL finishes loading, replace the target style(s)
    return Promise.all(Object.keys(urls).map(function (url) {
        return new Promise(function (resolve, reject) {
            Utils.loadResource(url).then(function (data) {
                // Mixin remote styles, within each remote file
                for (var source_style in data) {
                    StyleManager.mix(data[source_style], data);
                }

                // Add remote styles to local styles
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = urls[url][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var target = _step.value;

                        if (data && data[target.source_name]) {
                            styles[target.target_name] = data[target.source_name];
                        } else {
                            delete styles[target.target_name];
                            return reject(new Error("StyleManager.preload: error importing style " + target.target_name + ", could not find source style " + target.source_name + " in " + url));
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                resolve();

                _this.selection = false;
            })["catch"](function (error) {
                log.error("StyleManager.preload: error importing style(s) " + JSON.stringify(urls[url]) + " from " + url, error);
            });
        });
    })).then(function () {
        return Promise.resolve(styles);
    });
};

// Preload shader blocks from external URLs
StyleManager.loadShaderBlocks = function (styles) {
    var queue = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = Utils.values(styles)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var style = _step.value;

            if (style.shaders && style.shaders.blocks) {
                var _iteratorNormalCompletion2;

                var _didIteratorError2;

                var _iteratorError2;

                var _iterator2, _step2;

                var _step2$value;

                (function () {
                    var _blocks = style.shaders.blocks;

                    _iteratorNormalCompletion2 = true;
                    _didIteratorError2 = false;
                    _iteratorError2 = undefined;

                    try {
                        for (_iterator2 = Utils.entries(style.shaders.blocks)[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            (function () {
                                _step2$value = _slicedToArray(_step2.value, 2);
                                var key = _step2$value[0];
                                var block = _step2$value[1];

                                var _key = key;

                                // Array of blocks
                                if (Array.isArray(block)) {
                                    for (var b = 0; b < block.length; b++) {
                                        if (typeof block[b] === "object" && block[b].url) {
                                            (function () {
                                                var _index = b;
                                                queue.push(Utils.io(Utils.cacheBusterForUrl(block[b].url)).then(function (data) {
                                                    _blocks[_key][_index] = data;
                                                })["catch"](function (error) {
                                                    log.error("StyleManager.loadShaderBlocks: error loading shader block", _blocks, _key, _index, error);
                                                }));
                                            })();
                                        }
                                    }
                                }
                                // Single block
                                else if (typeof block === "object" && block.url) {
                                    queue.push(Utils.io(Utils.cacheBusterForUrl(block.url)).then(function (data) {
                                        _blocks[_key] = data;
                                    })["catch"](function (error) {
                                        log.error("StyleManager.loadShaderBlocks: error loading shader block", _blocks, _key, error);
                                    }));
                                }
                            })();
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                _iterator2["return"]();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                })();
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return Promise.all(queue).then(function () {
        return Promise.resolve(styles);
    }); // TODO: add error
};

StyleManager.mix = function (style, styles) {
    // Exit early if we have already applied mixins to this style
    if (style.mixed) {
        return style;
    }

    // Mixin sources, in order
    var sources = [];
    if (style.mix) {
        if (Array.isArray(style.mix)) {
            sources.push.apply(sources, _toConsumableArray(style.mix));
        } else {
            sources.push(style.mix);
        }
        sources = sources.map(function (x) {
            return styles[x];
        }).filter(function (x) {
            return x;
        });
    }
    sources.push(style);

    // Flags - OR'd, true if any style has it set
    style.animated = sources.some(function (x) {
        return x && x.animated;
    });
    style.texcoords = sources.some(function (x) {
        return x && x.texcoords;
    });

    // Overwrites - last definition wins
    style.base = sources.map(function (x) {
        return x.base;
    }).filter(function (x) {
        return x;
    }).pop();
    style.texture = sources.map(function (x) {
        return x.texture;
    }).filter(function (x) {
        return x;
    }).pop();

    // Merges - property-specific rules for merging values
    style.defines = Object.assign.apply(Object, [{}].concat(_toConsumableArray(sources.map(function (x) {
        return x.defines;
    }).filter(function (x) {
        return x;
    }))));
    style.material = Object.assign.apply(Object, [{}].concat(_toConsumableArray(sources.map(function (x) {
        return x.material;
    }).filter(function (x) {
        return x;
    }))));

    var merge = sources.map(function (x) {
        return x.shaders;
    }).filter(function (x) {
        return x;
    });
    var shaders = {};
    shaders.defines = Object.assign.apply(Object, [{}].concat(_toConsumableArray(merge.map(function (x) {
        return x.defines;
    }).filter(function (x) {
        return x;
    }))));
    shaders.uniforms = Object.assign.apply(Object, [{}].concat(_toConsumableArray(merge.map(function (x) {
        return x.uniforms;
    }).filter(function (x) {
        return x;
    }))));

    merge.map(function (x) {
        return x.blocks;
    }).filter(function (x) {
        return x;
    }).forEach(function (blocks) {
        shaders.blocks = shaders.blocks || {};

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Utils.entries(blocks)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _slicedToArray(_step.value, 2);

                var t = _step$value[0];
                var block = _step$value[1];

                shaders.blocks[t] = shaders.blocks[t] || [];

                if (Array.isArray(block)) {
                    var _shaders$blocks$t;

                    (_shaders$blocks$t = shaders.blocks[t]).push.apply(_shaders$blocks$t, _toConsumableArray(block));
                } else {
                    shaders.blocks[t].push(block);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    });

    style.shaders = shaders;
    style.mixed = true; // track that we already applied mixins (avoid dupe work later)

    return style;
};

// Create a new style
// name: name of new style
// config: properties of new style
// styles: working set of styles being built (used for mixing in existing styles)
StyleManager.create = function (name, config) {
    var styles = arguments[2] === undefined ? {} : arguments[2];

    var style = Object.assign({}, config); // shallow copy
    style.name = name;

    // Style mixins
    StyleManager.mix(style, styles);

    // Has base style?
    // Only renderable (instantiated) styles should be included for run-time use
    // Others are intermediary/abstract, used during style composition but not execution
    if (style.base && BaseStyles[style.base]) {
        Styles[name] = style = Object.assign(Object.create(BaseStyles[style.base]), style);
    }

    return style;
};

// Called to create and initialize styles
StyleManager.build = function (styles) {
    var scene = arguments[1] === undefined ? {} : arguments[1];

    // Sort styles by dependency, then build them
    var style_deps = Object.keys(styles).sort(function (a, b) {
        return StyleManager.inheritanceDepth(a, styles) - StyleManager.inheritanceDepth(b, styles);
    });

    // Only keep built-in base styles
    for (var sname in Styles) {
        if (!BaseStyles[sname]) {
            delete Styles[sname];
        }
    }

    // Working set of styles being built
    var ws = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = style_deps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var sname = _step.value;

            ws[sname] = StyleManager.create(sname, styles[sname], ws);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    StyleManager.initStyles();
    return Styles;
};

// Initialize all styles
StyleManager.initStyles = function () {
    // Initialize all
    for (var sname in Styles) {
        Styles[sname].init();
    }
};

// Given a style key in a set of styles to add, count the length of the inheritance chain
// TODO: remove current (Styles) and future (styles) duplication, confusing
StyleManager.inheritanceDepth = function (key, styles) {
    var parents = 0;

    while (true) {
        var style = styles[key];
        if (!style) {
            // this is a scene def error, trying to extend a style that doesn't exist
            // TODO: warn/throw?
            break;
        }

        // Dependency chain ends when this style isn't mixing in any others
        if (!style.mix) {
            break;
        }

        // Traverse next parent style
        parents++;

        if (Array.isArray(style.mix)) {
            // If multiple mixins, find the deepest one
            parents += Math.max.apply(Math, _toConsumableArray(style.mix.map(function (s) {
                return StyleManager.inheritanceDepth(s, styles);
            })));
            break;
        } else {
            // If single mixin, continue loop up the tree
            key = style.mix;
        }
    }
    return parents;
};

// Compile all styles
StyleManager.compile = function (keys) {
    keys = keys || Object.keys(Styles);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            try {
                Styles[key].compile();
                log.trace("StyleManager.compile(): compiled style " + key);
            } catch (error) {
                log.error("StyleManager.compile(): error compiling style " + key + ":", error);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    log.debug("StyleManager.compile(): compiled all styles");
};

// Add built-in rendering styles
StyleManager.register(Polygons);
StyleManager.register(Lines);
StyleManager.register(Points);
StyleManager.register(TextStyle);

},{"../gl/shader_program":71,"../gl/shader_sources":72,"../utils/utils":101,"./lines/lines":86,"./points/points":87,"./polygons/polygons":88,"./style":90,"./text/text":97,"loglevel":54}],92:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var Utils = _interopRequire(require("../utils/utils"));

var Geo = _interopRequire(require("../geo"));

var parseCSSColor = _interopRequire(require("csscolorparser"));

var log = _interopRequire(require("loglevel"));

var StyleParser = {};

exports.StyleParser = StyleParser;
// Style macros

StyleParser.expandMacros = function expandMacros(obj) {
    for (var p in obj) {
        var val = obj[p];

        // Loop through object properties
        if (typeof val === "object") {
            obj[p] = expandMacros(val);
        }
        // Convert strings back into functions
        else if (typeof val === "string") {
            for (var m in StyleParser.macros) {
                if (val.match(StyleParser.macros[m])) {
                    var f;
                    try {
                        /*jshint ignore:start */
                        eval("f = " + val);
                        /*jshint ignore:end */
                        obj[p] = f;
                        log.trace("expanded macro " + val + " to " + f);
                        break;
                    } catch (e) {
                        // fall-back to original value if parsing failed
                        obj[p] = val;
                        log.trace("failed to expand macro " + val);
                    }
                }
            }
        }
    }

    return obj;
};

// List of macros
StyleParser.macros = ["Style.color.pseudoRandomColor", "Style.color.randomColor", "Style.pixels"];

var Style = {};

Style.color = {
    // pseudo-random grayscale by geometry id
    pseudoRandomGrayscale: function pseudoRandomGrayscale() {
        var func = "function() {\n            var c = Math.max((parseInt(feature.osm_id, 16) % 100) / 100, 0.4);\n            return [0.7 * c, 0.7 * c, 0.7 * c];\n        }";
        return func;
    },

    // pseudo-random color by geometry id
    pseudoRandomColor: function pseudoRandomColor() {
        var func = "function() {\n            return [\n                0.7 * (parseInt(feature.osm_id, 16) / 100 % 1),\n                0.7 * (parseInt(feature.osm_id, 16) / 10000 % 1),\n                0.7 * (parseInt(feature.osm_id, 16) / 1000000 % 1)\n            ];\n        }";
        return func;
        // return `function() { return [0.7 * (parseInt(feature.osm_id, 16) / 100 % 1), 0.7 * (parseInt(feature.osm_id, 16) / 10000 % 1), 0.7 * (parseInt(feature.osm_id, 16) / 1000000 % 1)]; }`;
    },

    // random color
    randomColor: function randomColor() {
        var func = "function() {\n            return [0.7 * Math.random(), 0.7 * Math.random(), 0.7 * Math.random()];\n        }";
        return func;
    }
};

// Returns a function (that can be used as a dynamic style) that converts pixels to meters for the current zoom level.
// The provided pixel value ('p') can itself be a function, in which case it is wrapped by this one.
Style.pixels = function (p) {
    var f;
    f = "function() { return " + (typeof p === "function" ? "(" + (p.toString() + "())") : p) + " * $meters_per_pixel; }";
    return f;
};

// Wraps style functions and provides a scope of commonly accessible data:
// - feature: the 'properties' of the feature, e.g. accessed as 'feature.name'
// - $zoom: the current map zoom level
// - $geometry: the type of geometry, 'point', 'line', or 'polygon'
// - $meters_per_pixel: conversion for meters/pixels at current map zoom
// - properties: user-defined properties on the style-rule object in the stylesheet
StyleParser.wrapFunction = function (func) {
    var f = "function(context) {\n                var feature = context.feature.properties;\n                var $zoom = context.zoom;\n                var $geometry = context.geometry;\n                var $meters_per_pixel = context.meters_per_pixel;\n                var properties = context.properties;\n\n                // TODO: remove once tile feature ids are normalized\n                feature.osm_id = feature.osm_id || feature.uid || context.feature.id;\n\n                return (" + func + "());\n            }";
    return f;
};

// Style parsing

// Style defaults
StyleParser.defaults = {
    color: [1, 0, 0],
    width: 1,
    size: 1,
    extrude: false,
    height: 20,
    min_height: 0,
    order: 0,
    z: 0,
    material: {
        ambient: 1,
        diffuse: 1
    }
};

// A context object that is passed to style parsing functions to provide a scope of commonly used values
StyleParser.getFeatureParseContext = function (feature, tile) {
    return {
        feature: feature,
        tile: tile,
        zoom: tile.coords.z,
        geometry: Geo.geometryType(feature.geometry.type),
        meters_per_pixel: Geo.metersPerPixel(tile.coords.z),
        units_per_meter: Geo.units_per_meter[tile.coords.z]
    };
};

StyleParser.convertUnits = function (val, context) {
    var convert = arguments[2] === undefined ? true : arguments[2];

    if (typeof val === "string") {
        var units = val.match(/([0-9.-]+)([a-z]+)/);
        if (units && units.length === 3) {
            val = parseFloat(units[1]);
            units = units[2];
        }

        if (convert) {
            // Convert from pixels
            if (units === "px") {
                val *= Geo.metersPerPixel(context.zoom);
            }
            // Convert from kilometers
            else if (units === "km") {
                val *= 1000;
            }
        }
    } else if (Array.isArray(val)) {
        // Array of arrays, e.g. zoom-interpolated stops
        if (val.every(function (v) {
            return Array.isArray(v);
        })) {
            return val.map(function (v) {
                return [v[0], StyleParser.convertUnits(v[1], context, convert)];
            });
        }
        // Array of values
        else {
            return val.map(function (v) {
                return StyleParser.convertUnits(v, context, convert);
            });
        }
    }
    return val;
};

StyleParser.parseDistance = function (val, context) {
    var convert = arguments[2] === undefined ? true : arguments[2];

    if (typeof val === "function") {
        val = val(context);
    }
    val = StyleParser.convertUnits(val, context, convert);
    val = Utils.interpolate(context.zoom, val);

    if (convert) {
        if (typeof val === "number") {
            val *= context.units_per_meter;
        } else if (Array.isArray(val)) {
            val.forEach(function (v, i) {
                return val[i] *= context.units_per_meter;
            });
        }
    }
    return val;
};

StyleParser.parseColor = function (val) {
    var context = arguments[1] === undefined ? {} : arguments[1];

    if (typeof val === "function") {
        val = val(context);
    }

    // Parse CSS-style colors
    // TODO: change all colors to use 0-255 range internally to avoid dividing and then re-multiplying in geom builder
    if (typeof val === "string") {
        val = parseCSSColor.parseCSSColor(val);
        if (val && val.length === 4) {
            val = val.slice(0, 3).map(function (c) {
                return c / 255;
            });
        } else {
            val = null;
        }
    } else if (Array.isArray(val) && val.every(function (v) {
        return Array.isArray(v);
    })) {
        // Array of zoom-interpolated stops, e.g. [zoom, color] pairs
        val = val.map(function (v) {
            if (typeof v[1] === "string") {
                var vc = parseCSSColor.parseCSSColor(v[1]);
                if (vc && vc.length === 4) {
                    vc = vc.slice(0, 3).map(function (c) {
                        return c / 255;
                    });
                }
                return [v[0], vc];
            }
            return v;
        });
    }

    if (context.zoom) {
        val = Utils.interpolate(context.zoom, val);
    }

    // Defaults
    if (val) {
        // alpha
        if (!val[3]) {
            val[3] = 1;
        }
    } else {
        val = [0, 0, 0, 1];
    }

    return val;
};

// Order is summed from top to bottom in the style hierarchy:
// each child order value is added to the parent order value
StyleParser.calculateOrder = function (order, context) {
    if (typeof order === "function") {
        order = order(context);
    } else if (Array.isArray(order)) {
        order = order.reduce(function (sum, order) {
            order = order || StyleParser.defaults.order;
            if (typeof order === "function") {
                order = order(context);
            } else if (typeof order === "string") {
                order = context.feature.properties[order];
            } else {
                order = parseFloat(order);
            }

            if (!order || isNaN(order)) {
                return sum;
            }
            return sum + order;
        }, 0);
    } else if (typeof order === "string") {
        order = context.feature.properties[order];
    } else {
        order = parseFloat(order);
    }

    return order;
};

},{"../geo":67,"../utils/utils":101,"csscolorparser":20,"loglevel":54}],93:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Label */

var boxIntersect = _interopRequire(require("box-intersect"));

var Utils = _interopRequire(require("../../utils/utils"));

var Geo = _interopRequire(require("../../geo"));

var Label = (function () {
    function Label(text, size, _ref) {
        var move_in_tile = _ref.move_in_tile;
        var keep_in_tile = _ref.keep_in_tile;

        _classCallCheck(this, Label);

        Object.assign(this, {
            text: text,
            size: size,
            position: [],
            bbox: [],
            move_in_tile: move_in_tile,
            keep_in_tile: keep_in_tile
        });

        this.id = Label.id++;

        this.buffer = this.buffer || 2; // TODO: make configurable
        this.buffer *= Geo.units_per_pixel;
    }

    _createClass(Label, {
        isComposite: {
            value: function isComposite() {
                return false;
            }
        },
        occluded: {
            value: function occluded(bboxes) {
                var intersect = false;

                if (bboxes.length > 0) {
                    boxIntersect([this.bbox], bboxes, function (i, j) {
                        intersect = true;
                        return true;
                    });
                }

                if (!intersect) {
                    bboxes.push(this.bbox);
                }

                return intersect;
            }
        },
        inTileBounds: {
            value: function inTileBounds() {
                var min = [this.bbox[0], this.bbox[1]];
                var max = [this.bbox[2], this.bbox[3]];

                if (!Utils.pointInTile(min) || !Utils.pointInTile(max)) {
                    return false;
                }

                return true;
            }
        },
        discard: {
            value: function discard(bboxes) {
                var discard = false;

                // perform specific styling rule, should we keep the label in tile bounds?
                if (this.keep_in_tile) {
                    var in_tile = this.inTileBounds();

                    if (!in_tile && this.move_in_tile) {
                        // can we move?
                        discard = this.moveInTile();
                    } else if (!in_tile) {
                        // we didn't want to move at all,
                        // just discard since we're out of tile bounds
                        return true;
                    }
                }

                // should we discard? if not, just make occlusion test
                return discard || this.occluded(bboxes);
            }
        }
    });

    return Label;
})();

module.exports = Label;

Label.id = 0;

},{"../../geo":67,"../../utils/utils":101,"box-intersect":5}],94:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var LabelPoint = _interopRequire(require("./label_point"));

var LabelLine = _interopRequire(require("./label_line"));

var Utils = _interopRequire(require("../../utils/utils"));

var LabelBuilder;
module.exports = LabelBuilder = {};

LabelBuilder.labelsFromGeometry = function (geometry, _ref, label_style) {
    var text = _ref.text;
    var size = _ref.size;

    var labels = [];

    if (geometry.type === "LineString") {
        var lines = geometry.coordinates;

        labels.push(new LabelLine(text, size, lines, label_style.lines, { move_in_tile: true, keep_in_tile: true }));
    } else if (geometry.type === "MultiLineString") {
        var lines = geometry.coordinates;

        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];

            labels.push(new LabelLine(text, size, line, label_style.lines, { move_in_tile: true, keep_in_tile: true }));
        }
    } else if (geometry.type === "Point") {
        var width = label_style.points.max_width;

        if (width && size.text_size[0] > width) {
            var line_height = size.px_logical_size / 100 * label_style.points.line_height;
            line_height = Utils.pixelToMercator(line_height);
            var label = LabelPoint.explode(text, geometry.coordinates, size, width, line_height, { move_in_tile: true, keep_in_tile: true });

            labels.push(label);
        } else {
            labels.push(new LabelPoint(text, geometry.coordinates, size, null, { move_in_tile: true, keep_in_tile: true }));
        }
    } else if (geometry.type === "MultiPoint") {
        var points = geometry.coordinates;

        for (var i = 0; i < points.length; ++i) {
            var point = points[i];
            labels.push(new LabelPoint(text, point, size, null, { move_in_tile: true, keep_in_tile: true }));
        }
    } else if (geometry.type === "Polygon") {
        var centroid = Utils.centroid(geometry.coordinates[0]);
        var area = Utils.polygonArea(geometry.coordinates[0]);

        labels.push(new LabelPoint(text, centroid, size, area, { move_in_tile: true, keep_in_tile: true }));
    } else if (geometry.type === "MultiPolygon") {
        var centroid = Utils.multiCentroid(geometry.coordinates);
        var area = Utils.multiPolygonArea(geometry.coordinates);

        labels.push(new LabelPoint(text, centroid, size, area, { move_in_tile: true, keep_in_tile: true }));
    }

    return labels;
};

},{"../../utils/utils":101,"./label_line":95,"./label_point":96}],95:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Vector = _interopRequire(require("../../vector"));

var Geo = _interopRequire(require("../../geo"));

var Label = _interopRequire(require("./label"));

var Utils = _interopRequire(require("../../utils/utils"));

var LabelLine = (function (_Label) {
    function LabelLine(text, size, lines, style, _ref) {
        var move_in_tile = _ref.move_in_tile;
        var keep_in_tile = _ref.keep_in_tile;

        _classCallCheck(this, LabelLine);

        _get(Object.getPrototypeOf(LabelLine.prototype), "constructor", this).call(this, text, size, { move_in_tile: move_in_tile, keep_in_tile: keep_in_tile });

        this.segment_index = 0;
        this.lines = lines;
        this.exceed_heuristic = style.exceed;
        this.offset = style.offset;
        this.update();
    }

    _inherits(LabelLine, _Label);

    _createClass(LabelLine, {
        middleSegment: {
            value: function middleSegment(segment) {
                return [(segment[0][0] + segment[1][0]) / 2, (segment[0][1] + segment[1][1]) / 2];
            }
        },
        update: {
            value: function update() {
                var segment = this.currentSegment();

                this.angle = this.computeAngle();

                var perp = Vector.normalize(Vector.perp(segment[0], segment[1]));
                var dot = Vector.dot(perp, [0, 1]);
                var offset = Vector.mult(perp, Utils.pixelToMercator(this.offset * Math.sign(dot)));

                this.position = Vector.add(this.middleSegment(segment), offset);
                this.bbox = this.computeBBox();
            }
        },
        moveNextSegment: {
            value: function moveNextSegment() {
                if (this.segment_index + 1 >= this.lines.length - 1) {
                    return false;
                }

                this.segment_index++;
                this.update();

                return true;
            }
        },
        computeAngle: {
            value: function computeAngle() {
                var segment = this.currentSegment();
                var p0p1 = Vector.sub(segment[0], segment[1]);

                p0p1 = Vector.normalize(p0p1);

                var PI_2 = Math.PI / 2;
                var theta = Math.atan2(p0p1[0], p0p1[1]) + PI_2;

                if (theta > PI_2 || theta < -PI_2) {
                    theta += Math.PI;
                }
                theta %= Math.PI * 2;

                return theta;
            }
        },
        fitToSegment: {
            value: function fitToSegment() {
                var should_fit = arguments[0] === undefined ? true : arguments[0];

                if (!should_fit) {
                    return true;
                }

                var segment = this.currentSegment();
                var p0p1 = Vector.sub(segment[0], segment[1]);
                var length = Vector.length(p0p1);

                var label_length = Utils.pixelToMercator(this.size.text_size[0]);

                if (label_length > length) {
                    // an exceed heurestic of 100% would let the label fit in any cases
                    var exceed = (1 - length / label_length) * 100;
                    return exceed < this.exceed_heuristic;
                }

                return label_length < length;
            }
        },
        currentSegment: {
            value: function currentSegment() {
                var p1 = this.lines[this.segment_index];
                var p2 = this.lines[this.segment_index + 1];

                return [p1, p2];
            }
        },
        computeBBox: {
            value: function computeBBox(size) {
                var upp = Geo.units_per_pixel;

                var merc_width = this.size.text_size[0] * upp;
                var merc_height = this.size.text_size[1] * upp;

                var c = Math.cos(this.angle);
                var s = Math.sin(this.angle);

                var x = merc_width * c - merc_height * s;
                var y = merc_width * s + merc_height * c;

                var max = Math.max(Math.abs(x), Math.abs(y)) * 0.5 + this.buffer;

                var bbox = [this.position[0] - max, this.position[1] - max, this.position[0] + max, this.position[1] + max];

                return bbox;
            }
        },
        moveInTile: {
            value: function moveInTile() {
                var in_tile = false;
                var fits_to_segment = this.fitToSegment();

                // move this label until we found a line we can fit in
                while (!in_tile && !fits_to_segment) {
                    if (!this.moveNextSegment()) {
                        // we can't move further in this line
                        break;
                    }

                    in_tile = this.inTileBounds();
                    fits_to_segment = this.fitToSegment();
                }

                return !in_tile || !fits_to_segment;
            }
        },
        discard: {
            value: function discard(bboxes) {
                if (this.lines && !this.fitToSegment()) {
                    while (!this.fitToSegment()) {
                        if (!this.moveNextSegment()) {
                            return true;
                        }
                    }
                }

                return _get(Object.getPrototypeOf(LabelLine.prototype), "discard", this).call(this, bboxes);
            }
        }
    });

    return LabelLine;
})(Label);

module.exports = LabelLine;

},{"../../geo":67,"../../utils/utils":101,"../../vector":103,"./label":93}],96:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var Label = _interopRequire(require("./label"));

var Utils = _interopRequire(require("../../utils/utils"));

var Geo = _interopRequire(require("../../geo"));

var LabelPoint = (function (_Label) {
    function LabelPoint(text, position, size, area, _ref) {
        var move_in_tile = _ref.move_in_tile;
        var keep_in_tile = _ref.keep_in_tile;

        _classCallCheck(this, LabelPoint);

        _get(Object.getPrototypeOf(LabelPoint.prototype), "constructor", this).call(this, text, size, { move_in_tile: move_in_tile, keep_in_tile: keep_in_tile });

        this.area = area;
        this.position = position;
        this.bbox = this.computeBBox();
    }

    _inherits(LabelPoint, _Label);

    _createClass(LabelPoint, {
        computeBBox: {
            value: function computeBBox() {
                var half_merc_width = Utils.pixelToMercator(this.size.text_size[0]) * 0.5 + this.buffer;
                var half_merc_height = Utils.pixelToMercator(this.size.text_size[1]) * 0.5 + this.buffer;

                var bbox = [this.position[0] - half_merc_width, this.position[1] - half_merc_height, this.position[0] + half_merc_width, this.position[1] + half_merc_height];

                return bbox;
            }
        },
        moveInTile: {
            value: function moveInTile(in_tile) {
                var width = this.bbox[2] - this.bbox[0];
                var height = -this.bbox[3] - -this.bbox[1];

                // Move point labels to tile edges (only if mostly in this tile)
                if (this.position[0] - width / 2 < 0 && this.position[0] > 0) {
                    this.position[0] = width / 2 + 1;
                } else if (this.position[0] + width / 2 > Geo.tile_scale && this.position[0] < Geo.tile_scale) {
                    this.position[0] = Geo.tile_scale - (width / 2 + 1);
                }

                this.position[1] *= -1; // just doing this so Y coord is positive
                if (this.position[1] - height / 2 < 0 && this.position[1] > 0) {
                    this.position[1] = height / 2 + 1;
                } else if (this.position[1] + height / 2 > Geo.tile_scale && this.position[1] < Geo.tile_scale) {
                    this.position[1] = Geo.tile_scale - (height / 2 + 1);
                }
                this.position[1] *= -1;

                this.bbox = this.computeBBox();
                return !this.inTileBounds();
            }
        }
    }, {
        explode: {
            value: function explode(text, position, size, max_width, padding, move_in_tile, keep_in_tile) {
                var split_text = text.split(" ");

                if (split_text.length < 2) {
                    return new LabelPoint(text, position, size, null, move_in_tile, keep_in_tile);
                }

                var line = new TextLine(text, size.text_size[0], split_text, size.split_size);
                var lines = line.explode(max_width);
                var labels = [];

                if (lines.length === 1) {
                    return new LabelPoint(text, position, size, null, move_in_tile, keep_in_tile);
                }

                for (var i in lines) {
                    var l = lines[i];
                    var pos = [position[0], position[1] - Math.abs(padding) * i];
                    labels.push(new LabelPoint(l.text, pos, size, null, move_in_tile, keep_in_tile));
                }

                return new LabelComposite(text, position, size, labels, move_in_tile, keep_in_tile);
            }
        }
    });

    return LabelPoint;
})(Label);

module.exports = LabelPoint;

var LabelComposite = (function (_Label2) {
    function LabelComposite(text, position, size, labels, move_in_tile, keep_in_tile) {
        _classCallCheck(this, LabelComposite);

        _get(Object.getPrototypeOf(LabelComposite.prototype), "constructor", this).call(this, text, size, move_in_tile, keep_in_tile);

        this.position = position;
        this.labels = labels;
        this.bbox = this.computeBBox();
    }

    _inherits(LabelComposite, _Label2);

    _createClass(LabelComposite, {
        isComposite: {
            value: function isComposite() {
                return true;
            }
        },
        moveInTile: {
            value: function moveInTile(in_tile) {
                return false;
            }
        },
        computeBBox: {
            value: function computeBBox() {
                var bbox = [Infinity, Infinity, -Infinity, -Infinity];

                for (var i in this.labels) {
                    var b = this.labels[i].bbox;

                    bbox[0] = Math.min(b[0], bbox[0]);
                    bbox[1] = Math.min(b[1], bbox[1]);
                    bbox[2] = Math.max(b[2], bbox[2]);
                    bbox[3] = Math.max(b[3], bbox[3]);
                }

                return bbox;
            }
        }
    });

    return LabelComposite;
})(Label);

var TextLine = (function () {
    function TextLine(text, line_length, words, size_info) {
        _classCallCheck(this, TextLine);

        this.text = text;
        this.line_length = line_length;
        this.size_info = size_info;
        this.words = this.positions(words);
    }

    _createClass(TextLine, {
        positions: {
            value: function positions(words, size_info) {
                var word_infos = [];
                var offset = 0;
                var space_offset = this.size_info[" "];

                for (var i = 0; i < words.length; ++i) {
                    var word = words[i];
                    var word_length = this.size_info[word];

                    word_infos.push({
                        word: word,
                        start: offset,
                        end: offset + word_length
                    });
                    offset += word_length;

                    if (i !== words.length - 1) {
                        word_infos.push({
                            word: " ",
                            start: offset,
                            end: offset + space_offset
                        });
                        offset += space_offset;
                    }
                }

                return word_infos;
            }
        },
        explode: {
            value: function explode(max_width) {
                var exploded_lines = arguments[1] === undefined ? [] : arguments[1];

                if (max_width > this.line_length) {
                    exploded_lines.push(this);
                    return exploded_lines;
                }

                var index = this.wordInfoIndex(max_width);

                if (this.words[index].word === " ") {
                    index -= 1;
                }

                if (index < 1) {
                    exploded_lines.push(this);
                    return exploded_lines;
                }

                if (index < this.words.length) {
                    var next_line_length = 0,
                        previous_line_length = 0;
                    var next_line_words = "",
                        previous_line_words = "";

                    for (var i = index; i < this.words.length; ++i) {
                        next_line_words += this.words[i].word;
                        next_line_length += this.size_info[this.words[i].word];
                    }

                    for (var i = 0; i < index; i++) {
                        if (i !== index - 1 && this.words[i] !== " ") {
                            previous_line_words += this.words[i].word;
                            previous_line_length += this.size_info[this.words[i].word];
                        }
                    }

                    exploded_lines.push(new TextLine(previous_line_words, previous_line_length, previous_line_words.split(" "), this.size_info));

                    var next_line = new TextLine(next_line_words, next_line_length, next_line_words.split(" "), this.size_info);

                    return next_line.explode(max_width, exploded_lines);
                }

                exploded_lines.push(this);
                return exploded_lines;
            }
        },
        wordInfoIndex: {
            value: function wordInfoIndex(position) {
                if (position > this.line_length) {
                    return this.words.length - 1;
                } else if (position < 0) {
                    return 0;
                }

                var d = this.words.length / 2;
                var i = Math.ceil(d);
                i = Math.min(Math.max(0, i), this.words.length - 1);
                var word_info = this.words[i];

                // dichotomic search
                while (word_info.start > position || word_info.end < position) {
                    d /= 2;
                    i += word_info.end < position ? Math.ceil(d) : -Math.ceil(d);
                    i = Math.min(Math.max(0, i), this.words.length - 1);
                    word_info = this.words[i];
                }

                return i;
            }
        }
    });

    return TextLine;
})();

},{"../../geo":67,"../../utils/utils":101,"./label":93}],97:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});
// Text rendering style

var Builders = _interopRequire(require("../builders"));

var StyleParser = require("../style_parser").StyleParser;

var Texture = _interopRequire(require("../../gl/texture"));

var WorkerBroker = _interopRequire(require("../../utils/worker_broker"));

var Utils = _interopRequire(require("../../utils/utils"));

var Points = require("../points/points").Points;

var LabelBuilder = _interopRequire(require("./label_builder"));

var log = _interopRequire(require("loglevel"));

var TextStyle = Object.create(Points);

exports.TextStyle = TextStyle;
Object.assign(TextStyle, {
    name: "text",
    "super": Points,
    built_in: true,
    selection: false,

    init: function init() {

        this["super"].init.apply(this, arguments);

        // Provide a hook for this object to be called from worker threads
        if (Utils.isMainThread) {
            WorkerBroker.addTarget("TextStyle", this);
        }

        this.texts = {}; // unique texts, keyed by tile
        this.textures = {};
        this.canvas = {};
        this.bboxes = {};
        this.features = {};

        this.max_priority = 0;

        // Point style (parent class) requires texturing to be turned on
        // (labels are always drawn with textures)
        this.defines.TANGRAM_POINT_TEXTURE = true;

        // default font style
        this.font_style = {
            typeface: "Helvetica 12px",
            fill: "white",
            capitalized: false
        };

        // default label style
        this.label_style = {
            priorities: {
                administrative: 4,
                major_road: 3,
                minor_road: 2,
                restaurant: 1 },
            lines: {
                exceed: 80,
                offset: 0
            },
            points: {
                max_width: 100,
                line_height: 100 // percentage
            }
        };

        this.clear();
    },

    clear: function clear() {
        this["super"].init.apply(this, arguments);
        this.texts = {}; // unique texts, keyed by tile
        this.texture = {};
        this.canvas = {};
        this.bboxes = {};
        this.features = {};
        this.feature_labels = new Map();
        this.feature_style_key = new Map();
    },

    // Set font style params for canvas drawing
    setFont: function setFont(tile, _ref) {
        var font = _ref.font;
        var fill = _ref.fill;
        var stroke = _ref.stroke;
        var stroke_width = _ref.stroke_width;
        var px_size = _ref.px_size;
        var px_logical_size = _ref.px_logical_size;

        this.px_size = parseInt(px_size);
        this.px_logical_size = parseInt(px_logical_size);
        this.text_buffer = 6; // pixel padding around text
        var ctx = this.canvas[tile].context;

        ctx.font = font;
        if (stroke) {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = stroke_width;
        } else {
            ctx.strokeStyle = null;
            ctx.lineWidth = 0;
        }
        ctx.fillStyle = fill;
        ctx.miterLimit = 2;
    },

    // Width and height of text based on current font style
    textSize: function textSize(text, tile, capitalized) {
        var str = capitalized ? text.toUpperCase() : text;
        var ctx = this.canvas[tile].context;
        var split = str.split(" ");
        var px_size = this.px_size;
        var px_logical_size = this.px_logical_size;
        var buffer = this.text_buffer * Utils.device_pixel_ratio;
        var split_size = {
            " ": this.canvas[tile].context.measureText(" ").width / Utils.device_pixel_ratio
        };

        for (var i in split) {
            var word = split[i];
            split_size[word] = ctx.measureText(word).width / Utils.device_pixel_ratio;
        }

        var str_width = ctx.measureText(str).width;
        var text_size = [str_width / Utils.device_pixel_ratio, this.px_size / Utils.device_pixel_ratio];

        var texture_text_size = [Math.ceil(str_width) + buffer * 2, this.px_size + buffer * 2];

        return { split_size: split_size, text_size: text_size, texture_text_size: texture_text_size, px_size: px_size, px_logical_size: px_logical_size };
    },

    // Draw text at specified location, adjusting for buffer and baseline
    drawText: function drawText(text, _ref, tile, stroke, capitalized) {
        var _ref2 = _slicedToArray(_ref, 2);

        var x = _ref2[0];
        var y = _ref2[1];

        var str = capitalized ? text.toUpperCase() : text;
        var buffer = this.text_buffer * Utils.device_pixel_ratio;
        if (stroke) {
            this.canvas[tile].context.strokeText(str, x + buffer, y + buffer + this.px_size);
        }
        this.canvas[tile].context.fillText(str, x + buffer, y + buffer + this.px_size);
    },

    setTextureTextPositions: function setTextureTextPositions(texts) {
        // Find widest label and sum of all label heights
        var widest = 0,
            height = 0;

        for (var style in texts) {
            var text_infos = texts[style];

            for (var text in text_infos) {
                var text_info = text_infos[text];
                var size = text_info.size.texture_text_size;

                text_info.position = [0, height];

                if (size[0] > widest) {
                    widest = size[0];
                }

                height += size[1];
            }
        }

        return [widest, height];
    },

    getTextSizes: function getTextSizes(tile, texts) {
        // create a canvas
        if (!this.canvas[tile]) {
            var canvas = document.createElement("canvas");
            this.canvas[tile] = {
                canvas: canvas,
                context: canvas.getContext("2d")
            };
        }

        for (var style in texts) {
            var text_infos = texts[style];

            for (var text in text_infos) {
                var text_style = text_infos[text].text_style;
                // update text sizes
                this.setFont(tile, text_style);
                text_infos[text].size = this.textSize(text, tile, text_style.capitalized);
            }
        }

        return Promise.resolve(texts);
    },

    // Called on main thread to release tile-specific resources
    freeTile: function freeTile(tile) {
        delete this.canvas[tile];
        delete this.textures[tile];
    },

    rasterize: function rasterize(tile, texts, texture_size) {
        var pixel_scale = Utils.device_pixel_ratio;

        for (var style in texts) {
            var text_infos = texts[style];

            for (var text in text_infos) {
                var info = text_infos[text];

                this.setFont(tile, info.text_style);
                this.drawText(text, info.position, tile, info.text_style.stroke, info.text_style.capitalized);

                info.texcoords = Builders.getTexcoordsForSprite(info.position, info.size.texture_text_size, texture_size);

                if (!info.sub_texts) {
                    continue;
                }

                var width = this.text_buffer;
                var dists = [];
                var space_size = info.size.split_size[" "];

                for (var i = 0; i < info.sub_texts.length; ++i) {
                    var sub_text = info.sub_texts[i];
                    var split = sub_text.split(" ");

                    dists[i] = width * pixel_scale;

                    for (var j = 0; j < split.length; ++j) {
                        var word = split[j];
                        width += info.size.split_size[word];

                        if (j !== split.length - 1) {
                            width += space_size;
                        }
                    }

                    if (i !== info.sub_texts.length - 1) {
                        width += space_size / 2;
                    }
                }

                // sub-texts uv mapping
                for (var i = 0; i < info.sub_texts.length; ++i) {
                    var sub_text = info.sub_texts[i];

                    if (!info.subtexcoords) {
                        info.subtexcoords = {};
                    }

                    var offset = 0;

                    if (i < info.sub_texts.length - 1) {
                        offset = info.size.texture_text_size[0] - dists[i + 1];
                    }

                    var position = [info.position[0] + dists[i], info.position[1]];

                    var size = [info.size.texture_text_size[0] - offset - dists[i], info.size.texture_text_size[1]];

                    if (!info.subtext_size) {
                        info.subtext_size = {};
                    }
                    info.subtext_size[sub_text] = size;

                    info.subtexcoords[sub_text] = Builders.getTexcoordsForSprite(position, size, texture_size);
                }
            }
        }
    },

    // Called on main thread from worker, to create atlas of labels for a tile
    addTexts: function addTexts(tile, texts) {
        this.texts[tile] = texts;

        var texture_size = this.setTextureTextPositions(texts);
        var context = this.canvas[tile].context;

        log.trace("text summary for tile " + tile + ": fits in " + texture_size[0] + "x" + texture_size[1] + "px");

        // update the canvas "context"
        this.canvas[tile].canvas.width = texture_size[0];
        this.canvas[tile].canvas.height = texture_size[1];
        context.clearRect(0, 0, texture_size[0], texture_size[1]);

        // create a texture
        var texture = "labels-" + tile + "-" + TextStyle.texture_id++;
        this.textures[tile] = new Texture(this.gl, texture, { filtering: "linear" });
        // this.textures[tile].owner = { tile };

        // ask for rasterization for the text set
        this.rasterize(tile, texts, texture_size);

        this.textures[tile].setCanvas(this.canvas[tile].canvas);
        delete this.textures[tile];
        delete this.canvas[tile]; // we don't need canvas once it has been copied to GPU texture

        return Promise.resolve({ texts: this.texts[tile], texture: texture });
    },

    // Override
    startData: function startData() {
        var tile_data = this["super"].startData.apply(this);
        tile_data.queue = [];
        return tile_data;
    },

    subTextInfos: function subTextInfos(label_composite, text_info) {
        if (!text_info.sub_texts) {
            text_info.sub_texts = [];
        }

        for (var i in label_composite.labels) {
            var label = label_composite.labels[i];
            text_info.sub_texts.push(label.text);
        }
    },

    createLabels: function createLabels(tile, texts) {
        var labels_priorities = [];

        for (var style in texts) {
            var text_infos = texts[style];

            for (var text in text_infos) {
                var text_info = text_infos[text];
                text_info.ref = 0;

                for (var f = 0; f < this.features[tile][style][text].length; f++) {
                    var feature = this.features[tile][style][text][f];
                    var labels = LabelBuilder.labelsFromGeometry(feature.geometry, { text: text, size: text_info.size }, this.label_style);

                    for (var i = 0; i < labels.length; ++i) {
                        var label = labels[i];
                        var area = label.area;

                        labels_priorities[text_info.priority] = labels_priorities[text_info.priority] || [];
                        labels_priorities[text_info.priority].push({ style: style, feature: feature, label: label, area: area });

                        if (label.isComposite()) {
                            this.subTextInfos(label, text_info);
                        }
                    }
                }
            }
        }

        // sort by area size if defined
        for (var p = 0; p < labels_priorities.length; ++p) {
            if (!labels_priorities[p]) {
                continue;
            }

            labels_priorities[p].sort(function (e1, e2) {
                if (e1.area && e2.area) {
                    return e1.area < e2.area;
                } else {
                    return false;
                }
            });
        }

        return labels_priorities;
    },

    discardLabels: function discardLabels(tile, labels, texts) {
        this.bboxes[tile] = [];

        for (var priority = this.max_priority; priority >= 0; priority--) {
            if (!labels[priority]) {
                continue;
            }

            for (var i = 0; i < labels[priority].length; i++) {
                var _labels$priority$i = labels[priority][i];
                var style = _labels$priority$i.style;
                var feature = _labels$priority$i.feature;
                var label = _labels$priority$i.label;

                if (!label.discard(this.bboxes[tile])) {
                    if (!this.feature_labels.has(feature)) {
                        this.feature_labels.set(feature, []);
                    }
                    this.feature_labels.get(feature).push(label);
                    texts[style][label.text].ref++;
                }
            }
        }

        for (var style in texts) {
            for (var text in texts[style]) {
                if (texts[style][text].ref < 1) {
                    delete texts[style][text];
                }
            }
        }

        for (var style in texts) {
            var text_infos = texts[style];
            // No labels for this style
            if (Object.keys(text_infos).length === 0) {
                delete texts[style];
            }
        }
    },

    // Override
    endData: function endData(tile_data) {
        var _this25 = this;

        // Count collected text
        var tile = undefined,
            count = undefined;
        if (tile_data.queue.length > 0) {
            tile = tile_data.queue[0][2].tile.key;
            count = Object.keys(this.texts[tile] || {}).length;
            log.trace("# texts for tile " + tile + ": " + count);
        }
        if (!count) {
            return Promise.resolve();
        }

        // first call to main thread, ask for text pixel sizes
        return WorkerBroker.postMessage("TextStyle", "getTextSizes", tile, this.texts[tile]).then(function (texts) {
            var labels = _this25.createLabels(tile, texts);

            _this25.discardLabels(tile, labels, texts);

            // No labels for this tile
            if (Object.keys(texts).length === 0) {
                WorkerBroker.postMessage("TextStyle", "freeTile", tile);
                // early exit
                return;
            }

            // second call to main thread, for rasterizing the set of texts
            return WorkerBroker.postMessage("TextStyle", "addTexts", tile, texts).then(function (_ref) {
                var texts = _ref.texts;
                var texture = _ref.texture;

                _this25.texts[tile] = texts;

                // Attach tile-specific label atlas to mesh as a texture uniform
                tile_data.uniforms = { u_texture: texture };
                tile_data.textures = [texture]; // assign texture ownership to tile - TODO: implement in VBOMesh

                // Build queued features
                tile_data.queue.forEach(function (q) {
                    return _this25["super"].addFeature.apply(_this25, q);
                });
                tile_data.queue = [];
                delete _this25.texts[tile];

                return _this25["super"].endData.call(_this25, tile_data);
            });
        });
    },

    // Override to queue features instead of processing immediately
    addFeature: function addFeature(feature, rule, context, tile_data) {
        // Collect text
        var text = undefined;
        var source = rule.text_source || "name";

        if (typeof source === "string") {
            text = feature.properties[source];
        } else if (typeof source === "function") {
            text = source(context);
        }

        if (text) {
            feature.text = text;

            var tile = context.tile.key;
            if (!this.texts[tile]) {
                this.texts[tile] = {};
            }

            var style = this.constructFontStyle(rule, context);
            if (!style) {
                return;
            }

            var style_key = this.constructStyleKey(style);
            this.feature_style_key.set(feature, style_key);

            if (!this.texts[tile][style_key]) {
                this.texts[tile][style_key] = {};
            }

            var priority = 0;
            if (this.label_style.priorities[feature.properties.kind]) {
                priority = this.label_style.priorities[feature.properties.kind];
            }

            this.max_priority = Math.max(priority, this.max_priority);

            if (!this.texts[tile][style_key][text]) {
                this.texts[tile][style_key][text] = {
                    text_style: style,
                    priority: priority,
                    ref: 0
                };
            }

            this.features = this.features || {};
            this.features[tile] = this.features[tile] || {};
            this.features[tile][style_key] = this.features[tile][style_key] || {};
            this.features[tile][style_key][text] = this.features[tile][style_key][text] || [];
            this.features[tile][style_key][text].push(feature);

            tile_data.queue.push([feature, rule, context, tile_data]);
        }
    },

    constructFontStyle: function constructFontStyle(rule, context) {
        var style = undefined;

        if (rule.font) {
            style = {};

            // Use fill if specified, or default
            style.fill = rule.font.fill && Utils.toCanvasColor(StyleParser.parseColor(rule.font.fill, context)) || this.font_style.fill;

            // Use stroke if specified
            if (rule.font.stroke && rule.font.stroke.color) {
                style.stroke = Utils.toCanvasColor(StyleParser.parseColor(rule.font.stroke.color));
                style.stroke_width = rule.font.stroke.width || this.font_style.stroke.width;
            }

            // Use default typeface
            style.font = rule.font.typeface || this.font_style.typeface;
            style.capitalized = rule.font.capitalized || this.font_style.capitalized;

            var size_regex = /([0-9]*\.)?[0-9]+(px|pt|em|%)/g;
            var ft_size = style.font.match(size_regex)[0];
            var size_kind = ft_size.replace(/([0-9]*\.)?[0-9]+/g, "");

            style.px_logical_size = Utils.toPixelSize(ft_size.replace(/([a-z]|%)/g, ""), size_kind);
            style.px_size = style.px_logical_size * Utils.device_pixel_ratio;
            style.stroke_width *= Utils.device_pixel_ratio;
            style.font = style.font.replace(size_regex, style.px_size + "px");
        }

        return style;
    },

    constructStyleKey: function constructStyleKey(_ref) {
        var font = _ref.font;
        var fill = _ref.fill;
        var stroke = _ref.stroke;
        var stroke_width = _ref.stroke_width;

        return "" + font + "/" + fill + "/" + stroke + "/" + stroke_width;
    },

    buildLabel: function buildLabel(label, size, vertex_data, vertex_template, texcoord_scale) {
        var angle = label.angle || 0;
        Builders.buildSpriteQuadsForPoints([label.position], Utils.scaleInt16(size[0], 256), Utils.scaleInt16(size[1], 256), Utils.scaleInt16(Utils.radToDeg(angle), 360), Utils.scaleInt16(1, 256), vertex_data, vertex_template, this.vertex_layout.index.a_shape, {
            texcoord_index: this.vertex_layout.index.a_texcoord,
            texcoord_scale: texcoord_scale
        });
    },

    build: function build(style, vertex_data) {
        var vertex_template = this.makeVertexTemplate(style);

        for (var i in style.labels) {
            var label = style.labels[i];

            if (label.isComposite()) {
                for (var j in label.labels) {
                    var l = label.labels[j];
                    var subtexcoord_scale = this.subtexcoord_scale[l.text];
                    var size = this.subtext_size[l.text];
                    this.buildLabel(l, size, vertex_data, vertex_template, subtexcoord_scale);
                }
            } else {
                this.buildLabel(label, label.size.texture_text_size, vertex_data, vertex_template, this.texcoord_scale);
            }
        }
    },

    buildLines: function buildLines(lines, style, vertex_data) {
        this.build(style, vertex_data);
    },

    buildPoints: function buildPoints(points, style, vertex_data) {
        this.build(style, vertex_data);
    },

    buildPolygons: function buildPolygons(points, style, vertex_data) {
        this.build(style, vertex_data);
    },

    _parseFeature: function _parseFeature(feature, rule_style, context) {
        var text = feature.text;

        var style = this.feature_style;
        var tile = context.tile.key;
        var style_key = this.feature_style_key.get(feature);
        var text_info = this.texts[tile] && this.texts[tile][style_key] && this.texts[tile][style_key][text];

        if (!text_info || !this.feature_labels.has(feature)) {
            return;
        }

        this.texcoord_scale = text_info.texcoords;
        this.subtexcoord_scale = text_info.subtexcoords;
        this.subtext_size = text_info.subtext_size;
        style.text = text;
        style.labels = this.feature_labels.get(feature);

        // TODO: point style (parent class) requires a color, setting it to white for now,
        // but could be made conditional in the vertex layout to save space
        style.color = [1, 1, 1, 1];

        // tell the point style (base class) that we want to render polygon labels at the polygon's centroid
        style.centroid = true;

        return style;
    }

});

TextStyle.texture_id = 0;

},{"../../gl/texture":73,"../../utils/utils":101,"../../utils/worker_broker":102,"../builders":85,"../points/points":87,"../style_parser":92,"./label_builder":94,"loglevel":54}],98:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/*global Tile */

var Geo = _interopRequire(require("./geo"));

var StyleParser = require("./styles/style_parser").StyleParser;

var WorkerBroker = _interopRequire(require("./utils/worker_broker"));

var Texture = _interopRequire(require("./gl/texture"));

var log = _interopRequire(require("loglevel"));

var Tile = (function () {

    /**
        Tile
        @constructor
        Required properties:
        coords: object with {x, y, z} properties identifying tile coordinate location
        worker: web worker to handle tile construction
    */

    function Tile(_ref) {
        var coords = _ref.coords;
        var worker = _ref.worker;
        var max_zoom = _ref.max_zoom;

        _classCallCheck(this, Tile);

        Object.assign(this, {
            coords: {
                x: null,
                y: null,
                z: null
            },
            debug: {},
            loading: false,
            loaded: false,
            error: null,
            worker: null,
            visible: false,
            center_dist: 0
        });

        this.worker = worker;
        this.max_zoom = max_zoom;

        this.coords = coords;
        this.coords = Tile.calculateOverZoom(this.coords, this.max_zoom);
        this.key = Tile.key(this.coords);
        this.min = Geo.metersForTile(this.coords);
        this.max = Geo.metersForTile({ x: this.coords.x + 1, y: this.coords.y + 1, z: this.coords.z }), this.span = { x: this.max.x - this.min.x, y: this.max.y - this.min.y };
        this.bounds = { sw: { x: this.min.x, y: this.max.y }, ne: { x: this.max.x, y: this.min.y } };

        this.meshes = {}; // renderable VBO meshes keyed by style
        this.textures = []; // textures that the tile owns (labels, etc.)
    }

    _createClass(Tile, {
        freeResources: {
            value: function freeResources() {
                if (this.meshes) {
                    for (var m in this.meshes) {
                        this.meshes[m].destroy();
                    }
                }

                if (this.textures) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = this.textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var t = _step.value;

                            var texture = Texture.textures[t];
                            if (texture) {
                                texture.destroy();
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator["return"]) {
                                _iterator["return"]();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                }

                this.meshes = {};
                this.textures = [];
            }
        },
        destroy: {
            value: function destroy() {
                this.workerMessage("removeTile", this.key);
                this.freeResources();
                this.worker = null;
            }
        },
        buildAsMessage: {
            value: function buildAsMessage() {
                return {
                    key: this.key,
                    coords: this.coords,
                    min: this.min,
                    max: this.max,
                    debug: this.debug
                };
            }
        },
        workerMessage: {
            value: function workerMessage() {
                for (var _len = arguments.length, message = Array(_len), _key = 0; _key < _len; _key++) {
                    message[_key] = arguments[_key];
                }

                return WorkerBroker.postMessage.apply(WorkerBroker, [this.worker].concat(message));
            }
        },
        build: {

            // TODO: remove scene dependency

            value: function build(scene) {
                scene.trackTileBuildStart(this.key);
                this.workerMessage("buildTile", { tile: this.buildAsMessage() }).then(function (message) {
                    scene.buildTileCompleted(message);
                })["catch"](function (error) {
                    throw error;
                });
            }
        },
        finalizeBuild: {

            /**
               Called on main thread when a web worker completes processing
               for a single tile.
            */

            value: function finalizeBuild(styles) {
                // Cleanup existing VBOs
                this.freeResources();

                // Debug
                this.debug.geometries = 0;
                this.debug.buffer_size = 0;

                // Create VBOs
                var mesh_data = this.mesh_data;
                if (mesh_data) {
                    for (var s in mesh_data) {
                        if (mesh_data[s].vertex_data) {
                            this.debug.buffer_size += mesh_data[s].vertex_data.byteLength;
                            this.meshes[s] = styles[s].makeMesh(mesh_data[s].vertex_data, mesh_data[s]);
                            this.debug.geometries += this.meshes[s].geometry_count;
                        }

                        // Assign ownership to textures if needed
                        if (mesh_data[s].textures) {
                            var _textures;

                            (_textures = this.textures).push.apply(_textures, _toConsumableArray(mesh_data[s].textures));
                        }
                    }
                }

                this.debug.geom_ratio = (this.debug.geometries / this.debug.features).toFixed(1);
                this.mesh_data = null; // TODO: might want to preserve this for rebuilding geometries when styles/etc. change?
            }
        },
        printDebug: {
            value: function printDebug() {
                log.debug("Tile: debug for " + this.key + ": [  " + JSON.stringify(this.debug) + " ]");
            }
        },
        update: {
            value: function update(scene) {
                if (this.coords.z === scene.center_tile.z && scene.visible_tiles[this.key]) {
                    this.visible = true;
                } else {
                    this.visible = false;
                }

                // TODO: handle tiles of mismatching zoom levels
                if (this.coords.z === scene.center_tile.z) {
                    this.center_dist = Math.abs(scene.center_tile.x - this.coords.x) + Math.abs(scene.center_tile.y - this.coords.y);
                } else {
                    this.center_dist = Infinity;
                }
            }
        },
        load: {
            value: function load(scene) {
                scene.trackTileSetLoadStart();

                this.loading = true;
                this.build(scene);
                this.update(scene);
            }
        },
        merge: {
            value: function merge(other) {
                for (var key in other) {
                    if (key !== "key") {
                        this[key] = other[key];
                    }
                }
                return this;
            }
        }
    }, {
        create: {
            value: function create(spec) {
                return new Tile(spec);
            }
        },
        key: {
            value: function key(_ref) {
                var x = _ref.x;
                var y = _ref.y;
                var z = _ref.z;

                return [x, y, z].join("/");
            }
        },
        calculateOverZoom: {
            value: function calculateOverZoom(_ref, max_zoom) {
                var x = _ref.x;
                var y = _ref.y;
                var z = _ref.z;

                max_zoom = max_zoom || z;

                if (z > max_zoom) {
                    var zdiff = z - max_zoom;

                    x = Math.floor(x >> zdiff);
                    y = Math.floor(y >> zdiff);
                    z -= zdiff;
                }

                return { x: x, y: y, z: z };
            }
        },
        sort: {

            // Sort a set of tile instances (which already have a distance from center tile computed)

            value: function sort(tiles) {
                return tiles.sort(function (a, b) {
                    var ad = a.center_dist;
                    var bd = b.center_dist;
                    return bd > ad ? -1 : bd === ad ? 0 : 1;
                });
            }
        },
        buildGeometry: {

            // Process geometry for tile - called by web worker
            // Returns a set of tile keys that should be sent to the main thread (so that we can minimize data exchange between worker and main thread)

            value: function buildGeometry(tile, layers, rules, styles) {
                tile.debug.rendering = +new Date();

                var tile_data = {};

                for (var source_name in tile.sources) {
                    var source = tile.sources[source_name];
                    source.debug.rendering = +new Date();
                    source.debug.features = 0;

                    // Treat top-level style rules as 'layers'
                    for (var layer_name in layers) {
                        var layer = layers[layer_name];
                        // Skip layers with no data source defined
                        if (!layer.data) {
                            log.warn("Layer " + layer + " was defined without a geometry data source and will not be rendered.");
                            continue;
                        }

                        // Source names don't match
                        if (layer.data.source !== source_name) {
                            continue;
                        }

                        var geom = Tile.getDataForSource(source, layer.data, layer_name);
                        if (!geom) {
                            continue;
                        }

                        // Render features in layer
                        var num_features = geom.features.length;
                        for (var f = num_features - 1; f >= 0; f--) {
                            var feature = geom.features[f];
                            var context = StyleParser.getFeatureParseContext(feature, tile);

                            // Get draw groups for this feature
                            var layer_rules = rules[layer_name];
                            var draw_groups = layer_rules.buildDrawGroups(context, true);
                            if (!draw_groups) {
                                continue;
                            }

                            // Render draw groups
                            for (var group_name in draw_groups) {
                                var group = draw_groups[group_name];
                                if (!group.visible) {
                                    continue;
                                }

                                // Add to style
                                var style_name = group.style || group_name;
                                var style = styles[style_name];

                                if (!style) {
                                    log.warn("Style '" + style_name + "' not found for rule in layer '" + layer_name + "':", group, feature);
                                    continue;
                                }

                                if (!tile_data[style_name]) {
                                    tile_data[style_name] = style.startData();
                                }

                                context.properties = group.properties; // add rule-specific properties to context

                                style.addFeature(feature, group, context, tile_data[style_name]);

                                context.properties = null; // clear group-specific properties
                            }

                            source.debug.features++;
                        }
                    }

                    source.debug.rendering = +new Date() - source.debug.rendering;
                }

                // Finalize array buffer for each render style
                tile.mesh_data = {};
                var queue = [];
                for (var style_name in tile_data) {
                    (function (style_name) {
                        var style = styles[style_name];
                        queue.push(style.endData(tile_data[style_name]).then(function (style_data) {
                            if (style_data) {
                                tile.mesh_data[style_name] = {
                                    vertex_data: style_data.vertex_data,
                                    uniforms: style_data.uniforms,
                                    textures: style_data.textures
                                };
                            }
                        }));
                    })(style_name);
                }

                return Promise.all(queue).then(function () {
                    // Aggregate debug info
                    tile.debug.rendering = +new Date() - tile.debug.rendering;
                    tile.debug.projection = 0;
                    tile.debug.features = 0;
                    tile.debug.network = 0;
                    tile.debug.parsing = 0;

                    for (var i in tile.sources) {
                        tile.debug.features += tile.sources[i].debug.features;
                        tile.debug.projection += tile.sources[i].debug.projection;
                        tile.debug.network += tile.sources[i].debug.network;
                        tile.debug.parsing += tile.sources[i].debug.parsing;
                    }

                    // Return keys to be transfered to main thread
                    return {
                        mesh_data: true
                    };
                });
            }
        },
        getDataForSource: {

            /**
                Retrieves geometry from a tile according to a data source definition
            */

            value: function getDataForSource(source_data, source_config) {
                var default_layer = arguments[2] === undefined ? null : arguments[2];

                var geom;

                if (source_config != null) {
                    // If no layer specified, and a default source layer exists
                    if (!source_config.layer && source_data.layers._default) {
                        geom = source_data.layers._default;
                    }
                    // If no layer specified, and a default requested layer exists
                    else if (!source_config.layer && default_layer) {
                        geom = source_data.layers[default_layer];
                    }
                    // If a layer is specified by name, use it
                    else if (typeof source_config.layer === "string") {
                        geom = source_data.layers[source_config.layer];
                    }
                    // Assemble a custom layer via a function, which is called with all source layers
                    else if (typeof source_config.layer === "function") {
                        geom = source_config.layer(source_data.layers);
                    }
                }

                return geom;
            }
        },
        abortBuild: {

            /**
                Called on main thread when web worker completes processing, but tile has since been discarded
                Frees resources that would have been transferred to the tile object.
                Static method because the tile object no longer exists (the tile data returned by the worker is passed instead).
            */

            value: function abortBuild(tile) {
                if (tile.mesh_data) {
                    for (var s in tile.mesh_data) {
                        var textures = tile.mesh_data[s].textures;
                        if (textures) {
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var t = _step.value;

                                    var texture = Texture.textures[t];
                                    if (texture) {
                                        log.trace("destroying texture " + t + " for tile " + tile.key);
                                        texture.destroy();
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                                        _iterator["return"]();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        cancel: {

            /**
                Called on worker to cancel loading
                Static method because the worker only has object representations of tile data, there is no
                tile instance created yet.
            */

            value: function cancel(tile) {
                if (tile && tile.sources) {
                    Object.keys(tile.sources).map(function (s) {
                        return tile.sources[s].request;
                    }).filter(function (s) {
                        return s;
                    }).forEach(function (s) {
                        return s.abort();
                    });
                }
            }
        }
    });

    return Tile;
})();

module.exports = Tile;

},{"./geo":67,"./gl/texture":73,"./styles/style_parser":92,"./utils/worker_broker":102,"loglevel":54}],99:[function(require,module,exports){
"use strict";

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

Object.defineProperty(exports, "__esModule", {
    value: true
});

var MethodNotImplemented = exports.MethodNotImplemented = (function (_Error) {
    function MethodNotImplemented(methodName) {
        _classCallCheck(this, MethodNotImplemented);

        _get(Object.getPrototypeOf(MethodNotImplemented.prototype), "constructor", this).call(this);
        this.name = "MethodNotImplemented";
        this.message = "Method " + methodName + " must be implemented in subclass";
    }

    _inherits(MethodNotImplemented, _Error);

    return MethodNotImplemented;
})(Error);

},{}],100:[function(require,module,exports){
"use strict";

module.exports = subscribeMixin;

function subscribeMixin(target) {

    var listeners = new Set();
    // var listeners = [];

    return Object.assign(target, {

        subscribe: function subscribe(listener) {
            listeners.add(listener);
            // listeners.push(listener);
        },

        unsubscribe: function unsubscribe(listener) {
            listeners["delete"](listener);
            // var index = listeners.indexOf(listener);
            // if (index > -1) {
            //     listeners.splice(index, 1);
            // }
        },

        unsubscribeAll: function unsubscribeAll() {
            listeners.clear();
            // listeners = [];
        },

        trigger: function trigger(event) {
            for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                data[_key - 1] = arguments[_key];
            }

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var listener = _step.value;

                    if (typeof listener[event] === "function") {
                        listener[event].apply(listener, data);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

    });
}

},{}],101:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

// Miscellaneous utilities
/*jshint worker: true*/

var log = _interopRequire(require("loglevel"));

var yaml = _interopRequire(require("js-yaml"));

var Geo = _interopRequire(require("../geo"));

var Utils;
module.exports = Utils = {};

// Add the current base URL for schemeless or protocol-less URLs
// Maybe use https://github.com/medialize/URI.js if more robust functionality is needed
Utils.addBaseURL = function (url) {
    if (!url) {
        return;
    }

    // Schemeless, add protocol
    if (url.substr(0, 2) === "//") {
        url = window.location.protocol + url;
    }
    // No http(s) or data, add base
    else if (url.search(/(http|https|data):\/\//) < 0) {
        url = window.location.origin + window.location.pathname + url;
    }
    return url;
};

Utils.cacheBusterForUrl = function (url) {
    return url + "?" + +new Date();
};

Utils.io = function (url) {
    var timeout = arguments[1] === undefined ? 60000 : arguments[1];
    var responseType = arguments[2] === undefined ? "text" : arguments[2];
    var method = arguments[3] === undefined ? "GET" : arguments[3];
    var headers = arguments[4] === undefined ? {} : arguments[4];

    var request = new XMLHttpRequest();
    var promise = new Promise(function (resolve, reject) {
        request.open(method, url, true);
        request.timeout = timeout;
        request.responseType = responseType;
        request.onload = function () {
            if (request.status === 200) {
                if (["text", "json"].indexOf(request.responseType) > -1) {
                    resolve(request.responseText);
                } else {
                    resolve(request.response);
                }
            } else {
                reject(Error("Request error with a status of " + request.statusText));
            }
        };
        request.onerror = function (evt) {
            reject(Error("There was a network error" + evt.toString()));
        };
        request.ontimeout = function (evt) {
            reject(Error("timeout " + evt.toString()));
        };
        request.send();
    });

    Object.defineProperty(promise, "request", {
        value: request
    });

    return promise;
};

Utils.parseResource = function (body) {
    var data = null;
    try {
        eval("data = " + body); // jshint ignore:line
    } catch (e) {
        try {
            data = yaml.safeLoad(body);
        } catch (e) {
            log.error("Utils.parseResource: failed to parse", e);
            throw e;
        }
    }
    return data;
};

Utils.loadResource = function (source) {
    return new Promise(function (resolve, reject) {
        if (typeof source === "string") {
            Utils.io(Utils.cacheBusterForUrl(source)).then(function (body) {
                var data = Utils.parseResource(body);
                resolve(data);
            }, reject);
        } else {
            resolve(source);
        }
    });
};

// Needed for older browsers that still support WebGL (Safari 6 etc.)
Utils.requestAnimationFramePolyfill = function () {
    if (typeof window.requestAnimationFrame !== "function") {
        window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (cb) {
            setTimeout(cb, 1000 / 60);
        };
    }
};

// Stringify an object into JSON, but convert functions to strings
Utils.serializeWithFunctions = function (obj) {
    var serialized = JSON.stringify(obj, function (k, v) {
        // Convert functions to strings
        if (typeof v === "function") {
            return v.toString();
        }
        return v;
    });

    return serialized;
};

// Parse a JSON string, but convert function-like strings back into functions
Utils.deserializeWithFunctions = function (serialized, wrap) {
    var obj = JSON.parse(serialized);
    obj = Utils.stringsToFunctions(obj, wrap);
    return obj;
};

// Recursively parse an object, attempting to convert string properties that look like functions back into functions
Utils.stringsToFunctions = function (obj, wrap) {
    for (var p in obj) {
        var val = obj[p];

        // Loop through object properties
        if (typeof val === "object") {
            obj[p] = Utils.stringsToFunctions(val, wrap);
        }
        // Convert strings back into functions
        // TODO: make function matching tolerant of whitespace and multilines
        else if (typeof val === "string" && val.match(/^function.*\(.*\)/) != null) {
            var f;
            try {
                if (typeof wrap === "function") {
                    eval("f = " + wrap(val)); // jshint ignore:line
                } else {
                    eval("f = " + val); // jshint ignore:line
                }
                obj[p] = f;
            } catch (e) {
                // fall-back to original value if parsing failed
                obj[p] = val;
            }
        }
    }

    return obj;
};

// Log wrapper, sends message to main thread for display, and includes worker id #
Utils.log = function (level) {
    for (var _len = arguments.length, msg = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        msg[_key - 1] = arguments[_key];
    }

    level = level || "info";
    if (Utils.isWorkerThread) {
        self.postMessage({
            type: "log",
            level: level,
            worker_id: self._worker_id,
            msg: msg
        });
    } else if (typeof log[level] === "function") {
        log[level].apply(log, msg);
    }
};

// Default to allowing high pixel density
Utils.use_high_density_display = true;
Utils.updateDevicePixelRatio = function () {
    Utils.device_pixel_ratio = Utils.use_high_density_display && window.devicePixelRatio || 1;
};

// Mark thread as main or worker
(function () {
    try {
        if (window.document !== undefined) {
            Utils.isWorkerThread = false;
            Utils.isMainThread = true;
            Utils.updateDevicePixelRatio();
        }
    } catch (e) {
        if (self !== undefined) {
            Utils.isWorkerThread = true;
            Utils.isMainThread = false;
        }
    }
})();

// Get URL that the current script was loaded from
// If currentScript is not available, loops through <script> elements searching for a list of provided paths
// e.g. Utils.findCurrentURL('tangram.debug.js', 'tangram.min.js');
Utils.findCurrentURL = function () {
    for (var _len = arguments.length, paths = Array(_len), _key = 0; _key < _len; _key++) {
        paths[_key] = arguments[_key];
    }

    // Find currently executing script
    var script = document.currentScript;
    if (script) {
        return script.src;
    } else if (Array.isArray(paths)) {
        // Fallback on looping through <script> elements if document.currentScript is not supported
        var scripts = document.getElementsByTagName("script");
        for (var s = 0; s < scripts.length; s++) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var path = _step.value;

                    if (scripts[s].src.indexOf(path) > -1) {
                        return scripts[s].src;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator["return"]) {
                        _iterator["return"]();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
};

// Used for differentiating between power-of-2 and non-power-of-2 textures
// Via: http://stackoverflow.com/questions/19722247/webgl-wait-for-texture-to-load
Utils.isPowerOf2 = function (value) {
    return (value & value - 1) === 0;
};

Utils.nextPowerOf2 = function (value) {
    return Math.pow(2, Math.ceil(Math.log2(value)));
};

// Interpolate 'x' along a series of control points
// 'points' is an array of control points in the form [x, y]
//
// Example:
//     Control points:
//         [0, 5]:  when x=0, y=5
//         [4, 10]: when x=4, y=10
//
//     Utils.interpolate(2, [[0, 5], [4, 10]]);
//     -> computes x=2, halfway between x=0 and x=4: (10 - 5) / 2 +5
//     -> returns 7.5
//
// TODO: add other interpolation methods besides linear
//
Utils.interpolate = function (x, points) {
    // If this doesn't resemble a list of control points, just return the original value
    if (!Array.isArray(points) || points.some(function (v) {
        return !Array.isArray(v);
    })) {
        return points;
    } else if (points.length < 1) {
        return points;
    }

    var x1, x2, d, y;

    // Min bounds
    if (x <= points[0][0]) {
        y = points[0][1];
    }
    // Max bounds
    else if (x >= points[points.length - 1][0]) {
        y = points[points.length - 1][1];
    }
    // Find which control points x is between
    else {
        for (var i = 0; i < points.length - 1; i++) {
            if (x >= points[i][0] && x < points[i + 1][0]) {
                // Linear interpolation
                x1 = points[i][0];
                x2 = points[i + 1][0];

                // Multiple values
                if (Array.isArray(points[i][1])) {
                    y = [];
                    for (var c = 0; c < points[i][1].length; c++) {
                        d = points[i + 1][1][c] - points[i][1][c];
                        y[c] = d * (x - x1) / (x2 - x1) + points[i][1][c];
                    }
                }
                // Single value
                else {
                    d = points[i + 1][1] - points[i][1];
                    y = d * (x - x1) / (x2 - x1) + points[i][1];
                }
                break;
            }
        }
    }
    return y;
};

// Iterators (ES6 generators)

// Iterator for key/value pairs of an object
Utils.entries = regeneratorRuntime.mark(function callee$0$0(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 3;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 5:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 12;
                    break;
                }

                key = _step.value;
                context$1$0.next = 9;
                return [key, obj[key]];

            case 9:
                _iteratorNormalCompletion = true;
                context$1$0.next = 5;
                break;

            case 12:
                context$1$0.next = 18;
                break;

            case 14:
                context$1$0.prev = 14;
                context$1$0.t0 = context$1$0["catch"](3);
                _didIteratorError = true;
                _iteratorError = context$1$0.t0;

            case 18:
                context$1$0.prev = 18;
                context$1$0.prev = 19;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 21:
                context$1$0.prev = 21;

                if (!_didIteratorError) {
                    context$1$0.next = 24;
                    break;
                }

                throw _iteratorError;

            case 24:
                return context$1$0.finish(21);

            case 25:
                return context$1$0.finish(18);

            case 26:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$0, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

// Iterator for values of an object
Utils.values = regeneratorRuntime.mark(function callee$0$1(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$1$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 3;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 5:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 12;
                    break;
                }

                key = _step.value;
                context$1$0.next = 9;
                return obj[key];

            case 9:
                _iteratorNormalCompletion = true;
                context$1$0.next = 5;
                break;

            case 12:
                context$1$0.next = 18;
                break;

            case 14:
                context$1$0.prev = 14;
                context$1$0.t1 = context$1$0["catch"](3);
                _didIteratorError = true;
                _iteratorError = context$1$0.t1;

            case 18:
                context$1$0.prev = 18;
                context$1$0.prev = 19;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 21:
                context$1$0.prev = 21;

                if (!_didIteratorError) {
                    context$1$0.next = 24;
                    break;
                }

                throw _iteratorError;

            case 24:
                return context$1$0.finish(21);

            case 25:
                return context$1$0.finish(18);

            case 26:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$1, this, [[3, 14, 18, 26], [19,, 21, 25]]);
});

// Recursive iterators for all properties of an object, no matter how deeply nested
// TODO: fix for circular structures
Utils.recurseEntries = regeneratorRuntime.mark(function callee$0$2(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$2$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (obj) {
                    context$1$0.next = 2;
                    break;
                }

                return context$1$0.abrupt("return");

            case 2:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 5;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 7:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 17;
                    break;
                }

                key = _step.value;

                if (!obj[key]) {
                    context$1$0.next = 14;
                    break;
                }

                context$1$0.next = 12;
                return [key, obj[key], obj];

            case 12:
                if (!(typeof obj[key] === "object")) {
                    context$1$0.next = 14;
                    break;
                }

                return context$1$0.delegateYield(Utils.recurseEntries(obj[key]), "t2", 14);

            case 14:
                _iteratorNormalCompletion = true;
                context$1$0.next = 7;
                break;

            case 17:
                context$1$0.next = 23;
                break;

            case 19:
                context$1$0.prev = 19;
                context$1$0.t3 = context$1$0["catch"](5);
                _didIteratorError = true;
                _iteratorError = context$1$0.t3;

            case 23:
                context$1$0.prev = 23;
                context$1$0.prev = 24;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 26:
                context$1$0.prev = 26;

                if (!_didIteratorError) {
                    context$1$0.next = 29;
                    break;
                }

                throw _iteratorError;

            case 29:
                return context$1$0.finish(26);

            case 30:
                return context$1$0.finish(23);

            case 31:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$2, this, [[5, 19, 23, 31], [24,, 26, 30]]);
});

Utils.recurseValues = regeneratorRuntime.mark(function callee$0$3(obj) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

    return regeneratorRuntime.wrap(function callee$0$3$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (obj) {
                    context$1$0.next = 2;
                    break;
                }

                return context$1$0.abrupt("return");

            case 2:
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                context$1$0.prev = 5;
                _iterator = Object.keys(obj)[Symbol.iterator]();

            case 7:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    context$1$0.next = 17;
                    break;
                }

                key = _step.value;

                if (!obj[key]) {
                    context$1$0.next = 14;
                    break;
                }

                context$1$0.next = 12;
                return obj[key];

            case 12:
                if (!(typeof obj[key] === "object")) {
                    context$1$0.next = 14;
                    break;
                }

                return context$1$0.delegateYield(Utils.recurseValues(obj[key]), "t4", 14);

            case 14:
                _iteratorNormalCompletion = true;
                context$1$0.next = 7;
                break;

            case 17:
                context$1$0.next = 23;
                break;

            case 19:
                context$1$0.prev = 19;
                context$1$0.t5 = context$1$0["catch"](5);
                _didIteratorError = true;
                _iteratorError = context$1$0.t5;

            case 23:
                context$1$0.prev = 23;
                context$1$0.prev = 24;

                if (!_iteratorNormalCompletion && _iterator["return"]) {
                    _iterator["return"]();
                }

            case 26:
                context$1$0.prev = 26;

                if (!_didIteratorError) {
                    context$1$0.next = 29;
                    break;
                }

                throw _iteratorError;

            case 29:
                return context$1$0.finish(26);

            case 30:
                return context$1$0.finish(23);

            case 31:
            case "end":
                return context$1$0.stop();
        }
    }, callee$0$3, this, [[5, 19, 23, 31], [24,, 26, 30]]);
});

Utils.scaleInt16 = function (val, max) {
    return val / max * 32768;
};

Utils.degToRad = function (degrees) {
    return degrees * Math.PI / 180;
};

Utils.radToDeg = function (radians) {
    return radians * 180 / Math.PI;
};

Utils.toCanvasColor = function (color) {
    return "rgb(" + Math.round(color[0] * 255) + "," + Math.round(color[1] * 255) + "," + Math.round(color[2] * 255) + ")";
};

Utils.centroid = function (polygon) {
    var n = polygon.length;
    var centroid = [0, 0];

    for (var p = 0; p < polygon.length; p++) {
        centroid[0] += polygon[p][0];
        centroid[1] += polygon[p][1];
    }

    centroid[0] /= n;
    centroid[1] /= n;

    return centroid;
};

Utils.multiCentroid = function (polygons) {
    var n = polygons.length;
    var centroid = [0, 0];

    for (var p = 0; p < polygons.length; p++) {
        var polygon = polygons[p][0];
        var c = Utils.centroid(polygon);
        centroid[0] += c[0];
        centroid[1] += c[1];
    }

    centroid[0] /= n;
    centroid[1] /= n;

    return centroid;
};

Utils.polygonArea = function (polygon) {
    var area = 0;
    var n = polygon.length;

    for (var i = 0; i < n - 1; i++) {
        var p0 = polygon[i];
        var p1 = polygon[i + 1];

        area += p0[0] * p1[1] - p1[0] * p0[1];
    }

    area += polygon[n - 1][0] * polygon[0][1] - polygon[0][0] * polygon[n - 1][1];

    return Math.abs(area) / 2;
};

Utils.multiPolygonArea = function (polygons) {
    var area = 0;

    for (var p = 0; p < polygons.length; p++) {
        var polygon = polygons[p][0];
        area += Utils.polygonArea(polygon);
    }

    return area;
};

Utils.toPixelSize = function (size, kind) {
    if (kind === "px") {
        return size;
    } else if (kind === "em") {
        return 16 * size;
    } else if (kind === "pt") {
        return size / 0.75;
    } else if (kind === "%") {
        return size / 6.25;
    }
};

Utils.pointInTile = function (point) {
    return point[0] > 0 && point[1] > -Geo.tile_scale && point[0] < Geo.tile_scale && point[1] < 0;
};

Utils.pixelToMercator = function (size) {
    return size * Geo.units_per_pixel;
};

},{"../geo":67,"js-yaml":23,"loglevel":54}],102:[function(require,module,exports){
"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

/*jshint worker: true*/

// WorkerBroker routes messages between web workers and the main thread, allowing for simpler
// async code via promises. Example usage:
//
// In web worker, define a method:
//
//     self.square = function (x) {
//         return x * x;
//     };
//
// In main thread, invoke that method and receive the result (if any) as a promise:
//
//     worker = new Worker(...);
//     WorkerBroker.addWorker(worker);
//
//     WorkerBroker.postMessage(worker, 'square', 5).then(function(y) {
//         console.log(y);
//     });
//
//     -> prints 25
//
// Async code:
//
// For synchronous code that must pass a return value to the main thread, the function can simply
// return an immediate value (see example above). For cases where the worker method needs to run
// asynchronous code, the function can return a promise, and the resolved or rejected value will
// be sent back to the main thread when the promise is fulfilled.
//
// Error handling:
//
// If the worker method either throws an error, or returns a promise that is rejected, it will be
// sent back to the main thread as a promise rejection. These two examples are equivalent:
//
//     In worker, throwing an error:
//
//         self.broken = function () {
//             throw new Error('error in worker!');
//         };
//
//     In worker, returning a rejected promise:
//
//         self.broken = function () {
//             return Promise.reject(new Error('error in worker!'));
//         };
//
//     In main thread, both errors are received as a promise rejection:
//
//         WorkerBroker.postMessage(worker, 'broken').then(
//             // Promise resolved
//             function() {
//                 console.log('success!');
//             },
//             // Promise rejected
//             function(error) {
//                 console.log('error!', error);
//             });
//
//         -> prints 'error! error in worker'
//
// TODO: add documentation for invoking main thread methods from a worker (basically same API, but in reverse)

var Utils = _interopRequire(require("./utils"));

var WorkerBroker;
module.exports = WorkerBroker = {};

// Global list of all worker messages
// Uniquely tracks every call made between main thread and a worker
var message_id = 0;
var messages = {};

// Main thread:
// - Send messages to workers, and optionally receive an async response as a promise
// - Receive messages from workers, and optionally send an async response back as a promise
function setupMainThread() {

    // Send a message to a worker, and optionally get an async response
    // Arguments:
    //   - worker: the web worker instance
    //   - method: the method with this name will be invoked in the worker
    //   - message: will be passed to the method call in the worker
    // Returns:
    //   - a promise that will be fulfilled if the worker method returns a value (could be immediately, or async)
    //
    WorkerBroker.postMessage = function (worker, method) {
        for (var _len = arguments.length, message = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            message[_key - 2] = arguments[_key];
        }

        // Track state of this message
        var promise = new Promise(function (resolve, reject) {
            messages[message_id] = { method: method, message: message, resolve: resolve, reject: reject };
        });

        worker.postMessage({
            type: "main_send", // mark message as method invocation from main thread
            message_id: message_id, // unique id for this message, for life of program
            method: method, // will dispatch to a function of this name within the worker
            message: message // message payload
        });

        message_id++;
        return promise;
    };

    // Add a worker to communicate with - each worker must be registered from the main thread
    var worker_id = 0;
    var workers = {};

    WorkerBroker.addWorker = function (worker) {

        // Keep track of all registered workers
        // TODO: adding a property directly to the worker, would be better to track non-instrusively,
        // maybe with an ES6 Map
        worker._worker_broker_id = worker_id++;
        workers[worker._worker_broker_id] = worker;

        // Listen for messages coming back from the worker, and fulfill that message's promise
        worker.addEventListener("message", function (event) {
            if (event.data.type !== "worker_reply") {
                return;
            }

            // Pass the result to the promise
            var id = event.data.message_id;
            if (messages[id]) {
                if (event.data.error) {
                    messages[id].reject(event.data.error);
                } else {
                    messages[id].resolve(event.data.message);
                }
                delete messages[id];
            }
        });

        // Listen for messages initiating a call from the worker, dispatch them,
        // and send any return value back to the worker
        worker.addEventListener("message", function (event) {
            // Unique id for this message & return call to main thread
            var id = event.data.message_id;
            if (event.data.type !== "worker_send" || id == null) {
                return;
            }

            // Call the requested method and save the return value
            var target = targets[event.data.target];
            if (!target) {
                throw Error("Worker broker could not dispatch message type " + event.data.method + " on target " + event.data.target + " because no object with that name is registered on main thread");
            }

            var method = typeof target[event.data.method] === "function" && target[event.data.method];
            if (!method) {
                throw Error("Worker broker could not dispatch message type " + event.data.method + " on target " + event.data.target + " because object has no method with that name");
            }

            var result, error;
            try {
                result = method.apply(target, event.data.message);
            } catch (e) {
                // Thrown errors will be passed back (in string form) to worker
                error = e;
            }

            // Send return value to worker
            // Async result
            if (result instanceof Promise) {
                result.then(function (value) {
                    worker.postMessage({
                        type: "main_reply",
                        message_id: id,
                        message: value
                    });
                }, function (error) {
                    worker.postMessage({
                        type: "main_reply",
                        message_id: id,
                        error: error instanceof Error ? "" + error.message + ": " + error.stack : error
                    });
                });
            }
            // Immediate result
            else {
                worker.postMessage({
                    type: "main_reply",
                    message_id: id,
                    message: result,
                    error: error instanceof Error ? "" + error.message + ": " + error.stack : error
                });
            }
        });
    };

    // Register an object to receive calls from the worker
    var targets = {};
    WorkerBroker.addTarget = function (name, target) {
        targets[name] = target;
    };

    // Expose for debugging
    WorkerBroker.getMessages = function () {
        return messages;
    };

    WorkerBroker.getMessageId = function () {
        return message_id;
    };
}

// Worker threads:
// - Receive messages from main thread, and optionally send an async response back as a promise
// - Send messages to main thread, and optionally receive an async response as a promise
function setupWorkerThread() {

    // Send a message to the main thread, and optionally get an async response as a promise
    // Arguments:
    //   - target: the name of the object in the main thread to be called
    //   - method: the method with this name will be invoked on the main thread target object
    //   - message: will be passed to the method call in the main thread
    // Returns:
    //   - a promise that will be fulfilled if the main thread method returns a value (could be immediately, or async)
    //
    WorkerBroker.postMessage = function (target, method) {
        for (var _len = arguments.length, message = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            message[_key - 2] = arguments[_key];
        }

        // Track state of this message
        var promise = new Promise(function (resolve, reject) {
            messages[message_id] = { target: target, method: method, message: message, resolve: resolve, reject: reject };
        });

        self.postMessage({
            type: "worker_send", // mark message as method invocation from worker
            message_id: message_id, // unique id for this message, for life of program
            target: target, // name of the object to be called on main thread
            method: method, // will dispatch to a method of this name on the main thread
            message: message // message payload
        });

        message_id++;
        return promise;
    };

    // Listen for messages coming back from the main thread, and fulfill that message's promise
    self.addEventListener("message", function (event) {
        if (event.data.type !== "main_reply") {
            return;
        }

        // Pass the result to the promise
        var id = event.data.message_id;
        if (messages[id]) {
            if (event.data.error) {
                messages[id].reject(event.data.error);
            } else {
                messages[id].resolve(event.data.message);
            }
            delete messages[id];
        }
    });

    // Receive messages from main thread, dispatch them, and send back a reply
    self.addEventListener("message", function (event) {
        // Unique id for this message & return call to main thread
        var id = event.data.message_id;
        if (event.data.type !== "main_send" || id == null) {
            return;
        }

        // Call the requested worker method and save the return value
        var method_name = event.data.method;
        var method = typeof self[method_name] === "function" && self[method_name];
        if (!method) {
            throw Error("Worker broker could not dispatch message type " + method_name + " because worker has no method with that name");
        }

        var result, error;
        try {
            result = method.apply(self, event.data.message);
        } catch (e) {
            // Thrown errors will be passed back (in string form) to main thread
            error = e;
        }

        // Send return value to main thread
        var transferables = undefined;
        // Async result
        if (result instanceof Promise) {
            result.then(function (value) {
                transferables = findTransferables(value);

                self.postMessage({
                    type: "worker_reply",
                    message_id: id,
                    message: value
                }, transferables);

                if (transferables.length > 0) {
                    Utils.log("trace", "'" + method_name + "' transferred " + transferables.length + " objects to main thread");
                }
            }, function (error) {
                self.postMessage({
                    type: "worker_reply",
                    message_id: id,
                    error: error instanceof Error ? "" + error.message + ": " + error.stack : error
                });
            });
        }
        // Immediate result
        else {
            transferables = findTransferables(result);

            self.postMessage({
                type: "worker_reply",
                message_id: id,
                message: result,
                error: error instanceof Error ? "" + error.message + ": " + error.stack : error
            }, transferables);

            if (transferables.length > 0) {
                Utils.log("trace", "'" + method_name + "' transferred " + transferables.length + " objects to main thread");
            }
        }
    });
}

// Build a list of transferable objects from a source object
// TODO: add option in case you DON'T want to transfer objects
function findTransferables(source) {
    var list = arguments[1] === undefined ? [] : arguments[1];

    if (!source) {
        return list;
    }

    if (Array.isArray(source)) {
        // Check each array element
        source.forEach(function (x) {
            return findTransferables(x, list);
        });
    } else if (typeof source === "object") {
        // Is the object a transferable array buffer?
        if (source instanceof ArrayBuffer) {
            list.push(source);
        }
        // Or looks like a typed array (has an array buffer property)?
        else if (source.buffer instanceof ArrayBuffer) {
            list.push(source.buffer);
        }
        // Otherwise check each property
        else {
            for (var p in source) {
                findTransferables(source[p], list);
            }
        }
    }
    return list;
}

// Setup this thread as appropriate
if (Utils.isMainThread) {
    setupMainThread();
}

if (Utils.isWorkerThread) {
    setupWorkerThread();
}

},{"./utils":101}],103:[function(require,module,exports){
"use strict";

var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) { _arr.push(_step.value); if (i && _arr.length === i) break; } return _arr; } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } };

/*** Vector functions - vectors provided as [x, y, z] arrays ***/

var Vector;
module.exports = Vector = {};

Vector.set = function (v) {
    var V = [];
    var lim = v.length;
    for (var i = 0; i < lim; i++) {
        V[i] = v[i];
    }
    return V;
};

Vector.neg = function (v) {
    var V = [];
    var lim = v.length;
    for (var i = 0; i < lim; i++) {
        V[i] = v[i] * -1;
    }
    return V;
};

// Addition of two vectors
Vector.add = function (v1, v2) {
    var v = [];
    var lim = Math.min(v1.length, v2.length);
    for (var i = 0; i < lim; i++) {
        v[i] = v1[i] + v2[i];
    }
    return v;
};

// Substraction of two vectors
Vector.sub = function (v1, v2) {
    var v = [];
    var lim = Math.min(v1.length, v2.length);

    for (var i = 0; i < lim; i++) {
        v[i] = v1[i] - v2[i];
    }
    return v;
};

Vector.signed_area = function (v1, v2, v3) {
    return (v2[0] - v1[0]) * (v3[1] - v1[1]) - (v3[0] - v1[0]) * (v2[1] - v1[1]);
};

// Multiplication of two vectors
Vector.mult = function (v1, v2) {
    var v = [],
        len = v1.length,
        i;

    if (typeof v2 === "number") {
        // Mulitply by scalar
        for (i = 0; i < len; i++) {
            v[i] = v1[i] * v2;
        }
    } else {
        // Multiply two vectors
        len = Math.min(v1.length, v2.length);
        for (i = 0; i < len; i++) {
            v[i] = v1[i] * v2[i];
        }
    }
    return v;
};

// Division of two vectors
Vector.div = function (v1, v2) {
    var v = [],
        i;
    if (typeof v2 === "number") {
        // Divide by scalar
        for (i = 0; i < v1.length; i++) {
            v[i] = v1[i] / v2;
        }
    } else {
        // Divide to vectors
        var len = Math.min(v1.length, v2.length);
        for (i = 0; i < len; i++) {
            v[i] = v1[i] / v2[i];
        }
    }
    return v;
};

// Get 2D perpendicular
Vector.perp = function (v1, v2) {
    return [v2[1] - v1[1], v1[0] - v2[0]];
};

// Get 2D vector rotated
Vector.rot = function (v, a) {
    var vr = Vector.length(v);
    var va = Vector.angle(v);
    return [vr * Math.cos(va + a), vr * Math.sin(va + a)];
};

// Get 2D heading angle
Vector.angle = function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var x = _ref2[0];
    var y = _ref2[1];

    return Math.atan2(y, x);
};

// Compare two points
Vector.isEqual = function (v1, v2) {
    var len = v1.length;
    for (var i = 0; i < len; i++) {
        if (v1[i] !== v2[i]) {
            return false;
        }
    }
    return true;
};

// Vector length squared
Vector.lengthSq = function (v) {
    if (v.length === 2) {
        return v[0] * v[0] + v[1] * v[1];
    } else {
        return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    }
};

// Vector length
Vector.length = function (v) {
    return Math.sqrt(Vector.lengthSq(v));
};

// Normalize a vector
Vector.normalize = function (v) {
    var d;
    if (v.length === 2) {
        d = v[0] * v[0] + v[1] * v[1];
        d = Math.sqrt(d);

        if (d !== 0) {
            return [v[0] / d, v[1] / d];
        }
        return [0, 0];
    } else {
        d = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
        d = Math.sqrt(d);

        if (d !== 0) {
            return [v[0] / d, v[1] / d, v[2] / d];
        }
        return [0, 0, 0];
    }
};

// Cross product of two vectors
Vector.cross = function (v1, v2) {
    return [v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2], v1[0] * v2[1] - v1[1] * v2[0]];
};

// Dot product of two vectors
Vector.dot = function (v1, v2) {
    var n = 0;
    var lim = Math.min(v1.length, v2.length);
    for (var i = 0; i < lim; i++) {
        n += v1[i] * v2[i];
    }
    return n;
};

// Find the intersection of two lines specified as segments from points (p1, p2) and (p3, p4)
// http://en.wikipedia.org/wiki/Line-line_intersection
// http://en.wikipedia.org/wiki/Cramer's_rule
Vector.lineIntersection = function (p1, p2, p3, p4, parallel_tolerance) {
    parallel_tolerance = parallel_tolerance || 0.01;

    // a1*x + b1*y = c1 for line (x1, y1) to (x2, y2)
    // a2*x + b2*y = c2 for line (x3, y3) to (x4, y4)
    var a1 = p1[1] - p2[1]; // y1 - y2
    var b1 = p1[0] - p2[0]; // x1 - x2
    var a2 = p3[1] - p4[1]; // y3 - y4
    var b2 = p3[0] - p4[0]; // x3 - x4
    var c1 = p1[0] * p2[1] - p1[1] * p2[0]; // x1*y2 - y1*x2
    var c2 = p3[0] * p4[1] - p3[1] * p4[0]; // x3*y4 - y3*x4
    var denom = b1 * a2 - a1 * b2;

    if (Math.abs(denom) > parallel_tolerance) {
        return [(c1 * b2 - b1 * c2) / denom, (c1 * a2 - a1 * c2) / denom];
    }
    return null; // return null if lines are (close to) parallel
};

},{}]},{},[1,81])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwibm9kZV9tb2R1bGVzXFxiYWJlbFxccG9seWZpbGwuanMiLCJub2RlX21vZHVsZXNcXGJhYmVsXFxsaWJcXGJhYmVsXFxwb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlc1xcYmFiZWxcXG5vZGVfbW9kdWxlc1xcY29yZS1qc1xcc2hpbS5qcyIsIm5vZGVfbW9kdWxlc1xcYmFiZWxcXG5vZGVfbW9kdWxlc1xccmVnZW5lcmF0b3ItYmFiZWxcXHJ1bnRpbWUuanMiLCJub2RlX21vZHVsZXNcXGJveC1pbnRlcnNlY3RcXGluZGV4LmpzIiwibm9kZV9tb2R1bGVzXFxib3gtaW50ZXJzZWN0XFxsaWJcXGJydXRlLmpzIiwibm9kZV9tb2R1bGVzXFxib3gtaW50ZXJzZWN0XFxsaWJcXGludGVyc2VjdC5qcyIsIm5vZGVfbW9kdWxlc1xcYm94LWludGVyc2VjdFxcbGliXFxtZWRpYW4uanMiLCJub2RlX21vZHVsZXNcXGJveC1pbnRlcnNlY3RcXGxpYlxccGFydGl0aW9uLmpzIiwibm9kZV9tb2R1bGVzXFxib3gtaW50ZXJzZWN0XFxsaWJcXHNvcnQuanMiLCJub2RlX21vZHVsZXNcXGJveC1pbnRlcnNlY3RcXGxpYlxcc3dlZXAuanMiLCJub2RlX21vZHVsZXNcXGJveC1pbnRlcnNlY3RcXG5vZGVfbW9kdWxlc1xcYml0LXR3aWRkbGVcXHR3aWRkbGUuanMiLCJub2RlX21vZHVsZXNcXGJveC1pbnRlcnNlY3RcXG5vZGVfbW9kdWxlc1xcdHlwZWRhcnJheS1wb29sXFxub2RlX21vZHVsZXNcXGR1cFxcZHVwLmpzIiwibm9kZV9tb2R1bGVzXFxib3gtaW50ZXJzZWN0XFxub2RlX21vZHVsZXNcXHR5cGVkYXJyYXktcG9vbFxccG9vbC5qcyIsIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXJlc29sdmVcXGVtcHR5LmpzIiwibm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJ1ZmZlclxcaW5kZXguanMiLCJub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnVmZmVyXFxub2RlX21vZHVsZXNcXGJhc2U2NC1qc1xcbGliXFxiNjQuanMiLCJub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnVmZmVyXFxub2RlX21vZHVsZXNcXGllZWU3NTRcXGluZGV4LmpzIiwibm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJ1ZmZlclxcbm9kZV9tb2R1bGVzXFxpcy1hcnJheVxcaW5kZXguanMiLCJub2RlX21vZHVsZXNcXGNzc2NvbG9ycGFyc2VyXFxjc3Njb2xvcnBhcnNlci5qcyIsIm5vZGVfbW9kdWxlc1xcZWFyY3V0XFxzcmNcXGVhcmN1dC5qcyIsIm5vZGVfbW9kdWxlc1xcZ2wtbWF0cml4XFxkaXN0XFxnbC1tYXRyaXguanMiLCJub2RlX21vZHVsZXNcXGpzLXlhbWxcXGluZGV4LmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWwuanMiLCJub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXGR1bXBlci5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFxleGNlcHRpb24uanMiLCJub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXG1hcmsuanMiLCJub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcc2NoZW1hLmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHNjaGVtYVxcY29yZS5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFxzY2hlbWFcXGRlZmF1bHRfZnVsbC5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFxzY2hlbWFcXGRlZmF1bHRfc2FmZS5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFxzY2hlbWFcXGZhaWxzYWZlLmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHNjaGVtYVxcanNvbi5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlLmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHR5cGVcXGJpbmFyeS5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxib29sLmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHR5cGVcXGZsb2F0LmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHR5cGVcXGludC5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxqc1xcZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxcanNcXHJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxqc1xcdW5kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHR5cGVcXG1hcC5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxtZXJnZS5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxudWxsLmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHR5cGVcXG9tYXAuanMiLCJub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxccGFpcnMuanMiLCJub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxcc2VxLmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxsaWJcXGpzLXlhbWxcXHR5cGVcXHNldC5qcyIsIm5vZGVfbW9kdWxlc1xcanMteWFtbFxcbGliXFxqcy15YW1sXFx0eXBlXFxzdHIuanMiLCJub2RlX21vZHVsZXNcXGpzLXlhbWxcXGxpYlxcanMteWFtbFxcdHlwZVxcdGltZXN0YW1wLmpzIiwibm9kZV9tb2R1bGVzXFxqcy15YW1sXFxub2RlX21vZHVsZXNcXGVzcHJpbWFcXGVzcHJpbWEuanMiLCJub2RlX21vZHVsZXNcXGxvZ2xldmVsXFxsaWJcXGxvZ2xldmVsLmpzIiwibm9kZV9tb2R1bGVzXFxtYXRjaC1mZWF0dXJlXFxpbmRleC5qcyIsIm5vZGVfbW9kdWxlc1xccGJmXFxidWZmZXIuanMiLCJub2RlX21vZHVsZXNcXHBiZlxcaW5kZXguanMiLCJub2RlX21vZHVsZXNcXHN0cmlwLWNvbW1lbnRzXFxpbmRleC5qcyIsIm5vZGVfbW9kdWxlc1xcdmVjdG9yLXRpbGVcXGluZGV4LmpzIiwibm9kZV9tb2R1bGVzXFx2ZWN0b3ItdGlsZVxcbGliXFx2ZWN0b3J0aWxlLmpzIiwibm9kZV9tb2R1bGVzXFx2ZWN0b3ItdGlsZVxcbGliXFx2ZWN0b3J0aWxlZmVhdHVyZS5qcyIsIm5vZGVfbW9kdWxlc1xcdmVjdG9yLXRpbGVcXGxpYlxcdmVjdG9ydGlsZWxheWVyLmpzIiwibm9kZV9tb2R1bGVzXFx2ZWN0b3ItdGlsZVxcbm9kZV9tb2R1bGVzXFxwb2ludC1nZW9tZXRyeVxcaW5kZXguanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL2NhbWVyYS5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvZGF0YV9zb3VyY2UuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL2dlby5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvZ2wvY29uc3RhbnRzLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy9nbC9jb250ZXh0LmpzIiwiZDovd29yay90YW5ncmFtL3NyYy9nbC9nbHNsLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy9nbC9zaGFkZXJfcHJvZ3JhbS5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvZ2wvc2hhZGVyX3NvdXJjZXMuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL2dsL3RleHR1cmUuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL2dsL3Zhby5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvZ2wvdmJvX21lc2guanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL2dsL3ZlcnRleF9kYXRhLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy9nbC92ZXJ0ZXhfbGF5b3V0LmpzIiwiZDovd29yay90YW5ncmFtL3NyYy9sZWFmbGV0X2xheWVyLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy9saWdodC5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvbWF0ZXJpYWwuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL21vZHVsZS5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvc2NlbmUuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL3NjZW5lX3dvcmtlci5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvc2VsZWN0aW9uLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy9zdHlsZXMvYnVpbGRlcnMuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL3N0eWxlcy9saW5lcy9saW5lcy5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvc3R5bGVzL3BvaW50cy9wb2ludHMuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29ucy5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvc3R5bGVzL3J1bGUuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL3N0eWxlcy9zdHlsZS5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvc3R5bGVzL3N0eWxlX21hbmFnZXIuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL3N0eWxlcy9zdHlsZV9wYXJzZXIuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL3N0eWxlcy90ZXh0L2xhYmVsLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy9zdHlsZXMvdGV4dC9sYWJlbF9idWlsZGVyLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy9zdHlsZXMvdGV4dC9sYWJlbF9saW5lLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy9zdHlsZXMvdGV4dC9sYWJlbF9wb2ludC5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvc3R5bGVzL3RleHQvdGV4dC5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvdGlsZS5qcyIsImQ6L3dvcmsvdGFuZ3JhbS9zcmMvdXRpbHMvZXJyb3JzLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy91dGlscy9zdWJzY3JpYmUuanMiLCJkOi93b3JrL3RhbmdyYW0vc3JjL3V0aWxzL3V0aWxzLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy91dGlscy93b3JrZXJfYnJva2VyLmpzIiwiZDovd29yay90YW5ncmFtL3NyYy92ZWN0b3IuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6N0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4cElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwMEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUksSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7QUFDbkMsd0JBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7QUFDOUIsd0JBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFDaEMsd0JBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQzVHOztxQkFFSSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDbEIsd0JBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7QUFDL0Isd0JBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDakMsd0JBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQzdHOztxQkFFSSxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTs7QUFDaEMsd0JBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFF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Q3pIOzs7Ozs7O0FBT0QsU0FBUyxNQUFNLENBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFOztBQUU3RSxRQUFJLFlBQVksR0FBRyxDQUFDLEVBQUU7QUFDbEIsZUFBTztLQUNWOzs7O0FBSUQsY0FBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDOztBQUV0QixRQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzlCLFFBQUksUUFBUSxHQUFHLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDOztBQUVyQixRQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNyQyxRQUFJLFdBQVcsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUNsQixtQkFBVyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ3BCO0FBQ0QsZUFBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUMsWUFBWSxDQUFDOztBQUVsRCxRQUFJLENBQUMsTUFBTSxFQUFFO0FBQ1QsbUJBQVcsSUFBSSxDQUFDLENBQUMsQ0FBQztLQUNyQjs7QUFFRCxRQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzVCLFFBQUksUUFBUSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUMsRUFBRSxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUM7Ozs7QUFJM0QsYUFBUyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDOzs7QUFHcEMsYUFBUyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDOzs7QUFHMUMsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFD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RSxTQUFTLENBQUMsS0FBSyxHQUFHLEtBQUssR0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO1FBQ3pFLEVBQUUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFBLEdBQUUsU0FBUyxDQUFDLEtBQUssR0FBRyxLQUFLLEdBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztRQUN6RSxFQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQSxHQUFFLFNBQVMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFOUUsUUFBSSxNQUFNLEVBQUU7QUFDUixpQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3hDLGlCQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDM0MsTUFBTTtBQUNILFVBQUUsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RCLFVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVixVQUFFLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QixVQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQSxHQUFFLFNBQVMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxRSxVQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQSxHQUFFLFNBQVMsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFDLFNBQVMsQ0FBQyxLQUFLLENB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QUUsS0FBSyxDQUFDLEVBRWQsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQ2QsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQ2QsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQ2pCLENBQUM7S0FDTDs7QUFFRCxRQUFJLFVBQVUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0FBQy9CLFNBQUssSUFBSSxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDL0IsWUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUV0QixZQUFJLFNBQVMsR0FBRyxDQUNaLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBQyxDQUFDLENBQUMsRUFDekMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFDLENBQUMsQ0FBQyxFQUN6QyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUMsQ0FBQyxDQUFDLEVBRXpDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBQyxDQUFDLENBQUMsRUFDekMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFDLENBQUMsQ0FBQyxFQUN6QyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUMsQ0FBQyxD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RSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFO0tBQzFCLENBQUM7Q0FDTCxDQUFDOztBQUVGLFFBQVEsQ0FBQyxxQkFBcUIsR0FBRyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFO0FBQ3hELGFBQVMsR0FBRyxTQUFTLElBQUksQ0FBQyxDQUFDO0FBQzNCLFdBQVEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFFO0NBQ3hDLENBQUM7OztBQUdGLFFBQVEsQ0FBQywwQkFBMEIsR0FBRyxZQUFZO0FBQzlDLFFBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFDLENBQUM7QUFDeEIsUUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQzs7QUFFL0IsUUFBSSxDQUFDLEdBQUc7QUFDSixVQUFFLEVBQUUsR0FBRztBQUNQLGdCQUFRLEVBQUU7QUFDTixnQkFBSSxFQUFFLFlBQVk7QUFDbEIsdUJBQVcsRUFBRSxDQUNULENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsRUFDMUQsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUN4RCxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVB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QUFDeEMsb0JBQUksTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEFBQUMsQ0FBQzs7O0FBRzdDLG9CQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFDLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDeEQsd0JBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxHQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ2xDLE1BQ0ksSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxVQUFVLEVBQUU7QUFDdkYsd0JBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFVBQVUsSUFBSSxLQUFLLEdBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQSxBQUFDLENBQUM7aUJBQ3JEOztBQUVELG9CQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3ZCLG9CQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFDLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDekQsd0JBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ25DLE1BQ0ksSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sR0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFVBQVUsSUFB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QUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzFCLFNBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3hCO0FBQ0QsV0FBTyxDQUFDLENBQUM7Q0FDWixDQUFDOzs7QUFHRixNQUFNLENBQUMsR0FBRyxHQUFHLFVBQVUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUMzQixRQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDWCxRQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUV4QyxTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzFCLFNBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3hCO0FBQ0QsV0FBTyxDQUFDLENBQUM7Q0FDWixDQUFDOztBQUVGLE1BQU0sQ0FBQyxXQUFXLEdBQUcsVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN2QyxXQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQSxJQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUEsQUFBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQSxJQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUEsQUFBQyxDQUFDO0NBQ3BFLENBQUM7OztBQUdGLE1BQU0sQ0FBQyxJQUFJLEdBQUcsVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQzVCLFFBQUksQ0FBQyxHQUFHLEVB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QUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsUUFBSSxFQUFFLEdBQUcsQUFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEFBQUMsQ0FBQztBQUMzQyxRQUFJLEVBQUUsR0FBRyxBQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQUFBQyxDQUFDO0FBQzNDLFFBQUksS0FBSyxHQUFHLEFBQUMsRUFBRSxHQUFHLEVBQUUsR0FBSyxFQUFFLEdBQUcsRUFBRSxBQUFDLENBQUM7O0FBRWxDLFFBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxrQkFBa0IsRUFBRTtBQUN0QyxlQUFPLENBQ0gsQ0FBQyxBQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFJLEtBQUssRUFDL0IsQ0FBQyxBQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFJLEtBQUssQ0FDbEMsQ0FBQztLQUNMO0FBQ0QsV0FBTyxJQUFJLENBQUM7Q0FDZixDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL2JhYmVsL3BvbHlmaWxsXCIpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwvcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1iYWJlbC9ydW50aW1lXCIpO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiLyoqXG4gKiBDb3JlLmpzIDAuNi4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qc1xuICogTGljZW5zZTogaHR0cDovL3JvY2subWl0LWxpY2Vuc2Uub3JnXG4gKiDCqSAyMDE1IERlbmlzIFB1c2hrYXJldlxuICovXG4hZnVuY3Rpb24oZ2xvYmFsLCBmcmFtZXdvcmssIHVuZGVmaW5lZCl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvbW1vbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLy8gU2hvcnRjdXRzIGZvciBbW0NsYXNzXV0gJiBwcm9wZXJ0eSBuYW1lc1xyXG52YXIgT0JKRUNUICAgICAgICAgID0gJ09iamVjdCdcclxuICAsIEZVTkNUSU9OICAgICAgICA9ICdGdW5jdGlvbidcclxuICAsIEFSUkFZICAgICAgICAgICA9ICdBcnJheSdcclxuICAsIFNUUklORyAgICAgICAgICA9ICdTdHJpbmcnXHJcbiAgLCBOVU1CRVIgICAgICAgICAgPSAnTnVtYmVyJ1xyXG4gICwgUkVHRVhQICAgICAgICAgID0gJ1JlZ0V4cCdcclxuICAsIERBVEUgICAgICAgICAgICA9ICdEYXRlJ1xyXG4gICwgTUFQICAgICAgICAgICAgID0gJ01hcCdcclxuICAsIFNFVCAgICAgICAgICAgICA9ICdTZXQnXHJcbiAgLCBXRUFLTUFQICAgICAgICAgPSAnV2Vha01hcCdcclxuICAsIFdFQUtTRVQgICAgICAgICA9ICdXZWFrU2V0J1xyXG4gICwgU1lNQk9MICAgICAgICAgID0gJ1N5bWJvbCdcclxuICAsIFBST01JU0UgICAgICAgICA9ICdQcm9taXNlJ1xyXG4gICwgTUFUSCAgICAgICAgICAgID0gJ01hdGgnXHJcbiAgLCBBUkdVTUVOVFMgICAgICAgPSAnQXJndW1lbnRzJ1xyXG4gICwgUFJPVE9UWVBFICAgICAgID0gJ3Byb3RvdHlwZSdcclxuICAsIENPTlNUUlVDVE9SICAgICA9ICdjb25zdHJ1Y3RvcidcclxuICAsIFRPX1NUUklORyAgICAgICA9ICd0b1N0cmluZydcclxuICAsIFRPX1NUUklOR19UQUcgICA9IFRPX1NUUklORyArICdUYWcnXHJcbiAgLCBUT19MT0NBTEUgICAgICAgPSAndG9Mb2NhbGVTdHJpbmcnXHJcbiAgLCBIQVNfT1dOICAgICAgICAgPSAnaGFzT3duUHJvcGVydHknXHJcbiAgLCBGT1JfRUFDSCAgICAgICAgPSAnZm9yRWFjaCdcclxuICAsIElURVJBVE9SICAgICAgICA9ICdpdGVyYXRvcidcclxuICAsIEZGX0lURVJBVE9SICAgICA9ICdAQCcgKyBJVEVSQVRPUlxyXG4gICwgUFJPQ0VTUyAgICAgICAgID0gJ3Byb2Nlc3MnXHJcbiAgLCBDUkVBVEVfRUxFTUVOVCAgPSAnY3JlYXRlRWxlbWVudCdcclxuICAvLyBBbGlhc2VzIGdsb2JhbCBvYmplY3RzIGFuZCBwcm90b3R5cGVzXHJcbiAgLCBGdW5jdGlvbiAgICAgICAgPSBnbG9iYWxbRlVOQ1RJT05dXHJcbiAgLCBPYmplY3QgICAgICAgICAgPSBnbG9iYWxbT0JKRUNUXVxyXG4gICwgQXJyYXkgICAgICAgICAgID0gZ2xvYmFsW0FSUkFZXVxyXG4gICwgU3RyaW5nICAgICAgICAgID0gZ2xvYmFsW1NUUklOR11cclxuICAsIE51bWJlciAgICAgICAgICA9IGdsb2JhbFtOVU1CRVJdXHJcbiAgLCBSZWdFeHAgICAgICAgICAgPSBnbG9iYWxbUkVHRVhQXVxyXG4gICwgRGF0ZSAgICAgICAgICAgID0gZ2xvYmFsW0RBVEVdXHJcbiAgLCBNYXAgICAgICAgICAgICAgPSBnbG9iYWxbTUFQXVxyXG4gICwgU2V0ICAgICAgICAgICAgID0gZ2xvYmFsW1NFVF1cclxuICAsIFdlYWtNYXAgICAgICAgICA9IGdsb2JhbFtXRUFLTUFQXVxyXG4gICwgV2Vha1NldCAgICAgICAgID0gZ2xvYmFsW1dFQUtTRVRdXHJcbiAgLCBTeW1ib2wgICAgICAgICAgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICwgTWF0aCAgICAgICAgICAgID0gZ2xvYmFsW01BVEhdXHJcbiAgLCBUeXBlRXJyb3IgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXHJcbiAgLCBSYW5nZUVycm9yICAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxyXG4gICwgc2V0VGltZW91dCAgICAgID0gZ2xvYmFsLnNldFRpbWVvdXRcclxuICAsIHNldEltbWVkaWF0ZSAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcclxuICAsIGNsZWFySW1tZWRpYXRlICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxyXG4gICwgcGFyc2VJbnQgICAgICAgID0gZ2xvYmFsLnBhcnNlSW50XHJcbiAgLCBpc0Zpbml0ZSAgICAgICAgPSBnbG9iYWwuaXNGaW5pdGVcclxuICAsIHByb2Nlc3MgICAgICAgICA9IGdsb2JhbFtQUk9DRVNTXVxyXG4gICwgbmV4dFRpY2sgICAgICAgID0gcHJvY2VzcyAmJiBwcm9jZXNzLm5leHRUaWNrXHJcbiAgLCBkb2N1bWVudCAgICAgICAgPSBnbG9iYWwuZG9jdW1lbnRcclxuICAsIGh0bWwgICAgICAgICAgICA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxyXG4gICwgbmF2aWdhdG9yICAgICAgID0gZ2xvYmFsLm5hdmlnYXRvclxyXG4gICwgZGVmaW5lICAgICAgICAgID0gZ2xvYmFsLmRlZmluZVxyXG4gICwgY29uc29sZSAgICAgICAgID0gZ2xvYmFsLmNvbnNvbGUgfHwge31cclxuICAsIEFycmF5UHJvdG8gICAgICA9IEFycmF5W1BST1RPVFlQRV1cclxuICAsIE9iamVjdFByb3RvICAgICA9IE9iamVjdFtQUk9UT1RZUEVdXHJcbiAgLCBGdW5jdGlvblByb3RvICAgPSBGdW5jdGlvbltQUk9UT1RZUEVdXHJcbiAgLCBJbmZpbml0eSAgICAgICAgPSAxIC8gMFxyXG4gICwgRE9UICAgICAgICAgICAgID0gJy4nO1xyXG5cclxuLy8gaHR0cDovL2pzcGVyZi5jb20vY29yZS1qcy1pc29iamVjdFxyXG5mdW5jdGlvbiBpc09iamVjdChpdCl7XHJcbiAgcmV0dXJuIGl0ICE9PSBudWxsICYmICh0eXBlb2YgaXQgPT0gJ29iamVjdCcgfHwgdHlwZW9mIGl0ID09ICdmdW5jdGlvbicpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oaXQpe1xyXG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ2Z1bmN0aW9uJztcclxufVxyXG4vLyBOYXRpdmUgZnVuY3Rpb24/XHJcbnZhciBpc05hdGl2ZSA9IGN0eCgvLi8udGVzdCwgL1xcW25hdGl2ZSBjb2RlXFxdXFxzKlxcfVxccyokLywgMSk7XHJcblxyXG4vLyBPYmplY3QgaW50ZXJuYWwgW1tDbGFzc11dIG9yIHRvU3RyaW5nVGFnXHJcbi8vIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcclxudmFyIHRvU3RyaW5nID0gT2JqZWN0UHJvdG9bVE9fU1RSSU5HXTtcclxuZnVuY3Rpb24gc2V0VG9TdHJpbmdUYWcoaXQsIHRhZywgc3RhdCl7XHJcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0W1BST1RPVFlQRV0sIFNZTUJPTF9UQUcpKWhpZGRlbihpdCwgU1lNQk9MX1RBRywgdGFnKTtcclxufVxyXG5mdW5jdGlvbiBjb2YoaXQpe1xyXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XHJcbn1cclxuZnVuY3Rpb24gY2xhc3NvZihpdCl7XHJcbiAgdmFyIE8sIFQ7XHJcbiAgcmV0dXJuIGl0ID09IHVuZGVmaW5lZCA/IGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6ICdOdWxsJ1xyXG4gICAgOiB0eXBlb2YgKFQgPSAoTyA9IE9iamVjdChpdCkpW1NZTUJPTF9UQUddKSA9PSAnc3RyaW5nJyA/IFQgOiBjb2YoTyk7XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uXHJcbnZhciBjYWxsICA9IEZ1bmN0aW9uUHJvdG8uY2FsbFxyXG4gICwgYXBwbHkgPSBGdW5jdGlvblByb3RvLmFwcGx5XHJcbiAgLCBSRUZFUkVOQ0VfR0VUO1xyXG4vLyBQYXJ0aWFsIGFwcGx5XHJcbmZ1bmN0aW9uIHBhcnQoLyogLi4uYXJncyAqLyl7XHJcbiAgdmFyIGZuICAgICA9IGFzc2VydEZ1bmN0aW9uKHRoaXMpXHJcbiAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICwgYXJncyAgID0gQXJyYXkobGVuZ3RoKVxyXG4gICAgLCBpICAgICAgPSAwXHJcbiAgICAsIF8gICAgICA9IHBhdGguX1xyXG4gICAgLCBob2xkZXIgPSBmYWxzZTtcclxuICB3aGlsZShsZW5ndGggPiBpKWlmKChhcmdzW2ldID0gYXJndW1lbnRzW2krK10pID09PSBfKWhvbGRlciA9IHRydWU7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xyXG4gICAgdmFyIHRoYXQgICAgPSB0aGlzXHJcbiAgICAgICwgX2xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgLCBpID0gMCwgaiA9IDAsIF9hcmdzO1xyXG4gICAgaWYoIWhvbGRlciAmJiAhX2xlbmd0aClyZXR1cm4gaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcclxuICAgIF9hcmdzID0gYXJncy5zbGljZSgpO1xyXG4gICAgaWYoaG9sZGVyKWZvcig7bGVuZ3RoID4gaTsgaSsrKWlmKF9hcmdzW2ldID09PSBfKV9hcmdzW2ldID0gYXJndW1lbnRzW2orK107XHJcbiAgICB3aGlsZShfbGVuZ3RoID4gailfYXJncy5wdXNoKGFyZ3VtZW50c1tqKytdKTtcclxuICAgIHJldHVybiBpbnZva2UoZm4sIF9hcmdzLCB0aGF0KTtcclxuICB9XHJcbn1cclxuLy8gT3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXHJcbmZ1bmN0aW9uIGN0eChmbiwgdGhhdCwgbGVuZ3RoKXtcclxuICBhc3NlcnRGdW5jdGlvbihmbik7XHJcbiAgaWYofmxlbmd0aCAmJiB0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xyXG4gIHN3aXRjaChsZW5ndGgpe1xyXG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XHJcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xyXG4gICAgfVxyXG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XHJcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xyXG4gICAgfVxyXG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XHJcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xyXG4gICAgfVxyXG4gIH0gcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xyXG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcclxuICB9XHJcbn1cclxuLy8gRmFzdCBhcHBseVxyXG4vLyBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcclxuZnVuY3Rpb24gaW52b2tlKGZuLCBhcmdzLCB0aGF0KXtcclxuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XHJcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoIHwgMCl7XHJcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcclxuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcclxuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcclxuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcclxuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcclxuICAgIGNhc2UgNTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSlcclxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcclxuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XHJcbn1cclxuXHJcbi8vIE9iamVjdDpcclxudmFyIGNyZWF0ZSAgICAgICAgICAgPSBPYmplY3QuY3JlYXRlXHJcbiAgLCBnZXRQcm90b3R5cGVPZiAgID0gT2JqZWN0LmdldFByb3RvdHlwZU9mXHJcbiAgLCBzZXRQcm90b3R5cGVPZiAgID0gT2JqZWN0LnNldFByb3RvdHlwZU9mXHJcbiAgLCBkZWZpbmVQcm9wZXJ0eSAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XHJcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcclxuICAsIGdldE93bkRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXHJcbiAgLCBnZXRLZXlzICAgICAgICAgID0gT2JqZWN0LmtleXNcclxuICAsIGdldE5hbWVzICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xyXG4gICwgZ2V0U3ltYm9scyAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcclxuICAsIGlzRnJvemVuICAgICAgICAgPSBPYmplY3QuaXNGcm96ZW5cclxuICAsIGhhcyAgICAgICAgICAgICAgPSBjdHgoY2FsbCwgT2JqZWN0UHJvdG9bSEFTX09XTl0sIDIpXHJcbiAgLy8gRHVtbXksIGZpeCBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZyBpbiBlczUgbW9kdWxlXHJcbiAgLCBFUzVPYmplY3QgICAgICAgID0gT2JqZWN0XHJcbiAgLCBEaWN0O1xyXG5mdW5jdGlvbiB0b09iamVjdChpdCl7XHJcbiAgcmV0dXJuIEVTNU9iamVjdChhc3NlcnREZWZpbmVkKGl0KSk7XHJcbn1cclxuZnVuY3Rpb24gcmV0dXJuSXQoaXQpe1xyXG4gIHJldHVybiBpdDtcclxufVxyXG5mdW5jdGlvbiByZXR1cm5UaGlzKCl7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0KG9iamVjdCwga2V5KXtcclxuICBpZihoYXMob2JqZWN0LCBrZXkpKXJldHVybiBvYmplY3Rba2V5XTtcclxufVxyXG5mdW5jdGlvbiBvd25LZXlzKGl0KXtcclxuICBhc3NlcnRPYmplY3QoaXQpO1xyXG4gIHJldHVybiBnZXRTeW1ib2xzID8gZ2V0TmFtZXMoaXQpLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBnZXROYW1lcyhpdCk7XHJcbn1cclxuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxyXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSl7XHJcbiAgdmFyIFQgPSBPYmplY3QoYXNzZXJ0RGVmaW5lZCh0YXJnZXQpKVxyXG4gICAgLCBsID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgLCBpID0gMTtcclxuICB3aGlsZShsID4gaSl7XHJcbiAgICB2YXIgUyAgICAgID0gRVM1T2JqZWN0KGFyZ3VtZW50c1tpKytdKVxyXG4gICAgICAsIGtleXMgICA9IGdldEtleXMoUylcclxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG4gICAgICAsIGogICAgICA9IDBcclxuICAgICAgLCBrZXk7XHJcbiAgICB3aGlsZShsZW5ndGggPiBqKVRba2V5ID0ga2V5c1tqKytdXSA9IFNba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIFQ7XHJcbn1cclxuZnVuY3Rpb24ga2V5T2Yob2JqZWN0LCBlbCl7XHJcbiAgdmFyIE8gICAgICA9IHRvT2JqZWN0KG9iamVjdClcclxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxyXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG4gICAgLCBpbmRleCAgPSAwXHJcbiAgICAsIGtleTtcclxuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xyXG59XHJcblxyXG4vLyBBcnJheVxyXG4vLyBhcnJheSgnc3RyMSxzdHIyLHN0cjMnKSA9PiBbJ3N0cjEnLCAnc3RyMicsICdzdHIzJ11cclxuZnVuY3Rpb24gYXJyYXkoaXQpe1xyXG4gIHJldHVybiBTdHJpbmcoaXQpLnNwbGl0KCcsJyk7XHJcbn1cclxudmFyIHB1c2ggICAgPSBBcnJheVByb3RvLnB1c2hcclxuICAsIHVuc2hpZnQgPSBBcnJheVByb3RvLnVuc2hpZnRcclxuICAsIHNsaWNlICAgPSBBcnJheVByb3RvLnNsaWNlXHJcbiAgLCBzcGxpY2UgID0gQXJyYXlQcm90by5zcGxpY2VcclxuICAsIGluZGV4T2YgPSBBcnJheVByb3RvLmluZGV4T2ZcclxuICAsIGZvckVhY2ggPSBBcnJheVByb3RvW0ZPUl9FQUNIXTtcclxuLypcclxuICogMCAtPiBmb3JFYWNoXHJcbiAqIDEgLT4gbWFwXHJcbiAqIDIgLT4gZmlsdGVyXHJcbiAqIDMgLT4gc29tZVxyXG4gKiA0IC0+IGV2ZXJ5XHJcbiAqIDUgLT4gZmluZFxyXG4gKiA2IC0+IGZpbmRJbmRleFxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlNZXRob2QodHlwZSl7XHJcbiAgdmFyIGlzTWFwICAgICAgID0gdHlwZSA9PSAxXHJcbiAgICAsIGlzRmlsdGVyICAgID0gdHlwZSA9PSAyXHJcbiAgICAsIGlzU29tZSAgICAgID0gdHlwZSA9PSAzXHJcbiAgICAsIGlzRXZlcnkgICAgID0gdHlwZSA9PSA0XHJcbiAgICAsIGlzRmluZEluZGV4ID0gdHlwZSA9PSA2XHJcbiAgICAsIG5vaG9sZXMgICAgID0gdHlwZSA9PSA1IHx8IGlzRmluZEluZGV4O1xyXG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xyXG4gICAgdmFyIE8gICAgICA9IE9iamVjdChhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAsIHRoYXQgICA9IGFyZ3VtZW50c1sxXVxyXG4gICAgICAsIHNlbGYgICA9IEVTNU9iamVjdChPKVxyXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxyXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxyXG4gICAgICAsIGluZGV4ICA9IDBcclxuICAgICAgLCByZXN1bHQgPSBpc01hcCA/IEFycmF5KGxlbmd0aCkgOiBpc0ZpbHRlciA/IFtdIDogdW5kZWZpbmVkXHJcbiAgICAgICwgdmFsLCByZXM7XHJcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKG5vaG9sZXMgfHwgaW5kZXggaW4gc2VsZil7XHJcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xyXG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xyXG4gICAgICBpZih0eXBlKXtcclxuICAgICAgICBpZihpc01hcClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgICAvLyBtYXBcclxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2godHlwZSl7XHJcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxyXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcclxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcclxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcclxuICAgICAgICB9IGVsc2UgaWYoaXNFdmVyeSlyZXR1cm4gZmFsc2U7ICAgICAgICAgICAvLyBldmVyeVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNGaW5kSW5kZXggPyAtMSA6IGlzU29tZSB8fCBpc0V2ZXJ5ID8gaXNFdmVyeSA6IHJlc3VsdDtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlDb250YWlucyhpc0NvbnRhaW5zKXtcclxuICByZXR1cm4gZnVuY3Rpb24oZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xyXG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoaXMpXHJcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXHJcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChhcmd1bWVudHNbMV0sIGxlbmd0aCk7XHJcbiAgICBpZihpc0NvbnRhaW5zICYmIGVsICE9IGVsKXtcclxuICAgICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihzYW1lTmFOKE9baW5kZXhdKSlyZXR1cm4gaXNDb250YWlucyB8fCBpbmRleDtcclxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKGlzQ29udGFpbnMgfHwgaW5kZXggaW4gTyl7XHJcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gaXNDb250YWlucyB8fCBpbmRleDtcclxuICAgIH0gcmV0dXJuICFpc0NvbnRhaW5zICYmIC0xO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBnZW5lcmljKEEsIEIpe1xyXG4gIC8vIHN0cmFuZ2UgSUUgcXVpcmtzIG1vZGUgYnVnIC0+IHVzZSB0eXBlb2YgdnMgaXNGdW5jdGlvblxyXG4gIHJldHVybiB0eXBlb2YgQSA9PSAnZnVuY3Rpb24nID8gQSA6IEI7XHJcbn1cclxuXHJcbi8vIE1hdGhcclxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmIC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcclxuICAsIHBvdyAgICA9IE1hdGgucG93XHJcbiAgLCBhYnMgICAgPSBNYXRoLmFic1xyXG4gICwgY2VpbCAgID0gTWF0aC5jZWlsXHJcbiAgLCBmbG9vciAgPSBNYXRoLmZsb29yXHJcbiAgLCBtYXggICAgPSBNYXRoLm1heFxyXG4gICwgbWluICAgID0gTWF0aC5taW5cclxuICAsIHJhbmRvbSA9IE1hdGgucmFuZG9tXHJcbiAgLCB0cnVuYyAgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgcmV0dXJuIChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcclxuICAgIH1cclxuLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcclxuZnVuY3Rpb24gc2FtZU5hTihudW1iZXIpe1xyXG4gIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xyXG59XHJcbi8vIDcuMS40IFRvSW50ZWdlclxyXG5mdW5jdGlvbiB0b0ludGVnZXIoaXQpe1xyXG4gIHJldHVybiBpc05hTihpdCkgPyAwIDogdHJ1bmMoaXQpO1xyXG59XHJcbi8vIDcuMS4xNSBUb0xlbmd0aFxyXG5mdW5jdGlvbiB0b0xlbmd0aChpdCl7XHJcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCBNQVhfU0FGRV9JTlRFR0VSKSA6IDA7XHJcbn1cclxuZnVuY3Rpb24gdG9JbmRleChpbmRleCwgbGVuZ3RoKXtcclxuICB2YXIgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xyXG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xyXG59XHJcbmZ1bmN0aW9uIGx6KG51bSl7XHJcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlcGxhY2VyKHJlZ0V4cCwgcmVwbGFjZSwgaXNTdGF0aWMpe1xyXG4gIHZhciByZXBsYWNlciA9IGlzT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24ocGFydCl7XHJcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcclxuICB9IDogcmVwbGFjZTtcclxuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xyXG4gICAgcmV0dXJuIFN0cmluZyhpc1N0YXRpYyA/IGl0IDogdGhpcykucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUG9pbnRBdCh0b1N0cmluZyl7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHBvcyl7XHJcbiAgICB2YXIgcyA9IFN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxyXG4gICAgICAsIGwgPSBzLmxlbmd0aFxyXG4gICAgICAsIGEsIGI7XHJcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIHRvU3RyaW5nID8gJycgOiB1bmRlZmluZWQ7XHJcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcclxuICAgICAgPyB0b1N0cmluZyA/IHMuY2hhckF0KGkpIDogYVxyXG4gICAgICA6IHRvU3RyaW5nID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQXNzZXJ0aW9uICYgZXJyb3JzXHJcbnZhciBSRURVQ0VfRVJST1IgPSAnUmVkdWNlIG9mIGVtcHR5IG9iamVjdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnO1xyXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cxLCBtc2cyKXtcclxuICBpZighY29uZGl0aW9uKXRocm93IFR5cGVFcnJvcihtc2cyID8gbXNnMSArIG1zZzIgOiBtc2cxKTtcclxufVxyXG5mdW5jdGlvbiBhc3NlcnREZWZpbmVkKGl0KXtcclxuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcclxuICByZXR1cm4gaXQ7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24oaXQpe1xyXG4gIGFzc2VydChpc0Z1bmN0aW9uKGl0KSwgaXQsICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XHJcbiAgcmV0dXJuIGl0O1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydE9iamVjdChpdCl7XHJcbiAgYXNzZXJ0KGlzT2JqZWN0KGl0KSwgaXQsICcgaXMgbm90IGFuIG9iamVjdCEnKTtcclxuICByZXR1cm4gaXQ7XHJcbn1cclxuZnVuY3Rpb24gYXNzZXJ0SW5zdGFuY2UoaXQsIENvbnN0cnVjdG9yLCBuYW1lKXtcclxuICBhc3NlcnQoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgbmFtZSwgXCI6IHVzZSB0aGUgJ25ldycgb3BlcmF0b3IhXCIpO1xyXG59XHJcblxyXG4vLyBQcm9wZXJ0eSBkZXNjcmlwdG9ycyAmIFN5bWJvbFxyXG5mdW5jdGlvbiBkZXNjcmlwdG9yKGJpdG1hcCwgdmFsdWUpe1xyXG4gIHJldHVybiB7XHJcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXHJcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXHJcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXHJcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHNpbXBsZVNldChvYmplY3QsIGtleSwgdmFsdWUpe1xyXG4gIG9iamVjdFtrZXldID0gdmFsdWU7XHJcbiAgcmV0dXJuIG9iamVjdDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVEZWZpbmVyKGJpdG1hcCl7XHJcbiAgcmV0dXJuIERFU0MgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xyXG4gICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCBkZXNjcmlwdG9yKGJpdG1hcCwgdmFsdWUpKTtcclxuICB9IDogc2ltcGxlU2V0O1xyXG59XHJcbmZ1bmN0aW9uIHVpZChrZXkpe1xyXG4gIHJldHVybiBTWU1CT0wgKyAnKCcgKyBrZXkgKyAnKV8nICsgKCsrc2lkICsgcmFuZG9tKCkpW1RPX1NUUklOR10oMzYpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFdlbGxLbm93blN5bWJvbChuYW1lLCBzZXR0ZXIpe1xyXG4gIHJldHVybiAoU3ltYm9sICYmIFN5bWJvbFtuYW1lXSkgfHwgKHNldHRlciA/IFN5bWJvbCA6IHNhZmVTeW1ib2wpKFNZTUJPTCArIERPVCArIG5hbWUpO1xyXG59XHJcbi8vIFRoZSBlbmdpbmUgd29ya3MgZmluZSB3aXRoIGRlc2NyaXB0b3JzPyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5LlxyXG52YXIgREVTQyA9ICEhZnVuY3Rpb24oKXtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDIgfX0pLmEgPT0gMjtcclxuICAgICAgfSBjYXRjaChlKXt9XHJcbiAgICB9KClcclxuICAsIHNpZCAgICA9IDBcclxuICAsIGhpZGRlbiA9IGNyZWF0ZURlZmluZXIoMSlcclxuICAsIHNldCAgICA9IFN5bWJvbCA/IHNpbXBsZVNldCA6IGhpZGRlblxyXG4gICwgc2FmZVN5bWJvbCA9IFN5bWJvbCB8fCB1aWQ7XHJcbmZ1bmN0aW9uIGFzc2lnbkhpZGRlbih0YXJnZXQsIHNyYyl7XHJcbiAgZm9yKHZhciBrZXkgaW4gc3JjKWhpZGRlbih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbnZhciBTWU1CT0xfVU5TQ09QQUJMRVMgPSBnZXRXZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJylcclxuICAsIEFycmF5VW5zY29wYWJsZXMgICA9IEFycmF5UHJvdG9bU1lNQk9MX1VOU0NPUEFCTEVTXSB8fCB7fVxyXG4gICwgU1lNQk9MX1RBRyAgICAgICAgID0gZ2V0V2VsbEtub3duU3ltYm9sKFRPX1NUUklOR19UQUcpXHJcbiAgLCBTWU1CT0xfU1BFQ0lFUyAgICAgPSBnZXRXZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKVxyXG4gICwgU1lNQk9MX0lURVJBVE9SO1xyXG5mdW5jdGlvbiBzZXRTcGVjaWVzKEMpe1xyXG4gIGlmKERFU0MgJiYgKGZyYW1ld29yayB8fCAhaXNOYXRpdmUoQykpKWRlZmluZVByb3BlcnR5KEMsIFNZTUJPTF9TUEVDSUVTLCB7XHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IHJldHVyblRoaXNcclxuICB9KTtcclxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBjb21tb24uZXhwb3J0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgTk9ERSA9IGNvZihwcm9jZXNzKSA9PSBQUk9DRVNTXHJcbiAgLCBjb3JlID0ge31cclxuICAsIHBhdGggPSBmcmFtZXdvcmsgPyBnbG9iYWwgOiBjb3JlXHJcbiAgLCBvbGQgID0gZ2xvYmFsLmNvcmVcclxuICAsIGV4cG9ydEdsb2JhbFxyXG4gIC8vIHR5cGUgYml0bWFwXHJcbiAgLCBGT1JDRUQgPSAxXHJcbiAgLCBHTE9CQUwgPSAyXHJcbiAgLCBTVEFUSUMgPSA0XHJcbiAgLCBQUk9UTyAgPSA4XHJcbiAgLCBCSU5EICAgPSAxNlxyXG4gICwgV1JBUCAgID0gMzI7XHJcbmZ1bmN0aW9uICRkZWZpbmUodHlwZSwgbmFtZSwgc291cmNlKXtcclxuICB2YXIga2V5LCBvd24sIG91dCwgZXhwXHJcbiAgICAsIGlzR2xvYmFsID0gdHlwZSAmIEdMT0JBTFxyXG4gICAgLCB0YXJnZXQgICA9IGlzR2xvYmFsID8gZ2xvYmFsIDogKHR5cGUgJiBTVEFUSUMpXHJcbiAgICAgICAgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IE9iamVjdFByb3RvKVtQUk9UT1RZUEVdXHJcbiAgICAsIGV4cG9ydHMgID0gaXNHbG9iYWwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcclxuICBpZihpc0dsb2JhbClzb3VyY2UgPSBuYW1lO1xyXG4gIGZvcihrZXkgaW4gc291cmNlKXtcclxuICAgIC8vIHRoZXJlIGlzIGEgc2ltaWxhciBuYXRpdmVcclxuICAgIG93biA9ICEodHlwZSAmIEZPUkNFRCkgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXRcclxuICAgICAgJiYgKCFpc0Z1bmN0aW9uKHRhcmdldFtrZXldKSB8fCBpc05hdGl2ZSh0YXJnZXRba2V5XSkpO1xyXG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcclxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XHJcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcclxuICAgIGlmKCFmcmFtZXdvcmsgJiYgaXNHbG9iYWwgJiYgIWlzRnVuY3Rpb24odGFyZ2V0W2tleV0pKWV4cCA9IHNvdXJjZVtrZXldO1xyXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcclxuICAgIGVsc2UgaWYodHlwZSAmIEJJTkQgJiYgb3duKWV4cCA9IGN0eChvdXQsIGdsb2JhbCk7XHJcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxyXG4gICAgZWxzZSBpZih0eXBlICYgV1JBUCAmJiAhZnJhbWV3b3JrICYmIHRhcmdldFtrZXldID09IG91dCl7XHJcbiAgICAgIGV4cCA9IGZ1bmN0aW9uKHBhcmFtKXtcclxuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG91dCA/IG5ldyBvdXQocGFyYW0pIDogb3V0KHBhcmFtKTtcclxuICAgICAgfVxyXG4gICAgICBleHBbUFJPVE9UWVBFXSA9IG91dFtQUk9UT1RZUEVdO1xyXG4gICAgfSBlbHNlIGV4cCA9IHR5cGUgJiBQUk9UTyAmJiBpc0Z1bmN0aW9uKG91dCkgPyBjdHgoY2FsbCwgb3V0KSA6IG91dDtcclxuICAgIC8vIGV4dGVuZCBnbG9iYWxcclxuICAgIGlmKGZyYW1ld29yayAmJiB0YXJnZXQgJiYgIW93bil7XHJcbiAgICAgIGlmKGlzR2xvYmFsKXRhcmdldFtrZXldID0gb3V0O1xyXG4gICAgICBlbHNlIGRlbGV0ZSB0YXJnZXRba2V5XSAmJiBoaWRkZW4odGFyZ2V0LCBrZXksIG91dCk7XHJcbiAgICB9XHJcbiAgICAvLyBleHBvcnRcclxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpaGlkZGVuKGV4cG9ydHMsIGtleSwgZXhwKTtcclxuICB9XHJcbn1cclxuLy8gQ29tbW9uSlMgZXhwb3J0XHJcbmlmKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpbW9kdWxlLmV4cG9ydHMgPSBjb3JlO1xyXG4vLyBSZXF1aXJlSlMgZXhwb3J0XHJcbmVsc2UgaWYoaXNGdW5jdGlvbihkZWZpbmUpICYmIGRlZmluZS5hbWQpZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIGNvcmV9KTtcclxuLy8gRXhwb3J0IHRvIGdsb2JhbCBvYmplY3RcclxuZWxzZSBleHBvcnRHbG9iYWwgPSB0cnVlO1xyXG5pZihleHBvcnRHbG9iYWwgfHwgZnJhbWV3b3JrKXtcclxuICBjb3JlLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpe1xyXG4gICAgZ2xvYmFsLmNvcmUgPSBvbGQ7XHJcbiAgICByZXR1cm4gY29yZTtcclxuICB9XHJcbiAgZ2xvYmFsLmNvcmUgPSBjb3JlO1xyXG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGNvbW1vbi5pdGVyYXRvcnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblNZTUJPTF9JVEVSQVRPUiA9IGdldFdlbGxLbm93blN5bWJvbChJVEVSQVRPUik7XHJcbnZhciBJVEVSICA9IHNhZmVTeW1ib2woJ2l0ZXInKVxyXG4gICwgS0VZICAgPSAxXHJcbiAgLCBWQUxVRSA9IDJcclxuICAsIEl0ZXJhdG9ycyA9IHt9XHJcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9XHJcbiAgICAvLyBTYWZhcmkgaGFzIGJ5Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXHJcbiAgLCBCVUdHWV9JVEVSQVRPUlMgPSAna2V5cycgaW4gQXJyYXlQcm90byAmJiAhKCduZXh0JyBpbiBbXS5rZXlzKCkpO1xyXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxyXG5zZXRJdGVyYXRvcihJdGVyYXRvclByb3RvdHlwZSwgcmV0dXJuVGhpcyk7XHJcbmZ1bmN0aW9uIHNldEl0ZXJhdG9yKE8sIHZhbHVlKXtcclxuICBoaWRkZW4oTywgU1lNQk9MX0lURVJBVE9SLCB2YWx1ZSk7XHJcbiAgLy8gQWRkIGl0ZXJhdG9yIGZvciBGRiBpdGVyYXRvciBwcm90b2NvbFxyXG4gIEZGX0lURVJBVE9SIGluIEFycmF5UHJvdG8gJiYgaGlkZGVuKE8sIEZGX0lURVJBVE9SLCB2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIHByb3RvKXtcclxuICBDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gY3JlYXRlKHByb3RvIHx8IEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xyXG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yKENvbnN0cnVjdG9yLCBOQU1FLCB2YWx1ZSwgREVGQVVMVCl7XHJcbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3JbUFJPVE9UWVBFXVxyXG4gICAgLCBpdGVyICA9IGdldChwcm90bywgU1lNQk9MX0lURVJBVE9SKSB8fCBnZXQocHJvdG8sIEZGX0lURVJBVE9SKSB8fCAoREVGQVVMVCAmJiBnZXQocHJvdG8sIERFRkFVTFQpKSB8fCB2YWx1ZTtcclxuICBpZihmcmFtZXdvcmspe1xyXG4gICAgLy8gRGVmaW5lIGl0ZXJhdG9yXHJcbiAgICBzZXRJdGVyYXRvcihwcm90bywgaXRlcik7XHJcbiAgICBpZihpdGVyICE9PSB2YWx1ZSl7XHJcbiAgICAgIHZhciBpdGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihpdGVyLmNhbGwobmV3IENvbnN0cnVjdG9yKSk7XHJcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcclxuICAgICAgc2V0VG9TdHJpbmdUYWcoaXRlclByb3RvLCBOQU1FICsgJyBJdGVyYXRvcicsIHRydWUpO1xyXG4gICAgICAvLyBGRiBmaXhcclxuICAgICAgaGFzKHByb3RvLCBGRl9JVEVSQVRPUikgJiYgc2V0SXRlcmF0b3IoaXRlclByb3RvLCByZXR1cm5UaGlzKTtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxyXG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGl0ZXI7XHJcbiAgLy8gRkYgJiB2OCBmaXhcclxuICBJdGVyYXRvcnNbTkFNRSArICcgSXRlcmF0b3InXSA9IHJldHVyblRoaXM7XHJcbiAgcmV0dXJuIGl0ZXI7XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lU3RkSXRlcmF0b3JzKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQpe1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZXIoa2luZCl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTtcclxuICAgIH1cclxuICB9XHJcbiAgY3JlYXRlSXRlcmF0b3IoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xyXG4gIHZhciBlbnRyaWVzID0gY3JlYXRlSXRlcihLRVkrVkFMVUUpXHJcbiAgICAsIHZhbHVlcyAgPSBjcmVhdGVJdGVyKFZBTFVFKTtcclxuICBpZihERUZBVUxUID09IFZBTFVFKXZhbHVlcyA9IGRlZmluZUl0ZXJhdG9yKEJhc2UsIE5BTUUsIHZhbHVlcywgJ3ZhbHVlcycpO1xyXG4gIGVsc2UgZW50cmllcyA9IGRlZmluZUl0ZXJhdG9yKEJhc2UsIE5BTUUsIGVudHJpZXMsICdlbnRyaWVzJyk7XHJcbiAgaWYoREVGQVVMVCl7XHJcbiAgICAkZGVmaW5lKFBST1RPICsgRk9SQ0VEICogQlVHR1lfSVRFUkFUT1JTLCBOQU1FLCB7XHJcbiAgICAgIGVudHJpZXM6IGVudHJpZXMsXHJcbiAgICAgIGtleXM6IElTX1NFVCA/IHZhbHVlcyA6IGNyZWF0ZUl0ZXIoS0VZKSxcclxuICAgICAgdmFsdWVzOiB2YWx1ZXNcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpdGVyUmVzdWx0KGRvbmUsIHZhbHVlKXtcclxuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcclxufVxyXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKGl0KXtcclxuICB2YXIgTyAgICAgID0gT2JqZWN0KGl0KVxyXG4gICAgLCBTeW1ib2wgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICAgLCBoYXNFeHQgPSAoU3ltYm9sICYmIFN5bWJvbFtJVEVSQVRPUl0gfHwgRkZfSVRFUkFUT1IpIGluIE87XHJcbiAgcmV0dXJuIGhhc0V4dCB8fCBTWU1CT0xfSVRFUkFUT1IgaW4gTyB8fCBoYXMoSXRlcmF0b3JzLCBjbGFzc29mKE8pKTtcclxufVxyXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihpdCl7XHJcbiAgdmFyIFN5bWJvbCAgPSBnbG9iYWxbU1lNQk9MXVxyXG4gICAgLCBleHQgICAgID0gaXRbU3ltYm9sICYmIFN5bWJvbFtJVEVSQVRPUl0gfHwgRkZfSVRFUkFUT1JdXHJcbiAgICAsIGdldEl0ZXIgPSBleHQgfHwgaXRbU1lNQk9MX0lURVJBVE9SXSB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xyXG4gIHJldHVybiBhc3NlcnRPYmplY3QoZ2V0SXRlci5jYWxsKGl0KSk7XHJcbn1cclxuZnVuY3Rpb24gc3RlcENhbGwoZm4sIHZhbHVlLCBlbnRyaWVzKXtcclxuICByZXR1cm4gZW50cmllcyA/IGludm9rZShmbiwgdmFsdWUpIDogZm4odmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrRGFuZ2VySXRlckNsb3NpbmcoZm4pe1xyXG4gIHZhciBkYW5nZXIgPSB0cnVlO1xyXG4gIHZhciBPID0ge1xyXG4gICAgbmV4dDogZnVuY3Rpb24oKXsgdGhyb3cgMSB9LFxyXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uKCl7IGRhbmdlciA9IGZhbHNlIH1cclxuICB9O1xyXG4gIE9bU1lNQk9MX0lURVJBVE9SXSA9IHJldHVyblRoaXM7XHJcbiAgdHJ5IHtcclxuICAgIGZuKE8pO1xyXG4gIH0gY2F0Y2goZSl7fVxyXG4gIHJldHVybiBkYW5nZXI7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VJdGVyYXRvcihpdGVyYXRvcil7XHJcbiAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcclxuICBpZihyZXQgIT09IHVuZGVmaW5lZClyZXQuY2FsbChpdGVyYXRvcik7XHJcbn1cclxuZnVuY3Rpb24gc2FmZUl0ZXJDbG9zZShleGVjLCBpdGVyYXRvcil7XHJcbiAgdHJ5IHtcclxuICAgIGV4ZWMoaXRlcmF0b3IpO1xyXG4gIH0gY2F0Y2goZSl7XHJcbiAgICBjbG9zZUl0ZXJhdG9yKGl0ZXJhdG9yKTtcclxuICAgIHRocm93IGU7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGZvck9mKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCl7XHJcbiAgc2FmZUl0ZXJDbG9zZShmdW5jdGlvbihpdGVyYXRvcil7XHJcbiAgICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxyXG4gICAgICAsIHN0ZXA7XHJcbiAgICB3aGlsZSghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpaWYoc3RlcENhbGwoZiwgc3RlcC52YWx1ZSwgZW50cmllcykgPT09IGZhbHNlKXtcclxuICAgICAgcmV0dXJuIGNsb3NlSXRlcmF0b3IoaXRlcmF0b3IpO1xyXG4gICAgfVxyXG4gIH0sIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSk7XHJcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LnN5bWJvbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxyXG4hZnVuY3Rpb24oVEFHLCBTeW1ib2xSZWdpc3RyeSwgQWxsU3ltYm9scywgc2V0dGVyKXtcclxuICAvLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcclxuICBpZighaXNOYXRpdmUoU3ltYm9sKSl7XHJcbiAgICBTeW1ib2wgPSBmdW5jdGlvbihkZXNjcmlwdGlvbil7XHJcbiAgICAgIGFzc2VydCghKHRoaXMgaW5zdGFuY2VvZiBTeW1ib2wpLCBTWU1CT0wgKyAnIGlzIG5vdCBhICcgKyBDT05TVFJVQ1RPUik7XHJcbiAgICAgIHZhciB0YWcgPSB1aWQoZGVzY3JpcHRpb24pXHJcbiAgICAgICAgLCBzeW0gPSBzZXQoY3JlYXRlKFN5bWJvbFtQUk9UT1RZUEVdKSwgVEFHLCB0YWcpO1xyXG4gICAgICBBbGxTeW1ib2xzW3RhZ10gPSBzeW07XHJcbiAgICAgIERFU0MgJiYgc2V0dGVyICYmIGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvLCB0YWcsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgICAgICBoaWRkZW4odGhpcywgdGFnLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHN5bTtcclxuICAgIH1cclxuICAgIGhpZGRlbihTeW1ib2xbUFJPVE9UWVBFXSwgVE9fU1RSSU5HLCBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gdGhpc1tUQUddO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gICRkZWZpbmUoR0xPQkFMICsgV1JBUCwge1N5bWJvbDogU3ltYm9sfSk7XHJcbiAgXHJcbiAgdmFyIHN5bWJvbFN0YXRpY3MgPSB7XHJcbiAgICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcclxuICAgICdmb3InOiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXHJcbiAgICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXHJcbiAgICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gU3ltYm9sKGtleSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMTkuNC4yLjQgU3ltYm9sLml0ZXJhdG9yXHJcbiAgICBpdGVyYXRvcjogU1lNQk9MX0lURVJBVE9SIHx8IGdldFdlbGxLbm93blN5bWJvbChJVEVSQVRPUiksXHJcbiAgICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcclxuICAgIGtleUZvcjogcGFydC5jYWxsKGtleU9mLCBTeW1ib2xSZWdpc3RyeSksXHJcbiAgICAvLyAxOS40LjIuMTAgU3ltYm9sLnNwZWNpZXNcclxuICAgIHNwZWNpZXM6IFNZTUJPTF9TUEVDSUVTLFxyXG4gICAgLy8gMTkuNC4yLjEzIFN5bWJvbC50b1N0cmluZ1RhZ1xyXG4gICAgdG9TdHJpbmdUYWc6IFNZTUJPTF9UQUcgPSBnZXRXZWxsS25vd25TeW1ib2woVE9fU1RSSU5HX1RBRywgdHJ1ZSksXHJcbiAgICAvLyAxOS40LjIuMTQgU3ltYm9sLnVuc2NvcGFibGVzXHJcbiAgICB1bnNjb3BhYmxlczogU1lNQk9MX1VOU0NPUEFCTEVTLFxyXG4gICAgcHVyZTogc2FmZVN5bWJvbCxcclxuICAgIHNldDogc2V0LFxyXG4gICAgdXNlU2V0dGVyOiBmdW5jdGlvbigpe3NldHRlciA9IHRydWV9LFxyXG4gICAgdXNlU2ltcGxlOiBmdW5jdGlvbigpe3NldHRlciA9IGZhbHNlfVxyXG4gIH07XHJcbiAgLy8gMTkuNC4yLjIgU3ltYm9sLmhhc0luc3RhbmNlXHJcbiAgLy8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxyXG4gIC8vIDE5LjQuMi42IFN5bWJvbC5tYXRjaFxyXG4gIC8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXHJcbiAgLy8gMTkuNC4yLjkgU3ltYm9sLnNlYXJjaFxyXG4gIC8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcclxuICAvLyAxOS40LjIuMTIgU3ltYm9sLnRvUHJpbWl0aXZlXHJcbiAgZm9yRWFjaC5jYWxsKGFycmF5KCdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BsaXQsdG9QcmltaXRpdmUnKSxcclxuICAgIGZ1bmN0aW9uKGl0KXtcclxuICAgICAgc3ltYm9sU3RhdGljc1tpdF0gPSBnZXRXZWxsS25vd25TeW1ib2woaXQpO1xyXG4gICAgfVxyXG4gICk7XHJcbiAgJGRlZmluZShTVEFUSUMsIFNZTUJPTCwgc3ltYm9sU3RhdGljcyk7XHJcbiAgXHJcbiAgc2V0VG9TdHJpbmdUYWcoU3ltYm9sLCBTWU1CT0wpO1xyXG4gIFxyXG4gICRkZWZpbmUoU1RBVElDICsgRk9SQ0VEICogIWlzTmF0aXZlKFN5bWJvbCksIE9CSkVDVCwge1xyXG4gICAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcclxuICAgIGdldE93blByb3BlcnR5TmFtZXM6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgdmFyIG5hbWVzID0gZ2V0TmFtZXModG9PYmplY3QoaXQpKSwgcmVzdWx0ID0gW10sIGtleSwgaSA9IDA7XHJcbiAgICAgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pIHx8IHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxyXG4gICAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIHZhciBuYW1lcyA9IGdldE5hbWVzKHRvT2JqZWN0KGl0KSksIHJlc3VsdCA9IFtdLCBrZXksIGkgPSAwO1xyXG4gICAgICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cclxuICBzZXRUb1N0cmluZ1RhZyhNYXRoLCBNQVRILCB0cnVlKTtcclxuICAvLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxyXG4gIHNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xyXG59KHNhZmVTeW1ib2woJ3RhZycpLCB7fSwge30sIHRydWUpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYub2JqZWN0LnN0YXRpY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICB2YXIgb2JqZWN0U3RhdGljID0ge1xyXG4gICAgLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcclxuICAgIGFzc2lnbjogYXNzaWduLFxyXG4gICAgLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcclxuICAgIGlzOiBmdW5jdGlvbih4LCB5KXtcclxuICAgICAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxyXG4gIC8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrcyB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cclxuICAnX19wcm90b19fJyBpbiBPYmplY3RQcm90byAmJiBmdW5jdGlvbihidWdneSwgc2V0KXtcclxuICAgIHRyeSB7XHJcbiAgICAgIHNldCA9IGN0eChjYWxsLCBnZXRPd25EZXNjcmlwdG9yKE9iamVjdFByb3RvLCAnX19wcm90b19fJykuc2V0LCAyKTtcclxuICAgICAgc2V0KHt9LCBBcnJheVByb3RvKTtcclxuICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZSB9XHJcbiAgICBvYmplY3RTdGF0aWMuc2V0UHJvdG90eXBlT2YgPSBzZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8sIHByb3RvKXtcclxuICAgICAgYXNzZXJ0T2JqZWN0KE8pO1xyXG4gICAgICBhc3NlcnQocHJvdG8gPT09IG51bGwgfHwgaXNPYmplY3QocHJvdG8pLCBwcm90bywgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xyXG4gICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xyXG4gICAgICBlbHNlIHNldChPLCBwcm90byk7XHJcbiAgICAgIHJldHVybiBPO1xyXG4gICAgfVxyXG4gIH0oKTtcclxuICAkZGVmaW5lKFNUQVRJQywgT0JKRUNULCBvYmplY3RTdGF0aWMpO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5vYmplY3QucHJvdG90eXBlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbih0bXApe1xyXG4gIC8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxyXG4gIHRtcFtTWU1CT0xfVEFHXSA9IERPVDtcclxuICBpZihjb2YodG1wKSAhPSBET1QpaGlkZGVuKE9iamVjdFByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XHJcbiAgfSk7XHJcbn0oe30pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYub2JqZWN0LnN0YXRpY3MtYWNjZXB0LXByaW1pdGl2ZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICAvLyBPYmplY3Qgc3RhdGljIG1ldGhvZHMgYWNjZXB0IHByaW1pdGl2ZXNcclxuICBmdW5jdGlvbiB3cmFwT2JqZWN0TWV0aG9kKGtleSwgTU9ERSl7XHJcbiAgICB2YXIgZm4gID0gT2JqZWN0W2tleV1cclxuICAgICAgLCBleHAgPSBjb3JlW09CSkVDVF1ba2V5XVxyXG4gICAgICAsIGYgICA9IDBcclxuICAgICAgLCBvICAgPSB7fTtcclxuICAgIGlmKCFleHAgfHwgaXNOYXRpdmUoZXhwKSl7XHJcbiAgICAgIG9ba2V5XSA9IE1PREUgPT0gMSA/IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gZm4oaXQpIDogaXQ7XHJcbiAgICAgIH0gOiBNT0RFID09IDIgPyBmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IHRydWU7XHJcbiAgICAgIH0gOiBNT0RFID09IDMgPyBmdW5jdGlvbihpdCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IGZuKGl0KSA6IGZhbHNlO1xyXG4gICAgICB9IDogTU9ERSA9PSA0ID8gZnVuY3Rpb24oaXQsIGtleSl7XHJcbiAgICAgICAgcmV0dXJuIGZuKHRvT2JqZWN0KGl0KSwga2V5KTtcclxuICAgICAgfSA6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgICByZXR1cm4gZm4odG9PYmplY3QoaXQpKTtcclxuICAgICAgfTtcclxuICAgICAgdHJ5IHsgZm4oRE9UKSB9XHJcbiAgICAgIGNhdGNoKGUpeyBmID0gMSB9XHJcbiAgICAgICRkZWZpbmUoU1RBVElDICsgRk9SQ0VEICogZiwgT0JKRUNULCBvKTtcclxuICAgIH1cclxuICB9XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnZnJlZXplJywgMSk7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnc2VhbCcsIDEpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ3ByZXZlbnRFeHRlbnNpb25zJywgMSk7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgnaXNGcm96ZW4nLCAyKTtcclxuICB3cmFwT2JqZWN0TWV0aG9kKCdpc1NlYWxlZCcsIDIpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2lzRXh0ZW5zaWJsZScsIDMpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIDQpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2dldFByb3RvdHlwZU9mJyk7XHJcbiAgd3JhcE9iamVjdE1ldGhvZCgna2V5cycpO1xyXG4gIHdyYXBPYmplY3RNZXRob2QoJ2dldE93blByb3BlcnR5TmFtZXMnKTtcclxufSgpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuZnVuY3Rpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oTkFNRSl7XHJcbiAgLy8gMTkuMi40LjIgbmFtZVxyXG4gIE5BTUUgaW4gRnVuY3Rpb25Qcm90byB8fCAoREVTQyAmJiBkZWZpbmVQcm9wZXJ0eShGdW5jdGlvblByb3RvLCBOQU1FLCB7XHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHZhciBtYXRjaCA9IFN0cmluZyh0aGlzKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoW14gKF0qKS8pXHJcbiAgICAgICAgLCBuYW1lICA9IG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcclxuICAgICAgaGFzKHRoaXMsIE5BTUUpIHx8IGRlZmluZVByb3BlcnR5KHRoaXMsIE5BTUUsIGRlc2NyaXB0b3IoNSwgbmFtZSkpO1xyXG4gICAgICByZXR1cm4gbmFtZTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgaGFzKHRoaXMsIE5BTUUpIHx8IGRlZmluZVByb3BlcnR5KHRoaXMsIE5BTUUsIGRlc2NyaXB0b3IoMCwgdmFsdWUpKTtcclxuICAgIH1cclxuICB9KSk7XHJcbn0oJ25hbWUnKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm51bWJlci5jb25zdHJ1Y3RvciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuTnVtYmVyKCcwbzEnKSAmJiBOdW1iZXIoJzBiMScpIHx8IGZ1bmN0aW9uKF9OdW1iZXIsIE51bWJlclByb3RvKXtcclxuICBmdW5jdGlvbiB0b051bWJlcihpdCl7XHJcbiAgICBpZihpc09iamVjdChpdCkpaXQgPSB0b1ByaW1pdGl2ZShpdCk7XHJcbiAgICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMiAmJiBpdC5jaGFyQ29kZUF0KDApID09IDQ4KXtcclxuICAgICAgdmFyIGJpbmFyeSA9IGZhbHNlO1xyXG4gICAgICBzd2l0Y2goaXQuY2hhckNvZGVBdCgxKSl7XHJcbiAgICAgICAgY2FzZSA2NiA6IGNhc2UgOTggIDogYmluYXJ5ID0gdHJ1ZTtcclxuICAgICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByZXR1cm4gcGFyc2VJbnQoaXQuc2xpY2UoMiksIGJpbmFyeSA/IDIgOiA4KTtcclxuICAgICAgfVxyXG4gICAgfSByZXR1cm4gK2l0O1xyXG4gIH1cclxuICBmdW5jdGlvbiB0b1ByaW1pdGl2ZShpdCl7XHJcbiAgICB2YXIgZm4sIHZhbDtcclxuICAgIGlmKGlzRnVuY3Rpb24oZm4gPSBpdC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XHJcbiAgICBpZihpc0Z1bmN0aW9uKGZuID0gaXRbVE9fU1RSSU5HXSkgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xyXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gbnVtYmVyXCIpO1xyXG4gIH1cclxuICBOdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIoaXQpe1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBOdW1iZXIgPyBuZXcgX051bWJlcih0b051bWJlcihpdCkpIDogdG9OdW1iZXIoaXQpO1xyXG4gIH1cclxuICBmb3JFYWNoLmNhbGwoREVTQyA/IGdldE5hbWVzKF9OdW1iZXIpXHJcbiAgOiBhcnJheSgnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFknKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgIGtleSBpbiBOdW1iZXIgfHwgZGVmaW5lUHJvcGVydHkoTnVtYmVyLCBrZXksIGdldE93bkRlc2NyaXB0b3IoX051bWJlciwga2V5KSk7XHJcbiAgfSk7XHJcbiAgTnVtYmVyW1BST1RPVFlQRV0gPSBOdW1iZXJQcm90bztcclxuICBOdW1iZXJQcm90b1tDT05TVFJVQ1RPUl0gPSBOdW1iZXI7XHJcbiAgaGlkZGVuKGdsb2JhbCwgTlVNQkVSLCBOdW1iZXIpO1xyXG59KE51bWJlciwgTnVtYmVyW1BST1RPVFlQRV0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYubnVtYmVyLnN0YXRpY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oaXNJbnRlZ2VyKXtcclxuICAkZGVmaW5lKFNUQVRJQywgTlVNQkVSLCB7XHJcbiAgICAvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxyXG4gICAgRVBTSUxPTjogcG93KDIsIC01MiksXHJcbiAgICAvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxyXG4gICAgaXNGaW5pdGU6IGZ1bmN0aW9uKGl0KXtcclxuICAgICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShpdCk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXHJcbiAgICBpc0ludGVnZXI6IGlzSW50ZWdlcixcclxuICAgIC8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXHJcbiAgICBpc05hTjogc2FtZU5hTixcclxuICAgIC8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcclxuICAgIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uKG51bWJlcil7XHJcbiAgICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSOiBNQVhfU0FGRV9JTlRFR0VSLFxyXG4gICAgLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXHJcbiAgICBNSU5fU0FGRV9JTlRFR0VSOiAtTUFYX1NBRkVfSU5URUdFUixcclxuICAgIC8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXHJcbiAgICBwYXJzZUZsb2F0OiBwYXJzZUZsb2F0LFxyXG4gICAgLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxyXG4gICAgcGFyc2VJbnQ6IHBhcnNlSW50XHJcbiAgfSk7XHJcbi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxyXG59KE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24oaXQpe1xyXG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xyXG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2Lm1hdGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gRUNNQVNjcmlwdCA2IHNoaW1cclxuIWZ1bmN0aW9uKCl7XHJcbiAgLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxyXG4gIHZhciBFICAgID0gTWF0aC5FXHJcbiAgICAsIGV4cCAgPSBNYXRoLmV4cFxyXG4gICAgLCBsb2cgID0gTWF0aC5sb2dcclxuICAgICwgc3FydCA9IE1hdGguc3FydFxyXG4gICAgLCBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpe1xyXG4gICAgICAgIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcclxuICAgICAgfTtcclxuICBcclxuICAvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXHJcbiAgZnVuY3Rpb24gYXNpbmgoeCl7XHJcbiAgICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IGxvZyh4ICsgc3FydCh4ICogeCArIDEpKTtcclxuICB9XHJcbiAgLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcclxuICBmdW5jdGlvbiBleHBtMSh4KXtcclxuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBleHAoeCkgLSAxO1xyXG4gIH1cclxuICAgIFxyXG4gICRkZWZpbmUoU1RBVElDLCBNQVRILCB7XHJcbiAgICAvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXHJcbiAgICBhY29zaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiBpc0Zpbml0ZSh4KSA/IGxvZyh4IC8gRSArIHNxcnQoeCArIDEpICogc3FydCh4IC0gMSkgLyBFKSArIDEgOiB4O1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcclxuICAgIGFzaW5oOiBhc2luaCxcclxuICAgIC8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcclxuICAgIGF0YW5oOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogbG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXHJcbiAgICBjYnJ0OiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIHBvdyhhYnMoeCksIDEgLyAzKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxyXG4gICAgY2x6MzI6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMyIC0geFtUT19TVFJJTkddKDIpLmxlbmd0aCA6IDMyO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcclxuICAgIGNvc2g6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXHJcbiAgICBleHBtMTogZXhwbTEsXHJcbiAgICAvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcclxuICAgIC8vIFRPRE86IGZhbGxiYWNrIGZvciBJRTktXHJcbiAgICBmcm91bmQ6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbeF0pWzBdO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxyXG4gICAgaHlwb3Q6IGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKXtcclxuICAgICAgdmFyIHN1bSAgPSAwXHJcbiAgICAgICAgLCBsZW4xID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgbGVuMiA9IGxlbjFcclxuICAgICAgICAsIGFyZ3MgPSBBcnJheShsZW4xKVxyXG4gICAgICAgICwgbGFyZyA9IC1JbmZpbml0eVxyXG4gICAgICAgICwgYXJnO1xyXG4gICAgICB3aGlsZShsZW4xLS0pe1xyXG4gICAgICAgIGFyZyA9IGFyZ3NbbGVuMV0gPSArYXJndW1lbnRzW2xlbjFdO1xyXG4gICAgICAgIGlmKGFyZyA9PSBJbmZpbml0eSB8fCBhcmcgPT0gLUluZmluaXR5KXJldHVybiBJbmZpbml0eTtcclxuICAgICAgICBpZihhcmcgPiBsYXJnKWxhcmcgPSBhcmc7XHJcbiAgICAgIH1cclxuICAgICAgbGFyZyA9IGFyZyB8fCAxO1xyXG4gICAgICB3aGlsZShsZW4yLS0pc3VtICs9IHBvdyhhcmdzW2xlbjJdIC8gbGFyZywgMik7XHJcbiAgICAgIHJldHVybiBsYXJnICogc3FydChzdW0pO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcclxuICAgIGltdWw6IGZ1bmN0aW9uKHgsIHkpe1xyXG4gICAgICB2YXIgVUludDE2ID0gMHhmZmZmXHJcbiAgICAgICAgLCB4biA9ICt4XHJcbiAgICAgICAgLCB5biA9ICt5XHJcbiAgICAgICAgLCB4bCA9IFVJbnQxNiAmIHhuXHJcbiAgICAgICAgLCB5bCA9IFVJbnQxNiAmIHluO1xyXG4gICAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJbnQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJbnQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXHJcbiAgICBsb2cxcDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IGxvZygxICsgeCk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcclxuICAgIGxvZzEwOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIGxvZyh4KSAvIE1hdGguTE4xMDtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXHJcbiAgICBsb2cyOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIGxvZyh4KSAvIE1hdGguTE4yO1xyXG4gICAgfSxcclxuICAgIC8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcclxuICAgIHNpZ246IHNpZ24sXHJcbiAgICAvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXHJcbiAgICBzaW5oOiBmdW5jdGlvbih4KXtcclxuICAgICAgcmV0dXJuIChhYnMoeCA9ICt4KSA8IDEpID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDIgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChFIC8gMik7XHJcbiAgICB9LFxyXG4gICAgLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxyXG4gICAgdGFuaDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KVxyXG4gICAgICAgICwgYiA9IGV4cG0xKC14KTtcclxuICAgICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxyXG4gICAgdHJ1bmM6IHRydW5jXHJcbiAgfSk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LnN0cmluZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKGZyb21DaGFyQ29kZSl7XHJcbiAgZnVuY3Rpb24gYXNzZXJ0Tm90UmVnRXhwKGl0KXtcclxuICAgIGlmKGNvZihpdCkgPT0gUkVHRVhQKXRocm93IFR5cGVFcnJvcigpO1xyXG4gIH1cclxuICBcclxuICAkZGVmaW5lKFNUQVRJQywgU1RSSU5HLCB7XHJcbiAgICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxyXG4gICAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24oeCl7XHJcbiAgICAgIHZhciByZXMgPSBbXVxyXG4gICAgICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgaSAgID0gMFxyXG4gICAgICAgICwgY29kZVxyXG4gICAgICB3aGlsZShsZW4gPiBpKXtcclxuICAgICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xyXG4gICAgICAgIGlmKHRvSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKXRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xyXG4gICAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXHJcbiAgICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxyXG4gICAgICAgICAgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxyXG4gICAgcmF3OiBmdW5jdGlvbihjYWxsU2l0ZSl7XHJcbiAgICAgIHZhciByYXcgPSB0b09iamVjdChjYWxsU2l0ZS5yYXcpXHJcbiAgICAgICAgLCBsZW4gPSB0b0xlbmd0aChyYXcubGVuZ3RoKVxyXG4gICAgICAgICwgc2xuID0gYXJndW1lbnRzLmxlbmd0aFxyXG4gICAgICAgICwgcmVzID0gW11cclxuICAgICAgICAsIGkgICA9IDA7XHJcbiAgICAgIHdoaWxlKGxlbiA+IGkpe1xyXG4gICAgICAgIHJlcy5wdXNoKFN0cmluZyhyYXdbaSsrXSkpO1xyXG4gICAgICAgIGlmKGkgPCBzbG4pcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICB9IHJldHVybiByZXMuam9pbignJyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgJGRlZmluZShQUk9UTywgU1RSSU5HLCB7XHJcbiAgICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcclxuICAgIGNvZGVQb2ludEF0OiBjcmVhdGVQb2ludEF0KGZhbHNlKSxcclxuICAgIC8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcclxuICAgIGVuZHNXaXRoOiBmdW5jdGlvbihzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XHJcbiAgICAgIGFzc2VydE5vdFJlZ0V4cChzZWFyY2hTdHJpbmcpO1xyXG4gICAgICB2YXIgdGhhdCA9IFN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAgICwgZW5kUG9zaXRpb24gPSBhcmd1bWVudHNbMV1cclxuICAgICAgICAsIGxlbiA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKVxyXG4gICAgICAgICwgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IG1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XHJcbiAgICAgIHNlYXJjaFN0cmluZyArPSAnJztcclxuICAgICAgcmV0dXJuIHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoU3RyaW5nLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoU3RyaW5nO1xyXG4gICAgfSxcclxuICAgIC8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXHJcbiAgICBpbmNsdWRlczogZnVuY3Rpb24oc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xyXG4gICAgICBhc3NlcnROb3RSZWdFeHAoc2VhcmNoU3RyaW5nKTtcclxuICAgICAgcmV0dXJuICEhflN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKS5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzWzFdKTtcclxuICAgIH0sXHJcbiAgICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXHJcbiAgICByZXBlYXQ6IGZ1bmN0aW9uKGNvdW50KXtcclxuICAgICAgdmFyIHN0ciA9IFN0cmluZyhhc3NlcnREZWZpbmVkKHRoaXMpKVxyXG4gICAgICAgICwgcmVzID0gJydcclxuICAgICAgICAsIG4gICA9IHRvSW50ZWdlcihjb3VudCk7XHJcbiAgICAgIGlmKDAgPiBuIHx8IG4gPT0gSW5maW5pdHkpdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xyXG4gICAgICBmb3IoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSlpZihuICYgMSlyZXMgKz0gc3RyO1xyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSxcclxuICAgIC8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXHJcbiAgICBzdGFydHNXaXRoOiBmdW5jdGlvbihzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XHJcbiAgICAgIGFzc2VydE5vdFJlZ0V4cChzZWFyY2hTdHJpbmcpO1xyXG4gICAgICB2YXIgdGhhdCAgPSBTdHJpbmcoYXNzZXJ0RGVmaW5lZCh0aGlzKSlcclxuICAgICAgICAsIGluZGV4ID0gdG9MZW5ndGgobWluKGFyZ3VtZW50c1sxXSwgdGhhdC5sZW5ndGgpKTtcclxuICAgICAgc2VhcmNoU3RyaW5nICs9ICcnO1xyXG4gICAgICByZXR1cm4gdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KFN0cmluZy5mcm9tQ2hhckNvZGUpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuYXJyYXkuc3RhdGljcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4hZnVuY3Rpb24oKXtcclxuICAkZGVmaW5lKFNUQVRJQyArIEZPUkNFRCAqIGNoZWNrRGFuZ2VySXRlckNsb3NpbmcoQXJyYXkuZnJvbSksIEFSUkFZLCB7XHJcbiAgICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXHJcbiAgICBmcm9tOiBmdW5jdGlvbihhcnJheUxpa2UvKiwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQqLyl7XHJcbiAgICAgIHZhciBPICAgICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQoYXJyYXlMaWtlKSlcclxuICAgICAgICAsIG1hcGZuICAgPSBhcmd1bWVudHNbMV1cclxuICAgICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgLCBmICAgICAgID0gbWFwcGluZyA/IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICwgaW5kZXggICA9IDBcclxuICAgICAgICAsIGxlbmd0aCwgcmVzdWx0LCBzdGVwO1xyXG4gICAgICBpZihpc0l0ZXJhYmxlKE8pKXtcclxuICAgICAgICByZXN1bHQgPSBuZXcgKGdlbmVyaWModGhpcywgQXJyYXkpKTtcclxuICAgICAgICBzYWZlSXRlckNsb3NlKGZ1bmN0aW9uKGl0ZXJhdG9yKXtcclxuICAgICAgICAgIGZvcig7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gZihzdGVwLnZhbHVlLCBpbmRleCkgOiBzdGVwLnZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIGdldEl0ZXJhdG9yKE8pKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSBuZXcgKGdlbmVyaWModGhpcywgQXJyYXkpKShsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCkpO1xyXG4gICAgICAgIGZvcig7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcclxuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBtYXBwaW5nID8gZihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICB9KTtcclxuICBcclxuICAkZGVmaW5lKFNUQVRJQywgQVJSQVksIHtcclxuICAgIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcclxuICAgIG9mOiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuICAgICAgdmFyIGluZGV4ICA9IDBcclxuICAgICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAsIHJlc3VsdCA9IG5ldyAoZ2VuZXJpYyh0aGlzLCBBcnJheSkpKGxlbmd0aCk7XHJcbiAgICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgc2V0U3BlY2llcyhBcnJheSk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM2LmFycmF5LnByb3RvdHlwZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgJGRlZmluZShQUk9UTywgQVJSQVksIHtcclxuICAgIC8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxyXG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24odGFyZ2V0IC8qID0gMCAqLywgc3RhcnQgLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcclxuICAgICAgdmFyIE8gICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICAgLCBsZW4gICA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxyXG4gICAgICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxyXG4gICAgICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXHJcbiAgICAgICAgLCBlbmQgICA9IGFyZ3VtZW50c1syXVxyXG4gICAgICAgICwgZmluICAgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pXHJcbiAgICAgICAgLCBjb3VudCA9IG1pbihmaW4gLSBmcm9tLCBsZW4gLSB0bylcclxuICAgICAgICAsIGluYyAgID0gMTtcclxuICAgICAgaWYoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KXtcclxuICAgICAgICBpbmMgID0gLTE7XHJcbiAgICAgICAgZnJvbSA9IGZyb20gKyBjb3VudCAtIDE7XHJcbiAgICAgICAgdG8gICA9IHRvICsgY291bnQgLSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlKGNvdW50LS0gPiAwKXtcclxuICAgICAgICBpZihmcm9tIGluIE8pT1t0b10gPSBPW2Zyb21dO1xyXG4gICAgICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xyXG4gICAgICAgIHRvICs9IGluYztcclxuICAgICAgICBmcm9tICs9IGluYztcclxuICAgICAgfSByZXR1cm4gTztcclxuICAgIH0sXHJcbiAgICAvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcclxuICAgIGZpbGw6IGZ1bmN0aW9uKHZhbHVlIC8qLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xyXG4gICAgICB2YXIgTyAgICAgID0gT2JqZWN0KGFzc2VydERlZmluZWQodGhpcykpXHJcbiAgICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcclxuICAgICAgICAsIGluZGV4ICA9IHRvSW5kZXgoYXJndW1lbnRzWzFdLCBsZW5ndGgpXHJcbiAgICAgICAgLCBlbmQgICAgPSBhcmd1bWVudHNbMl1cclxuICAgICAgICAsIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCk7XHJcbiAgICAgIHdoaWxlKGVuZFBvcyA+IGluZGV4KU9baW5kZXgrK10gPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIE87XHJcbiAgICB9LFxyXG4gICAgLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgZmluZDogY3JlYXRlQXJyYXlNZXRob2QoNSksXHJcbiAgICAvLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIGZpbmRJbmRleDogY3JlYXRlQXJyYXlNZXRob2QoNilcclxuICB9KTtcclxuICBcclxuICBpZihmcmFtZXdvcmspe1xyXG4gICAgLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxyXG4gICAgZm9yRWFjaC5jYWxsKGFycmF5KCdmaW5kLGZpbmRJbmRleCxmaWxsLGNvcHlXaXRoaW4sZW50cmllcyxrZXlzLHZhbHVlcycpLCBmdW5jdGlvbihpdCl7XHJcbiAgICAgIEFycmF5VW5zY29wYWJsZXNbaXRdID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgU1lNQk9MX1VOU0NPUEFCTEVTIGluIEFycmF5UHJvdG8gfHwgaGlkZGVuKEFycmF5UHJvdG8sIFNZTUJPTF9VTlNDT1BBQkxFUywgQXJyYXlVbnNjb3BhYmxlcyk7XHJcbiAgfVxyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5pdGVyYXRvcnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbihhdCl7XHJcbiAgLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxyXG4gIC8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXHJcbiAgLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxyXG4gIC8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxyXG4gIGRlZmluZVN0ZEl0ZXJhdG9ycyhBcnJheSwgQVJSQVksIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcclxuICAgIHNldCh0aGlzLCBJVEVSLCB7bzogdG9PYmplY3QoaXRlcmF0ZWQpLCBpOiAwLCBrOiBraW5kfSk7XHJcbiAgLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXHJcbiAgfSwgZnVuY3Rpb24oKXtcclxuICAgIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cclxuICAgICAgLCBPICAgICA9IGl0ZXIub1xyXG4gICAgICAsIGtpbmQgID0gaXRlci5rXHJcbiAgICAgICwgaW5kZXggPSBpdGVyLmkrKztcclxuICAgIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcclxuICAgICAgaXRlci5vID0gdW5kZWZpbmVkO1xyXG4gICAgICByZXR1cm4gaXRlclJlc3VsdCgxKTtcclxuICAgIH1cclxuICAgIGlmKGtpbmQgPT0gS0VZKSAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwgaW5kZXgpO1xyXG4gICAgaWYoa2luZCA9PSBWQUxVRSlyZXR1cm4gaXRlclJlc3VsdCgwLCBPW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyUmVzdWx0KDAsIFtpbmRleCwgT1tpbmRleF1dKTtcclxuICB9LCBWQUxVRSk7XHJcbiAgXHJcbiAgLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxyXG4gIEl0ZXJhdG9yc1tBUkdVTUVOVFNdID0gSXRlcmF0b3JzW0FSUkFZXTtcclxuICBcclxuICAvLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXHJcbiAgZGVmaW5lU3RkSXRlcmF0b3JzKFN0cmluZywgU1RSSU5HLCBmdW5jdGlvbihpdGVyYXRlZCl7XHJcbiAgICBzZXQodGhpcywgSVRFUiwge286IFN0cmluZyhpdGVyYXRlZCksIGk6IDB9KTtcclxuICAvLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXHJcbiAgfSwgZnVuY3Rpb24oKXtcclxuICAgIHZhciBpdGVyICA9IHRoaXNbSVRFUl1cclxuICAgICAgLCBPICAgICA9IGl0ZXIub1xyXG4gICAgICAsIGluZGV4ID0gaXRlci5pXHJcbiAgICAgICwgcG9pbnQ7XHJcbiAgICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4gaXRlclJlc3VsdCgxKTtcclxuICAgIHBvaW50ID0gYXQuY2FsbChPLCBpbmRleCk7XHJcbiAgICBpdGVyLmkgKz0gcG9pbnQubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwgcG9pbnQpO1xyXG4gIH0pO1xyXG59KGNyZWF0ZVBvaW50QXQodHJ1ZSkpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYucmVnZXhwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5ERVNDICYmICFmdW5jdGlvbihSZWdFeHBQcm90bywgX1JlZ0V4cCl7ICBcclxuICAvLyBSZWdFeHAgYWxsb3dzIGEgcmVnZXggd2l0aCBmbGFncyBhcyB0aGUgcGF0dGVyblxyXG4gIGlmKCFmdW5jdGlvbigpe3RyeXtyZXR1cm4gUmVnRXhwKC9hL2csICdpJykgPT0gJy9hL2knfWNhdGNoKGUpe319KCkpe1xyXG4gICAgUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHBhdHRlcm4sIGZsYWdzKXtcclxuICAgICAgcmV0dXJuIG5ldyBfUmVnRXhwKGNvZihwYXR0ZXJuKSA9PSBSRUdFWFAgJiYgZmxhZ3MgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgID8gcGF0dGVybi5zb3VyY2UgOiBwYXR0ZXJuLCBmbGFncyk7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoLmNhbGwoZ2V0TmFtZXMoX1JlZ0V4cCksIGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGtleSBpbiBSZWdFeHAgfHwgZGVmaW5lUHJvcGVydHkoUmVnRXhwLCBrZXksIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gX1JlZ0V4cFtrZXldIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihpdCl7IF9SZWdFeHBba2V5XSA9IGl0IH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIFJlZ0V4cFByb3RvW0NPTlNUUlVDVE9SXSA9IFJlZ0V4cDtcclxuICAgIFJlZ0V4cFtQUk9UT1RZUEVdID0gUmVnRXhwUHJvdG87XHJcbiAgICBoaWRkZW4oZ2xvYmFsLCBSRUdFWFAsIFJlZ0V4cCk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcclxuICBpZigvLi9nLmZsYWdzICE9ICdnJylkZWZpbmVQcm9wZXJ0eShSZWdFeHBQcm90bywgJ2ZsYWdzJywge1xyXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBjcmVhdGVSZXBsYWNlcigvXi4qXFwvKFxcdyopJC8sICckMScpXHJcbiAgfSk7XHJcbiAgXHJcbiAgc2V0U3BlY2llcyhSZWdFeHApO1xyXG59KFJlZ0V4cFtQUk9UT1RZUEVdLCBSZWdFeHApO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiB3ZWIuaW1tZWRpYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBzZXRJbW1lZGlhdGUgc2hpbVxyXG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBlbHNlOlxyXG5pc0Z1bmN0aW9uKHNldEltbWVkaWF0ZSkgJiYgaXNGdW5jdGlvbihjbGVhckltbWVkaWF0ZSkgfHwgZnVuY3Rpb24oT05SRUFEWVNUQVRFQ0hBTkdFKXtcclxuICB2YXIgcG9zdE1lc3NhZ2UgICAgICA9IGdsb2JhbC5wb3N0TWVzc2FnZVxyXG4gICAgLCBhZGRFdmVudExpc3RlbmVyID0gZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXJcclxuICAgICwgTWVzc2FnZUNoYW5uZWwgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxyXG4gICAgLCBjb3VudGVyICAgICAgICAgID0gMFxyXG4gICAgLCBxdWV1ZSAgICAgICAgICAgID0ge31cclxuICAgICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XHJcbiAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZm4pe1xyXG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XHJcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGludm9rZShpc0Z1bmN0aW9uKGZuKSA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGRlZmVyKGNvdW50ZXIpO1xyXG4gICAgcmV0dXJuIGNvdW50ZXI7XHJcbiAgfVxyXG4gIGNsZWFySW1tZWRpYXRlID0gZnVuY3Rpb24oaWQpe1xyXG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcnVuKGlkKXtcclxuICAgIGlmKGhhcyhxdWV1ZSwgaWQpKXtcclxuICAgICAgdmFyIGZuID0gcXVldWVbaWRdO1xyXG4gICAgICBkZWxldGUgcXVldWVbaWRdO1xyXG4gICAgICBmbigpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBsaXN0bmVyKGV2ZW50KXtcclxuICAgIHJ1bihldmVudC5kYXRhKTtcclxuICB9XHJcbiAgLy8gTm9kZS5qcyAwLjgtXHJcbiAgaWYoTk9ERSl7XHJcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcclxuICAgICAgbmV4dFRpY2socGFydC5jYWxsKHJ1biwgaWQpKTtcclxuICAgIH1cclxuICAvLyBNb2Rlcm4gYnJvd3NlcnMsIHNraXAgaW1wbGVtZW50YXRpb24gZm9yIFdlYldvcmtlcnNcclxuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyBvYmplY3RcclxuICB9IGVsc2UgaWYoYWRkRXZlbnRMaXN0ZW5lciAmJiBpc0Z1bmN0aW9uKHBvc3RNZXNzYWdlKSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xyXG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XHJcbiAgICAgIHBvc3RNZXNzYWdlKGlkLCAnKicpO1xyXG4gICAgfVxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RuZXIsIGZhbHNlKTtcclxuICAvLyBXZWJXb3JrZXJzXHJcbiAgfSBlbHNlIGlmKGlzRnVuY3Rpb24oTWVzc2FnZUNoYW5uZWwpKXtcclxuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XHJcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcclxuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdG5lcjtcclxuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xyXG4gIC8vIElFOC1cclxuICB9IGVsc2UgaWYoZG9jdW1lbnQgJiYgT05SRUFEWVNUQVRFQ0hBTkdFIGluIGRvY3VtZW50W0NSRUFURV9FTEVNRU5UXSgnc2NyaXB0Jykpe1xyXG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XHJcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnRbQ1JFQVRFX0VMRU1FTlRdKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcclxuICAgICAgICBydW4oaWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcclxuICB9IGVsc2Uge1xyXG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XHJcbiAgICAgIHNldFRpbWVvdXQocnVuLCAwLCBpZCk7XHJcbiAgICB9XHJcbiAgfVxyXG59KCdvbnJlYWR5c3RhdGVjaGFuZ2UnKTtcclxuJGRlZmluZShHTE9CQUwgKyBCSU5ELCB7XHJcbiAgc2V0SW1tZWRpYXRlOiAgIHNldEltbWVkaWF0ZSxcclxuICBjbGVhckltbWVkaWF0ZTogY2xlYXJJbW1lZGlhdGVcclxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5wcm9taXNlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEVTNiBwcm9taXNlcyBzaGltXHJcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRpZnkvbmF0aXZlLXByb21pc2Utb25seS9cclxuIWZ1bmN0aW9uKFByb21pc2UsIHRlc3Qpe1xyXG4gIGlzRnVuY3Rpb24oUHJvbWlzZSkgJiYgaXNGdW5jdGlvbihQcm9taXNlLnJlc29sdmUpXHJcbiAgJiYgUHJvbWlzZS5yZXNvbHZlKHRlc3QgPSBuZXcgUHJvbWlzZShmdW5jdGlvbigpe30pKSA9PSB0ZXN0XHJcbiAgfHwgZnVuY3Rpb24oYXNhcCwgUkVDT1JEKXtcclxuICAgIGZ1bmN0aW9uIGlzVGhlbmFibGUoaXQpe1xyXG4gICAgICB2YXIgdGhlbjtcclxuICAgICAgaWYoaXNPYmplY3QoaXQpKXRoZW4gPSBpdC50aGVuO1xyXG4gICAgICByZXR1cm4gaXNGdW5jdGlvbih0aGVuKSA/IHRoZW4gOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhbmRsZWRSZWplY3Rpb25Pckhhc09uUmVqZWN0ZWQocHJvbWlzZSl7XHJcbiAgICAgIHZhciByZWNvcmQgPSBwcm9taXNlW1JFQ09SRF1cclxuICAgICAgICAsIGNoYWluICA9IHJlY29yZC5jXHJcbiAgICAgICAgLCBpICAgICAgPSAwXHJcbiAgICAgICAgLCByZWFjdDtcclxuICAgICAgaWYocmVjb3JkLmgpcmV0dXJuIHRydWU7XHJcbiAgICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xyXG4gICAgICAgIHJlYWN0ID0gY2hhaW5baSsrXTtcclxuICAgICAgICBpZihyZWFjdC5mYWlsIHx8IGhhbmRsZWRSZWplY3Rpb25Pckhhc09uUmVqZWN0ZWQocmVhY3QuUCkpcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG5vdGlmeShyZWNvcmQsIHJlamVjdCl7XHJcbiAgICAgIHZhciBjaGFpbiA9IHJlY29yZC5jO1xyXG4gICAgICBpZihyZWplY3QgfHwgY2hhaW4ubGVuZ3RoKWFzYXAoZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IHJlY29yZC5wXHJcbiAgICAgICAgICAsIHZhbHVlICAgPSByZWNvcmQudlxyXG4gICAgICAgICAgLCBvayAgICAgID0gcmVjb3JkLnMgPT0gMVxyXG4gICAgICAgICAgLCBpICAgICAgID0gMDtcclxuICAgICAgICBpZihyZWplY3QgJiYgIWhhbmRsZWRSZWplY3Rpb25Pckhhc09uUmVqZWN0ZWQocHJvbWlzZSkpe1xyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZighaGFuZGxlZFJlamVjdGlvbk9ySGFzT25SZWplY3RlZChwcm9taXNlKSl7XHJcbiAgICAgICAgICAgICAgaWYoTk9ERSl7XHJcbiAgICAgICAgICAgICAgICBpZighcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSkpe1xyXG4gICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IG5vZGUuanMgYmVoYXZpb3JcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2UgaWYoaXNGdW5jdGlvbihjb25zb2xlLmVycm9yKSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LCAxZTMpO1xyXG4gICAgICAgIH0gZWxzZSB3aGlsZShjaGFpbi5sZW5ndGggPiBpKSFmdW5jdGlvbihyZWFjdCl7XHJcbiAgICAgICAgICB2YXIgY2IgPSBvayA/IHJlYWN0Lm9rIDogcmVhY3QuZmFpbFxyXG4gICAgICAgICAgICAsIHJldCwgdGhlbjtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmKGNiKXtcclxuICAgICAgICAgICAgICBpZighb2spcmVjb3JkLmggPSB0cnVlO1xyXG4gICAgICAgICAgICAgIHJldCA9IGNiID09PSB0cnVlID8gdmFsdWUgOiBjYih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgaWYocmV0ID09PSByZWFjdC5QKXtcclxuICAgICAgICAgICAgICAgIHJlYWN0LnJlaihUeXBlRXJyb3IoUFJPTUlTRSArICctY2hhaW4gY3ljbGUnKSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJldCkpe1xyXG4gICAgICAgICAgICAgICAgdGhlbi5jYWxsKHJldCwgcmVhY3QucmVzLCByZWFjdC5yZWopO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSByZWFjdC5yZXMocmV0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHJlYWN0LnJlaih2YWx1ZSk7XHJcbiAgICAgICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgICAgIHJlYWN0LnJlaihlcnIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0oY2hhaW5baSsrXSk7XHJcbiAgICAgICAgY2hhaW4ubGVuZ3RoID0gMDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKXtcclxuICAgICAgdmFyIHJlY29yZCA9IHRoaXNcclxuICAgICAgICAsIHRoZW4sIHdyYXBwZXI7XHJcbiAgICAgIGlmKHJlY29yZC5kKXJldHVybjtcclxuICAgICAgcmVjb3JkLmQgPSB0cnVlO1xyXG4gICAgICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XHJcbiAgICAgICAgICB3cmFwcGVyID0ge3I6IHJlY29yZCwgZDogZmFsc2V9OyAvLyB3cmFwXHJcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eChyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KHJlamVjdCwgd3JhcHBlciwgMSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZWNvcmQudiA9IHZhbHVlO1xyXG4gICAgICAgICAgcmVjb3JkLnMgPSAxO1xyXG4gICAgICAgICAgbm90aWZ5KHJlY29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgcmVqZWN0LmNhbGwod3JhcHBlciB8fCB7cjogcmVjb3JkLCBkOiBmYWxzZX0sIGVycik7IC8vIHdyYXBcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKXtcclxuICAgICAgdmFyIHJlY29yZCA9IHRoaXM7XHJcbiAgICAgIGlmKHJlY29yZC5kKXJldHVybjtcclxuICAgICAgcmVjb3JkLmQgPSB0cnVlO1xyXG4gICAgICByZWNvcmQgPSByZWNvcmQuciB8fCByZWNvcmQ7IC8vIHVud3JhcFxyXG4gICAgICByZWNvcmQudiA9IHZhbHVlO1xyXG4gICAgICByZWNvcmQucyA9IDI7XHJcbiAgICAgIG5vdGlmeShyZWNvcmQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3IoQyl7XHJcbiAgICAgIHZhciBTID0gYXNzZXJ0T2JqZWN0KEMpW1NZTUJPTF9TUEVDSUVTXTtcclxuICAgICAgcmV0dXJuIFMgIT0gdW5kZWZpbmVkID8gUyA6IEM7XHJcbiAgICB9XHJcbiAgICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxyXG4gICAgUHJvbWlzZSA9IGZ1bmN0aW9uKGV4ZWN1dG9yKXtcclxuICAgICAgYXNzZXJ0RnVuY3Rpb24oZXhlY3V0b3IpO1xyXG4gICAgICBhc3NlcnRJbnN0YW5jZSh0aGlzLCBQcm9taXNlLCBQUk9NSVNFKTtcclxuICAgICAgdmFyIHJlY29yZCA9IHtcclxuICAgICAgICBwOiB0aGlzLCAgICAgIC8vIHByb21pc2VcclxuICAgICAgICBjOiBbXSwgICAgICAgIC8vIGNoYWluXHJcbiAgICAgICAgczogMCwgICAgICAgICAvLyBzdGF0ZVxyXG4gICAgICAgIGQ6IGZhbHNlLCAgICAgLy8gZG9uZVxyXG4gICAgICAgIHY6IHVuZGVmaW5lZCwgLy8gdmFsdWVcclxuICAgICAgICBoOiBmYWxzZSAgICAgIC8vIGhhbmRsZWQgcmVqZWN0aW9uXHJcbiAgICAgIH07XHJcbiAgICAgIGhpZGRlbih0aGlzLCBSRUNPUkQsIHJlY29yZCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgZXhlY3V0b3IoY3R4KHJlc29sdmUsIHJlY29yZCwgMSksIGN0eChyZWplY3QsIHJlY29yZCwgMSkpO1xyXG4gICAgICB9IGNhdGNoKGVycil7XHJcbiAgICAgICAgcmVqZWN0LmNhbGwocmVjb3JkLCBlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3NpZ25IaWRkZW4oUHJvbWlzZVtQUk9UT1RZUEVdLCB7XHJcbiAgICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXHJcbiAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcclxuICAgICAgICB2YXIgUyA9IGFzc2VydE9iamVjdChhc3NlcnRPYmplY3QodGhpcylbQ09OU1RSVUNUT1JdKVtTWU1CT0xfU1BFQ0lFU107XHJcbiAgICAgICAgdmFyIHJlYWN0ID0ge1xyXG4gICAgICAgICAgb2s6ICAgaXNGdW5jdGlvbihvbkZ1bGZpbGxlZCkgPyBvbkZ1bGZpbGxlZCA6IHRydWUsXHJcbiAgICAgICAgICBmYWlsOiBpc0Z1bmN0aW9uKG9uUmVqZWN0ZWQpICA/IG9uUmVqZWN0ZWQgIDogZmFsc2VcclxuICAgICAgICB9ICwgUCA9IHJlYWN0LlAgPSBuZXcgKFMgIT0gdW5kZWZpbmVkID8gUyA6IFByb21pc2UpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XHJcbiAgICAgICAgICByZWFjdC5yZXMgPSBhc3NlcnRGdW5jdGlvbihyZXNvbHZlKTtcclxuICAgICAgICAgIHJlYWN0LnJlaiA9IGFzc2VydEZ1bmN0aW9uKHJlamVjdCk7XHJcbiAgICAgICAgfSksIHJlY29yZCA9IHRoaXNbUkVDT1JEXTtcclxuICAgICAgICByZWNvcmQuYy5wdXNoKHJlYWN0KTtcclxuICAgICAgICByZWNvcmQucyAmJiBub3RpZnkocmVjb3JkKTtcclxuICAgICAgICByZXR1cm4gUDtcclxuICAgICAgfSxcclxuICAgICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcclxuICAgICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGFzc2lnbkhpZGRlbihQcm9taXNlLCB7XHJcbiAgICAgIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxyXG4gICAgICBhbGw6IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICB2YXIgUHJvbWlzZSA9IGdldENvbnN0cnVjdG9yKHRoaXMpXHJcbiAgICAgICAgICAsIHZhbHVlcyAgPSBbXTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcclxuICAgICAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgcHVzaCwgdmFsdWVzKTtcclxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoXHJcbiAgICAgICAgICAgICwgcmVzdWx0cyAgID0gQXJyYXkocmVtYWluaW5nKTtcclxuICAgICAgICAgIGlmKHJlbWFpbmluZylmb3JFYWNoLmNhbGwodmFsdWVzLCBmdW5jdGlvbihwcm9taXNlLCBpbmRleCl7XHJcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUocmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGVsc2UgcmVzb2x2ZShyZXN1bHRzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxyXG4gICAgICByYWNlOiBmdW5jdGlvbihpdGVyYWJsZSl7XHJcbiAgICAgICAgdmFyIFByb21pc2UgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzKTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcclxuICAgICAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XHJcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShwcm9taXNlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcclxuICAgICAgcmVqZWN0OiBmdW5jdGlvbihyKXtcclxuICAgICAgICByZXR1cm4gbmV3IChnZXRDb25zdHJ1Y3Rvcih0aGlzKSkoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcclxuICAgICAgICAgIHJlamVjdChyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXHJcbiAgICAgIHJlc29sdmU6IGZ1bmN0aW9uKHgpe1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdCh4KSAmJiBSRUNPUkQgaW4geCAmJiBnZXRQcm90b3R5cGVPZih4KSA9PT0gdGhpc1tQUk9UT1RZUEVdXHJcbiAgICAgICAgICA/IHggOiBuZXcgKGdldENvbnN0cnVjdG9yKHRoaXMpKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xyXG4gICAgICAgICAgICByZXNvbHZlKHgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0obmV4dFRpY2sgfHwgc2V0SW1tZWRpYXRlLCBzYWZlU3ltYm9sKCdyZWNvcmQnKSk7XHJcbiAgc2V0VG9TdHJpbmdUYWcoUHJvbWlzZSwgUFJPTUlTRSk7XHJcbiAgc2V0U3BlY2llcyhQcm9taXNlKTtcclxuICAkZGVmaW5lKEdMT0JBTCArIEZPUkNFRCAqICFpc05hdGl2ZShQcm9taXNlKSwge1Byb21pc2U6IFByb21pc2V9KTtcclxufShnbG9iYWxbUFJPTUlTRV0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBlczYuY29sbGVjdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBFQ01BU2NyaXB0IDYgY29sbGVjdGlvbnMgc2hpbVxyXG4hZnVuY3Rpb24oKXtcclxuICB2YXIgVUlEICAgPSBzYWZlU3ltYm9sKCd1aWQnKVxyXG4gICAgLCBPMSAgICA9IHNhZmVTeW1ib2woJ08xJylcclxuICAgICwgV0VBSyAgPSBzYWZlU3ltYm9sKCd3ZWFrJylcclxuICAgICwgTEVBSyAgPSBzYWZlU3ltYm9sKCdsZWFrJylcclxuICAgICwgTEFTVCAgPSBzYWZlU3ltYm9sKCdsYXN0JylcclxuICAgICwgRklSU1QgPSBzYWZlU3ltYm9sKCdmaXJzdCcpXHJcbiAgICAsIFNJWkUgID0gREVTQyA/IHNhZmVTeW1ib2woJ3NpemUnKSA6ICdzaXplJ1xyXG4gICAgLCB1aWQgICA9IDBcclxuICAgICwgdG1wICAgPSB7fTtcclxuICBcclxuICBmdW5jdGlvbiBnZXRDb2xsZWN0aW9uKEMsIE5BTUUsIG1ldGhvZHMsIGNvbW1vbk1ldGhvZHMsIGlzTWFwLCBpc1dlYWspe1xyXG4gICAgdmFyIEFEREVSID0gaXNNYXAgPyAnc2V0JyA6ICdhZGQnXHJcbiAgICAgICwgcHJvdG8gPSBDICYmIENbUFJPVE9UWVBFXVxyXG4gICAgICAsIE8gICAgID0ge307XHJcbiAgICBmdW5jdGlvbiBpbml0RnJvbUl0ZXJhYmxlKHRoYXQsIGl0ZXJhYmxlKXtcclxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBpc01hcCwgdGhhdFtBRERFUl0sIHRoYXQpO1xyXG4gICAgICByZXR1cm4gdGhhdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZpeFNWWihrZXksIGNoYWluKXtcclxuICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XHJcbiAgICAgIGlmKGZyYW1ld29yaylwcm90b1trZXldID0gZnVuY3Rpb24oYSwgYil7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1ldGhvZC5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7XHJcbiAgICAgICAgcmV0dXJuIGNoYWluID8gdGhpcyA6IHJlc3VsdDtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmKCFpc05hdGl2ZShDKSB8fCAhKGlzV2VhayB8fCAoIUJVR0dZX0lURVJBVE9SUyAmJiBoYXMocHJvdG8sIEZPUl9FQUNIKSAmJiBoYXMocHJvdG8sICdlbnRyaWVzJykpKSl7XHJcbiAgICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXHJcbiAgICAgIEMgPSBpc1dlYWtcclxuICAgICAgICA/IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICAgICAgYXNzZXJ0SW5zdGFuY2UodGhpcywgQywgTkFNRSk7XHJcbiAgICAgICAgICAgIHNldCh0aGlzLCBVSUQsIHVpZCsrKTtcclxuICAgICAgICAgICAgaW5pdEZyb21JdGVyYWJsZSh0aGlzLCBpdGVyYWJsZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgOiBmdW5jdGlvbihpdGVyYWJsZSl7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgYXNzZXJ0SW5zdGFuY2UodGhhdCwgQywgTkFNRSk7XHJcbiAgICAgICAgICAgIHNldCh0aGF0LCBPMSwgY3JlYXRlKG51bGwpKTtcclxuICAgICAgICAgICAgc2V0KHRoYXQsIFNJWkUsIDApO1xyXG4gICAgICAgICAgICBzZXQodGhhdCwgTEFTVCwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgc2V0KHRoYXQsIEZJUlNULCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBpbml0RnJvbUl0ZXJhYmxlKHRoYXQsIGl0ZXJhYmxlKTtcclxuICAgICAgICAgIH07XHJcbiAgICAgIGFzc2lnbkhpZGRlbihhc3NpZ25IaWRkZW4oQ1tQUk9UT1RZUEVdLCBtZXRob2RzKSwgY29tbW9uTWV0aG9kcyk7XHJcbiAgICAgIGlzV2VhayB8fCAhREVTQyB8fCBkZWZpbmVQcm9wZXJ0eShDW1BST1RPVFlQRV0sICdzaXplJywge2dldDogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4gYXNzZXJ0RGVmaW5lZCh0aGlzW1NJWkVdKTtcclxuICAgICAgfX0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIE5hdGl2ZSA9IENcclxuICAgICAgICAsIGluc3QgICA9IG5ldyBDXHJcbiAgICAgICAgLCBjaGFpbiAgPSBpbnN0W0FEREVSXShpc1dlYWsgPyB7fSA6IC0wLCAxKVxyXG4gICAgICAgICwgYnVnZ3laZXJvO1xyXG4gICAgICAvLyB3cmFwIHRvIGluaXQgY29sbGVjdGlvbnMgZnJvbSBpdGVyYWJsZVxyXG4gICAgICBpZihjaGVja0Rhbmdlckl0ZXJDbG9zaW5nKGZ1bmN0aW9uKE8peyBuZXcgQyhPKSB9KSl7XHJcbiAgICAgICAgQyA9IGZ1bmN0aW9uKGl0ZXJhYmxlKXtcclxuICAgICAgICAgIGFzc2VydEluc3RhbmNlKHRoaXMsIEMsIE5BTUUpO1xyXG4gICAgICAgICAgcmV0dXJuIGluaXRGcm9tSXRlcmFibGUobmV3IE5hdGl2ZSwgaXRlcmFibGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDW1BST1RPVFlQRV0gPSBwcm90bztcclxuICAgICAgICBpZihmcmFtZXdvcmspcHJvdG9bQ09OU1RSVUNUT1JdID0gQztcclxuICAgICAgfVxyXG4gICAgICBpc1dlYWsgfHwgaW5zdFtGT1JfRUFDSF0oZnVuY3Rpb24odmFsLCBrZXkpe1xyXG4gICAgICAgIGJ1Z2d5WmVybyA9IDEgLyBrZXkgPT09IC1JbmZpbml0eTtcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIGZpeCBjb252ZXJ0aW5nIC0wIGtleSB0byArMFxyXG4gICAgICBpZihidWdneVplcm8pe1xyXG4gICAgICAgIGZpeFNWWignZGVsZXRlJyk7XHJcbiAgICAgICAgZml4U1ZaKCdoYXMnKTtcclxuICAgICAgICBpc01hcCAmJiBmaXhTVlooJ2dldCcpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vICsgZml4IC5hZGQgJiAuc2V0IGZvciBjaGFpbmluZ1xyXG4gICAgICBpZihidWdneVplcm8gfHwgY2hhaW4gIT09IGluc3QpZml4U1ZaKEFEREVSLCB0cnVlKTtcclxuICAgIH1cclxuICAgIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xyXG4gICAgc2V0U3BlY2llcyhDKTtcclxuICAgIFxyXG4gICAgT1tOQU1FXSA9IEM7XHJcbiAgICAkZGVmaW5lKEdMT0JBTCArIFdSQVAgKyBGT1JDRUQgKiAhaXNOYXRpdmUoQyksIE8pO1xyXG4gICAgXHJcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cclxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcclxuICAgIGlzV2VhayB8fCBkZWZpbmVTdGRJdGVyYXRvcnMoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xyXG4gICAgICBzZXQodGhpcywgSVRFUiwge286IGl0ZXJhdGVkLCBrOiBraW5kfSk7XHJcbiAgICB9LCBmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgaXRlciAgPSB0aGlzW0lURVJdXHJcbiAgICAgICAgLCBraW5kICA9IGl0ZXIua1xyXG4gICAgICAgICwgZW50cnkgPSBpdGVyLmw7XHJcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxyXG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcclxuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcclxuICAgICAgaWYoIWl0ZXIubyB8fCAhKGl0ZXIubCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogaXRlci5vW0ZJUlNUXSkpe1xyXG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXHJcbiAgICAgICAgaXRlci5vID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBpdGVyUmVzdWx0KDEpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcclxuICAgICAgaWYoa2luZCA9PSBLRVkpICByZXR1cm4gaXRlclJlc3VsdCgwLCBlbnRyeS5rKTtcclxuICAgICAgaWYoa2luZCA9PSBWQUxVRSlyZXR1cm4gaXRlclJlc3VsdCgwLCBlbnRyeS52KTtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlclJlc3VsdCgwLCBbZW50cnkuaywgZW50cnkudl0pOyAgIFxyXG4gICAgfSwgaXNNYXAgPyBLRVkrVkFMVUUgOiBWQUxVRSwgIWlzTWFwKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIEM7XHJcbiAgfVxyXG4gIFxyXG4gIGZ1bmN0aW9uIGZhc3RLZXkoaXQsIGNyZWF0ZSl7XHJcbiAgICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XHJcbiAgICBpZighaXNPYmplY3QoaXQpKXJldHVybiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xyXG4gICAgLy8gY2FuJ3Qgc2V0IGlkIHRvIGZyb3plbiBvYmplY3RcclxuICAgIGlmKGlzRnJvemVuKGl0KSlyZXR1cm4gJ0YnO1xyXG4gICAgaWYoIWhhcyhpdCwgVUlEKSl7XHJcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIGlkXHJcbiAgICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcclxuICAgICAgLy8gYWRkIG1pc3Npbmcgb2JqZWN0IGlkXHJcbiAgICAgIGhpZGRlbihpdCwgVUlELCArK3VpZCk7XHJcbiAgICAvLyByZXR1cm4gb2JqZWN0IGlkIHdpdGggcHJlZml4XHJcbiAgICB9IHJldHVybiAnTycgKyBpdFtVSURdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRFbnRyeSh0aGF0LCBrZXkpe1xyXG4gICAgLy8gZmFzdCBjYXNlXHJcbiAgICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xyXG4gICAgaWYoaW5kZXggIT0gJ0YnKXJldHVybiB0aGF0W08xXVtpbmRleF07XHJcbiAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcclxuICAgIGZvcihlbnRyeSA9IHRoYXRbRklSU1RdOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcclxuICAgICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBkZWYodGhhdCwga2V5LCB2YWx1ZSl7XHJcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXHJcbiAgICAgICwgcHJldiwgaW5kZXg7XHJcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcclxuICAgIGlmKGVudHJ5KWVudHJ5LnYgPSB2YWx1ZTtcclxuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcclxuICAgIGVsc2Uge1xyXG4gICAgICB0aGF0W0xBU1RdID0gZW50cnkgPSB7XHJcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XHJcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxyXG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxyXG4gICAgICAgIHA6IHByZXYgPSB0aGF0W0xBU1RdLCAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxyXG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XHJcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcclxuICAgICAgfTtcclxuICAgICAgaWYoIXRoYXRbRklSU1RdKXRoYXRbRklSU1RdID0gZW50cnk7XHJcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XHJcbiAgICAgIHRoYXRbU0laRV0rKztcclxuICAgICAgLy8gYWRkIHRvIGluZGV4XHJcbiAgICAgIGlmKGluZGV4ICE9ICdGJyl0aGF0W08xXVtpbmRleF0gPSBlbnRyeTtcclxuICAgIH0gcmV0dXJuIHRoYXQ7XHJcbiAgfVxyXG5cclxuICB2YXIgY29sbGVjdGlvbk1ldGhvZHMgPSB7XHJcbiAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcclxuICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0W08xXSwgZW50cnkgPSB0aGF0W0ZJUlNUXTsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XHJcbiAgICAgICAgZW50cnkuciA9IHRydWU7XHJcbiAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xyXG4gICAgICB9XHJcbiAgICAgIHRoYXRbRklSU1RdID0gdGhhdFtMQVNUXSA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhhdFtTSVpFXSA9IDA7XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxyXG4gICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXHJcbiAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIHRoYXQgID0gdGhpc1xyXG4gICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xyXG4gICAgICBpZihlbnRyeSl7XHJcbiAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXHJcbiAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xyXG4gICAgICAgIGRlbGV0ZSB0aGF0W08xXVtlbnRyeS5pXTtcclxuICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcclxuICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XHJcbiAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xyXG4gICAgICAgIGlmKHRoYXRbRklSU1RdID09IGVudHJ5KXRoYXRbRklSU1RdID0gbmV4dDtcclxuICAgICAgICBpZih0aGF0W0xBU1RdID09IGVudHJ5KXRoYXRbTEFTVF0gPSBwcmV2O1xyXG4gICAgICAgIHRoYXRbU0laRV0tLTtcclxuICAgICAgfSByZXR1cm4gISFlbnRyeTtcclxuICAgIH0sXHJcbiAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcclxuICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxyXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XHJcbiAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSwgMylcclxuICAgICAgICAsIGVudHJ5O1xyXG4gICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXNbRklSU1RdKXtcclxuICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xyXG4gICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxyXG4gICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxyXG4gICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXHJcbiAgICBoYXM6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIzLjEgTWFwIE9iamVjdHNcclxuICBNYXAgPSBnZXRDb2xsZWN0aW9uKE1hcCwgTUFQLCB7XHJcbiAgICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoaXMsIGtleSk7XHJcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xyXG4gICAgfSxcclxuICAgIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xyXG4gICAgICByZXR1cm4gZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9LCBjb2xsZWN0aW9uTWV0aG9kcywgdHJ1ZSk7XHJcbiAgXHJcbiAgLy8gMjMuMiBTZXQgT2JqZWN0c1xyXG4gIFNldCA9IGdldENvbGxlY3Rpb24oU2V0LCBTRVQsIHtcclxuICAgIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxyXG4gICAgYWRkOiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiBkZWYodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH0sIGNvbGxlY3Rpb25NZXRob2RzKTtcclxuICBcclxuICBmdW5jdGlvbiBkZWZXZWFrKHRoYXQsIGtleSwgdmFsdWUpe1xyXG4gICAgaWYoaXNGcm96ZW4oYXNzZXJ0T2JqZWN0KGtleSkpKWxlYWtTdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICBlbHNlIHtcclxuICAgICAgaGFzKGtleSwgV0VBSykgfHwgaGlkZGVuKGtleSwgV0VBSywge30pO1xyXG4gICAgICBrZXlbV0VBS11bdGhhdFtVSURdXSA9IHZhbHVlO1xyXG4gICAgfSByZXR1cm4gdGhhdDtcclxuICB9XHJcbiAgZnVuY3Rpb24gbGVha1N0b3JlKHRoYXQpe1xyXG4gICAgcmV0dXJuIHRoYXRbTEVBS10gfHwgaGlkZGVuKHRoYXQsIExFQUssIG5ldyBNYXApW0xFQUtdO1xyXG4gIH1cclxuICBcclxuICB2YXIgd2Vha01ldGhvZHMgPSB7XHJcbiAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxyXG4gICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxyXG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGlmKCFpc09iamVjdChrZXkpKXJldHVybiBmYWxzZTtcclxuICAgICAgaWYoaXNGcm96ZW4oa2V5KSlyZXR1cm4gbGVha1N0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xyXG4gICAgICByZXR1cm4gaGFzKGtleSwgV0VBSykgJiYgaGFzKGtleVtXRUFLXSwgdGhpc1tVSURdKSAmJiBkZWxldGUga2V5W1dFQUtdW3RoaXNbVUlEXV07XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcclxuICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcclxuICAgIGhhczogZnVuY3Rpb24oa2V5KXtcclxuICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZihpc0Zyb3plbihrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuaGFzKGtleSk7XHJcbiAgICAgIHJldHVybiBoYXMoa2V5LCBXRUFLKSAmJiBoYXMoa2V5W1dFQUtdLCB0aGlzW1VJRF0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgXHJcbiAgLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcclxuICBXZWFrTWFwID0gZ2V0Q29sbGVjdGlvbihXZWFrTWFwLCBXRUFLTUFQLCB7XHJcbiAgICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxyXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICBpZihpc09iamVjdChrZXkpKXtcclxuICAgICAgICBpZihpc0Zyb3plbihrZXkpKXJldHVybiBsZWFrU3RvcmUodGhpcykuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYoaGFzKGtleSwgV0VBSykpcmV0dXJuIGtleVtXRUFLXVt0aGlzW1VJRF1dO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xyXG4gICAgICByZXR1cm4gZGVmV2Vhayh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9LCB3ZWFrTWV0aG9kcywgdHJ1ZSwgdHJ1ZSk7XHJcbiAgXHJcbiAgLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxyXG4gIGlmKGZyYW1ld29yayAmJiBuZXcgV2Vha01hcCgpLnNldChPYmplY3QuZnJlZXplKHRtcCksIDcpLmdldCh0bXApICE9IDcpe1xyXG4gICAgZm9yRWFjaC5jYWxsKGFycmF5KCdkZWxldGUsaGFzLGdldCxzZXQnKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAgdmFyIG1ldGhvZCA9IFdlYWtNYXBbUFJPVE9UWVBFXVtrZXldO1xyXG4gICAgICBXZWFrTWFwW1BST1RPVFlQRV1ba2V5XSA9IGZ1bmN0aW9uKGEsIGIpe1xyXG4gICAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGxlYWt5IG1hcFxyXG4gICAgICAgIGlmKGlzT2JqZWN0KGEpICYmIGlzRnJvemVuKGEpKXtcclxuICAgICAgICAgIHZhciByZXN1bHQgPSBsZWFrU3RvcmUodGhpcylba2V5XShhLCBiKTtcclxuICAgICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xyXG4gICAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxyXG4gICAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIDIzLjQgV2Vha1NldCBPYmplY3RzXHJcbiAgV2Vha1NldCA9IGdldENvbGxlY3Rpb24oV2Vha1NldCwgV0VBS1NFVCwge1xyXG4gICAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxyXG4gICAgYWRkOiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiBkZWZXZWFrKHRoaXMsIHZhbHVlLCB0cnVlKTtcclxuICAgIH1cclxuICB9LCB3ZWFrTWV0aG9kcywgZmFsc2UsIHRydWUpO1xyXG59KCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1vZHVsZSA6IGVzNi5yZWZsZWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiFmdW5jdGlvbigpe1xyXG4gIGZ1bmN0aW9uIEVudW1lcmF0ZShpdGVyYXRlZCl7XHJcbiAgICB2YXIga2V5cyA9IFtdLCBrZXk7XHJcbiAgICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xyXG4gICAgc2V0KHRoaXMsIElURVIsIHtvOiBpdGVyYXRlZCwgYToga2V5cywgaTogMH0pO1xyXG4gIH1cclxuICBjcmVhdGVJdGVyYXRvcihFbnVtZXJhdGUsIE9CSkVDVCwgZnVuY3Rpb24oKXtcclxuICAgIHZhciBpdGVyID0gdGhpc1tJVEVSXVxyXG4gICAgICAsIGtleXMgPSBpdGVyLmFcclxuICAgICAgLCBrZXk7XHJcbiAgICBkbyB7XHJcbiAgICAgIGlmKGl0ZXIuaSA+PSBrZXlzLmxlbmd0aClyZXR1cm4gaXRlclJlc3VsdCgxKTtcclxuICAgIH0gd2hpbGUoISgoa2V5ID0ga2V5c1tpdGVyLmkrK10pIGluIGl0ZXIubykpO1xyXG4gICAgcmV0dXJuIGl0ZXJSZXN1bHQoMCwga2V5KTtcclxuICB9KTtcclxuICBcclxuICBmdW5jdGlvbiB3cmFwKGZuKXtcclxuICAgIHJldHVybiBmdW5jdGlvbihpdCl7XHJcbiAgICAgIGFzc2VydE9iamVjdChpdCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSwgdHJ1ZTtcclxuICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgZnVuY3Rpb24gcmVmbGVjdEdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xyXG4gICAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl1cclxuICAgICAgLCBkZXNjID0gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpLCBwcm90bztcclxuICAgIGlmKGRlc2MpcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxyXG4gICAgICA/IGRlc2MudmFsdWVcclxuICAgICAgOiBkZXNjLmdldCA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICA6IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSlcclxuICAgICAgPyByZWZsZWN0R2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuICBmdW5jdGlvbiByZWZsZWN0U2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XHJcbiAgICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXVxyXG4gICAgICAsIG93bkRlc2MgID0gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpXHJcbiAgICAgICwgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcclxuICAgIGlmKCFvd25EZXNjKXtcclxuICAgICAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSl7XHJcbiAgICAgICAgcmV0dXJuIHJlZmxlY3RTZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XHJcbiAgICAgIH1cclxuICAgICAgb3duRGVzYyA9IGRlc2NyaXB0b3IoMCk7XHJcbiAgICB9XHJcbiAgICBpZihoYXMob3duRGVzYywgJ3ZhbHVlJykpe1xyXG4gICAgICBpZihvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKXJldHVybiBmYWxzZTtcclxuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ2V0T3duRGVzY3JpcHRvcihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGRlc2NyaXB0b3IoMCk7XHJcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XHJcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvciksIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZFxyXG4gICAgICA/IGZhbHNlXHJcbiAgICAgIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcclxuICB9XHJcbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgcmV0dXJuSXQ7XHJcbiAgXHJcbiAgdmFyIHJlZmxlY3QgPSB7XHJcbiAgICAvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcclxuICAgIGFwcGx5OiBjdHgoY2FsbCwgYXBwbHksIDMpLFxyXG4gICAgLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxyXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbih0YXJnZXQsIGFyZ3VtZW50c0xpc3QgLyosIG5ld1RhcmdldCovKXtcclxuICAgICAgdmFyIHByb3RvICAgID0gYXNzZXJ0RnVuY3Rpb24oYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl0pW1BST1RPVFlQRV1cclxuICAgICAgICAsIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0UHJvdG8pXHJcbiAgICAgICAgLCByZXN1bHQgICA9IGFwcGx5LmNhbGwodGFyZ2V0LCBpbnN0YW5jZSwgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcclxuICAgIGRlZmluZVByb3BlcnR5OiB3cmFwKGRlZmluZVByb3BlcnR5KSxcclxuICAgIC8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXHJcbiAgICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eUtleSl7XHJcbiAgICAgIHZhciBkZXNjID0gZ2V0T3duRGVzY3JpcHRvcihhc3NlcnRPYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xyXG4gICAgICByZXR1cm4gZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXHJcbiAgICBlbnVtZXJhdGU6IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICAgIHJldHVybiBuZXcgRW51bWVyYXRlKGFzc2VydE9iamVjdCh0YXJnZXQpKTtcclxuICAgIH0sXHJcbiAgICAvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXHJcbiAgICBnZXQ6IHJlZmxlY3RHZXQsXHJcbiAgICAvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcclxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eUtleSl7XHJcbiAgICAgIHJldHVybiBnZXRPd25EZXNjcmlwdG9yKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxyXG4gICAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uKHRhcmdldCl7XHJcbiAgICAgIHJldHVybiBnZXRQcm90b3R5cGVPZihhc3NlcnRPYmplY3QodGFyZ2V0KSk7XHJcbiAgICB9LFxyXG4gICAgLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXHJcbiAgICBoYXM6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHlLZXkpe1xyXG4gICAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxyXG4gICAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbih0YXJnZXQpe1xyXG4gICAgICByZXR1cm4gISFpc0V4dGVuc2libGUoYXNzZXJ0T2JqZWN0KHRhcmdldCkpO1xyXG4gICAgfSxcclxuICAgIC8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcclxuICAgIG93bktleXM6IG93bktleXMsXHJcbiAgICAvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxyXG4gICAgcHJldmVudEV4dGVuc2lvbnM6IHdyYXAoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zIHx8IHJldHVybkl0KSxcclxuICAgIC8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXHJcbiAgICBzZXQ6IHJlZmxlY3RTZXRcclxuICB9XHJcbiAgLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXHJcbiAgaWYoc2V0UHJvdG90eXBlT2YpcmVmbGVjdC5zZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvdG8pe1xyXG4gICAgcmV0dXJuIHNldFByb3RvdHlwZU9mKGFzc2VydE9iamVjdCh0YXJnZXQpLCBwcm90byksIHRydWU7XHJcbiAgfTtcclxuICBcclxuICAkZGVmaW5lKEdMT0JBTCwge1JlZmxlY3Q6IHt9fSk7XHJcbiAgJGRlZmluZShTVEFUSUMsICdSZWZsZWN0JywgcmVmbGVjdCk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM3LnByb3Bvc2FscyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKCl7XHJcbiAgJGRlZmluZShQUk9UTywgQVJSQVksIHtcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb21lbmljL0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xyXG4gICAgaW5jbHVkZXM6IGNyZWF0ZUFycmF5Q29udGFpbnModHJ1ZSlcclxuICB9KTtcclxuICAkZGVmaW5lKFBST1RPLCBTVFJJTkcsIHtcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcclxuICAgIGF0OiBjcmVhdGVQb2ludEF0KHRydWUpXHJcbiAgfSk7XHJcbiAgXHJcbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0VG9BcnJheShpc0VudHJpZXMpe1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgICAgIHZhciBPICAgICAgPSB0b09iamVjdChvYmplY3QpXHJcbiAgICAgICAgLCBrZXlzICAgPSBnZXRLZXlzKG9iamVjdClcclxuICAgICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAgICAgLCBpICAgICAgPSAwXHJcbiAgICAgICAgLCByZXN1bHQgPSBBcnJheShsZW5ndGgpXHJcbiAgICAgICAgLCBrZXk7XHJcbiAgICAgIGlmKGlzRW50cmllcyl3aGlsZShsZW5ndGggPiBpKXJlc3VsdFtpXSA9IFtrZXkgPSBrZXlzW2krK10sIE9ba2V5XV07XHJcbiAgICAgIGVsc2Ugd2hpbGUobGVuZ3RoID4gaSlyZXN1bHRbaV0gPSBPW2tleXNbaSsrXV07XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gICRkZWZpbmUoU1RBVElDLCBPQkpFQ1QsIHtcclxuICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vOTM1Mzc4MVxyXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24ob2JqZWN0KXtcclxuICAgICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KG9iamVjdClcclxuICAgICAgICAsIHJlc3VsdCA9IHt9O1xyXG4gICAgICBmb3JFYWNoLmNhbGwob3duS2V5cyhPKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAgICBkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzY3JpcHRvcigwLCBnZXRPd25EZXNjcmlwdG9yKE8sIGtleSkpKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDQvYXByLTkubWQjNTEtb2JqZWN0ZW50cmllcy1vYmplY3R2YWx1ZXNcclxuICAgIHZhbHVlczogIGNyZWF0ZU9iamVjdFRvQXJyYXkoZmFsc2UpLFxyXG4gICAgZW50cmllczogY3JlYXRlT2JqZWN0VG9BcnJheSh0cnVlKVxyXG4gIH0pO1xyXG4gICRkZWZpbmUoU1RBVElDLCBSRUdFWFAsIHtcclxuICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2thbmdheC85Njk4MTAwXHJcbiAgICBlc2NhcGU6IGNyZWF0ZVJlcGxhY2VyKC8oW1xcXFxcXC1bXFxde30oKSorPy4sXiR8XSkvZywgJ1xcXFwkMScsIHRydWUpXHJcbiAgfSk7XHJcbn0oKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogZXM3LmFic3RyYWN0LXJlZnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtYWJzdHJhY3QtcmVmc1xyXG4hZnVuY3Rpb24oUkVGRVJFTkNFKXtcclxuICBSRUZFUkVOQ0VfR0VUID0gZ2V0V2VsbEtub3duU3ltYm9sKFJFRkVSRU5DRSsnR2V0JywgdHJ1ZSk7XHJcbiAgdmFyIFJFRkVSRU5DRV9TRVQgPSBnZXRXZWxsS25vd25TeW1ib2woUkVGRVJFTkNFK1NFVCwgdHJ1ZSlcclxuICAgICwgUkVGRVJFTkNFX0RFTEVURSA9IGdldFdlbGxLbm93blN5bWJvbChSRUZFUkVOQ0UrJ0RlbGV0ZScsIHRydWUpO1xyXG4gIFxyXG4gICRkZWZpbmUoU1RBVElDLCBTWU1CT0wsIHtcclxuICAgIHJlZmVyZW5jZUdldDogUkVGRVJFTkNFX0dFVCxcclxuICAgIHJlZmVyZW5jZVNldDogUkVGRVJFTkNFX1NFVCxcclxuICAgIHJlZmVyZW5jZURlbGV0ZTogUkVGRVJFTkNFX0RFTEVURVxyXG4gIH0pO1xyXG4gIFxyXG4gIGhpZGRlbihGdW5jdGlvblByb3RvLCBSRUZFUkVOQ0VfR0VULCByZXR1cm5UaGlzKTtcclxuICBcclxuICBmdW5jdGlvbiBzZXRNYXBNZXRob2RzKENvbnN0cnVjdG9yKXtcclxuICAgIGlmKENvbnN0cnVjdG9yKXtcclxuICAgICAgdmFyIE1hcFByb3RvID0gQ29uc3RydWN0b3JbUFJPVE9UWVBFXTtcclxuICAgICAgaGlkZGVuKE1hcFByb3RvLCBSRUZFUkVOQ0VfR0VULCBNYXBQcm90by5nZXQpO1xyXG4gICAgICBoaWRkZW4oTWFwUHJvdG8sIFJFRkVSRU5DRV9TRVQsIE1hcFByb3RvLnNldCk7XHJcbiAgICAgIGhpZGRlbihNYXBQcm90bywgUkVGRVJFTkNFX0RFTEVURSwgTWFwUHJvdG9bJ2RlbGV0ZSddKTtcclxuICAgIH1cclxuICB9XHJcbiAgc2V0TWFwTWV0aG9kcyhNYXApO1xyXG4gIHNldE1hcE1ldGhvZHMoV2Vha01hcCk7XHJcbn0oJ3JlZmVyZW5jZScpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNb2R1bGUgOiBqcy5hcnJheS5zdGF0aWNzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBKYXZhU2NyaXB0IDEuNiAvIFN0cmF3bWFuIGFycmF5IHN0YXRpY3Mgc2hpbVxyXG4hZnVuY3Rpb24oYXJyYXlTdGF0aWNzKXtcclxuICBmdW5jdGlvbiBzZXRBcnJheVN0YXRpY3Moa2V5cywgbGVuZ3RoKXtcclxuICAgIGZvckVhY2guY2FsbChhcnJheShrZXlzKSwgZnVuY3Rpb24oa2V5KXtcclxuICAgICAgaWYoa2V5IGluIEFycmF5UHJvdG8pYXJyYXlTdGF0aWNzW2tleV0gPSBjdHgoY2FsbCwgQXJyYXlQcm90b1trZXldLCBsZW5ndGgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHNldEFycmF5U3RhdGljcygncG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcycsIDEpO1xyXG4gIHNldEFycmF5U3RhdGljcygnaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcycsIDMpO1xyXG4gIHNldEFycmF5U3RhdGljcygnam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLCcgK1xyXG4gICAgICAgICAgICAgICAgICAncmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbCx0dXJuJyk7XHJcbiAgJGRlZmluZShTVEFUSUMsIEFSUkFZLCBhcnJheVN0YXRpY3MpO1xyXG59KHt9KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogTW9kdWxlIDogd2ViLmRvbS5pdGFyYWJsZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuIWZ1bmN0aW9uKE5vZGVMaXN0KXtcclxuICBpZihmcmFtZXdvcmsgJiYgTm9kZUxpc3QgJiYgIShTWU1CT0xfSVRFUkFUT1IgaW4gTm9kZUxpc3RbUFJPVE9UWVBFXSkpe1xyXG4gICAgaGlkZGVuKE5vZGVMaXN0W1BST1RPVFlQRV0sIFNZTUJPTF9JVEVSQVRPUiwgSXRlcmF0b3JzW0FSUkFZXSk7XHJcbiAgfVxyXG4gIEl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9yc1tBUlJBWV07XHJcbn0oZ2xvYmFsLk5vZGVMaXN0KTtcbn0odHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCksIHRydWUpOyIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID1cbiAgICB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHJldHVybiBuZXcgR2VuZXJhdG9yKGlubmVyRm4sIG91dGVyRm4sIHNlbGYgfHwgbnVsbCwgdHJ5TG9jc0xpc3QgfHwgW10pO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCk7XG4gICAgICB2YXIgY2FsbE5leHQgPSBzdGVwLmJpbmQoZ2VuZXJhdG9yLm5leHQpO1xuICAgICAgdmFyIGNhbGxUaHJvdyA9IHN0ZXAuYmluZChnZW5lcmF0b3JbXCJ0aHJvd1wiXSk7XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXAoYXJnKSB7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaCh0aGlzLCBudWxsLCBhcmcpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICByZXNvbHZlKGluZm8udmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZShpbmZvLnZhbHVlKS50aGVuKGNhbGxOZXh0LCBjYWxsVGhyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxOZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGdlbmVyYXRvciA9IG91dGVyRm4gPyBPYmplY3QuY3JlYXRlKG91dGVyRm4ucHJvdG90eXBlKSA6IHRoaXM7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCk7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kXSxcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yLFxuICAgICAgICAgICAgYXJnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gTGlrZSByZXR1cm5pbmcgZ2VuZXJhdG9yLnRocm93KHVuY2F1Z2h0KSwgYnV0IHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAvLyBvdmVyaGVhZCBvZiBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgXCJhdHRlbXB0IHRvIHNlbmQgXCIgKyBKU09OLnN0cmluZ2lmeShhcmcpICsgXCIgdG8gbmV3Ym9ybiBnZW5lcmF0b3JcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkWWllbGQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGFyZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGNvbnRleHQuc2VudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG5cbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihyZWNvcmQuYXJnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZW5lcmF0b3IubmV4dCA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJuZXh0XCIpO1xuICAgIGdlbmVyYXRvcltcInRocm93XCJdID0gaW52b2tlLmJpbmQoZ2VuZXJhdG9yLCBcInRocm93XCIpO1xuICAgIGdlbmVyYXRvcltcInJldHVyblwiXSA9IGludm9rZS5iaW5kKGdlbmVyYXRvciwgXCJyZXR1cm5cIik7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIHRoaXMuc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICAvLyBQcmUtaW5pdGlhbGl6ZSBhdCBsZWFzdCAyMCB0ZW1wb3JhcnkgdmFyaWFibGVzIHRvIGVuYWJsZSBoaWRkZW5cbiAgICAgIC8vIGNsYXNzIG9wdGltaXphdGlvbnMgZm9yIHNpbXBsZSBnZW5lcmF0b3JzLlxuICAgICAgZm9yICh2YXIgdGVtcEluZGV4ID0gMCwgdGVtcE5hbWU7XG4gICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIHRlbXBOYW1lID0gXCJ0XCIgKyB0ZW1wSW5kZXgpIHx8IHRlbXBJbmRleCA8IDIwO1xuICAgICAgICAgICArK3RlbXBJbmRleCkge1xuICAgICAgICB0aGlzW3RlbXBOYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuICAvLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3RcbiAgLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbiAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gIHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB0aGlzXG4pO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBib3hJbnRlcnNlY3RXcmFwcGVyXG5cbnZhciBwb29sID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBzd2VlcCA9IHJlcXVpcmUoJy4vbGliL3N3ZWVwJylcbnZhciBib3hJbnRlcnNlY3RJdGVyID0gcmVxdWlyZSgnLi9saWIvaW50ZXJzZWN0JylcblxuZnVuY3Rpb24gYm94RW1wdHkoZCwgYm94KSB7XG4gIGZvcih2YXIgaj0wOyBqPGQ7ICsraikge1xuICAgIGlmKCEoYm94W2pdIDw9IGJveFtqK2RdKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vVW5wYWNrIGJveGVzIGludG8gYSBmbGF0IHR5cGVkIGFycmF5LCByZW1vdmUgZW1wdHkgYm94ZXNcbmZ1bmN0aW9uIGNvbnZlcnRCb3hlcyhib3hlcywgZCwgZGF0YSwgaWRzKSB7XG4gIHZhciBwdHIgPSAwXG4gIHZhciBjb3VudCA9IDBcbiAgZm9yKHZhciBpPTAsIG49Ym94ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBiID0gYm94ZXNbaV1cbiAgICBpZihib3hFbXB0eShkLCBiKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZm9yKHZhciBqPTA7IGo8MipkOyArK2opIHtcbiAgICAgIGRhdGFbcHRyKytdID0gYltqXVxuICAgIH1cbiAgICBpZHNbY291bnQrK10gPSBpXG4gIH1cbiAgcmV0dXJuIGNvdW50XG59XG5cbi8vUGVyZm9ybSB0eXBlIGNvbnZlcnNpb25zLCBjaGVjayBib3VuZHNcbmZ1bmN0aW9uIGJveEludGVyc2VjdChyZWQsIGJsdWUsIHZpc2l0LCBmdWxsKSB7XG4gIHZhciBuID0gcmVkLmxlbmd0aFxuICB2YXIgbSA9IGJsdWUubGVuZ3RoXG5cbiAgLy9JZiBlaXRoZXIgYXJyYXkgaXMgZW1wdHksIHRoZW4gd2UgY2FuIHNraXAgdGhpcyB3aG9sZSB0aGluZ1xuICBpZihuIDw9IDAgfHwgbSA8PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvL0NvbXB1dGUgZGltZW5zaW9uLCBpZiBpdCBpcyAwIHRoZW4gd2Ugc2tpcFxuICB2YXIgZCA9IChyZWRbMF0ubGVuZ3RoKT4+PjFcbiAgaWYoZCA8PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgcmV0dmFsXG5cbiAgLy9Db252ZXJ0IHJlZCBib3hlc1xuICB2YXIgcmVkTGlzdCAgPSBwb29sLm1hbGxvY0RvdWJsZSgyKmQqbilcbiAgdmFyIHJlZElkcyAgID0gcG9vbC5tYWxsb2NJbnQzMihuKVxuICBuID0gY29udmVydEJveGVzKHJlZCwgZCwgcmVkTGlzdCwgcmVkSWRzKVxuXG4gIGlmKG4gPiAwKSB7XG4gICAgaWYoZCA9PT0gMSAmJiBmdWxsKSB7XG4gICAgICAvL1NwZWNpYWwgY2FzZTogMWQgY29tcGxldGVcbiAgICAgIHN3ZWVwLmluaXQobilcbiAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQ29tcGxldGUoXG4gICAgICAgIGQsIHZpc2l0LCBcbiAgICAgICAgMCwgbiwgcmVkTGlzdCwgcmVkSWRzLFxuICAgICAgICAwLCBuLCByZWRMaXN0LCByZWRJZHMpXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy9Db252ZXJ0IGJsdWUgYm94ZXNcbiAgICAgIHZhciBibHVlTGlzdCA9IHBvb2wubWFsbG9jRG91YmxlKDIqZCptKVxuICAgICAgdmFyIGJsdWVJZHMgID0gcG9vbC5tYWxsb2NJbnQzMihtKVxuICAgICAgbSA9IGNvbnZlcnRCb3hlcyhibHVlLCBkLCBibHVlTGlzdCwgYmx1ZUlkcylcblxuICAgICAgaWYobSA+IDApIHtcbiAgICAgICAgc3dlZXAuaW5pdChuK20pXG5cbiAgICAgICAgaWYoZCA9PT0gMSkge1xuICAgICAgICAgIC8vU3BlY2lhbCBjYXNlOiAxZCBiaXBhcnRpdGVcbiAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgIGQsIHZpc2l0LCBcbiAgICAgICAgICAgIDAsIG4sIHJlZExpc3QsICByZWRJZHMsXG4gICAgICAgICAgICAwLCBtLCBibHVlTGlzdCwgYmx1ZUlkcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL0dlbmVyYWwgY2FzZTogIGQ+MVxuICAgICAgICAgIHJldHZhbCA9IGJveEludGVyc2VjdEl0ZXIoXG4gICAgICAgICAgICBkLCB2aXNpdCwgICAgZnVsbCxcbiAgICAgICAgICAgIG4sIHJlZExpc3QsICByZWRJZHMsXG4gICAgICAgICAgICBtLCBibHVlTGlzdCwgYmx1ZUlkcylcbiAgICAgICAgfVxuXG4gICAgICAgIHBvb2wuZnJlZShibHVlTGlzdClcbiAgICAgICAgcG9vbC5mcmVlKGJsdWVJZHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9vbC5mcmVlKHJlZExpc3QpXG4gICAgcG9vbC5mcmVlKHJlZElkcylcbiAgfVxuXG4gIHJldHVybiByZXR2YWxcbn1cblxuXG52YXIgUkVTVUxUXG5cbmZ1bmN0aW9uIGFwcGVuZEl0ZW0oaSxqKSB7XG4gIFJFU1VMVC5wdXNoKFtpLGpdKVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RGdWxsQXJyYXkoeCkge1xuICBSRVNVTFQgPSBbXVxuICBib3hJbnRlcnNlY3QoeCwgeCwgYXBwZW5kSXRlbSwgdHJ1ZSlcbiAgcmV0dXJuIFJFU1VMVFxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RCaXBhcnRpdGVBcnJheSh4LCB5KSB7XG4gIFJFU1VMVCA9IFtdXG4gIGJveEludGVyc2VjdCh4LCB5LCBhcHBlbmRJdGVtLCBmYWxzZSlcbiAgcmV0dXJuIFJFU1VMVFxufVxuXG4vL1VzZXItZnJpZW5kbHkgd3JhcHBlciwgaGFuZGxlIGZ1bGwgaW5wdXQgYW5kIG5vLXZpc2l0b3IgY2FzZXNcbmZ1bmN0aW9uIGJveEludGVyc2VjdFdyYXBwZXIoYXJnMCwgYXJnMSwgYXJnMikge1xuICB2YXIgcmVzdWx0XG4gIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGludGVyc2VjdEZ1bGxBcnJheShhcmcwKVxuICAgIGNhc2UgMjpcbiAgICAgIGlmKHR5cGVvZiBhcmcxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBib3hJbnRlcnNlY3QoYXJnMCwgYXJnMCwgYXJnMSwgdHJ1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3RCaXBhcnRpdGVBcnJheShhcmcwLCBhcmcxKVxuICAgICAgfVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBib3hJbnRlcnNlY3QoYXJnMCwgYXJnMSwgYXJnMiwgZmFsc2UpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignYm94LWludGVyc2VjdDogSW52YWxpZCBhcmd1bWVudHMnKVxuICB9XG59IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBESU1FTlNJT04gICA9ICdkJ1xudmFyIEFYSVMgICAgICAgID0gJ2F4J1xudmFyIFZJU0lUICAgICAgID0gJ3Z2J1xudmFyIEZMSVAgICAgICAgID0gJ2ZwJ1xuXG52YXIgRUxFTV9TSVpFICAgPSAnZXMnXG5cbnZhciBSRURfU1RBUlQgICA9ICdycydcbnZhciBSRURfRU5EICAgICA9ICdyZSdcbnZhciBSRURfQk9YRVMgICA9ICdyYidcbnZhciBSRURfSU5ERVggICA9ICdyaSdcbnZhciBSRURfUFRSICAgICA9ICdycCdcblxudmFyIEJMVUVfU1RBUlQgID0gJ2JzJ1xudmFyIEJMVUVfRU5EICAgID0gJ2JlJ1xudmFyIEJMVUVfQk9YRVMgID0gJ2JiJ1xudmFyIEJMVUVfSU5ERVggID0gJ2JpJ1xudmFyIEJMVUVfUFRSICAgID0gJ2JwJ1xuXG52YXIgUkVUVkFMICAgICAgPSAncnYnXG5cbnZhciBJTk5FUl9MQUJFTCA9ICdRJ1xuXG52YXIgQVJHUyA9IFtcbiAgRElNRU5TSU9OLFxuICBBWElTLFxuICBWSVNJVCxcbiAgUkVEX1NUQVJULFxuICBSRURfRU5ELFxuICBSRURfQk9YRVMsXG4gIFJFRF9JTkRFWCxcbiAgQkxVRV9TVEFSVCxcbiAgQkxVRV9FTkQsXG4gIEJMVUVfQk9YRVMsXG4gIEJMVUVfSU5ERVhcbl1cblxuZnVuY3Rpb24gZ2VuZXJhdGVCcnV0ZUZvcmNlKHJlZE1ham9yLCBmbGlwLCBmdWxsKSB7XG4gIHZhciBmdW5jTmFtZSA9ICdicnV0ZUZvcmNlJyArIFxuICAgIChyZWRNYWpvciA/ICdSZWQnIDogJ0JsdWUnKSArIFxuICAgIChmbGlwID8gJ0ZsaXAnIDogJycpICtcbiAgICAoZnVsbCA/ICdGdWxsJyA6ICcnKVxuXG4gIHZhciBjb2RlID0gWydmdW5jdGlvbiAnLCBmdW5jTmFtZSwgJygnLCBBUkdTLmpvaW4oKSwgJyl7JyxcbiAgICAndmFyICcsIEVMRU1fU0laRSwgJz0yKicsIERJTUVOU0lPTiwgJzsnXVxuXG4gIHZhciByZWRMb29wID0gXG4gICAgJ2Zvcih2YXIgaT0nICsgUkVEX1NUQVJUICsgJywnICsgUkVEX1BUUiArICc9JyArIEVMRU1fU0laRSArICcqJyArIFJFRF9TVEFSVCArICc7JyArXG4gICAgICAgICdpPCcgKyBSRURfRU5EICsnOycgK1xuICAgICAgICAnKytpLCcgKyBSRURfUFRSICsgJys9JyArIEVMRU1fU0laRSArICcpeycgK1xuICAgICAgICAndmFyIHgwPScgKyBSRURfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgUkVEX1BUUiArICddLCcgK1xuICAgICAgICAgICAgJ3gxPScgKyBSRURfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgUkVEX1BUUiArICcrJyArIERJTUVOU0lPTiArICddLCcgK1xuICAgICAgICAgICAgJ3hpPScgKyBSRURfSU5ERVggKyAnW2ldOydcblxuICB2YXIgYmx1ZUxvb3AgPSBcbiAgICAnZm9yKHZhciBqPScgKyBCTFVFX1NUQVJUICsgJywnICsgQkxVRV9QVFIgKyAnPScgKyBFTEVNX1NJWkUgKyAnKicgKyBCTFVFX1NUQVJUICsgJzsnICtcbiAgICAgICAgJ2o8JyArIEJMVUVfRU5EICsgJzsnICtcbiAgICAgICAgJysraiwnICsgQkxVRV9QVFIgKyAnKz0nICsgRUxFTV9TSVpFICsgJyl7JyArXG4gICAgICAgICd2YXIgeTA9JyArIEJMVUVfQk9YRVMgKyAnWycgKyBBWElTICsgJysnICsgQkxVRV9QVFIgKyAnXSwnICtcbiAgICAgICAgICAgIChmdWxsID8gJ3kxPScgKyBCTFVFX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIEJMVUVfUFRSICsgJysnICsgRElNRU5TSU9OICsgJ10sJyA6ICcnKSArXG4gICAgICAgICAgICAneWk9JyArIEJMVUVfSU5ERVggKyAnW2pdOydcblxuICBpZihyZWRNYWpvcikge1xuICAgIGNvZGUucHVzaChyZWRMb29wLCBJTk5FUl9MQUJFTCwgJzonLCBibHVlTG9vcClcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goYmx1ZUxvb3AsIElOTkVSX0xBQkVMLCAnOicsIHJlZExvb3ApXG4gIH1cblxuICBpZihmdWxsKSB7XG4gICAgY29kZS5wdXNoKCdpZih5MTx4MHx8eDE8eTApY29udGludWU7JylcbiAgfSBlbHNlIGlmKGZsaXApIHtcbiAgICBjb2RlLnB1c2goJ2lmKHkwPD14MHx8eDE8eTApY29udGludWU7JylcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goJ2lmKHkwPHgwfHx4MTx5MCljb250aW51ZTsnKVxuICB9XG5cbiAgY29kZS5wdXNoKCdmb3IodmFyIGs9JytBWElTKycrMTtrPCcrRElNRU5TSU9OKyc7KytrKXsnK1xuICAgICd2YXIgcjA9JytSRURfQk9YRVMrJ1trKycrUkVEX1BUUisnXSwnK1xuICAgICAgICAncjE9JytSRURfQk9YRVMrJ1trKycrRElNRU5TSU9OKycrJytSRURfUFRSKyddLCcrXG4gICAgICAgICdiMD0nK0JMVUVfQk9YRVMrJ1trKycrQkxVRV9QVFIrJ10sJytcbiAgICAgICAgJ2IxPScrQkxVRV9CT1hFUysnW2srJytESU1FTlNJT04rJysnK0JMVUVfUFRSKyddOycrXG4gICAgICAnaWYocjE8YjB8fGIxPHIwKWNvbnRpbnVlICcgKyBJTk5FUl9MQUJFTCArICc7fScgK1xuICAgICAgJ3ZhciAnICsgUkVUVkFMICsgJz0nICsgVklTSVQgKyAnKCcpXG5cbiAgaWYoZmxpcCkge1xuICAgIGNvZGUucHVzaCgneWkseGknKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaCgneGkseWknKVxuICB9XG5cbiAgY29kZS5wdXNoKCcpO2lmKCcgKyBSRVRWQUwgKyAnIT09dm9pZCAwKXJldHVybiAnICsgUkVUVkFMICsgJzt9fX0nKVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogZnVuY05hbWUsIFxuICAgIGNvZGU6IGNvZGUuam9pbignJylcbiAgfVxufVxuXG5mdW5jdGlvbiBicnV0ZUZvcmNlUGxhbm5lcihmdWxsKSB7XG4gIHZhciBmdW5jTmFtZSA9ICdicnV0ZUZvcmNlJyArIChmdWxsID8gJ0Z1bGwnIDogJ1BhcnRpYWwnKVxuICB2YXIgcHJlZml4ID0gW11cbiAgdmFyIGZhcmdzID0gQVJHUy5zbGljZSgpXG4gIGlmKCFmdWxsKSB7XG4gICAgZmFyZ3Muc3BsaWNlKDMsIDAsIEZMSVApXG4gIH1cblxuICB2YXIgY29kZSA9IFsnZnVuY3Rpb24gJyArIGZ1bmNOYW1lICsgJygnICsgZmFyZ3Muam9pbigpICsgJyl7J11cblxuICBmdW5jdGlvbiBpbnZva2UocmVkTWFqb3IsIGZsaXApIHtcbiAgICB2YXIgcmVzID0gZ2VuZXJhdGVCcnV0ZUZvcmNlKHJlZE1ham9yLCBmbGlwLCBmdWxsKVxuICAgIHByZWZpeC5wdXNoKHJlcy5jb2RlKVxuICAgIGNvZGUucHVzaCgncmV0dXJuICcgKyByZXMubmFtZSArICcoJyArIEFSR1Muam9pbigpICsgJyk7JylcbiAgfVxuXG4gIGNvZGUucHVzaCgnaWYoJyArIFJFRF9FTkQgKyAnLScgKyBSRURfU1RBUlQgKyAnPicgK1xuICAgICAgICAgICAgICAgICAgICBCTFVFX0VORCArICctJyArIEJMVUVfU1RBUlQgKyAnKXsnKVxuXG4gIGlmKGZ1bGwpIHtcbiAgICBpbnZva2UodHJ1ZSwgZmFsc2UpXG4gICAgY29kZS5wdXNoKCd9ZWxzZXsnKVxuICAgIGludm9rZShmYWxzZSwgZmFsc2UpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKCdpZignICsgRkxJUCArICcpeycpXG4gICAgaW52b2tlKHRydWUsIHRydWUpXG4gICAgY29kZS5wdXNoKCd9ZWxzZXsnKVxuICAgIGludm9rZSh0cnVlLCBmYWxzZSlcbiAgICBjb2RlLnB1c2goJ319ZWxzZXtpZignICsgRkxJUCArICcpeycpXG4gICAgaW52b2tlKGZhbHNlLCB0cnVlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UoZmFsc2UsIGZhbHNlKVxuICAgIGNvZGUucHVzaCgnfScpXG4gIH1cbiAgY29kZS5wdXNoKCd9fXJldHVybiAnICsgZnVuY05hbWUpXG5cbiAgdmFyIGNvZGVTdHIgPSBwcmVmaXguam9pbignJykgKyBjb2RlLmpvaW4oJycpXG4gIHZhciBwcm9jID0gbmV3IEZ1bmN0aW9uKGNvZGVTdHIpXG4gIHJldHVybiBwcm9jKClcbn1cblxuXG5leHBvcnRzLnBhcnRpYWwgPSBicnV0ZUZvcmNlUGxhbm5lcihmYWxzZSlcbmV4cG9ydHMuZnVsbCAgICA9IGJydXRlRm9yY2VQbGFubmVyKHRydWUpIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYm94SW50ZXJzZWN0SXRlclxuXG52YXIgcG9vbCA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktcG9vbCcpXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBicnV0ZUZvcmNlID0gcmVxdWlyZSgnLi9icnV0ZScpXG52YXIgYnJ1dGVGb3JjZVBhcnRpYWwgPSBicnV0ZUZvcmNlLnBhcnRpYWxcbnZhciBicnV0ZUZvcmNlRnVsbCA9IGJydXRlRm9yY2UuZnVsbFxudmFyIHN3ZWVwID0gcmVxdWlyZSgnLi9zd2VlcCcpXG52YXIgZmluZE1lZGlhbiA9IHJlcXVpcmUoJy4vbWVkaWFuJylcbnZhciBnZW5QYXJ0aXRpb24gPSByZXF1aXJlKCcuL3BhcnRpdGlvbicpXG5cbi8vVHdpZGRsZSBwYXJhbWV0ZXJzXG52YXIgQlJVVEVfRk9SQ0VfQ1VUT0ZGICAgID0gMTI4ICAgICAgIC8vQ3V0IG9mZiBmb3IgYnJ1dGUgZm9yY2Ugc2VhcmNoXG52YXIgU0NBTl9DVVRPRkYgICAgICAgICAgID0gKDE8PDIyKSAgIC8vQ3V0IG9mZiBmb3IgdHdvIHdheSBzY2FuXG52YXIgU0NBTl9DT01QTEVURV9DVVRPRkYgID0gKDE8PDIyKSAgXG5cbi8vUGFydGl0aW9uIGZ1bmN0aW9uc1xudmFyIHBhcnRpdGlvbkludGVyaW9yQ29udGFpbnNJbnRlcnZhbCA9IGdlblBhcnRpdGlvbihcbiAgJyEobG8+PXAwKSYmIShwMT49aGkpJywgXG4gIFsncDAnLCAncDEnXSlcblxudmFyIHBhcnRpdGlvblN0YXJ0RXF1YWwgPSBnZW5QYXJ0aXRpb24oXG4gICdsbz09PXAwJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uU3RhcnRMZXNzVGhhbiA9IGdlblBhcnRpdGlvbihcbiAgJ2xvPHAwJyxcbiAgWydwMCddKVxuXG52YXIgcGFydGl0aW9uRW5kTGVzc1RoYW5FcXVhbCA9IGdlblBhcnRpdGlvbihcbiAgJ2hpPD1wMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvbkNvbnRhaW5zUG9pbnQgPSBnZW5QYXJ0aXRpb24oXG4gICdsbzw9cDAmJnAwPD1oaScsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvbkNvbnRhaW5zUG9pbnRQcm9wZXIgPSBnZW5QYXJ0aXRpb24oXG4gICdsbzxwMCYmcDA8PWhpJyxcbiAgWydwMCddKVxuXG4vL0ZyYW1lIHNpemUgZm9yIGl0ZXJhdGl2ZSBsb29wXG52YXIgSUZSQU1FX1NJWkUgPSA2XG52YXIgREZSQU1FX1NJWkUgPSAyXG5cbi8vRGF0YSBmb3IgYm94IHN0YXRja1xudmFyIElOSVRfQ0FQQUNJVFkgPSAxMDI0XG52YXIgQk9YX0lTVEFDSyAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQk9YX0RTVEFDSyAgPSBwb29sLm1hbGxvY0RvdWJsZShJTklUX0NBUEFDSVRZKVxuXG4vL0luaXRpYWxpemUgaXRlcmF0aXZlIGxvb3AgcXVldWVcbmZ1bmN0aW9uIGl0ZXJJbml0KGQsIGNvdW50KSB7XG4gIHZhciBsZXZlbHMgPSAoOCAqIGJpdHMubG9nMihjb3VudCsxKSAqIChkKzEpKXwwXG4gIHZhciBtYXhJbnRzID0gYml0cy5uZXh0UG93MihJRlJBTUVfU0laRSpsZXZlbHMpXG4gIGlmKEJPWF9JU1RBQ0subGVuZ3RoIDwgbWF4SW50cykge1xuICAgIHBvb2wuZnJlZShCT1hfSVNUQUNLKVxuICAgIEJPWF9JU1RBQ0sgPSBwb29sLm1hbGxvY0ludDMyKG1heEludHMpXG4gIH1cbiAgdmFyIG1heERvdWJsZXMgPSBiaXRzLm5leHRQb3cyKERGUkFNRV9TSVpFKmxldmVscylcbiAgaWYoQk9YX0RTVEFDSyA8IG1heERvdWJsZXMpIHtcbiAgICBwb29sLmZyZWUoQk9YX0RTVEFDSylcbiAgICBCT1hfRFNUQUNLID0gcG9vbC5tYWxsb2NEb3VibGUobWF4RG91YmxlcylcbiAgfVxufVxuXG4vL0FwcGVuZCBpdGVtIHRvIHF1ZXVlXG5mdW5jdGlvbiBpdGVyUHVzaChwdHIsXG4gIGF4aXMsIFxuICByZWRTdGFydCwgcmVkRW5kLCBcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBcbiAgc3RhdGUsIFxuICBsbywgaGkpIHtcblxuICB2YXIgaXB0ciA9IElGUkFNRV9TSVpFICogcHRyXG4gIEJPWF9JU1RBQ0tbaXB0cl0gICA9IGF4aXNcbiAgQk9YX0lTVEFDS1tpcHRyKzFdID0gcmVkU3RhcnRcbiAgQk9YX0lTVEFDS1tpcHRyKzJdID0gcmVkRW5kXG4gIEJPWF9JU1RBQ0tbaXB0ciszXSA9IGJsdWVTdGFydFxuICBCT1hfSVNUQUNLW2lwdHIrNF0gPSBibHVlRW5kXG4gIEJPWF9JU1RBQ0tbaXB0cis1XSA9IHN0YXRlXG5cbiAgdmFyIGRwdHIgPSBERlJBTUVfU0laRSAqIHB0clxuICBCT1hfRFNUQUNLW2RwdHJdICAgPSBsb1xuICBCT1hfRFNUQUNLW2RwdHIrMV0gPSBoaVxufVxuXG4vL1NwZWNpYWwgY2FzZTogIEludGVyc2VjdCBzaW5nbGUgcG9pbnQgd2l0aCBsaXN0IG9mIGludGVydmFsc1xuZnVuY3Rpb24gb25lUG9pbnRQYXJ0aWFsKFxuICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZU9mZnNldCwgYmx1ZSwgYmx1ZUlkKSB7XG5cbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJsdWVQdHIgID0gYmx1ZU9mZnNldCAqIGVsZW1TaXplXG4gIHZhciBibHVlWCAgICA9IGJsdWVbYmx1ZVB0ciArIGF4aXNdXG5cbnJlZF9sb29wOlxuICBmb3IodmFyIGk9cmVkU3RhcnQsIHJlZFB0cj1yZWRTdGFydCplbGVtU2l6ZTsgaTxyZWRFbmQ7ICsraSwgcmVkUHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciByMCA9IHJlZFtyZWRQdHIrYXhpc11cbiAgICB2YXIgcjEgPSByZWRbcmVkUHRyK2F4aXMrZF1cbiAgICBpZihibHVlWCA8IHIwIHx8IHIxIDwgYmx1ZVgpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmKGZsaXAgJiYgYmx1ZVggPT09IHIwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcmVkSWQgPSByZWRJbmRleFtpXVxuICAgIGZvcih2YXIgaj1heGlzKzE7IGo8ZDsgKytqKSB7XG4gICAgICB2YXIgcjAgPSByZWRbcmVkUHRyK2pdXG4gICAgICB2YXIgcjEgPSByZWRbcmVkUHRyK2orZF1cbiAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citqXVxuICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2orZF1cbiAgICAgIGlmKHIxIDwgYjAgfHwgYjEgPCByMCkge1xuICAgICAgICBjb250aW51ZSByZWRfbG9vcFxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmV0dmFsXG4gICAgaWYoZmxpcCkge1xuICAgICAgcmV0dmFsID0gdmlzaXQoYmx1ZUlkLCByZWRJZClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICB9XG4gICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiByZXR2YWxcbiAgICB9XG4gIH1cbn1cblxuLy9TcGVjaWFsIGNhc2U6ICBJbnRlcnNlY3Qgb25lIHBvaW50IHdpdGggbGlzdCBvZiBpbnRlcnZhbHNcbmZ1bmN0aW9uIG9uZVBvaW50RnVsbChcbiAgZCwgYXhpcywgdmlzaXQsXG4gIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVPZmZzZXQsIGJsdWUsIGJsdWVJZCkge1xuXG4gIHZhciBlbGVtU2l6ZSA9IDIgKiBkXG4gIHZhciBibHVlUHRyICA9IGJsdWVPZmZzZXQgKiBlbGVtU2l6ZVxuICB2YXIgYmx1ZVggICAgPSBibHVlW2JsdWVQdHIgKyBheGlzXVxuXG5yZWRfbG9vcDpcbiAgZm9yKHZhciBpPXJlZFN0YXJ0LCByZWRQdHI9cmVkU3RhcnQqZWxlbVNpemU7IGk8cmVkRW5kOyArK2ksIHJlZFB0cis9ZWxlbVNpemUpIHtcbiAgICB2YXIgcmVkSWQgPSByZWRJbmRleFtpXVxuICAgIGlmKHJlZElkID09PSBibHVlSWQpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByMCA9IHJlZFtyZWRQdHIrYXhpc11cbiAgICB2YXIgcjEgPSByZWRbcmVkUHRyK2F4aXMrZF1cbiAgICBpZihibHVlWCA8IHIwIHx8IHIxIDwgYmx1ZVgpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGZvcih2YXIgaj1heGlzKzE7IGo8ZDsgKytqKSB7XG4gICAgICB2YXIgcjAgPSByZWRbcmVkUHRyK2pdXG4gICAgICB2YXIgcjEgPSByZWRbcmVkUHRyK2orZF1cbiAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citqXVxuICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2orZF1cbiAgICAgIGlmKHIxIDwgYjAgfHwgYjEgPCByMCkge1xuICAgICAgICBjb250aW51ZSByZWRfbG9vcFxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJldHZhbFxuICAgIH1cbiAgfVxufVxuXG4vL1RoZSBtYWluIGJveCBpbnRlcnNlY3Rpb24gcm91dGluZVxuZnVuY3Rpb24gYm94SW50ZXJzZWN0SXRlcihcbiAgZCwgdmlzaXQsIGluaXRGdWxsLFxuICB4U2l6ZSwgeEJveGVzLCB4SW5kZXgsXG4gIHlTaXplLCB5Qm94ZXMsIHlJbmRleCkge1xuXG4gIC8vUmVzZXJ2ZSBtZW1vcnkgZm9yIHN0YWNrXG4gIGl0ZXJJbml0KGQsIHhTaXplICsgeVNpemUpXG5cbiAgdmFyIHRvcCAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIgKiBkXG4gIHZhciByZXR2YWxcblxuICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgIDAsXG4gICAgICAwLCB4U2l6ZSxcbiAgICAgIDAsIHlTaXplLFxuICAgICAgaW5pdEZ1bGwgPyAxNiA6IDAsIFxuICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgaWYoIWluaXRGdWxsKSB7XG4gICAgaXRlclB1c2godG9wKyssXG4gICAgICAwLFxuICAgICAgMCwgeVNpemUsXG4gICAgICAwLCB4U2l6ZSxcbiAgICAgIDEsIFxuICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgfVxuXG4gIHdoaWxlKHRvcCA+IDApIHtcbiAgICB0b3AgIC09IDFcblxuICAgIHZhciBpcHRyID0gdG9wICogSUZSQU1FX1NJWkVcbiAgICB2YXIgYXhpcyAgICAgID0gQk9YX0lTVEFDS1tpcHRyXVxuICAgIHZhciByZWRTdGFydCAgPSBCT1hfSVNUQUNLW2lwdHIrMV1cbiAgICB2YXIgcmVkRW5kICAgID0gQk9YX0lTVEFDS1tpcHRyKzJdXG4gICAgdmFyIGJsdWVTdGFydCA9IEJPWF9JU1RBQ0tbaXB0ciszXVxuICAgIHZhciBibHVlRW5kICAgPSBCT1hfSVNUQUNLW2lwdHIrNF1cbiAgICB2YXIgc3RhdGUgICAgID0gQk9YX0lTVEFDS1tpcHRyKzVdXG5cbiAgICB2YXIgZHB0ciA9IHRvcCAqIERGUkFNRV9TSVpFXG4gICAgdmFyIGxvICAgICAgICA9IEJPWF9EU1RBQ0tbZHB0cl1cbiAgICB2YXIgaGkgICAgICAgID0gQk9YX0RTVEFDS1tkcHRyKzFdXG5cbiAgICAvL1VucGFjayBzdGF0ZSBpbmZvXG4gICAgdmFyIGZsaXAgICAgICA9IChzdGF0ZSAmIDEpXG4gICAgdmFyIGZ1bGwgICAgICA9ICEhKHN0YXRlICYgMTYpXG5cbiAgICAvL1VucGFjayBpbmRpY2VzXG4gICAgdmFyIHJlZCAgICAgICA9IHhCb3hlc1xuICAgIHZhciByZWRJbmRleCAgPSB4SW5kZXhcbiAgICB2YXIgYmx1ZSAgICAgID0geUJveGVzXG4gICAgdmFyIGJsdWVJbmRleCA9IHlJbmRleFxuICAgIGlmKGZsaXApIHtcbiAgICAgIHJlZCAgICAgICAgID0geUJveGVzXG4gICAgICByZWRJbmRleCAgICA9IHlJbmRleFxuICAgICAgYmx1ZSAgICAgICAgPSB4Qm94ZXNcbiAgICAgIGJsdWVJbmRleCAgID0geEluZGV4XG4gICAgfVxuXG4gICAgaWYoc3RhdGUgJiAyKSB7XG4gICAgICByZWRFbmQgPSBwYXJ0aXRpb25TdGFydExlc3NUaGFuKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICBoaSlcbiAgICAgIGlmKHJlZFN0YXJ0ID49IHJlZEVuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZihzdGF0ZSAmIDQpIHtcbiAgICAgIHJlZFN0YXJ0ID0gcGFydGl0aW9uRW5kTGVzc1RoYW5FcXVhbChcbiAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgbG8pXG4gICAgICBpZihyZWRTdGFydCA+PSByZWRFbmQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdmFyIHJlZENvdW50ICA9IHJlZEVuZCAgLSByZWRTdGFydFxuICAgIHZhciBibHVlQ291bnQgPSBibHVlRW5kIC0gYmx1ZVN0YXJ0XG5cbiAgICBpZihmdWxsKSB7XG4gICAgICBpZihkICogcmVkQ291bnQgKiAocmVkQ291bnQgKyBibHVlQ291bnQpIDwgU0NBTl9DT01QTEVURV9DVVRPRkYpIHtcbiAgICAgICAgcmV0dmFsID0gc3dlZXAuc2NhbkNvbXBsZXRlKFxuICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBcbiAgICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihkICogTWF0aC5taW4ocmVkQ291bnQsIGJsdWVDb3VudCkgPCBCUlVURV9GT1JDRV9DVVRPRkYpIHtcbiAgICAgICAgLy9JZiBpbnB1dCBzbWFsbCwgdGhlbiB1c2UgYnJ1dGUgZm9yY2VcbiAgICAgICAgcmV0dmFsID0gYnJ1dGVGb3JjZVBhcnRpYWwoXG4gICAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgICAgICAgICAgIHJlZFN0YXJ0LCAgcmVkRW5kLCAgcmVkLCAgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZihkICogcmVkQ291bnQgKiBibHVlQ291bnQgPCBTQ0FOX0NVVE9GRikge1xuICAgICAgICAvL0lmIGlucHV0IG1lZGl1bSBzaXplZCwgdGhlbiB1c2Ugc3dlZXAgYW5kIHBydW5lXG4gICAgICAgIHJldHZhbCA9IHN3ZWVwLnNjYW5CaXBhcnRpdGUoXG4gICAgICAgICAgZCwgYXhpcywgdmlzaXQsIGZsaXAsIFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vRmlyc3QsIGZpbmQgYWxsIHJlZCBpbnRlcnZhbHMgd2hvc2UgaW50ZXJpb3IgY29udGFpbnMgKGxvLGhpKVxuICAgIHZhciByZWQwID0gcGFydGl0aW9uSW50ZXJpb3JDb250YWluc0ludGVydmFsKFxuICAgICAgZCwgYXhpcywgXG4gICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgbG8sIGhpKVxuXG4gICAgLy9Mb3dlciBkaW1lbnNpb25hbCBjYXNlXG4gICAgaWYocmVkU3RhcnQgPCByZWQwKSB7XG5cbiAgICAgIGlmKGQgKiAocmVkMCAtIHJlZFN0YXJ0KSA8IEJSVVRFX0ZPUkNFX0NVVE9GRikge1xuICAgICAgICAvL1NwZWNpYWwgY2FzZSBmb3Igc21hbGwgaW5wdXRzOiB1c2UgYnJ1dGUgZm9yY2VcbiAgICAgICAgcmV0dmFsID0gYnJ1dGVGb3JjZUZ1bGwoXG4gICAgICAgICAgZCwgYXhpcysxLCB2aXNpdCxcbiAgICAgICAgICByZWRTdGFydCwgcmVkMCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihheGlzID09PSBkLTIpIHtcbiAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCxcbiAgICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICByZWRTdGFydCwgcmVkMCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICB9XG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZDAsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLFxuICAgICAgICAgIGZsaXAsXG4gICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgYXhpcysxLFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCxcbiAgICAgICAgICByZWRTdGFydCwgcmVkMCxcbiAgICAgICAgICBmbGlwXjEsXG4gICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0RpdmlkZSBhbmQgY29ucXVlciBwaGFzZVxuICAgIGlmKHJlZDAgPCByZWRFbmQpIHtcblxuICAgICAgLy9DdXQgYmx1ZSBpbnRvIDMgcGFydHM6XG4gICAgICAvL1xuICAgICAgLy8gIFBvaW50cyA8IG1pZCBwb2ludFxuICAgICAgLy8gIFBvaW50cyA9IG1pZCBwb2ludFxuICAgICAgLy8gIFBvaW50cyA+IG1pZCBwb2ludFxuICAgICAgLy9cbiAgICAgIHZhciBibHVlMCA9IGZpbmRNZWRpYW4oXG4gICAgICAgIGQsIGF4aXMsIFxuICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgIHZhciBtaWQgPSBibHVlW2VsZW1TaXplICogYmx1ZTAgKyBheGlzXVxuICAgICAgdmFyIGJsdWUxID0gcGFydGl0aW9uU3RhcnRFcXVhbChcbiAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgYmx1ZTAsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCxcbiAgICAgICAgbWlkKVxuXG4gICAgICAvL1JpZ2h0IGNhc2VcbiAgICAgIGlmKGJsdWUxIDwgYmx1ZUVuZCkge1xuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzLFxuICAgICAgICAgIHJlZDAsIHJlZEVuZCxcbiAgICAgICAgICBibHVlMSwgYmx1ZUVuZCxcbiAgICAgICAgICAoZmxpcHw0KSArIChmdWxsID8gMTYgOiAwKSxcbiAgICAgICAgICBtaWQsIGhpKVxuICAgICAgfVxuXG4gICAgICAvL0xlZnQgY2FzZVxuICAgICAgaWYoYmx1ZVN0YXJ0IDwgYmx1ZTApIHtcbiAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgYXhpcyxcbiAgICAgICAgICByZWQwLCByZWRFbmQsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlMCxcbiAgICAgICAgICAoZmxpcHwyKSArIChmdWxsID8gMTYgOiAwKSxcbiAgICAgICAgICBsbywgbWlkKVxuICAgICAgfVxuXG4gICAgICAvL0NlbnRlciBjYXNlICh0aGUgaGFyZCBwYXJ0KVxuICAgICAgaWYoYmx1ZTAgKyAxID09PSBibHVlMSkge1xuICAgICAgICAvL09wdGltaXphdGlvbjogUmFuZ2Ugd2l0aCBleGFjdGx5IDEgcG9pbnQsIHVzZSBhIGJydXRlIGZvcmNlIHNjYW5cbiAgICAgICAgaWYoZnVsbCkge1xuICAgICAgICAgIHJldHZhbCA9IG9uZVBvaW50RnVsbChcbiAgICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LFxuICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZTAsIGJsdWUsIGJsdWVJbmRleFtibHVlMF0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dmFsID0gb25lUG9pbnRQYXJ0aWFsKFxuICAgICAgICAgICAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlMCwgYmx1ZSwgYmx1ZUluZGV4W2JsdWUwXSlcbiAgICAgICAgfVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGJsdWUwIDwgYmx1ZTEpIHtcbiAgICAgICAgdmFyIHJlZDFcbiAgICAgICAgaWYoZnVsbCkge1xuICAgICAgICAgIC8vSWYgZnVsbCBpbnRlcnNlY3Rpb24sIG5lZWQgdG8gaGFuZGxlIHNwZWNpYWwgY2FzZVxuICAgICAgICAgIHJlZDEgPSBwYXJ0aXRpb25Db250YWluc1BvaW50KFxuICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIG1pZClcbiAgICAgICAgICBpZihyZWQwIDwgcmVkMSkge1xuICAgICAgICAgICAgdmFyIHJlZFggPSBwYXJ0aXRpb25TdGFydEVxdWFsKFxuICAgICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgICByZWQwLCByZWQxLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICBtaWQpXG4gICAgICAgICAgICBpZihheGlzID09PSBkLTIpIHtcbiAgICAgICAgICAgICAgLy9EZWdlbmVyYXRlIHN3ZWVwIGludGVyc2VjdGlvbjpcbiAgICAgICAgICAgICAgLy8gIFtyZWQwLCByZWRYXSB3aXRoIFtibHVlMCwgYmx1ZTFdXG4gICAgICAgICAgICAgIGlmKHJlZDAgPCByZWRYKSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBDb21wbGV0ZShcbiAgICAgICAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgICAgICAgcmVkMCwgcmVkWCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy9Ob3JtYWwgc3dlZXAgaW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgICAvLyAgW3JlZFgsIHJlZDFdIHdpdGggW2JsdWUwLCBibHVlMV1cbiAgICAgICAgICAgICAgaWYocmVkWCA8IHJlZDEpIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgICAgICAgcmVkWCwgcmVkMSwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZihyZWQwIDwgcmVkWCkge1xuICAgICAgICAgICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgICAgcmVkMCwgcmVkWCxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICAgIDE2LFxuICAgICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZihyZWRYIDwgcmVkMSkge1xuICAgICAgICAgICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgICAgcmVkWCwgcmVkMSxcbiAgICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgcmVkWCwgcmVkMSxcbiAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICAgIHJlZDEgPSBwYXJ0aXRpb25Db250YWluc1BvaW50UHJvcGVyKFxuICAgICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgIG1pZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnQoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZWQwIDwgcmVkMSkge1xuICAgICAgICAgICAgaWYoYXhpcyA9PT0gZC0yKSB7XG4gICAgICAgICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcEJpcGFydGl0ZShcbiAgICAgICAgICAgICAgICAgIGQsIHZpc2l0LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWQxLCByZWQsIHJlZEluZGV4KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWQxLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICByZWQwLCByZWQxLFxuICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICBmbGlwLFxuICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgcmVkMCwgcmVkMSxcbiAgICAgICAgICAgICAgICBmbGlwXjEsXG4gICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kTWVkaWFuXG5cbnZhciBnZW5QYXJ0aXRpb24gPSByZXF1aXJlKCcuL3BhcnRpdGlvbicpXG5cbnZhciBwYXJ0aXRpb25TdGFydExlc3NUaGFuID0gZ2VuUGFydGl0aW9uKCdsbzxwMCcsIFsncDAnXSlcblxudmFyIFBBUlRJVElPTl9USFJFU0hPTEQgPSA4ICAgLy9DdXQgb2ZmIGZvciB1c2luZyBpbnNlcnRpb24gc29ydCBpbiBmaW5kTWVkaWFuXG5cbi8vQmFzZSBjYXNlIGZvciBtZWRpYW4gZmluZGluZzogIFVzZSBpbnNlcnRpb24gc29ydFxuZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChkLCBheGlzLCBzdGFydCwgZW5kLCBib3hlcywgaWRzKSB7XG4gIHZhciBlbGVtU2l6ZSA9IDIgKiBkXG4gIHZhciBib3hQdHIgPSBlbGVtU2l6ZSAqIChzdGFydCsxKSArIGF4aXNcbiAgZm9yKHZhciBpPXN0YXJ0KzE7IGk8ZW5kOyArK2ksIGJveFB0cis9ZWxlbVNpemUpIHtcbiAgICB2YXIgeCA9IGJveGVzW2JveFB0cl1cbiAgICBmb3IodmFyIGo9aSwgcHRyPWVsZW1TaXplKihpLTEpOyBcbiAgICAgICAgaj5zdGFydCAmJiBib3hlc1twdHIrYXhpc10gPiB4OyBcbiAgICAgICAgLS1qLCBwdHItPWVsZW1TaXplKSB7XG4gICAgICAvL1N3YXBcbiAgICAgIHZhciBhUHRyID0gcHRyXG4gICAgICB2YXIgYlB0ciA9IHB0citlbGVtU2l6ZVxuICAgICAgZm9yKHZhciBrPTA7IGs8ZWxlbVNpemU7ICsraywgKythUHRyLCArK2JQdHIpIHtcbiAgICAgICAgdmFyIHkgPSBib3hlc1thUHRyXVxuICAgICAgICBib3hlc1thUHRyXSA9IGJveGVzW2JQdHJdXG4gICAgICAgIGJveGVzW2JQdHJdID0geVxuICAgICAgfVxuICAgICAgdmFyIHRtcCA9IGlkc1tqXVxuICAgICAgaWRzW2pdID0gaWRzW2otMV1cbiAgICAgIGlkc1tqLTFdID0gdG1wXG4gICAgfVxuICB9XG59XG5cbi8vRmluZCBtZWRpYW4gdXNpbmcgcXVpY2sgc2VsZWN0IGFsZ29yaXRobVxuLy8gIHRha2VzIE8obikgdGltZSB3aXRoIGhpZ2ggcHJvYmFiaWxpdHlcbmZ1bmN0aW9uIGZpbmRNZWRpYW4oZCwgYXhpcywgc3RhcnQsIGVuZCwgYm94ZXMsIGlkcykge1xuICBpZihlbmQgPD0gc3RhcnQrMSkge1xuICAgIHJldHVybiBzdGFydFxuICB9XG5cbiAgdmFyIGxvICAgICAgID0gc3RhcnRcbiAgdmFyIGhpICAgICAgID0gZW5kXG4gIHZhciBtaWQgICAgICA9ICgoZW5kICsgc3RhcnQpID4+PiAxKVxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIHBpdm90ICAgID0gbWlkXG4gIHZhciB2YWx1ZSAgICA9IGJveGVzW2VsZW1TaXplKm1pZCtheGlzXVxuICBcbiAgd2hpbGUobG8gPCBoaSkge1xuICAgIGlmKGhpIC0gbG8gPCBQQVJUSVRJT05fVEhSRVNIT0xEKSB7XG4gICAgICBpbnNlcnRpb25Tb3J0KGQsIGF4aXMsIGxvLCBoaSwgYm94ZXMsIGlkcylcbiAgICAgIHZhbHVlID0gYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdXG4gICAgICBicmVha1xuICAgIH1cbiAgICBcbiAgICAvL1NlbGVjdCBwaXZvdCB1c2luZyBtZWRpYW4tb2YtM1xuICAgIHZhciBjb3VudCAgPSBoaSAtIGxvXG4gICAgdmFyIHBpdm90MCA9IChNYXRoLnJhbmRvbSgpKmNvdW50K2xvKXwwXG4gICAgdmFyIHZhbHVlMCA9IGJveGVzW2VsZW1TaXplKnBpdm90MCArIGF4aXNdXG4gICAgdmFyIHBpdm90MSA9IChNYXRoLnJhbmRvbSgpKmNvdW50K2xvKXwwXG4gICAgdmFyIHZhbHVlMSA9IGJveGVzW2VsZW1TaXplKnBpdm90MSArIGF4aXNdXG4gICAgdmFyIHBpdm90MiA9IChNYXRoLnJhbmRvbSgpKmNvdW50K2xvKXwwXG4gICAgdmFyIHZhbHVlMiA9IGJveGVzW2VsZW1TaXplKnBpdm90MiArIGF4aXNdXG4gICAgaWYodmFsdWUwIDw9IHZhbHVlMSkge1xuICAgICAgaWYodmFsdWUyID49IHZhbHVlMSkge1xuICAgICAgICBwaXZvdCA9IHBpdm90MVxuICAgICAgICB2YWx1ZSA9IHZhbHVlMVxuICAgICAgfSBlbHNlIGlmKHZhbHVlMCA+PSB2YWx1ZTIpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDBcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QyXG4gICAgICAgIHZhbHVlID0gdmFsdWUyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHZhbHVlMSA+PSB2YWx1ZTIpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDFcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTFcbiAgICAgIH0gZWxzZSBpZih2YWx1ZTIgPj0gdmFsdWUwKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QwXG4gICAgICAgIHZhbHVlID0gdmFsdWUwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXZvdCA9IHBpdm90MlxuICAgICAgICB2YWx1ZSA9IHZhbHVlMlxuICAgICAgfVxuICAgIH1cblxuICAgIC8vU3dhcCBwaXZvdCB0byBlbmQgb2YgYXJyYXlcbiAgICB2YXIgYVB0ciA9IGVsZW1TaXplICogKGhpLTEpXG4gICAgdmFyIGJQdHIgPSBlbGVtU2l6ZSAqIHBpdm90XG4gICAgZm9yKHZhciBpPTA7IGk8ZWxlbVNpemU7ICsraSwgKythUHRyLCArK2JQdHIpIHtcbiAgICAgIHZhciB4ID0gYm94ZXNbYVB0cl1cbiAgICAgIGJveGVzW2FQdHJdID0gYm94ZXNbYlB0cl1cbiAgICAgIGJveGVzW2JQdHJdID0geFxuICAgIH1cbiAgICB2YXIgeSA9IGlkc1toaS0xXVxuICAgIGlkc1toaS0xXSA9IGlkc1twaXZvdF1cbiAgICBpZHNbcGl2b3RdID0geVxuXG4gICAgLy9QYXJ0aXRpb24gdXNpbmcgcGl2b3RcbiAgICBwaXZvdCA9IHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4oXG4gICAgICBkLCBheGlzLCBcbiAgICAgIGxvLCBoaS0xLCBib3hlcywgaWRzLFxuICAgICAgdmFsdWUpXG5cbiAgICAvL1N3YXAgcGl2b3QgYmFja1xuICAgIHZhciBhUHRyID0gZWxlbVNpemUgKiAoaGktMSlcbiAgICB2YXIgYlB0ciA9IGVsZW1TaXplICogcGl2b3RcbiAgICBmb3IodmFyIGk9MDsgaTxlbGVtU2l6ZTsgKytpLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgdmFyIHggPSBib3hlc1thUHRyXVxuICAgICAgYm94ZXNbYVB0cl0gPSBib3hlc1tiUHRyXVxuICAgICAgYm94ZXNbYlB0cl0gPSB4XG4gICAgfVxuICAgIHZhciB5ID0gaWRzW2hpLTFdXG4gICAgaWRzW2hpLTFdID0gaWRzW3Bpdm90XVxuICAgIGlkc1twaXZvdF0gPSB5XG5cbiAgICAvL1N3YXAgcGl2b3QgdG8gbGFzdCBwaXZvdFxuICAgIGlmKG1pZCA8IHBpdm90KSB7XG4gICAgICBoaSA9IHBpdm90LTFcbiAgICAgIHdoaWxlKGxvIDwgaGkgJiYgXG4gICAgICAgIGJveGVzW2VsZW1TaXplKihoaS0xKStheGlzXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgaGkgLT0gMVxuICAgICAgfVxuICAgICAgaGkgKz0gMVxuICAgIH0gZWxzZSBpZihwaXZvdCA8IG1pZCkge1xuICAgICAgbG8gPSBwaXZvdCArIDFcbiAgICAgIHdoaWxlKGxvIDwgaGkgJiZcbiAgICAgICAgYm94ZXNbZWxlbVNpemUqbG8rYXhpc10gPT09IHZhbHVlKSB7XG4gICAgICAgIGxvICs9IDFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvL01ha2Ugc3VyZSBwaXZvdCBpcyBhdCBzdGFydFxuICByZXR1cm4gcGFydGl0aW9uU3RhcnRMZXNzVGhhbihcbiAgICBkLCBheGlzLCBcbiAgICBzdGFydCwgbWlkLCBib3hlcywgaWRzLFxuICAgIGJveGVzW2VsZW1TaXplKm1pZCtheGlzXSlcbn0iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5QYXJ0aXRpb25cblxudmFyIGNvZGUgPSAnZm9yKHZhciBqPTIqYSxrPWoqYyxsPWssbT1jLG49YixvPWErYixwPWM7ZD5wOysrcCxrKz1qKXt2YXIgXztpZigkKWlmKG09PT1wKW0rPTEsbCs9ajtlbHNle2Zvcih2YXIgcz0wO2o+czsrK3Mpe3ZhciB0PWVbaytzXTtlW2src109ZVtsXSxlW2wrK109dH12YXIgdT1mW3BdO2ZbcF09ZlttXSxmW20rK109dX19cmV0dXJuIG0nXG5cbmZ1bmN0aW9uIGdlblBhcnRpdGlvbihwcmVkaWNhdGUsIGFyZ3MpIHtcbiAgdmFyIGZhcmdzID0nYWJjZGVmJy5zcGxpdCgnJykuY29uY2F0KGFyZ3MpXG4gIHZhciByZWFkcyA9IFtdXG4gIGlmKHByZWRpY2F0ZS5pbmRleE9mKCdsbycpID49IDApIHtcbiAgICByZWFkcy5wdXNoKCdsbz1lW2srbl0nKVxuICB9XG4gIGlmKHByZWRpY2F0ZS5pbmRleE9mKCdoaScpID49IDApIHtcbiAgICByZWFkcy5wdXNoKCdoaT1lW2srb10nKVxuICB9XG4gIGZhcmdzLnB1c2goXG4gICAgY29kZS5yZXBsYWNlKCdfJywgcmVhZHMuam9pbigpKVxuICAgICAgICAucmVwbGFjZSgnJCcsIHByZWRpY2F0ZSkpXG4gIHJldHVybiBGdW5jdGlvbi5hcHBseSh2b2lkIDAsIGZhcmdzKVxufSIsIid1c2Ugc3RyaWN0JztcblxuLy9UaGlzIGNvZGUgaXMgZXh0cmFjdGVkIGZyb20gbmRhcnJheS1zb3J0XG4vL0l0IGlzIGlubGluZWQgaGVyZSBhcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kXG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHBlcjtcblxudmFyIElOU0VSVF9TT1JUX0NVVE9GRiA9IDMyXG5cbmZ1bmN0aW9uIHdyYXBwZXIoZGF0YSwgbjApIHtcbiAgaWYgKG4wIDw9IDQqSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydCgwLCBuMCAtIDEsIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHF1aWNrU29ydCgwLCBuMCAtIDEsIGRhdGEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydGlvblNvcnQobGVmdCwgcmlnaHQsIGRhdGEpIHtcbiAgdmFyIHB0ciA9IDIqKGxlZnQrMSlcbiAgZm9yKHZhciBpPWxlZnQrMTsgaTw9cmlnaHQ7ICsraSkge1xuICAgIHZhciBhID0gZGF0YVtwdHIrK11cbiAgICB2YXIgYiA9IGRhdGFbcHRyKytdXG4gICAgdmFyIGogPSBpXG4gICAgdmFyIGpwdHIgPSBwdHItMlxuICAgIHdoaWxlKGotLSA+IGxlZnQpIHtcbiAgICAgIHZhciB4ID0gZGF0YVtqcHRyLTJdXG4gICAgICB2YXIgeSA9IGRhdGFbanB0ci0xXVxuICAgICAgaWYoeCA8IGEpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZih4ID09PSBhICYmIHkgPCBiKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBkYXRhW2pwdHJdICAgPSB4XG4gICAgICBkYXRhW2pwdHIrMV0gPSB5XG4gICAgICBqcHRyIC09IDJcbiAgICB9XG4gICAgZGF0YVtqcHRyXSAgID0gYVxuICAgIGRhdGFbanB0cisxXSA9IGJcbiAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICB2YXIgeCA9IGRhdGFbaV1cbiAgdmFyIHkgPSBkYXRhW2krMV1cbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtpKzFdID0gZGF0YVtqKzFdXG4gIGRhdGFbal0gPSB4XG4gIGRhdGFbaisxXSA9IHlcbn1cblxuZnVuY3Rpb24gbW92ZShpLCBqLCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtpKzFdID0gZGF0YVtqKzFdXG59XG5cbmZ1bmN0aW9uIHJvdGF0ZShpLCBqLCBrLCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgayAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXVxuICB2YXIgeSA9IGRhdGFbaSsxXVxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbiAgZGF0YVtqXSA9IGRhdGFba11cbiAgZGF0YVtqKzFdID0gZGF0YVtrKzFdXG4gIGRhdGFba10gPSB4XG4gIGRhdGFbaysxXSA9IHlcbn1cblxuZnVuY3Rpb24gc2h1ZmZsZVBpdm90KGksIGosIHB4LCBweSwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbal0gPSBweFxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbiAgZGF0YVtqKzFdID0gcHlcbn1cblxuZnVuY3Rpb24gY29tcGFyZShpLCBqLCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldLFxuICAgICAgeSA9IGRhdGFbal1cbiAgaWYoeCA8IHkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmKHggPT09IHkpIHtcbiAgICByZXR1cm4gZGF0YVtpKzFdID4gZGF0YVtqKzFdXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY29tcGFyZVBpdm90KGksIHksIGIsIGRhdGEpIHtcbiAgaSAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXVxuICBpZih4IDwgeSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZih4ID09PSB5KSB7XG4gICAgcmV0dXJuIGRhdGFbaSsxXSA8IGJcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcXVpY2tTb3J0KGxlZnQsIHJpZ2h0LCBkYXRhKSB7XG4gIHZhciBzaXh0aCA9IChyaWdodCAtIGxlZnQgKyAxKSAvIDYgfCAwLCBcbiAgICAgIGluZGV4MSA9IGxlZnQgKyBzaXh0aCwgXG4gICAgICBpbmRleDUgPSByaWdodCAtIHNpeHRoLCBcbiAgICAgIGluZGV4MyA9IGxlZnQgKyByaWdodCA+PiAxLCBcbiAgICAgIGluZGV4MiA9IGluZGV4MyAtIHNpeHRoLCBcbiAgICAgIGluZGV4NCA9IGluZGV4MyArIHNpeHRoLCBcbiAgICAgIGVsMSA9IGluZGV4MSwgXG4gICAgICBlbDIgPSBpbmRleDIsIFxuICAgICAgZWwzID0gaW5kZXgzLCBcbiAgICAgIGVsNCA9IGluZGV4NCwgXG4gICAgICBlbDUgPSBpbmRleDUsIFxuICAgICAgbGVzcyA9IGxlZnQgKyAxLCBcbiAgICAgIGdyZWF0ID0gcmlnaHQgLSAxLCBcbiAgICAgIHRtcCA9IDBcbiAgaWYoY29tcGFyZShlbDEsIGVsMiwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDFcbiAgICBlbDEgPSBlbDJcbiAgICBlbDIgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsNCwgZWw1LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsNFxuICAgIGVsNCA9IGVsNVxuICAgIGVsNSA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwxLCBlbDMsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwxXG4gICAgZWwxID0gZWwzXG4gICAgZWwzID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDIsIGVsMywgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDJcbiAgICBlbDIgPSBlbDNcbiAgICBlbDMgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMSwgZWw0LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMVxuICAgIGVsMSA9IGVsNFxuICAgIGVsNCA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwzLCBlbDQsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwzXG4gICAgZWwzID0gZWw0XG4gICAgZWw0ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDIsIGVsNSwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDJcbiAgICBlbDIgPSBlbDVcbiAgICBlbDUgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWwzLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsM1xuICAgIGVsMyA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWw0LCBlbDUsIGRhdGEpKSB7XG4gICAgdG1wID0gZWw0XG4gICAgZWw0ID0gZWw1XG4gICAgZWw1ID0gdG1wXG4gIH1cblxuICB2YXIgcGl2b3QxWCA9IGRhdGFbMiplbDJdXG4gIHZhciBwaXZvdDFZID0gZGF0YVsyKmVsMisxXVxuICB2YXIgcGl2b3QyWCA9IGRhdGFbMiplbDRdXG4gIHZhciBwaXZvdDJZID0gZGF0YVsyKmVsNCsxXVxuXG4gIHZhciBwdHIwID0gMiAqIGVsMTtcbiAgdmFyIHB0cjIgPSAyICogZWwzO1xuICB2YXIgcHRyNCA9IDIgKiBlbDU7XG4gIHZhciBwdHI1ID0gMiAqIGluZGV4MTtcbiAgdmFyIHB0cjYgPSAyICogaW5kZXgzO1xuICB2YXIgcHRyNyA9IDIgKiBpbmRleDU7XG4gIGZvciAodmFyIGkxID0gMDsgaTEgPCAyOyArK2kxKSB7XG4gICAgdmFyIHggPSBkYXRhW3B0cjAraTFdO1xuICAgIHZhciB5ID0gZGF0YVtwdHIyK2kxXTtcbiAgICB2YXIgeiA9IGRhdGFbcHRyNCtpMV07XG4gICAgZGF0YVtwdHI1K2kxXSA9IHg7XG4gICAgZGF0YVtwdHI2K2kxXSA9IHk7XG4gICAgZGF0YVtwdHI3K2kxXSA9IHo7XG4gIH1cblxuICBtb3ZlKGluZGV4MiwgbGVmdCwgZGF0YSlcbiAgbW92ZShpbmRleDQsIHJpZ2h0LCBkYXRhKVxuICBmb3IgKHZhciBrID0gbGVzczsgayA8PSBncmVhdDsgKytrKSB7XG4gICAgaWYgKGNvbXBhcmVQaXZvdChrLCBwaXZvdDFYLCBwaXZvdDFZLCBkYXRhKSkge1xuICAgICAgaWYgKGsgIT09IGxlc3MpIHtcbiAgICAgICAgc3dhcChrLCBsZXNzLCBkYXRhKVxuICAgICAgfVxuICAgICAgKytsZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNvbXBhcmVQaXZvdChrLCBwaXZvdDJYLCBwaXZvdDJZLCBkYXRhKSkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmICghY29tcGFyZVBpdm90KGdyZWF0LCBwaXZvdDJYLCBwaXZvdDJZLCBkYXRhKSkge1xuICAgICAgICAgICAgaWYgKC0tZ3JlYXQgPCBrKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlUGl2b3QoZ3JlYXQsIHBpdm90MVgsIHBpdm90MVksIGRhdGEpKSB7XG4gICAgICAgICAgICAgIHJvdGF0ZShrLCBsZXNzLCBncmVhdCwgZGF0YSlcbiAgICAgICAgICAgICAgKytsZXNzO1xuICAgICAgICAgICAgICAtLWdyZWF0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3dhcChrLCBncmVhdCwgZGF0YSlcbiAgICAgICAgICAgICAgLS1ncmVhdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaHVmZmxlUGl2b3QobGVmdCwgbGVzcy0xLCBwaXZvdDFYLCBwaXZvdDFZLCBkYXRhKVxuICBzaHVmZmxlUGl2b3QocmlnaHQsIGdyZWF0KzEsIHBpdm90MlgsIHBpdm90MlksIGRhdGEpXG4gIGlmIChsZXNzIC0gMiAtIGxlZnQgPD0gSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydChsZWZ0LCBsZXNzIC0gMiwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGxlZnQsIGxlc3MgLSAyLCBkYXRhKTtcbiAgfVxuICBpZiAocmlnaHQgLSAoZ3JlYXQgKyAyKSA8PSBJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KGdyZWF0ICsgMiwgcmlnaHQsIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHF1aWNrU29ydChncmVhdCArIDIsIHJpZ2h0LCBkYXRhKTtcbiAgfVxuICBpZiAoZ3JlYXQgLSBsZXNzIDw9IElOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQobGVzcywgZ3JlYXQsIGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHF1aWNrU29ydChsZXNzLCBncmVhdCwgZGF0YSk7XG4gIH1cbn0iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXQ6ICAgICAgICAgICBzcUluaXQsXG4gIHN3ZWVwQmlwYXJ0aXRlOiBzd2VlcEJpcGFydGl0ZSxcbiAgc3dlZXBDb21wbGV0ZTogIHN3ZWVwQ29tcGxldGUsXG4gIHNjYW5CaXBhcnRpdGU6ICBzY2FuQmlwYXJ0aXRlLFxuICBzY2FuQ29tcGxldGU6ICAgc2NhbkNvbXBsZXRlXG59XG5cbnZhciBwb29sICA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktcG9vbCcpXG52YXIgYml0cyAgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpXG52YXIgaXNvcnQgPSByZXF1aXJlKCcuL3NvcnQnKVxuXG4vL0ZsYWcgZm9yIGJsdWVcbnZhciBCTFVFX0ZMQUcgPSAoMTw8MjgpXG5cbi8vMUQgc3dlZXAgZXZlbnQgcXVldWUgc3R1ZmYgKHVzZSBwb29sIHRvIHNhdmUgc3BhY2UpXG52YXIgSU5JVF9DQVBBQ0lUWSAgICAgID0gMTAyNFxudmFyIFJFRF9TV0VFUF9RVUVVRSAgICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBSRURfU1dFRVBfSU5ERVggICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQkxVRV9TV0VFUF9RVUVVRSAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIEJMVUVfU1dFRVBfSU5ERVggICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBDT01NT05fU1dFRVBfUVVFVUUgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQ09NTU9OX1NXRUVQX0lOREVYID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIFNXRUVQX0VWRU5UUyAgICAgICA9IHBvb2wubWFsbG9jRG91YmxlKElOSVRfQ0FQQUNJVFkgKiA4KVxuXG4vL1Jlc2VydmVzIG1lbW9yeSBmb3IgdGhlIDFEIHN3ZWVwIGRhdGEgc3RydWN0dXJlc1xuZnVuY3Rpb24gc3FJbml0KGNvdW50KSB7XG4gIHZhciByY291bnQgPSBiaXRzLm5leHRQb3cyKGNvdW50KVxuICBpZihSRURfU1dFRVBfUVVFVUUubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKFJFRF9TV0VFUF9RVUVVRSlcbiAgICBSRURfU1dFRVBfUVVFVUUgPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICBpZihSRURfU1dFRVBfSU5ERVgubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKFJFRF9TV0VFUF9JTkRFWClcbiAgICBSRURfU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICBpZihCTFVFX1NXRUVQX1FVRVVFLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShCTFVFX1NXRUVQX1FVRVVFKVxuICAgIEJMVUVfU1dFRVBfUVVFVUUgPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICBpZihCTFVFX1NXRUVQX0lOREVYLmxlbmd0aCA8IHJjb3VudCkge1xuICAgIHBvb2wuZnJlZShCTFVFX1NXRUVQX0lOREVYKVxuICAgIEJMVUVfU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICBpZihDT01NT05fU1dFRVBfUVVFVUUubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKENPTU1PTl9TV0VFUF9RVUVVRSlcbiAgICBDT01NT05fU1dFRVBfUVVFVUUgPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICBpZihDT01NT05fU1dFRVBfSU5ERVgubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKENPTU1PTl9TV0VFUF9JTkRFWClcbiAgICBDT01NT05fU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKHJjb3VudClcbiAgfVxuICB2YXIgZXZlbnRMZW5ndGggPSA4ICogcmNvdW50XG4gIGlmKFNXRUVQX0VWRU5UUy5sZW5ndGggPCBldmVudExlbmd0aCkge1xuICAgIHBvb2wuZnJlZShTV0VFUF9FVkVOVFMpXG4gICAgU1dFRVBfRVZFTlRTID0gcG9vbC5tYWxsb2NEb3VibGUoZXZlbnRMZW5ndGgpXG4gIH1cbn1cblxuLy9SZW1vdmUgYW4gaXRlbSBmcm9tIHRoZSBhY3RpdmUgcXVldWUgaW4gTygxKVxuZnVuY3Rpb24gc3FQb3AocXVldWUsIGluZGV4LCBjb3VudCwgaXRlbSkge1xuICB2YXIgaWR4ID0gaW5kZXhbaXRlbV1cbiAgdmFyIHRvcCA9IHF1ZXVlW2NvdW50LTFdXG4gIHF1ZXVlW2lkeF0gPSB0b3BcbiAgaW5kZXhbdG9wXSA9IGlkeFxufVxuXG4vL0luc2VydCBhbiBpdGVtIGludG8gdGhlIGFjdGl2ZSBxdWV1ZSBpbiBPKDEpXG5mdW5jdGlvbiBzcVB1c2gocXVldWUsIGluZGV4LCBjb3VudCwgaXRlbSkge1xuICBxdWV1ZVtjb3VudF0gPSBpdGVtXG4gIGluZGV4W2l0ZW1dICA9IGNvdW50XG59XG5cbi8vUmVjdXJzaW9uIGJhc2UgY2FzZTogdXNlIDFEIHN3ZWVwIGFsZ29yaXRobVxuZnVuY3Rpb24gc3dlZXBCaXBhcnRpdGUoXG4gICAgZCwgdmlzaXQsXG4gICAgcmVkU3RhcnQsICByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcblxuICAvL3N0b3JlIGV2ZW50cyBhcyBwYWlycyBbY29vcmRpbmF0ZSwgaWR4XVxuICAvL1xuICAvLyAgcmVkIGNyZWF0ZTogIC0oaWR4KzEpXG4gIC8vICByZWQgZGVzdHJveTogaWR4XG4gIC8vICBibHVlIGNyZWF0ZTogLShpZHgrQkxVRV9GTEFHKVxuICAvLyAgYmx1ZSBkZXN0cm95OiBpZHgrQkxVRV9GTEFHXG4gIC8vXG4gIHZhciBwdHIgICAgICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBpc3RhcnQgICA9IGQtMVxuICB2YXIgaWVuZCAgICAgPSBlbGVtU2l6ZS0xXG5cbiAgZm9yKHZhciBpPXJlZFN0YXJ0OyBpPHJlZEVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IHJlZEluZGV4W2ldXG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC0oaWR4KzEpXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cblxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBibHVlSW5kZXhbaV0rQkxVRV9GTEFHXG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgID0gMFxuICB2YXIgYmx1ZUFjdGl2ZSA9IDBcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGUgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICBpZihlID49IEJMVUVfRkxBRykge1xuICAgICAgLy9ibHVlIGRlc3Ryb3kgZXZlbnRcbiAgICAgIGUgPSAoZS1CTFVFX0ZMQUcpfDBcbiAgICAgIHNxUG9wKEJMVUVfU1dFRVBfUVVFVUUsIEJMVUVfU1dFRVBfSU5ERVgsIGJsdWVBY3RpdmUtLSwgZSlcbiAgICB9IGVsc2UgaWYoZSA+PSAwKSB7XG4gICAgICAvL3JlZCBkZXN0cm95IGV2ZW50XG4gICAgICBzcVBvcChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlLS0sIGUpXG4gICAgfSBlbHNlIGlmKGUgPD0gLUJMVUVfRkxBRykge1xuICAgICAgLy9ibHVlIGNyZWF0ZSBldmVudFxuICAgICAgZSA9ICgtZS1CTFVFX0ZMQUcpfDBcbiAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChSRURfU1dFRVBfUVVFVUVbal0sIGUpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcVB1c2goQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZSsrLCBlKVxuICAgIH0gZWxzZSB7XG4gICAgICAvL3JlZCBjcmVhdGUgZXZlbnRcbiAgICAgIGUgPSAoLWUtMSl8MFxuICAgICAgZm9yKHZhciBqPTA7IGo8Ymx1ZUFjdGl2ZTsgKytqKSB7XG4gICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChlLCBCTFVFX1NXRUVQX1FVRVVFW2pdKVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3FQdXNoKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUrKywgZSlcbiAgICB9XG4gIH1cbn1cblxuLy9Db21wbGV0ZSBzd2VlcFxuZnVuY3Rpb24gc3dlZXBDb21wbGV0ZShkLCB2aXNpdCwgXG4gIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG5cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gZC0xXG4gIHZhciBpZW5kICAgICA9IGVsZW1TaXplLTFcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gKHJlZEluZGV4W2ldKzEpPDwxXG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuXG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChibHVlSW5kZXhbaV0rMSk8PDFcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gKC1pZHgpfDFcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeHwxXG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgICA9IDBcbiAgdmFyIGJsdWVBY3RpdmUgICA9IDBcbiAgdmFyIGNvbW1vbkFjdGl2ZSA9IDBcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGUgICAgID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgdmFyIGNvbG9yID0gZSYxXG4gICAgaWYoaSA8IG4tMSAmJiAoZT4+MSkgPT09IChTV0VFUF9FVkVOVFNbMippKzNdPj4xKSkge1xuICAgICAgY29sb3IgPSAyXG4gICAgICBpICs9IDFcbiAgICB9XG4gICAgXG4gICAgaWYoZSA8IDApIHtcbiAgICAgIC8vQ3JlYXRlIGV2ZW50XG4gICAgICB2YXIgaWQgPSAtKGU+PjEpIC0gMVxuXG4gICAgICAvL0ludGVyc2VjdCB3aXRoIGNvbW1vblxuICAgICAgZm9yKHZhciBqPTA7IGo8Y29tbW9uQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KENPTU1PTl9TV0VFUF9RVUVVRVtqXSwgaWQpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbG9yICE9PSAwKSB7XG4gICAgICAgIC8vSW50ZXJzZWN0IHdpdGggcmVkXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KFJFRF9TV0VFUF9RVUVVRVtqXSwgaWQpXG4gICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY29sb3IgIT09IDEpIHtcbiAgICAgICAgLy9JbnRlcnNlY3Qgd2l0aCBibHVlXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPGJsdWVBY3RpdmU7ICsraikge1xuICAgICAgICAgIHZhciByZXR2YWwgPSB2aXNpdChCTFVFX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihjb2xvciA9PT0gMCkge1xuICAgICAgICAvL1JlZFxuICAgICAgICBzcVB1c2goUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZSsrLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMSkge1xuICAgICAgICAvL0JsdWVcbiAgICAgICAgc3FQdXNoKEJMVUVfU1dFRVBfUVVFVUUsIEJMVUVfU1dFRVBfSU5ERVgsIGJsdWVBY3RpdmUrKywgaWQpXG4gICAgICB9IGVsc2UgaWYoY29sb3IgPT09IDIpIHtcbiAgICAgICAgLy9Cb3RoXG4gICAgICAgIHNxUHVzaChDT01NT05fU1dFRVBfUVVFVUUsIENPTU1PTl9TV0VFUF9JTkRFWCwgY29tbW9uQWN0aXZlKyssIGlkKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL0Rlc3Ryb3kgZXZlbnRcbiAgICAgIHZhciBpZCA9IChlPj4xKSAtIDFcbiAgICAgIGlmKGNvbG9yID09PSAwKSB7XG4gICAgICAgIC8vUmVkXG4gICAgICAgIHNxUG9wKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUtLSwgaWQpXG4gICAgICB9IGVsc2UgaWYoY29sb3IgPT09IDEpIHtcbiAgICAgICAgLy9CbHVlXG4gICAgICAgIHNxUG9wKEJMVUVfU1dFRVBfUVVFVUUsIEJMVUVfU1dFRVBfSU5ERVgsIGJsdWVBY3RpdmUtLSwgaWQpXG4gICAgICB9IGVsc2UgaWYoY29sb3IgPT09IDIpIHtcbiAgICAgICAgLy9Cb3RoXG4gICAgICAgIHNxUG9wKENPTU1PTl9TV0VFUF9RVUVVRSwgQ09NTU9OX1NXRUVQX0lOREVYLCBjb21tb25BY3RpdmUtLSwgaWQpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vU3dlZXAgYW5kIHBydW5lL3NjYW5saW5lIGFsZ29yaXRobTpcbi8vICBTY2FuIGFsb25nIGF4aXMsIGRldGVjdCBpbnRlcnNlY3Rpb25zXG4vLyAgQnJ1dGUgZm9yY2UgYWxsIGJveGVzIGFsb25nIGF4aXNcbmZ1bmN0aW9uIHNjYW5CaXBhcnRpdGUoXG4gIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICByZWRTdGFydCwgIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcbiAgXG4gIHZhciBwdHIgICAgICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBpc3RhcnQgICA9IGF4aXNcbiAgdmFyIGllbmQgICAgID0gYXhpcytkXG5cbiAgdmFyIHJlZFNoaWZ0ICA9IDFcbiAgdmFyIGJsdWVTaGlmdCA9IDFcbiAgaWYoZmxpcCkge1xuICAgIGJsdWVTaGlmdCA9IEJMVUVfRkxBR1xuICB9IGVsc2Uge1xuICAgIHJlZFNoaWZ0ICA9IEJMVUVfRkxBR1xuICB9XG5cbiAgZm9yKHZhciBpPXJlZFN0YXJ0OyBpPHJlZEVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGkgKyByZWRTaGlmdFxuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIGJsdWVTaGlmdFxuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgICA9IDBcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGUgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICBpZihlIDwgMCkge1xuICAgICAgdmFyIGlkeCAgID0gLWVcbiAgICAgIHZhciBpc1JlZCA9IGZhbHNlXG4gICAgICBpZihpZHggPj0gQkxVRV9GTEFHKSB7XG4gICAgICAgIGlzUmVkID0gIWZsaXBcbiAgICAgICAgaWR4IC09IEJMVUVfRkxBRyBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzUmVkID0gISFmbGlwXG4gICAgICAgIGlkeCAtPSAxXG4gICAgICB9XG4gICAgICBpZihpc1JlZCkge1xuICAgICAgICBzcVB1c2goUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZSsrLCBpZHgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmx1ZUlkICA9IGJsdWVJbmRleFtpZHhdXG4gICAgICAgIHZhciBibHVlUHRyID0gZWxlbVNpemUgKiBpZHhcbiAgICAgICAgXG4gICAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citheGlzKzFdXG4gICAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citheGlzKzErZF1cblxucmVkX2xvb3A6XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIG9pZHggICA9IFJFRF9TV0VFUF9RVUVVRVtqXVxuICAgICAgICAgIHZhciByZWRQdHIgPSBlbGVtU2l6ZSAqIG9pZHhcblxuICAgICAgICAgIGlmKGIxIDwgcmVkW3JlZFB0citheGlzKzFdIHx8IFxuICAgICAgICAgICAgIHJlZFtyZWRQdHIrYXhpcysxK2RdIDwgYjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yKHZhciBrPWF4aXMrMjsgazxkOyArK2spIHtcbiAgICAgICAgICAgIGlmKGJsdWVbYmx1ZVB0ciArIGsgKyBkXSA8IHJlZFtyZWRQdHIgKyBrXSB8fCBcbiAgICAgICAgICAgICAgIHJlZFtyZWRQdHIgKyBrICsgZF0gPCBibHVlW2JsdWVQdHIgKyBrXSkge1xuICAgICAgICAgICAgICBjb250aW51ZSByZWRfbG9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWRJZCAgPSByZWRJbmRleFtvaWR4XVxuICAgICAgICAgIHZhciByZXR2YWxcbiAgICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgICByZXR2YWwgPSB2aXNpdChibHVlSWQsIHJlZElkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbCBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3FQb3AoUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZS0tLCBlIC0gcmVkU2hpZnQpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjYW5Db21wbGV0ZShcbiAgZCwgYXhpcywgdmlzaXQsXG4gIHJlZFN0YXJ0LCAgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuXG4gIHZhciBwdHIgICAgICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMipkXG4gIHZhciBpc3RhcnQgICA9IGF4aXNcbiAgdmFyIGllbmQgICAgID0gYXhpcytkXG5cbiAgZm9yKHZhciBpPXJlZFN0YXJ0OyBpPHJlZEVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGkgKyBCTFVFX0ZMQUdcbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGkgKyAxXG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPCAwKSB7XG4gICAgICB2YXIgaWR4ICAgPSAtZVxuICAgICAgaWYoaWR4ID49IEJMVUVfRkxBRykge1xuICAgICAgICBSRURfU1dFRVBfUVVFVUVbcmVkQWN0aXZlKytdID0gaWR4IC0gQkxVRV9GTEFHXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHggLT0gMVxuICAgICAgICB2YXIgYmx1ZUlkICA9IGJsdWVJbmRleFtpZHhdXG4gICAgICAgIHZhciBibHVlUHRyID0gZWxlbVNpemUgKiBpZHhcblxuICAgICAgICB2YXIgYjAgPSBibHVlW2JsdWVQdHIrYXhpcysxXVxuICAgICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIrYXhpcysxK2RdXG5cbnJlZF9sb29wOlxuICAgICAgICBmb3IodmFyIGo9MDsgajxyZWRBY3RpdmU7ICsraikge1xuICAgICAgICAgIHZhciBvaWR4ICAgPSBSRURfU1dFRVBfUVVFVUVbal1cbiAgICAgICAgICB2YXIgcmVkSWQgID0gcmVkSW5kZXhbb2lkeF1cblxuICAgICAgICAgIGlmKHJlZElkID09PSBibHVlSWQpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlZFB0ciA9IGVsZW1TaXplICogb2lkeFxuICAgICAgICAgIGlmKGIxIDwgcmVkW3JlZFB0citheGlzKzFdIHx8IFxuICAgICAgICAgICAgcmVkW3JlZFB0citheGlzKzErZF0gPCBiMCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yKHZhciBrPWF4aXMrMjsgazxkOyArK2spIHtcbiAgICAgICAgICAgIGlmKGJsdWVbYmx1ZVB0ciArIGsgKyBkXSA8IHJlZFtyZWRQdHIgKyBrXSB8fCBcbiAgICAgICAgICAgICAgIHJlZFtyZWRQdHIgKyBrICsgZF0gICA8IGJsdWVbYmx1ZVB0ciArIGtdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXR2YWwgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpZHggPSBlIC0gQkxVRV9GTEFHXG4gICAgICBmb3IodmFyIGo9cmVkQWN0aXZlLTE7IGo+PTA7IC0taikge1xuICAgICAgICBpZihSRURfU1dFRVBfUVVFVUVbal0gPT09IGlkeCkge1xuICAgICAgICAgIGZvcih2YXIgaz1qKzE7IGs8cmVkQWN0aXZlOyArK2spIHtcbiAgICAgICAgICAgIFJFRF9TV0VFUF9RVUVVRVtrLTFdID0gUkVEX1NXRUVQX1FVRVVFW2tdXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC0tcmVkQWN0aXZlXG4gICAgfVxuICB9XG59IiwiLyoqXG4gKiBCaXQgdHdpZGRsaW5nIGhhY2tzIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEF1dGhvcjogTWlrb2xhIEx5c2Vua29cbiAqXG4gKiBQb3J0ZWQgZnJvbSBTdGFuZm9yZCBiaXQgdHdpZGRsaW5nIGhhY2sgbGlicmFyeTpcbiAqICAgIGh0dHA6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbFxuICovXG5cblwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG4vL051bWJlciBvZiBiaXRzIGluIGFuIGludGVnZXJcbnZhciBJTlRfQklUUyA9IDMyO1xuXG4vL0NvbnN0YW50c1xuZXhwb3J0cy5JTlRfQklUUyAgPSBJTlRfQklUUztcbmV4cG9ydHMuSU5UX01BWCAgID0gIDB4N2ZmZmZmZmY7XG5leHBvcnRzLklOVF9NSU4gICA9IC0xPDwoSU5UX0JJVFMtMSk7XG5cbi8vUmV0dXJucyAtMSwgMCwgKzEgZGVwZW5kaW5nIG9uIHNpZ24gb2YgeFxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gKHYgPiAwKSAtICh2IDwgMCk7XG59XG5cbi8vQ29tcHV0ZXMgYWJzb2x1dGUgdmFsdWUgb2YgaW50ZWdlclxuZXhwb3J0cy5hYnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBtYXNrID0gdiA+PiAoSU5UX0JJVFMtMSk7XG4gIHJldHVybiAodiBeIG1hc2spIC0gbWFzaztcbn1cblxuLy9Db21wdXRlcyBtaW5pbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWluID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geSBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NvbXB1dGVzIG1heGltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5tYXggPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB4IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ2hlY2tzIGlmIGEgbnVtYmVyIGlzIGEgcG93ZXIgb2YgdHdvXG5leHBvcnRzLmlzUG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICEodiAmICh2LTEpKSAmJiAoISF2KTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAyIG9mIHZcbmV4cG9ydHMubG9nMiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHIsIHNoaWZ0O1xuICByID0gICAgICh2ID4gMHhGRkZGKSA8PCA0OyB2ID4+Pj0gcjtcbiAgc2hpZnQgPSAodiA+IDB4RkYgICkgPDwgMzsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHhGICAgKSA8PCAyOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweDMgICApIDw8IDE7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgcmV0dXJuIHIgfCAodiA+PiAxKTtcbn1cblxuLy9Db21wdXRlcyBsb2cgYmFzZSAxMCBvZiB2XG5leHBvcnRzLmxvZzEwID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gICh2ID49IDEwMDAwMDAwMDApID8gOSA6ICh2ID49IDEwMDAwMDAwMCkgPyA4IDogKHYgPj0gMTAwMDAwMDApID8gNyA6XG4gICAgICAgICAgKHYgPj0gMTAwMDAwMCkgPyA2IDogKHYgPj0gMTAwMDAwKSA/IDUgOiAodiA+PSAxMDAwMCkgPyA0IDpcbiAgICAgICAgICAodiA+PSAxMDAwKSA/IDMgOiAodiA+PSAxMDApID8gMiA6ICh2ID49IDEwKSA/IDEgOiAwO1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgYml0c1xuZXhwb3J0cy5wb3BDb3VudCA9IGZ1bmN0aW9uKHYpIHtcbiAgdiA9IHYgLSAoKHYgPj4+IDEpICYgMHg1NTU1NTU1NSk7XG4gIHYgPSAodiAmIDB4MzMzMzMzMzMpICsgKCh2ID4+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICByZXR1cm4gKCh2ICsgKHYgPj4+IDQpICYgMHhGMEYwRjBGKSAqIDB4MTAxMDEwMSkgPj4+IDI0O1xufVxuXG4vL0NvdW50cyBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3NcbmZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcyh2KSB7XG4gIHZhciBjID0gMzI7XG4gIHYgJj0gLXY7XG4gIGlmICh2KSBjLS07XG4gIGlmICh2ICYgMHgwMDAwRkZGRikgYyAtPSAxNjtcbiAgaWYgKHYgJiAweDAwRkYwMEZGKSBjIC09IDg7XG4gIGlmICh2ICYgMHgwRjBGMEYwRikgYyAtPSA0O1xuICBpZiAodiAmIDB4MzMzMzMzMzMpIGMgLT0gMjtcbiAgaWYgKHYgJiAweDU1NTU1NTU1KSBjIC09IDE7XG4gIHJldHVybiBjO1xufVxuZXhwb3J0cy5jb3VudFRyYWlsaW5nWmVyb3MgPSBjb3VudFRyYWlsaW5nWmVyb3M7XG5cbi8vUm91bmRzIHRvIG5leHQgcG93ZXIgb2YgMlxuZXhwb3J0cy5uZXh0UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiArPSB2ID09PSAwO1xuICAtLXY7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgKyAxO1xufVxuXG4vL1JvdW5kcyBkb3duIHRvIHByZXZpb3VzIHBvd2VyIG9mIDJcbmV4cG9ydHMucHJldlBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgfD0gdiA+Pj4gMTtcbiAgdiB8PSB2ID4+PiAyO1xuICB2IHw9IHYgPj4+IDQ7XG4gIHYgfD0gdiA+Pj4gODtcbiAgdiB8PSB2ID4+PiAxNjtcbiAgcmV0dXJuIHYgLSAodj4+PjEpO1xufVxuXG4vL0NvbXB1dGVzIHBhcml0eSBvZiB3b3JkXG5leHBvcnRzLnBhcml0eSA9IGZ1bmN0aW9uKHYpIHtcbiAgdiBePSB2ID4+PiAxNjtcbiAgdiBePSB2ID4+PiA4O1xuICB2IF49IHYgPj4+IDQ7XG4gIHYgJj0gMHhmO1xuICByZXR1cm4gKDB4Njk5NiA+Pj4gdikgJiAxO1xufVxuXG52YXIgUkVWRVJTRV9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuXG4oZnVuY3Rpb24odGFiKSB7XG4gIGZvcih2YXIgaT0wOyBpPDI1NjsgKytpKSB7XG4gICAgdmFyIHYgPSBpLCByID0gaSwgcyA9IDc7XG4gICAgZm9yICh2ID4+Pj0gMTsgdjsgdiA+Pj49IDEpIHtcbiAgICAgIHIgPDw9IDE7XG4gICAgICByIHw9IHYgJiAxO1xuICAgICAgLS1zO1xuICAgIH1cbiAgICB0YWJbaV0gPSAociA8PCBzKSAmIDB4ZmY7XG4gIH1cbn0pKFJFVkVSU0VfVEFCTEUpO1xuXG4vL1JldmVyc2UgYml0cyBpbiBhIDMyIGJpdCB3b3JkXG5leHBvcnRzLnJldmVyc2UgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKFJFVkVSU0VfVEFCTEVbIHYgICAgICAgICAmIDB4ZmZdIDw8IDI0KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDgpICAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgICAgKFJFVkVSU0VfVEFCTEVbKHYgPj4+IDE2KSAmIDB4ZmZdIDw8IDgpICB8XG4gICAgICAgICAgIFJFVkVSU0VfVEFCTEVbKHYgPj4+IDI0KSAmIDB4ZmZdO1xufVxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAyIGNvb3JkaW5hdGVzIHdpdGggMTYgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBxdWFkdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgeCAmPSAweEZGRkY7XG4gIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgeSAmPSAweEZGRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy9FeHRyYWN0cyB0aGUgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudFxuZXhwb3J0cy5kZWludGVybGVhdmUyID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICYgMHg1NTU1NTU1NTtcbiAgdiA9ICh2IHwgKHYgPj4+IDEpKSAgJiAweDMzMzMzMzMzO1xuICB2ID0gKHYgfCAodiA+Pj4gMikpICAmIDB4MEYwRjBGMEY7XG4gIHYgPSAodiB8ICh2ID4+PiA0KSkgICYgMHgwMEZGMDBGRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDE2KSkgJiAweDAwMEZGRkY7XG4gIHJldHVybiAodiA8PCAxNikgPj4gMTY7XG59XG5cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMyBjb29yZGluYXRlcywgZWFjaCB3aXRoIDEwIGJpdHMuICBVc2VmdWwgZm9yIGZhc3Qgb2N0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICB4ICY9IDB4M0ZGO1xuICB4ICA9ICh4IHwgKHg8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB4ICA9ICh4IHwgKHg8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHggID0gKHggfCAoeDw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHggID0gKHggfCAoeDw8MikpICAmIDEyMjcxMzM1MTM7XG5cbiAgeSAmPSAweDNGRjtcbiAgeSAgPSAoeSB8ICh5PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeSAgPSAoeSB8ICh5PDw4KSkgICYgMjUxNzE5Njk1O1xuICB5ICA9ICh5IHwgKHk8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB5ICA9ICh5IHwgKHk8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICB4IHw9ICh5IDw8IDEpO1xuICBcbiAgeiAmPSAweDNGRjtcbiAgeiAgPSAoeiB8ICh6PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeiAgPSAoeiB8ICh6PDw4KSkgICYgMjUxNzE5Njk1O1xuICB6ICA9ICh6IHwgKHo8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB6ICA9ICh6IHwgKHo8PDIpKSAgJiAxMjI3MTMzNTEzO1xuICBcbiAgcmV0dXJuIHggfCAoeiA8PCAyKTtcbn1cblxuLy9FeHRyYWN0cyBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50IG9mIGEgMy10dXBsZVxuZXhwb3J0cy5kZWludGVybGVhdmUzID0gZnVuY3Rpb24odiwgbikge1xuICB2ID0gKHYgPj4+IG4pICAgICAgICYgMTIyNzEzMzUxMztcbiAgdiA9ICh2IHwgKHY+Pj4yKSkgICAmIDMyNzIzNTYwMzU7XG4gIHYgPSAodiB8ICh2Pj4+NCkpICAgJiAyNTE3MTk2OTU7XG4gIHYgPSAodiB8ICh2Pj4+OCkpICAgJiA0Mjc4MTkwMzM1O1xuICB2ID0gKHYgfCAodj4+PjE2KSkgICYgMHgzRkY7XG4gIHJldHVybiAodjw8MjIpPj4yMjtcbn1cblxuLy9Db21wdXRlcyBuZXh0IGNvbWJpbmF0aW9uIGluIGNvbGV4aWNvZ3JhcGhpYyBvcmRlciAodGhpcyBpcyBtaXN0YWtlbmx5IGNhbGxlZCBuZXh0UGVybXV0YXRpb24gb24gdGhlIGJpdCB0d2lkZGxpbmcgaGFja3MgcGFnZSlcbmV4cG9ydHMubmV4dENvbWJpbmF0aW9uID0gZnVuY3Rpb24odikge1xuICB2YXIgdCA9IHYgfCAodiAtIDEpO1xuICByZXR1cm4gKHQgKyAxKSB8ICgoKH50ICYgLX50KSAtIDEpID4+PiAoY291bnRUcmFpbGluZ1plcm9zKHYpICsgMSkpO1xufVxuXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSkge1xuICB2YXIgYyA9IGNvdW50W2ldfDBcbiAgaWYoYyA8PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjKSwgalxuICBpZihpID09PSBjb3VudC5sZW5ndGgtMSkge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkrMSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlX251bWJlcihjb3VudCwgdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCwgaVxuICByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpXG4gIGZvcihpPTA7IGk8Y291bnQ7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHZhbHVlXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlKGNvdW50LCB2YWx1ZSkge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWx1ZSA9IDBcbiAgfVxuICBzd2l0Y2godHlwZW9mIGNvdW50KSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgaWYoY291bnQgPiAwKSB7XG4gICAgICAgIHJldHVybiBkdXBlX251bWJlcihjb3VudHwwLCB2YWx1ZSlcbiAgICAgIH1cbiAgICBicmVha1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmKHR5cGVvZiAoY291bnQubGVuZ3RoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIDApXG4gICAgICB9XG4gICAgYnJlYWtcbiAgfVxuICByZXR1cm4gW11cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkdXBlIiwiKGZ1bmN0aW9uIChnbG9iYWwsQnVmZmVyKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxuXG4vL0xlZ2FjeSBwb29sIHN1cHBvcnRcbmlmKCFnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wpIHtcbiAgZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MID0ge1xuICAgICAgVUlOVDggICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDE2ICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDMyICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UOCAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMTYgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMzIgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRkxPQVQgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRE9VQkxFICA6IGR1cChbMzIsIDBdKVxuICAgICwgREFUQSAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDhDICA6IGR1cChbMzIsIDBdKVxuICAgICwgQlVGRkVSICA6IGR1cChbMzIsIDBdKVxuICB9XG59XG5cbnZhciBoYXNVaW50OEMgPSAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSAhPT0gJ3VuZGVmaW5lZCdcbnZhciBQT09MID0gZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MXG5cbi8vVXBncmFkZSBwb29sXG5pZighUE9PTC5VSU5UOEMpIHtcbiAgUE9PTC5VSU5UOEMgPSBkdXAoWzMyLCAwXSlcbn1cbmlmKCFQT09MLkJVRkZFUikge1xuICBQT09MLkJVRkZFUiA9IGR1cChbMzIsIDBdKVxufVxuXG4vL05ldyB0ZWNobmlxdWU6IE9ubHkgYWxsb2NhdGUgZnJvbSBBcnJheUJ1ZmZlclZpZXcgYW5kIEJ1ZmZlclxudmFyIERBVEEgICAgPSBQT09MLkRBVEFcbiAgLCBCVUZGRVIgID0gUE9PTC5CVUZGRVJcblxuZXhwb3J0cy5mcmVlID0gZnVuY3Rpb24gZnJlZShhcnJheSkge1xuICBpZihCdWZmZXIuaXNCdWZmZXIoYXJyYXkpKSB7XG4gICAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxuICB9IGVsc2Uge1xuICAgIGlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnJheSkgIT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGFycmF5ID0gYXJyYXkuYnVmZmVyXG4gICAgfVxuICAgIGlmKCFhcnJheSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBuID0gYXJyYXkubGVuZ3RoIHx8IGFycmF5LmJ5dGVMZW5ndGhcbiAgICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobil8MFxuICAgIERBVEFbbG9nX25dLnB1c2goYXJyYXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZnJlZUFycmF5QnVmZmVyKGJ1ZmZlcikge1xuICBpZighYnVmZmVyKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG4gPSBidWZmZXIubGVuZ3RoIHx8IGJ1ZmZlci5ieXRlTGVuZ3RoXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICBEQVRBW2xvZ19uXS5wdXNoKGJ1ZmZlcilcbn1cblxuZnVuY3Rpb24gZnJlZVR5cGVkQXJyYXkoYXJyYXkpIHtcbiAgZnJlZUFycmF5QnVmZmVyKGFycmF5LmJ1ZmZlcilcbn1cblxuZXhwb3J0cy5mcmVlVWludDggPVxuZXhwb3J0cy5mcmVlVWludDE2ID1cbmV4cG9ydHMuZnJlZVVpbnQzMiA9XG5leHBvcnRzLmZyZWVJbnQ4ID1cbmV4cG9ydHMuZnJlZUludDE2ID1cbmV4cG9ydHMuZnJlZUludDMyID1cbmV4cG9ydHMuZnJlZUZsb2F0MzIgPSBcbmV4cG9ydHMuZnJlZUZsb2F0ID1cbmV4cG9ydHMuZnJlZUZsb2F0NjQgPSBcbmV4cG9ydHMuZnJlZURvdWJsZSA9IFxuZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gXG5leHBvcnRzLmZyZWVEYXRhVmlldyA9IGZyZWVUeXBlZEFycmF5XG5cbmV4cG9ydHMuZnJlZUFycmF5QnVmZmVyID0gZnJlZUFycmF5QnVmZmVyXG5cbmV4cG9ydHMuZnJlZUJ1ZmZlciA9IGZ1bmN0aW9uIGZyZWVCdWZmZXIoYXJyYXkpIHtcbiAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLm1hbGxvYyA9IGZ1bmN0aW9uIG1hbGxvYyhuLCBkdHlwZSkge1xuICBpZihkdHlwZSA9PT0gdW5kZWZpbmVkIHx8IGR0eXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgcmV0dXJuIG1hbGxvY0FycmF5QnVmZmVyKG4pXG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoKGR0eXBlKSB7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQxNihuKVxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQzMihuKVxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQ4KG4pXG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQxNihuKVxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MzIobilcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jRmxvYXQobilcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RvdWJsZShuKVxuICAgICAgY2FzZSAndWludDhfY2xhbXBlZCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OENsYW1wZWQobilcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgIHJldHVybiBtYWxsb2NCdWZmZXIobilcbiAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgY2FzZSAnZGF0YXZpZXcnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRGF0YVZpZXcobilcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbWFsbG9jQXJyYXlCdWZmZXIobikge1xuICB2YXIgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBkID0gREFUQVtsb2dfbl1cbiAgaWYoZC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGQucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0FycmF5QnVmZmVyID0gbWFsbG9jQXJyYXlCdWZmZXJcblxuZnVuY3Rpb24gbWFsbG9jVWludDgobikge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4ID0gbWFsbG9jVWludDhcblxuZnVuY3Rpb24gbWFsbG9jVWludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MTYgPSBtYWxsb2NVaW50MTZcblxuZnVuY3Rpb24gbWFsbG9jVWludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MzIgPSBtYWxsb2NVaW50MzJcblxuZnVuY3Rpb24gbWFsbG9jSW50OChuKSB7XG4gIHJldHVybiBuZXcgSW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQ4ID0gbWFsbG9jSW50OFxuXG5mdW5jdGlvbiBtYWxsb2NJbnQxNihuKSB7XG4gIHJldHVybiBuZXcgSW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQxNiA9IG1hbGxvY0ludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDMyID0gbWFsbG9jSW50MzJcblxuZnVuY3Rpb24gbWFsbG9jRmxvYXQobikge1xuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDMyID0gZXhwb3J0cy5tYWxsb2NGbG9hdCA9IG1hbGxvY0Zsb2F0XG5cbmZ1bmN0aW9uIG1hbGxvY0RvdWJsZShuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0NjQgPSBleHBvcnRzLm1hbGxvY0RvdWJsZSA9IG1hbGxvY0RvdWJsZVxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OENsYW1wZWQobikge1xuICBpZihoYXNVaW50OEMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICB9XG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4Q2xhbXBlZCA9IG1hbGxvY1VpbnQ4Q2xhbXBlZFxuXG5mdW5jdGlvbiBtYWxsb2NEYXRhVmlldyhuKSB7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0RhdGFWaWV3ID0gbWFsbG9jRGF0YVZpZXdcblxuZnVuY3Rpb24gbWFsbG9jQnVmZmVyKG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IEJVRkZFUltsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0J1ZmZlciA9IG1hbGxvY0J1ZmZlclxuXG5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICBmb3IodmFyIGk9MDsgaTwzMjsgKytpKSB7XG4gICAgUE9PTC5VSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRkxPQVRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRE9VQkxFW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQ4Q1tpXS5sZW5ndGggPSAwXG4gICAgREFUQVtpXS5sZW5ndGggPSAwXG4gICAgQlVGRkVSW2ldLmxlbmd0aCA9IDBcbiAgfVxufVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIixudWxsLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG52YXIga01heExlbmd0aCA9IDB4M2ZmZmZmZmZcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAtIEltcGxlbWVudGF0aW9uIG11c3Qgc3VwcG9ydCBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcy5cbiAqICAgRmlyZWZveCA0LTI5IGxhY2tlZCBzdXBwb3J0LCBmaXhlZCBpbiBGaXJlZm94IDMwKy5cbiAqICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cbiAqXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleSB3aWxsXG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCB3aWxsIHdvcmsgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IChmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBuZXcgVWludDhBcnJheSgxKS5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBzdWJqZWN0ID4gMCA/IHN1YmplY3QgPj4+IDAgOiAwXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JylcbiAgICAgIHN1YmplY3QgPSBiYXNlNjRjbGVhbihzdWJqZWN0KVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHN1YmplY3QgIT09IG51bGwpIHsgLy8gYXNzdW1lIG9iamVjdCBpcyBhcnJheS1saWtlXG4gICAgaWYgKHN1YmplY3QudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShzdWJqZWN0LmRhdGEpKVxuICAgICAgc3ViamVjdCA9IHN1YmplY3QuZGF0YVxuICAgIGxlbmd0aCA9ICtzdWJqZWN0Lmxlbmd0aCA+IDAgPyBNYXRoLmZsb29yKCtzdWJqZWN0Lmxlbmd0aCkgOiAwXG4gIH0gZWxzZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcblxuICBpZiAodGhpcy5sZW5ndGggPiBrTWF4TGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSAoKHN1YmplY3RbaV0gJSAyNTYpICsgMjU2KSAlIDI1NlxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW4gJiYgYVtpXSA9PT0gYltpXTsgaSsrKSB7fVxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0WywgbGVuZ3RoXSknKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyICsgJydcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggPj4+IDFcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8vIHByZS1zZXQgZm9yIHZhbHVlcyB0aGF0IG1heSBleGlzdCBpbiB0aGUgZnV0dXJlXG5CdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IHVuZGVmaW5lZFxuQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYikge1xuICBpZighQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heClcbiAgICAgIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiB1dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW47XG4gICAgaWYgKHN0YXJ0IDwgMClcbiAgICAgIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKVxuICAgICAgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KVxuICAgIGVuZCA9IHN0YXJ0XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSlcbiAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHNvdXJjZS5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5jb25zdHJ1Y3RvciA9IEJ1ZmZlclxuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtel0vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpIHtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsIlxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuIiwiLy8gKGMpIERlYW4gTWNOYW1lZSA8ZGVhbkBnbWFpbC5jb20+LCAyMDEyLlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncbi8vIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci9cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgXCJ0cmFuc3BhcmVudFwiOiBbMCwwLDAsMF0sIFwiYWxpY2VibHVlXCI6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwyMzUsMjE1LDFdLCBcImFxdWFcIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsMjU1LDIxMiwxXSwgXCJhenVyZVwiOiBbMjQwLDI1NSwyNTUsMV0sXG4gIFwiYmVpZ2VcIjogWzI0NSwyNDUsMjIwLDFdLCBcImJpc3F1ZVwiOiBbMjU1LDIyOCwxOTYsMV0sXG4gIFwiYmxhY2tcIjogWzAsMCwwLDFdLCBcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNSwxXSxcbiAgXCJibHVlXCI6IFswLDAsMjU1LDFdLCBcImJsdWV2aW9sZXRcIjogWzEzOCw0MywyMjYsMV0sXG4gIFwiYnJvd25cIjogWzE2NSw0Miw0MiwxXSwgXCJidXJseXdvb2RcIjogWzIyMiwxODQsMTM1LDFdLFxuICBcImNhZGV0Ymx1ZVwiOiBbOTUsMTU4LDE2MCwxXSwgXCJjaGFydHJldXNlXCI6IFsxMjcsMjU1LDAsMV0sXG4gIFwiY2hvY29sYXRlXCI6IFsyMTAsMTA1LDMwLDFdLCBcImNvcmFsXCI6IFsyNTUsMTI3LDgwLDFdLFxuICBcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsMTQ5LDIzNywxXSwgXCJjb3Juc2lsa1wiOiBbMjU1LDI0OCwyMjAsMV0sXG4gIFwiY3JpbXNvblwiOiBbMjIwLDIwLDYwLDFdLCBcImN5YW5cIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJkYXJrYmx1ZVwiOiBbMCwwLDEzOSwxXSwgXCJkYXJrY3lhblwiOiBbMCwxMzksMTM5LDFdLFxuICBcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwxMzQsMTEsMV0sIFwiZGFya2dyYXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtncmVlblwiOiBbMCwxMDAsMCwxXSwgXCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2toYWtpXCI6IFsxODksMTgzLDEwNywxXSwgXCJkYXJrbWFnZW50YVwiOiBbMTM5LDAsMTM5LDFdLFxuICBcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwxMDcsNDcsMV0sIFwiZGFya29yYW5nZVwiOiBbMjU1LDE0MCwwLDFdLFxuICBcImRhcmtvcmNoaWRcIjogWzE1Myw1MCwyMDQsMV0sIFwiZGFya3JlZFwiOiBbMTM5LDAsMCwxXSxcbiAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsMTUwLDEyMiwxXSwgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywxODgsMTQzLDFdLFxuICBcImRhcmtzbGF0ZWJsdWVcIjogWzcyLDYxLDEzOSwxXSwgXCJkYXJrc2xhdGVncmF5XCI6IFs0Nyw3OSw3OSwxXSxcbiAgXCJkYXJrc2xhdGVncmV5XCI6IFs0Nyw3OSw3OSwxXSwgXCJkYXJrdHVycXVvaXNlXCI6IFswLDIwNiwyMDksMV0sXG4gIFwiZGFya3Zpb2xldFwiOiBbMTQ4LDAsMjExLDFdLCBcImRlZXBwaW5rXCI6IFsyNTUsMjAsMTQ3LDFdLFxuICBcImRlZXBza3libHVlXCI6IFswLDE5MSwyNTUsMV0sIFwiZGltZ3JheVwiOiBbMTA1LDEwNSwxMDUsMV0sXG4gIFwiZGltZ3JleVwiOiBbMTA1LDEwNSwxMDUsMV0sIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NSwxXSxcbiAgXCJmaXJlYnJpY2tcIjogWzE3OCwzNCwzNCwxXSwgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LDI1MCwyNDAsMV0sXG4gIFwiZm9yZXN0Z3JlZW5cIjogWzM0LDEzOSwzNCwxXSwgXCJmdWNoc2lhXCI6IFsyNTUsMCwyNTUsMV0sXG4gIFwiZ2FpbnNib3JvXCI6IFsyMjAsMjIwLDIyMCwxXSwgXCJnaG9zdHdoaXRlXCI6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgXCJnb2xkXCI6IFsyNTUsMjE1LDAsMV0sIFwiZ29sZGVucm9kXCI6IFsyMTgsMTY1LDMyLDFdLFxuICBcImdyYXlcIjogWzEyOCwxMjgsMTI4LDFdLCBcImdyZWVuXCI6IFswLDEyOCwwLDFdLFxuICBcImdyZWVueWVsbG93XCI6IFsxNzMsMjU1LDQ3LDFdLCBcImdyZXlcIjogWzEyOCwxMjgsMTI4LDFdLFxuICBcImhvbmV5ZGV3XCI6IFsyNDAsMjU1LDI0MCwxXSwgXCJob3RwaW5rXCI6IFsyNTUsMTA1LDE4MCwxXSxcbiAgXCJpbmRpYW5yZWRcIjogWzIwNSw5Miw5MiwxXSwgXCJpbmRpZ29cIjogWzc1LDAsMTMwLDFdLFxuICBcIml2b3J5XCI6IFsyNTUsMjU1LDI0MCwxXSwgXCJraGFraVwiOiBbMjQwLDIzMCwxNDAsMV0sXG4gIFwibGF2ZW5kZXJcIjogWzIzMCwyMzAsMjUwLDFdLCBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwyNDAsMjQ1LDFdLFxuICBcImxhd25ncmVlblwiOiBbMTI0LDI1MiwwLDFdLCBcImxlbW9uY2hpZmZvblwiOiBbMjU1LDI1MCwyMDUsMV0sXG4gIFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMCwxXSwgXCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOCwxXSxcbiAgXCJsaWdodGN5YW5cIjogWzIyNCwyNTUsMjU1LDFdLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsMjUwLDIxMCwxXSxcbiAgXCJsaWdodGdyYXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0Z3JlZW5cIjogWzE0NCwyMzgsMTQ0LDFdLFxuICBcImxpZ2h0Z3JleVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRwaW5rXCI6IFsyNTUsMTgyLDE5MywxXSxcbiAgXCJsaWdodHNhbG1vblwiOiBbMjU1LDE2MCwxMjIsMV0sIFwibGlnaHRzZWFncmVlblwiOiBbMzIsMTc4LDE3MCwxXSxcbiAgXCJsaWdodHNreWJsdWVcIjogWzEzNSwyMDYsMjUwLDFdLCBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksMTM2LDE1MywxXSxcbiAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LDEzNiwxNTMsMV0sIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwxOTYsMjIyLDFdLFxuICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsMjU1LDIyNCwxXSwgXCJsaW1lXCI6IFswLDI1NSwwLDFdLFxuICBcImxpbWVncmVlblwiOiBbNTAsMjA1LDUwLDFdLCBcImxpbmVuXCI6IFsyNTAsMjQwLDIzMCwxXSxcbiAgXCJtYWdlbnRhXCI6IFsyNTUsMCwyNTUsMV0sIFwibWFyb29uXCI6IFsxMjgsMCwwLDFdLFxuICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwyMDUsMTcwLDFdLCBcIm1lZGl1bWJsdWVcIjogWzAsMCwyMDUsMV0sXG4gIFwibWVkaXVtb3JjaGlkXCI6IFsxODYsODUsMjExLDFdLCBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LDExMiwyMTksMV0sXG4gIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTMsMV0sIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsMTA0LDIzOCwxXSxcbiAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwyNTAsMTU0LDFdLCBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsMjA5LDIwNCwxXSxcbiAgXCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwyMSwxMzMsMV0sIFwibWlkbmlnaHRibHVlXCI6IFsyNSwyNSwxMTIsMV0sXG4gIFwibWludGNyZWFtXCI6IFsyNDUsMjU1LDI1MCwxXSwgXCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1LDFdLFxuICBcIm1vY2Nhc2luXCI6IFsyNTUsMjI4LDE4MSwxXSwgXCJuYXZham93aGl0ZVwiOiBbMjU1LDIyMiwxNzMsMV0sXG4gIFwibmF2eVwiOiBbMCwwLDEyOCwxXSwgXCJvbGRsYWNlXCI6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgXCJvbGl2ZVwiOiBbMTI4LDEyOCwwLDFdLCBcIm9saXZlZHJhYlwiOiBbMTA3LDE0MiwzNSwxXSxcbiAgXCJvcmFuZ2VcIjogWzI1NSwxNjUsMCwxXSwgXCJvcmFuZ2VyZWRcIjogWzI1NSw2OSwwLDFdLFxuICBcIm9yY2hpZFwiOiBbMjE4LDExMiwyMTQsMV0sIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LDIzMiwxNzAsMV0sXG4gIFwicGFsZWdyZWVuXCI6IFsxNTIsMjUxLDE1MiwxXSwgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOCwxXSxcbiAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksMTEyLDE0NywxXSwgXCJwYXBheWF3aGlwXCI6IFsyNTUsMjM5LDIxMywxXSxcbiAgXCJwZWFjaHB1ZmZcIjogWzI1NSwyMTgsMTg1LDFdLCBcInBlcnVcIjogWzIwNSwxMzMsNjMsMV0sXG4gIFwicGlua1wiOiBbMjU1LDE5MiwyMDMsMV0sIFwicGx1bVwiOiBbMjIxLDE2MCwyMjEsMV0sXG4gIFwicG93ZGVyYmx1ZVwiOiBbMTc2LDIyNCwyMzAsMV0sIFwicHVycGxlXCI6IFsxMjgsMCwxMjgsMV0sXG4gIFwicmVkXCI6IFsyNTUsMCwwLDFdLCBcInJvc3licm93blwiOiBbMTg4LDE0MywxNDMsMV0sXG4gIFwicm95YWxibHVlXCI6IFs2NSwxMDUsMjI1LDFdLCBcInNhZGRsZWJyb3duXCI6IFsxMzksNjksMTksMV0sXG4gIFwic2FsbW9uXCI6IFsyNTAsMTI4LDExNCwxXSwgXCJzYW5keWJyb3duXCI6IFsyNDQsMTY0LDk2LDFdLFxuICBcInNlYWdyZWVuXCI6IFs0NiwxMzksODcsMV0sIFwic2Vhc2hlbGxcIjogWzI1NSwyNDUsMjM4LDFdLFxuICBcInNpZW5uYVwiOiBbMTYwLDgyLDQ1LDFdLCBcInNpbHZlclwiOiBbMTkyLDE5MiwxOTIsMV0sXG4gIFwic2t5Ymx1ZVwiOiBbMTM1LDIwNiwyMzUsMV0sIFwic2xhdGVibHVlXCI6IFsxMDYsOTAsMjA1LDFdLFxuICBcInNsYXRlZ3JheVwiOiBbMTEyLDEyOCwxNDQsMV0sIFwic2xhdGVncmV5XCI6IFsxMTIsMTI4LDE0NCwxXSxcbiAgXCJzbm93XCI6IFsyNTUsMjUwLDI1MCwxXSwgXCJzcHJpbmdncmVlblwiOiBbMCwyNTUsMTI3LDFdLFxuICBcInN0ZWVsYmx1ZVwiOiBbNzAsMTMwLDE4MCwxXSwgXCJ0YW5cIjogWzIxMCwxODAsMTQwLDFdLFxuICBcInRlYWxcIjogWzAsMTI4LDEyOCwxXSwgXCJ0aGlzdGxlXCI6IFsyMTYsMTkxLDIxNiwxXSxcbiAgXCJ0b21hdG9cIjogWzI1NSw5OSw3MSwxXSwgXCJ0dXJxdW9pc2VcIjogWzY0LDIyNCwyMDgsMV0sXG4gIFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOCwxXSwgXCJ3aGVhdFwiOiBbMjQ1LDIyMiwxNzksMV0sXG4gIFwid2hpdGVcIjogWzI1NSwyNTUsMjU1LDFdLCBcIndoaXRlc21va2VcIjogWzI0NSwyNDUsMjQ1LDFdLFxuICBcInllbGxvd1wiOiBbMjU1LDI1NSwwLDFdLCBcInllbGxvd2dyZWVuXCI6IFsxNTQsMjA1LDUwLDFdfVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfYnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19mbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIGggKz0gMTtcbiAgZWxzZSBpZiAoaCA+IDEpIGggLT0gMTtcblxuICBpZiAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yO1xuICBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1NTQ29sb3IoY3NzX3N0cikge1xuICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHJldHVybiBrQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7ICAvLyBkdXAuXG5cbiAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWygoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtwYXJzZV9jc3NfaW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChwYXJhbXNbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1sxXSk7XG4gICAgICAgIHZhciBsID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1syXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICAgICAgICByZXR1cm4gW2NsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCsxLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgtMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnRyeSB7IGV4cG9ydHMucGFyc2VDU1NDb2xvciA9IHBhcnNlQ1NTQ29sb3IgfSBjYXRjaChlKSB7IH1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChwb2ludHMpIHtcblxuICAgIHZhciBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KHBvaW50c1swXSwgdHJ1ZSksXG4gICAgICAgIG5vZGUsIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIHNpemUsXG4gICAgICAgIGxlbiA9IDAsXG4gICAgICAgIHRocmVzaG9sZCA9IDgwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGxlbiA8IHRocmVzaG9sZCAmJiBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSBsZW4gKz0gcG9pbnRzW2ldLmxlbmd0aDtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChsZW4gPj0gdGhyZXNob2xkKSB7XG4gICAgICAgIG5vZGUgPSBvdXRlck5vZGUubmV4dDtcbiAgICAgICAgbWluWCA9IG1heFggPSBub2RlLnBbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gbm9kZS5wWzFdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB4ID0gbm9kZS5wWzBdO1xuICAgICAgICAgICAgeSA9IG5vZGUucFsxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChub2RlICE9PSBvdXRlck5vZGUpO1xuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIHNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIHNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH1cblxuICAgIGlmIChwb2ludHMubGVuZ3RoID4gMSkgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMocG9pbnRzLCBvdXRlck5vZGUpO1xuXG4gICAgdmFyIHRyaWFuZ2xlcyA9IFtdO1xuICAgIGlmIChvdXRlck5vZGUpIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgbWluWCwgbWluWSwgc2l6ZSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QocG9pbnRzLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgc3VtID0gMCxcbiAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgaSwgaiwgbGFzdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBvcmlnaW5hbCB3aW5kaW5nIG9yZGVyIG9mIGEgcG9seWdvbiByaW5nXG4gICAgZm9yIChpID0gMCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcbiAgICAgICAgdmFyIHAxID0gcG9pbnRzW2ldLFxuICAgICAgICAgICAgcDIgPSBwb2ludHNbal07XG4gICAgICAgIHN1bSArPSAocDJbMF0gLSBwMVswXSkgKiAocDFbMV0gKyBwMlsxXSk7XG4gICAgfVxuXG4gICAgLy8gbGluayBwb2ludHMgaW50byBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHN1bSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgbGFzdCA9IGluc2VydE5vZGUocG9pbnRzW2ldLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgbGFzdCA9IGluc2VydE5vZGUocG9pbnRzW2ldLCBsYXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0KSB7XG4gICAgLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbiAgICB2YXIgbm9kZSA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGVxdWFscyhub2RlLnAsIG5vZGUubmV4dC5wKSB8fCBvcmllbnQobm9kZS5wcmV2LnAsIG5vZGUucCwgbm9kZS5uZXh0LnApID09PSAwKSB7XG5cbiAgICAgICAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG5cbiAgICAgICAgICAgIGlmIChub2RlLnByZXZaKSBub2RlLnByZXZaLm5leHRaID0gbm9kZS5uZXh0WjtcbiAgICAgICAgICAgIGlmIChub2RlLm5leHRaKSBub2RlLm5leHRaLnByZXZaID0gbm9kZS5wcmV2WjtcblxuICAgICAgICAgICAgbm9kZSA9IHN0YXJ0ID0gbm9kZS5wcmV2O1xuXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbm9kZS5uZXh0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBzdGFydDtcbn1cblxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplLCBzZWNvbmRQYXNzKSB7XG4gICAgZWFyID0gZmlsdGVyUG9pbnRzKGVhcik7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIGlmICghc2Vjb25kUGFzcyAmJiBtaW5YICE9PSB1bmRlZmluZWQpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoaXNFYXIoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKSkge1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5wLCBlYXIucCwgbmV4dC5wKTtcblxuICAgICAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG5cbiAgICAgICAgICAgIGlmIChlYXIucHJldlopIGVhci5wcmV2Wi5uZXh0WiA9IGVhci5uZXh0WjtcbiAgICAgICAgICAgIGlmIChlYXIubmV4dFopIGVhci5uZXh0Wi5wcmV2WiA9IGVhci5wcmV2WjtcblxuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZpbmQgYW55IG1vcmUgZWFycywgdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIGN1dHRpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghc2Vjb25kUGFzcykgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICBlbHNlIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0VhcihlYXIsIG1pblgsIG1pblksIHNpemUpIHtcblxuICAgIHZhciBhID0gZWFyLnByZXYucCxcbiAgICAgICAgYiA9IGVhci5wLFxuICAgICAgICBjID0gZWFyLm5leHQucCxcblxuICAgICAgICBheCA9IGFbMF0sIGJ4ID0gYlswXSwgY3ggPSBjWzBdLFxuICAgICAgICBheSA9IGFbMV0sIGJ5ID0gYlsxXSwgY3kgPSBjWzFdLFxuXG4gICAgICAgIGFiZCA9IGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgICBhY2QgPSBheCAqIGN5IC0gYXkgKiBjeCxcbiAgICAgICAgY2JkID0gY3ggKiBieSAtIGN5ICogYngsXG4gICAgICAgIEEgPSBhYmQgLSBhY2QgLSBjYmQ7XG5cbiAgICBpZiAoQSA8PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuXG4gICAgdmFyIGNheSA9IGN5IC0gYXksXG4gICAgICAgIGFjeCA9IGF4IC0gY3gsXG4gICAgICAgIGFieSA9IGF5IC0gYnksXG4gICAgICAgIGJheCA9IGJ4IC0gYXgsXG4gICAgICAgIHAsIHB4LCBweSwgcywgdCwgaywgbm9kZTtcblxuICAgIC8vIGlmIHdlIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2hpbmcsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgY3VydmVcbiAgICBpZiAobWluWCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICAgICAgdmFyIG1pblRYID0gYXggPCBieCA/IChheCA8IGN4ID8gYXggOiBjeCkgOiAoYnggPCBjeCA/IGJ4IDogY3gpLFxuICAgICAgICAgICAgbWluVFkgPSBheSA8IGJ5ID8gKGF5IDwgY3kgPyBheSA6IGN5KSA6IChieSA8IGN5ID8gYnkgOiBjeSksXG4gICAgICAgICAgICBtYXhUWCA9IGF4ID4gYnggPyAoYXggPiBjeCA/IGF4IDogY3gpIDogKGJ4ID4gY3ggPyBieCA6IGN4KSxcbiAgICAgICAgICAgIG1heFRZID0gYXkgPiBieSA/IChheSA+IGN5ID8gYXkgOiBjeSkgOiAoYnkgPiBjeSA/IGJ5IDogY3kpLFxuXG4gICAgICAgICAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgICAgICAgICAgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIHNpemUpLFxuICAgICAgICAgICAgbWF4WiA9IHpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIHNpemUpO1xuXG4gICAgICAgIC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgICAgICBub2RlID0gZWFyLm5leHRaO1xuXG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUueiA8PSBtYXhaKSB7XG4gICAgICAgICAgICBwID0gbm9kZS5wO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFo7XG4gICAgICAgICAgICBpZiAocCA9PT0gYSB8fCBwID09PSBjKSBjb250aW51ZTtcblxuICAgICAgICAgICAgcHggPSBwWzBdO1xuICAgICAgICAgICAgcHkgPSBwWzFdO1xuXG4gICAgICAgICAgICBzID0gY2F5ICogcHggKyBhY3ggKiBweSAtIGFjZDtcbiAgICAgICAgICAgIGlmIChzID49IDApIHtcbiAgICAgICAgICAgICAgICB0ID0gYWJ5ICogcHggKyBiYXggKiBweSArIGFiZDtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBBIC0gcyAtIHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoayA+PSAwKSAmJiAoKHMgJiYgdCkgfHwgKHMgJiYgaykgfHwgKHQgJiYgaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlbiBsb29rIGZvciBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG4gICAgICAgIG5vZGUgPSBlYXIucHJldlo7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS56ID49IG1pblopIHtcbiAgICAgICAgICAgIHAgPSBub2RlLnA7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wcmV2WjtcbiAgICAgICAgICAgIGlmIChwID09PSBhIHx8IHAgPT09IGMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBweCA9IHBbMF07XG4gICAgICAgICAgICBweSA9IHBbMV07XG5cbiAgICAgICAgICAgIHMgPSBjYXkgKiBweCArIGFjeCAqIHB5IC0gYWNkO1xuICAgICAgICAgICAgaWYgKHMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHQgPSBhYnkgKiBweCArIGJheCAqIHB5ICsgYWJkO1xuICAgICAgICAgICAgICAgIGlmICh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IEEgLSBzIC0gdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChrID49IDApICYmICgocyAmJiB0KSB8fCAocyAmJiBrKSB8fCAodCAmJiBrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIC8vIGlmIHdlIGRvbid0IHVzZSB6LW9yZGVyIGN1cnZlIGhhc2gsIHNpbXBseSBpdGVyYXRlIHRocm91Z2ggYWxsIG90aGVyIHBvaW50c1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBlYXIubmV4dC5uZXh0O1xuXG4gICAgICAgIHdoaWxlIChub2RlICE9PSBlYXIucHJldikge1xuICAgICAgICAgICAgcCA9IG5vZGUucDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG5cbiAgICAgICAgICAgIHB4ID0gcFswXTtcbiAgICAgICAgICAgIHB5ID0gcFsxXTtcblxuICAgICAgICAgICAgcyA9IGNheSAqIHB4ICsgYWN4ICogcHkgLSBhY2Q7XG4gICAgICAgICAgICBpZiAocyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdCA9IGFieSAqIHB4ICsgYmF4ICogcHkgKyBhYmQ7XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrID0gQSAtIHMgLSB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGsgPj0gMCkgJiYgKChzICYmIHQpIHx8IChzICYmIGspIHx8ICh0ICYmIGspKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gZmluZCBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhLm5leHQ7XG4gICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xufVxuXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhwb2ludHMsIG91dGVyTm9kZSkge1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgbGlzdCA9IGZpbHRlclBvaW50cyhsaW5rZWRMaXN0KHBvaW50c1tpXSwgZmFsc2UpKTtcbiAgICAgICAgaWYgKGxpc3QpIHF1ZXVlLnB1c2goZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgIH1cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgICAgIG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyhvdXRlck5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59XG5cbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZU5vZGUsIG91dGVyTm9kZSkge1xuICAgIG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGVOb2RlLCBvdXRlck5vZGUpO1xuICAgIGlmIChvdXRlck5vZGUpIHNwbGl0UG9seWdvbihob2xlTm9kZSwgb3V0ZXJOb2RlKTtcbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZU5vZGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBub2RlID0gb3V0ZXJOb2RlLFxuICAgICAgICBwID0gaG9sZU5vZGUucCxcbiAgICAgICAgcHggPSBwWzBdLFxuICAgICAgICBweSA9IHBbMV0sXG4gICAgICAgIHFNYXggPSAtSW5maW5pdHksXG4gICAgICAgIG1Ob2RlLCBhLCBiO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGEgPSBub2RlLnA7XG4gICAgICAgIGIgPSBub2RlLm5leHQucDtcblxuICAgICAgICBpZiAocHkgPD0gYVsxXSAmJiBweSA+PSBiWzFdKSB7XG4gICAgICAgICAgICB2YXIgcXggPSBhWzBdICsgKHB5IC0gYVsxXSkgKiAoYlswXSAtIGFbMF0pIC8gKGJbMV0gLSBhWzFdKTtcbiAgICAgICAgICAgIGlmIChxeCA8PSBweCAmJiBxeCA+IHFNYXgpIHtcbiAgICAgICAgICAgICAgICBxTWF4ID0gcXg7XG4gICAgICAgICAgICAgICAgbU5vZGUgPSBhWzBdIDwgYlswXSA/IG5vZGUgOiBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9IHdoaWxlIChub2RlICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtTm9kZSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgc3RyaWN0bHkgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBieCA9IG1Ob2RlLnBbMF0sXG4gICAgICAgIGJ5ID0gbU5vZGUucFsxXSxcbiAgICAgICAgcGJkID0gcHggKiBieSAtIHB5ICogYngsXG4gICAgICAgIHBjZCA9IHB4ICogcHkgLSBweSAqIHFNYXgsXG4gICAgICAgIGNweSA9IHB5IC0gcHksXG4gICAgICAgIHBjeCA9IHB4IC0gcU1heCxcbiAgICAgICAgcGJ5ID0gcHkgLSBieSxcbiAgICAgICAgYnB4ID0gYnggLSBweCxcbiAgICAgICAgQSA9IHBiZCAtIHBjZCAtIChxTWF4ICogYnkgLSBweSAqIGJ4KSxcbiAgICAgICAgc2lnbiA9IEEgPD0gMCA/IC0xIDogMSxcbiAgICAgICAgc3RvcCA9IG1Ob2RlLFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgbXgsIG15LCBhbXgsIHMsIHQsIHRhbjtcblxuICAgIG5vZGUgPSBtTm9kZS5uZXh0O1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IHN0b3ApIHtcblxuICAgICAgICBteCA9IG5vZGUucFswXTtcbiAgICAgICAgbXkgPSBub2RlLnBbMV07XG4gICAgICAgIGFteCA9IHB4IC0gbXg7XG5cbiAgICAgICAgaWYgKGFteCA+PSAwICYmIG14ID49IGJ4KSB7XG4gICAgICAgICAgICBzID0gKGNweSAqIG14ICsgcGN4ICogbXkgLSBwY2QpICogc2lnbjtcbiAgICAgICAgICAgIGlmIChzID49IDApIHtcbiAgICAgICAgICAgICAgICB0ID0gKHBieSAqIG14ICsgYnB4ICogbXkgKyBwYmQpICogc2lnbjtcblxuICAgICAgICAgICAgICAgIGlmICh0ID49IDAgJiYgQSAqIHNpZ24gLSBzIC0gdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKHB5IC0gbXkpIC8gYW14OyAvLyB0YW5nZW50aWFsXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YW4gPCB0YW5NaW4gJiYgbG9jYWxseUluc2lkZShub2RlLCBob2xlTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1Ob2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1Ob2RlO1xufVxuXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydDtcblxuICAgIGRvIHtcbiAgICAgICAgbm9kZS56ID0gbm9kZS56IHx8IHpPcmRlcihub2RlLnBbMF0sIG5vZGUucFsxXSwgbWluWCwgbWluWSwgc2l6ZSk7XG4gICAgICAgIG5vZGUucHJldlogPSBub2RlLnByZXY7XG4gICAgICAgIG5vZGUubmV4dFogPSBub2RlLm5leHQ7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gc3RhcnQpO1xuXG4gICAgbm9kZS5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgbm9kZS5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKG5vZGUpO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHAgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgIG51bU1lcmdlcyA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIG51bU1lcmdlcysrO1xuICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgIGlmICghcSkgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxU2l6ZSA9PT0gMCB8fCAhcSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwLnogPD0gcS56KSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHFTaXplLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRhaWwpIHRhaWwubmV4dFogPSBlO1xuICAgICAgICAgICAgICAgIGVsc2UgbGlzdCA9IGU7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcblxuICAgICAgICBpZiAobnVtTWVyZ2VzIDw9IDEpIHJldHVybiBsaXN0O1xuXG4gICAgICAgIGluU2l6ZSAqPSAyO1xuICAgIH1cbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIHNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gKDAuLjEwMDApIGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMTAwMCAqICh4IC0gbWluWCkgLyBzaXplO1xuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gMTAwMCAqICh5IC0gbWluWSkgLyBzaXplO1xuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBub2RlID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAobm9kZS5wWzBdIDwgbGVmdG1vc3QucFswXSkgbGVmdG1vc3QgPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICByZXR1cm4gIWludGVyc2VjdHNQb2x5Z29uKGEsIGEucCwgYi5wKSAmJlxuICAgICAgICAgICBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiZcbiAgICAgICAgICAgbWlkZGxlSW5zaWRlKGEsIGEucCwgYi5wKTtcbn1cblxuLy8gd2luZGluZyBvcmRlciBvZiB0cmlhbmdsZSBmb3JtZWQgYnkgMyBnaXZlbiBwb2ludHNcbmZ1bmN0aW9uIG9yaWVudChwLCBxLCByKSB7XG4gICAgdmFyIG8gPSAocVsxXSAtIHBbMV0pICogKHJbMF0gLSBxWzBdKSAtIChxWzBdIC0gcFswXSkgKiAoclsxXSAtIHFbMV0pO1xuICAgIHJldHVybiBvID4gMCA/IDEgOlxuICAgICAgICAgICBvIDwgMCA/IC0xIDogMDtcbn1cblxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMVswXSA9PT0gcDJbMF0gJiYgcDFbMV0gPT09IHAyWzFdO1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgcmV0dXJuIG9yaWVudChwMSwgcTEsIHAyKSAhPT0gb3JpZW50KHAxLCBxMSwgcTIpICYmXG4gICAgICAgICAgIG9yaWVudChwMiwgcTIsIHAxKSAhPT0gb3JpZW50KHAyLCBxMiwgcTEpO1xufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oc3RhcnQsIGEsIGIpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIHAxID0gbm9kZS5wLFxuICAgICAgICAgICAgcDIgPSBub2RlLm5leHQucDtcblxuICAgICAgICBpZiAocDEgIT09IGEgJiYgcDIgIT09IGEgJiYgcDEgIT09IGIgJiYgcDIgIT09IGIgJiYgaW50ZXJzZWN0cyhwMSwgcDIsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gb3JpZW50KGEucHJldi5wLCBhLnAsIGEubmV4dC5wKSA9PT0gLTEgP1xuICAgICAgICBvcmllbnQoYS5wLCBiLnAsIGEubmV4dC5wKSAhPT0gLTEgJiYgb3JpZW50KGEucCwgYS5wcmV2LnAsIGIucCkgIT09IC0xIDpcbiAgICAgICAgb3JpZW50KGEucCwgYi5wLCBhLnByZXYucCkgPT09IC0xIHx8IG9yaWVudChhLnAsIGEubmV4dC5wLCBiLnApID09PSAtMTtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoc3RhcnQsIGEsIGIpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0LFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYVswXSArIGJbMF0pIC8gMixcbiAgICAgICAgcHkgPSAoYVsxXSArIGJbMV0pIC8gMjtcbiAgICBkbyB7XG4gICAgICAgIHZhciBwMSA9IG5vZGUucCxcbiAgICAgICAgICAgIHAyID0gbm9kZS5uZXh0LnA7XG5cbiAgICAgICAgaWYgKCgocDFbMV0gPiBweSkgIT09IChwMlsxXSA+IHB5KSkgJiZcbiAgICAgICAgICAgIChweCA8IChwMlswXSAtIHAxWzBdKSAqIChweSAtIHAxWzFdKSAvIChwMlsxXSAtIHAxWzFdKSArIHAxWzBdKSkgaW5zaWRlID0gIWluc2lkZTtcblxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVYKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wWzBdIC0gYi5wWzBdO1xufVxuXG4vLyBzcGxpdCB0aGUgcG9seWdvbiB2ZXJ0aWNlcyBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpbmtlZCBsaXN0IGludG8gdHdvXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEucCksXG4gICAgICAgIGIyID0gbmV3IE5vZGUoYi5wKSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGEyO1xufVxuXG5mdW5jdGlvbiBpbnNlcnROb2RlKHBvaW50LCBsYXN0KSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgTm9kZShwb2ludCk7XG5cbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgbm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgbm9kZS5uZXh0ID0gbm9kZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUubmV4dCA9IGxhc3QubmV4dDtcbiAgICAgICAgbm9kZS5wcmV2ID0gbGFzdDtcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBub2RlO1xuICAgICAgICBsYXN0Lm5leHQgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gTm9kZShwKSB7XG4gICAgdGhpcy5wID0gcDtcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICB0aGlzLnogPSBudWxsO1xuICAgIHRoaXMucHJldlogPSBudWxsO1xuICAgIHRoaXMubmV4dFogPSBudWxsO1xufVxuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGdsLW1hdHJpeCAtIEhpZ2ggcGVyZm9ybWFuY2UgbWF0cml4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuICogQGF1dGhvciBCcmFuZG9uIEpvbmVzXG4gKiBAYXV0aG9yIENvbGluIE1hY0tlbnppZSBJVlxuICogQHZlcnNpb24gMi4yLjFcbiAqL1xuXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuXG4oZnVuY3Rpb24oX2dsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgc2hpbSA9IHt9O1xuICBpZiAodHlwZW9mKGV4cG9ydHMpID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBzaGltLmV4cG9ydHMgPSB7fTtcbiAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNoaW0uZXhwb3J0cztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnbC1tYXRyaXggbGl2ZXMgaW4gYSBicm93c2VyLCBkZWZpbmUgaXRzIG5hbWVzcGFjZXMgaW4gZ2xvYmFsXG4gICAgICBzaGltLmV4cG9ydHMgPSB0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBfZ2xvYmFsO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnbC1tYXRyaXggbGl2ZXMgaW4gY29tbW9uanMsIGRlZmluZSBpdHMgbmFtZXNwYWNlcyBpbiBleHBvcnRzXG4gICAgc2hpbS5leHBvcnRzID0gZXhwb3J0cztcbiAgfVxuXG4gIChmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuXG5pZighR0xNQVRfRVBTSUxPTikge1xuICAgIHZhciBHTE1BVF9FUFNJTE9OID0gMC4wMDAwMDE7XG59XG5cbmlmKCFHTE1BVF9BUlJBWV9UWVBFKSB7XG4gICAgdmFyIEdMTUFUX0FSUkFZX1RZUEUgPSAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG59XG5cbmlmKCFHTE1BVF9SQU5ET00pIHtcbiAgICB2YXIgR0xNQVRfUkFORE9NID0gTWF0aC5yYW5kb207XG59XG5cbi8qKlxuICogQGNsYXNzIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBuYW1lIGdsTWF0cml4XG4gKi9cbnZhciBnbE1hdHJpeCA9IHt9O1xuXG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNpZXNcbiAqXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcbiAqL1xuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIEdMTUFUX0FSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5nbE1hdHJpeCA9IGdsTWF0cml4O1xufVxuXG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcblxuLyoqXG4qIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuKlxuKiBAcGFyYW0ge051bWJlcn0gQW5nbGUgaW4gRGVncmVlc1xuKi9cbmdsTWF0cml4LnRvUmFkaWFuID0gZnVuY3Rpb24oYSl7XG4gICAgIHJldHVybiBhICogZGVncmVlO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzJcbiAqL1xuXG52YXIgdmVjMiA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcbiAqXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnN1YiA9IHZlYzIuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIubXVsID0gdmVjMi5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmRpdiA9IHZlYzIuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmRpc3QgPSB2ZWMyLmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJEaXN0ID0gdmVjMi5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIubGVuID0gdmVjMi5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyTGVuID0gdmVjMi5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMi5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzIuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgICB2YXIgciA9IEdMTUFUX1JBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDJkID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59O1xuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy52ZWMyID0gdmVjMjtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDMgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMzXG4gKi9cblxudmFyIHZlYzMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zdWIgPSB2ZWMzLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLm11bCA9IHZlYzMubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5kaXYgPSB2ZWMzLmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzMuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5kaXN0ID0gdmVjMy5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzMuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zcXJEaXN0ID0gdmVjMy5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMzLmxlbiA9IHZlYzMubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5zcXJMZW4gPSB2ZWMzLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgdmFyIHIgPSBHTE1BVF9SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgdmFyIHogPSAoR0xNQVRfUkFORE9NKCkgKiAyLjApIC0gMS4wO1xuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZTtcblxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICAgIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdO1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdO1xuICAgIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSB4ICogbVswXSArIHkgKiBtWzNdICsgeiAqIG1bNl07XG4gICAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKlxuKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4qIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4qIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuKiBAcmV0dXJucyB7dmVjM30gb3V0XG4qL1xudmVjMy5yb3RhdGVYID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgIHZhciBwID0gW10sIHI9W107XG5cdCAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXHQgIHBbMF0gPSBhWzBdIC0gYlswXTtcblx0ICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuXG5cdCAgLy9wZXJmb3JtIHJvdGF0aW9uXG5cdCAgclswXSA9IHBbMF07XG5cdCAgclsxXSA9IHBbMV0qTWF0aC5jb3MoYykgLSBwWzJdKk1hdGguc2luKGMpO1xuXHQgIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuXHQgIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblx0ICBvdXRbMF0gPSByWzBdICsgYlswXTtcblx0ICBvdXRbMV0gPSByWzFdICsgYlsxXTtcblx0ICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKlxuKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4qIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4qIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuKiBAcmV0dXJucyB7dmVjM30gb3V0XG4qL1xudmVjMy5yb3RhdGVZID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgXHR2YXIgcCA9IFtdLCByPVtdO1xuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgXHRwWzBdID0gYVswXSAtIGJbMF07XG4gIFx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcbiAgXG4gIFx0Ly9wZXJmb3JtIHJvdGF0aW9uXG4gIFx0clswXSA9IHBbMl0qTWF0aC5zaW4oYykgKyBwWzBdKk1hdGguY29zKGMpO1xuICBcdHJbMV0gPSBwWzFdO1xuICBcdHJbMl0gPSBwWzJdKk1hdGguY29zKGMpIC0gcFswXSpNYXRoLnNpbihjKTtcbiAgXG4gIFx0Ly90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBcdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBcdG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuICBcbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLypcbiogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4qIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4qIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiogQHJldHVybnMge3ZlYzN9IG91dFxuKi9cbnZlYzMucm90YXRlWiA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gIFx0dmFyIHAgPSBbXSwgcj1bXTtcbiAgXHQvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIFx0cFswXSA9IGFbMF0gLSBiWzBdO1xuICBcdHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG4gIFxuICBcdC8vcGVyZm9ybSByb3RhdGlvblxuICBcdHJbMF0gPSBwWzBdKk1hdGguY29zKGMpIC0gcFsxXSpNYXRoLnNpbihjKTtcbiAgXHRyWzFdID0gcFswXSpNYXRoLnNpbihjKSArIHBbMV0qTWF0aC5jb3MoYyk7XG4gIFx0clsyXSA9IHBbMl07XG4gIFxuICBcdC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgXHRvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgXHRvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgXHRvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMy5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnKSc7XG59O1xuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy52ZWMzID0gdmVjMztcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDQgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWM0XG4gKi9cblxudmFyIHZlYzQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWM0XG4gKlxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6LCB3KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zdWIgPSB2ZWM0LnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0Lm11bCA9IHZlYzQubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5kaXYgPSB2ZWM0LmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdLFxuICAgICAgICB3ID0gYlszXSAtIGFbM107XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5kaXN0ID0gdmVjNC5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzQuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdLFxuICAgICAgICB3ID0gYlszXSAtIGFbM107XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckRpc3QgPSB2ZWM0LnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWM0Lmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmxlbiA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3FyTGVuID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gLWFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgICAgICAgb3V0WzNdID0gYVszXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWM0LmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdLFxuICAgICAgICBhdyA9IGFbM107XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgLy9UT0RPOiBUaGlzIGlzIGEgcHJldHR5IGF3ZnVsIHdheSBvZiBkb2luZyB0aGlzLiBGaW5kIHNvbWV0aGluZyBiZXR0ZXIuXG4gICAgb3V0WzBdID0gR0xNQVRfUkFORE9NKCk7XG4gICAgb3V0WzFdID0gR0xNQVRfUkFORE9NKCk7XG4gICAgb3V0WzJdID0gR0xNQVRfUkFORE9NKCk7XG4gICAgb3V0WzNdID0gR0xNQVRfUkFORE9NKCk7XG4gICAgdmVjNC5ub3JtYWxpemUob3V0LCBvdXQpO1xuICAgIHZlYzQuc2NhbGUob3V0LCBvdXQsIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sIHcgPSBhWzNdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gICAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjNHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjNC4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IHZlYzQuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSA0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTsgdmVjWzNdID0gYVtpKzNdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTsgYVtpKzNdID0gdmVjWzNdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjNC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjNCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnZlYzQgPSB2ZWM0O1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMngyIE1hdHJpeFxuICogQG5hbWUgbWF0MlxuICovXG5cbnZhciBtYXQyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMSA9IGFbMV07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGFbMV07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgXG4gICAgb3V0WzBdID0gIGEzICogZGV0O1xuICAgIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gICAgb3V0WzNdID0gIGEwICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gICAgdmFyIGEwID0gYVswXTtcbiAgICBvdXRbMF0gPSAgYVszXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAgYTA7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0Mi5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICAgIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDIubXVsID0gbWF0Mi5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5tYXQyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyLmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikpKVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cblxubWF0Mi5MRFUgPSBmdW5jdGlvbiAoTCwgRCwgVSwgYSkgeyBcbiAgICBMWzJdID0gYVsyXS9hWzBdOyBcbiAgICBVWzBdID0gYVswXTsgXG4gICAgVVsxXSA9IGFbMV07IFxuICAgIFVbM10gPSBhWzNdIC0gTFsyXSAqIFVbMV07IFxuICAgIHJldHVybiBbTCwgRCwgVV07ICAgICAgIFxufTsgXG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDIgPSBtYXQyO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMngzIE1hdHJpeFxuICogQG5hbWUgbWF0MmRcbiAqIFxuICogQGRlc2NyaXB0aW9uIFxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHksXG4gKiAgMCwgMCwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3Qgcm93IGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xuXG52YXIgbWF0MmQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJkXG4gKlxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbm1hdDJkLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDJkIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDJkIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyZCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGFhID0gYVswXSwgYWIgPSBhWzFdLCBhYyA9IGFbMl0sIGFkID0gYVszXSxcbiAgICAgICAgYXR4ID0gYVs0XSwgYXR5ID0gYVs1XTtcblxuICAgIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcbiAgICBpZighZGV0KXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGFkICogZGV0O1xuICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gICAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQyZC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsxXSAqIGFbMl07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgICBvdXRbNF0gPSBhMCAqIGI0ICsgYTIgKiBiNSArIGE0O1xuICAgIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyZC5tdWwgPSBtYXQyZC5tdWx0aXBseTtcblxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyZCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0MmQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDJkKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDJkLmZyb2IgPSBmdW5jdGlvbiAoYSkgeyBcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIDEpKVxufTsgXG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDJkID0gbWF0MmQ7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAzeDMgTWF0cml4XG4gKiBAbmFtZSBtYXQzXG4gKi9cblxudmFyIG1hdDMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbU1hdDQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzRdO1xuICAgIG91dFs0XSA9IGFbNV07XG4gICAgb3V0WzVdID0gYVs2XTtcbiAgICBvdXRbNl0gPSBhWzhdO1xuICAgIG91dFs3XSA9IGFbOV07XG4gICAgb3V0WzhdID0gYVsxMF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTEyID0gYVs1XTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYTAxO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhMDI7XG4gICAgICAgIG91dFs3XSA9IGExMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhWzFdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhWzJdO1xuICAgICAgICBvdXRbN10gPSBhWzVdO1xuICAgICAgICBvdXRbOF0gPSBhWzhdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjEsXG4gICAgICAgIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjAsXG4gICAgICAgIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMCxcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGIwMSAqIGRldDtcbiAgICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gICAgb3V0WzNdID0gYjExICogZGV0O1xuICAgIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICAgIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gICAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICAgIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICBvdXRbMF0gPSAoYTExICogYTIyIC0gYTEyICogYTIxKTtcbiAgICBvdXRbMV0gPSAoYTAyICogYTIxIC0gYTAxICogYTIyKTtcbiAgICBvdXRbMl0gPSAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgICBvdXRbM10gPSAoYTEyICogYTIwIC0gYTEwICogYTIyKTtcbiAgICBvdXRbNF0gPSAoYTAwICogYTIyIC0gYTAyICogYTIwKTtcbiAgICBvdXRbNV0gPSAoYTAyICogYTEwIC0gYTAwICogYTEyKTtcbiAgICBvdXRbNl0gPSAoYTEwICogYTIxIC0gYTExICogYTIwKTtcbiAgICBvdXRbN10gPSAoYTAxICogYTIwIC0gYTAwICogYTIxKTtcbiAgICBvdXRbOF0gPSAoYTAwICogYTExIC0gYTAxICogYTEwKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0My5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMCA9IGJbMF0sIGIwMSA9IGJbMV0sIGIwMiA9IGJbMl0sXG4gICAgICAgIGIxMCA9IGJbM10sIGIxMSA9IGJbNF0sIGIxMiA9IGJbNV0sXG4gICAgICAgIGIyMCA9IGJbNl0sIGIyMSA9IGJbN10sIGIyMiA9IGJbOF07XG5cbiAgICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gICAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICAgIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcblxuICAgIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gICAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuXG4gICAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICAgIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDMubXVsID0gbWF0My5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuICAgICAgICB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcblxuICAgIG91dFszXSA9IGExMDtcbiAgICBvdXRbNF0gPSBhMTE7XG4gICAgb3V0WzVdID0gYTEyO1xuXG4gICAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gICAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gICAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcbiAgICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcblxuICAgIG91dFszXSA9IGMgKiBhMTAgLSBzICogYTAwO1xuICAgIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICAgIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuXG4gICAgb3V0WzZdID0gYTIwO1xuICAgIG91dFs3XSA9IGEyMTtcbiAgICBvdXRbOF0gPSBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbm1hdDMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0geCAqIGFbMF07XG4gICAgb3V0WzFdID0geCAqIGFbMV07XG4gICAgb3V0WzJdID0geCAqIGFbMl07XG5cbiAgICBvdXRbM10gPSB5ICogYVszXTtcbiAgICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgICBvdXRbNV0gPSB5ICogYVs1XTtcblxuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5mcm9tTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IGFbMl07XG4gICAgb3V0WzRdID0gYVszXTtcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gYVs0XTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzNdID0geXggLSB3ejtcbiAgICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbNV0gPSB6eSArIHd4O1xuICAgIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMubm9ybWFsRnJvbU1hdDQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0My5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDMuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpKVxufTtcblxuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5tYXQzID0gbWF0Mztcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDR4NCBNYXRyaXhcbiAqIEBuYW1lIG1hdDRcbiAqL1xuXG52YXIgbWF0NCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICAgICAgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhMDE7XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhMDI7XG4gICAgICAgIG91dFs5XSA9IGExMjtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYTAzO1xuICAgICAgICBvdXRbMTNdID0gYTEzO1xuICAgICAgICBvdXRbMTRdID0gYTIzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhWzFdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYVsyXTtcbiAgICAgICAgb3V0WzldID0gYVs2XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhWzNdO1xuICAgICAgICBvdXRbMTNdID0gYVs3XTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFsxXSAgPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs0XSAgPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs3XSAgPSAgKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICAgIG91dFsxMF0gPSAgKGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICAgIG91dFsxM10gPSAgKGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSk7XG4gICAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQ0LmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQ0Lm11bCA9IG1hdDQubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc2xhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjM1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbm1hdDQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcblxuICAgIG91dFswXSA9IGFbMF0gKiB4O1xuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xuICAgIG91dFsyXSA9IGFbMl0gKiB4O1xuICAgIG91dFszXSA9IGFbM10gKiB4O1xuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xuICAgIG91dFs1XSA9IGFbNV0gKiB5O1xuICAgIG91dFs2XSA9IGFbNl0gKiB5O1xuICAgIG91dFs3XSA9IGFbN10gKiB5O1xuICAgIG91dFs4XSA9IGFbOF0gKiB6O1xuICAgIG91dFs5XSA9IGFbOV0gKiB6O1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gICAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0LFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzLFxuICAgICAgICBiMDAsIGIwMSwgYjAyLFxuICAgICAgICBiMTAsIGIxMSwgYjEyLFxuICAgICAgICBiMjAsIGIyMSwgYjIyO1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCBHTE1BVF9FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG4gICAgXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7IGIxMSA9IHkgKiB5ICogdCArIGM7IGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIGIyMCA9IHggKiB6ICogdCArIHkgKiBzOyBiMjEgPSB5ICogeiAqIHQgLSB4ICogczsgYjIyID0geiAqIHogKiB0ICsgYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gICAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICAgIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICAgIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gICAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICAgIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gICAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFs0XSAgPSBhWzRdO1xuICAgICAgICBvdXRbNV0gID0gYVs1XTtcbiAgICAgICAgb3V0WzZdICA9IGFbNl07XG4gICAgICAgIG91dFs3XSAgPSBhWzddO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICAgIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICAgIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbOF0gID0gYVs4XTtcbiAgICAgICAgb3V0WzldICA9IGFbOV07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICAgIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAob3V0LCBxLCB2KSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIG91dFsxXSA9IHh5ICsgd3o7XG4gICAgb3V0WzJdID0geHogLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHh5IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICBvdXRbNl0gPSB5eiArIHd4O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geHogKyB3eTtcbiAgICBvdXRbOV0gPSB5eiAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tYXQ0LmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFszXSA9IDA7XG5cbiAgICBvdXRbNF0gPSB5eCAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs2XSA9IHp5ICsgd3g7XG4gICAgb3V0WzddID0gMDtcblxuICAgIG91dFs4XSA9IHp4ICsgd3k7XG4gICAgb3V0WzldID0genkgLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gICAgb3V0WzExXSA9IDA7XG5cbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZydXN0dW0gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KSxcbiAgICAgICAgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAobmVhciAqIDIpICogcmw7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAobmVhciAqIDIpICogdGI7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gICAgb3V0WzldID0gKHRvcCArIGJvdHRvbSkgKiB0YjtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhciAqIDIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gZjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9ICgyICogZmFyICogbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm9ydGhvID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXG4gICAgICAgIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gLTIgKiBscjtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IC0yICogYnQ7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMiAqIG5mO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICAgIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICAgIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubG9va0F0ID0gZnVuY3Rpb24gKG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gICAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbixcbiAgICAgICAgZXlleCA9IGV5ZVswXSxcbiAgICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgICB1cHogPSB1cFsyXSxcbiAgICAgICAgY2VudGVyeCA9IGNlbnRlclswXSxcbiAgICAgICAgY2VudGVyeSA9IGNlbnRlclsxXSxcbiAgICAgICAgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICAgIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCBHTE1BVF9FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IEdMTUFUX0VQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgR0xNQVRfRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gbWF0NC5pZGVudGl0eShvdXQpO1xuICAgIH1cblxuICAgIHowID0gZXlleCAtIGNlbnRlcng7XG4gICAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuXG4gICAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuXG4gICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeDAgPSAwO1xuICAgICAgICB4MSA9IDA7XG4gICAgICAgIHgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB4MCAqPSBsZW47XG4gICAgICAgIHgxICo9IGxlbjtcbiAgICAgICAgeDIgKj0gbGVuO1xuICAgIH1cblxuICAgIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuXG4gICAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeTAgPSAwO1xuICAgICAgICB5MSA9IDA7XG4gICAgICAgIHkyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgIHkxICo9IGxlbjtcbiAgICAgICAgeTIgKj0gbGVuO1xuICAgIH1cblxuICAgIG91dFswXSA9IHgwO1xuICAgIG91dFsxXSA9IHkwO1xuICAgIG91dFsyXSA9IHowO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geDE7XG4gICAgb3V0WzVdID0geTE7XG4gICAgb3V0WzZdID0gejE7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4MjtcbiAgICBvdXRbOV0gPSB5MjtcbiAgICBvdXRbMTBdID0gejI7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICAgIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0NC5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcbn07XG5cblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0NCA9IG1hdDQ7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAbmFtZSBxdWF0XG4gKi9cblxudmFyIHF1YXQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcbiAqXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICovXG5xdWF0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCB0aGUgc2hvcnRlc3Qgcm90YXRpb24gZnJvbSBvbmVcbiAqIHZlY3RvciB0byBhbm90aGVyLlxuICpcbiAqIEJvdGggdmVjdG9ycyBhcmUgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGluaXRpYWwgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIGRlc3RpbmF0aW9uIHZlY3RvclxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0aW9uVG8gPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIHZhciB4VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMSwwLDApO1xuICAgIHZhciB5VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgICAgICB2YXIgZG90ID0gdmVjMy5kb3QoYSwgYik7XG4gICAgICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgICAgICAgIGlmICh2ZWMzLmxlbmd0aCh0bXB2ZWMzKSA8IDAuMDAwMDAxKVxuICAgICAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeVVuaXRWZWMzLCBhKTtcbiAgICAgICAgICAgIHZlYzMubm9ybWFsaXplKHRtcHZlYzMsIHRtcHZlYzMpO1xuICAgICAgICAgICAgcXVhdC5zZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZG90ID4gMC45OTk5OTkpIHtcbiAgICAgICAgICAgIG91dFswXSA9IDA7XG4gICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgb3V0WzJdID0gMDtcbiAgICAgICAgICAgIG91dFszXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgICAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgICAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICAgICAgICByZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHF1YXRlcm5pb24gd2l0aCB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW5cbiAqIGF4ZXMuIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZFxuICogcGVycGVuZGljdWxhciB0byBhbGwgb3RoZXIgc3BlY2lmaWVkIGF4ZXMuXG4gKlxuICogQHBhcmFtIHt2ZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gcmlnaHQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwicmlnaHRcIiBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7dmVjM30gdXAgICAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwidXBcIiBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zZXRBeGVzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXRyID0gbWF0My5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIHZpZXcsIHJpZ2h0LCB1cCkge1xuICAgICAgICBtYXRyWzBdID0gcmlnaHRbMF07XG4gICAgICAgIG1hdHJbM10gPSByaWdodFsxXTtcbiAgICAgICAgbWF0cls2XSA9IHJpZ2h0WzJdO1xuXG4gICAgICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICAgICAgbWF0cls0XSA9IHVwWzFdO1xuICAgICAgICBtYXRyWzddID0gdXBbMl07XG5cbiAgICAgICAgbWF0clsyXSA9IC12aWV3WzBdO1xuICAgICAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgICAgIG1hdHJbOF0gPSAtdmlld1syXTtcblxuICAgICAgICByZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBxdWF0LmZyb21NYXQzKG91dCwgbWF0cikpO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNsb25lID0gdmVjNC5jbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNvcHkgPSB2ZWM0LmNvcHk7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc2V0ID0gdmVjNC5zZXQ7XG5cbi8qKlxuICogU2V0IGEgcXVhdCB0byB0aGUgaWRlbnRpdHkgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgcm90YXRpb24gYXhpcyxcbiAqIHRoZW4gcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiovXG5xdWF0LnNldEF4aXNBbmdsZSA9IGZ1bmN0aW9uKG91dCwgYXhpcywgcmFkKSB7XG4gICAgcmFkID0gcmFkICogMC41O1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBvdXRbMF0gPSBzICogYXhpc1swXTtcbiAgICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgICBvdXRbM10gPSBNYXRoLmNvcyhyYWQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5hZGQgPSB2ZWM0LmFkZDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5tdWwgPSBxdWF0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFNjYWxlcyBhIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc2NhbGUgPSB2ZWM0LnNjYWxlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICAgIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieSA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBheCAqIGJ5O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieiA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICAgIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxuICogQXNzdW1lcyB0aGF0IHF1YXRlcm5pb24gaXMgMSB1bml0IGluIGxlbmd0aC5cbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgVyBjb21wb25lbnQgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jYWxjdWxhdGVXID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuXG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gLU1hdGguc3FydChNYXRoLmFicygxLjAgLSB4ICogeCAtIHkgKiB5IC0geiAqIHopKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5kb3QgPSB2ZWM0LmRvdDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZXJwID0gdmVjNC5sZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNsZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIC8vIGJlbmNobWFya3M6XG4gICAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIHZhciAgICAgICAgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7XG5cbiAgICAvLyBjYWxjIGNvc2luZVxuICAgIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcbiAgICAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcbiAgICBpZiAoIGNvc29tIDwgMC4wICkge1xuICAgICAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICAgICAgYnggPSAtIGJ4O1xuICAgICAgICBieSA9IC0gYnk7XG4gICAgICAgIGJ6ID0gLSBiejtcbiAgICAgICAgYncgPSAtIGJ3O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG4gICAgaWYgKCAoMS4wIC0gY29zb20pID4gMC4wMDAwMDEgKSB7XG4gICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgICAgICBvbWVnYSAgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgICAgICBzaW5vbSAgPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHsgICAgICAgIFxuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlIFxuICAgICAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICAgIHNjYWxlMSA9IHQ7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcbiAgICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICAgIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gICAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIGRvdCA9IGEwKmEwICsgYTEqYTEgKyBhMiphMiArIGEzKmEzLFxuICAgICAgICBpbnZEb3QgPSBkb3QgPyAxLjAvZG90IDogMDtcbiAgICBcbiAgICAvLyBUT0RPOiBXb3VsZCBiZSBmYXN0ZXIgdG8gcmV0dXJuIFswLDAsMCwwXSBpbW1lZGlhdGVseSBpZiBkb3QgPT0gMFxuXG4gICAgb3V0WzBdID0gLWEwKmludkRvdDtcbiAgICBvdXRbMV0gPSAtYTEqaW52RG90O1xuICAgIG91dFsyXSA9IC1hMippbnZEb3Q7XG4gICAgb3V0WzNdID0gYTMqaW52RG90O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY29uanVnYXRlID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lmxlbmd0aCA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW4gPSBxdWF0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxckxlbiA9IHF1YXQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIDN4MyByb3RhdGlvbiBtYXRyaXguXG4gKlxuICogTk9URTogVGhlIHJlc3VsdGFudCBxdWF0ZXJuaW9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyB5b3Ugc2hvdWxkIGJlIHN1cmVcbiAqIHRvIHJlbm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uIHlvdXJzZWxmIHdoZXJlIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7bWF0M30gbSByb3RhdGlvbiBtYXRyaXhcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21NYXQzID0gZnVuY3Rpb24ob3V0LCBtKSB7XG4gICAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cbiAgICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICAgIHZhciBmUm9vdDtcblxuICAgIGlmICggZlRyYWNlID4gMC4wICkge1xuICAgICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7ICAvLyAyd1xuICAgICAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUvZlJvb3Q7ICAvLyAxLyg0dylcbiAgICAgICAgb3V0WzBdID0gKG1bN10tbVs1XSkqZlJvb3Q7XG4gICAgICAgIG91dFsxXSA9IChtWzJdLW1bNl0pKmZSb290O1xuICAgICAgICBvdXRbMl0gPSAobVszXS1tWzFdKSpmUm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB8d3wgPD0gMS8yXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKCBtWzRdID4gbVswXSApXG4gICAgICAgICAgaSA9IDE7XG4gICAgICAgIGlmICggbVs4XSA+IG1baSozK2ldIClcbiAgICAgICAgICBpID0gMjtcbiAgICAgICAgdmFyIGogPSAoaSsxKSUzO1xuICAgICAgICB2YXIgayA9IChpKzIpJTM7XG4gICAgICAgIFxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChtW2kqMytpXS1tW2oqMytqXS1tW2sqMytrXSArIDEuMCk7XG4gICAgICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290O1xuICAgICAgICBvdXRbM10gPSAobVtrKjMral0gLSBtW2oqMytrXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2pdID0gKG1baiozK2ldICsgbVtpKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtrXSA9IChtW2sqMytpXSArIG1baSozK2tdKSAqIGZSb290O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xucXVhdC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAncXVhdCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnF1YXQgPSBxdWF0O1xufVxuO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4gIH0pKHNoaW0uZXhwb3J0cyk7XG59KSh0aGlzKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgeWFtbCA9IHJlcXVpcmUoJy4vbGliL2pzLXlhbWwuanMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHlhbWw7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGxvYWRlciA9IHJlcXVpcmUoJy4vanMteWFtbC9sb2FkZXInKTtcbnZhciBkdW1wZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvZHVtcGVyJyk7XG5cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiAnICsgbmFtZSArICcgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuJyk7XG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC90eXBlJyk7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYScpO1xubW9kdWxlLmV4cG9ydHMuRkFJTFNBRkVfU0NIRU1BICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2pzb24nKTtcbm1vZHVsZS5leHBvcnRzLkNPUkVfU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICAgICAgICAgID0gbG9hZGVyLmxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgICAgICAgICA9IGxvYWRlci5zYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wICAgICAgICAgICAgPSBkdW1wZXIuc2FmZUR1bXA7XG5tb2R1bGUuZXhwb3J0cy5ZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL2V4Y2VwdGlvbicpO1xuXG4vLyBEZXByZWNhcmVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcbm1vZHVsZS5leHBvcnRzLk1JTklNQUxfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuU0FGRV9TQ0hFTUEgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG4vLyBEZXByZWNhdGVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMS54Lnhcbm1vZHVsZS5leHBvcnRzLnNjYW4gICAgICAgICAgID0gZGVwcmVjYXRlZCgnc2NhbicpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgICAgICAgICAgPSBkZXByZWNhdGVkKCdwYXJzZScpO1xubW9kdWxlLmV4cG9ydHMuY29tcG9zZSAgICAgICAgPSBkZXByZWNhdGVkKCdjb21wb3NlJyk7XG5tb2R1bGUuZXhwb3J0cy5hZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gaXNOb3RoaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuICh1bmRlZmluZWQgPT09IHN1YmplY3QpIHx8IChudWxsID09PSBzdWJqZWN0KTtcbn1cblxuXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiAoJ29iamVjdCcgPT09IHR5cGVvZiBzdWJqZWN0KSAmJiAobnVsbCAhPT0gc3ViamVjdCk7XG59XG5cblxuZnVuY3Rpb24gdG9BcnJheShzZXF1ZW5jZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHtcbiAgICByZXR1cm4gc2VxdWVuY2U7XG4gIH0gZWxzZSBpZiAoaXNOb3RoaW5nKHNlcXVlbmNlKSkge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCBrZXksIHNvdXJjZUtleXM7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgY291bnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBjeWNsZTtcblxuICBmb3IgKGN5Y2xlID0gMDsgY3ljbGUgPCBjb3VudDsgY3ljbGUgKz0gMSkge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzTmVnYXRpdmVaZXJvKG51bWJlcikge1xuICByZXR1cm4gKDAgPT09IG51bWJlcikgJiYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gMSAvIG51bWJlcik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuaXNOb3RoaW5nICAgICAgPSBpc05vdGhpbmc7XG5tb2R1bGUuZXhwb3J0cy5pc09iamVjdCAgICAgICA9IGlzT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMudG9BcnJheSAgICAgICAgPSB0b0FycmF5O1xubW9kdWxlLmV4cG9ydHMucmVwZWF0ICAgICAgICAgPSByZXBlYXQ7XG5tb2R1bGUuZXhwb3J0cy5pc05lZ2F0aXZlWmVybyA9IGlzTmVnYXRpdmVaZXJvO1xubW9kdWxlLmV4cG9ydHMuZXh0ZW5kICAgICAgICAgPSBleHRlbmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIERFRkFVTFRfRlVMTF9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5cblxudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXG52YXIgQ0hBUl9UQUIgICAgICAgICAgICAgICAgICA9IDB4MDk7IC8qIFRhYiAqL1xudmFyIENIQVJfTElORV9GRUVEICAgICAgICAgICAgPSAweDBBOyAvKiBMRiAqL1xudmFyIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgPSAweDBEOyAvKiBDUiAqL1xudmFyIENIQVJfU1BBQ0UgICAgICAgICAgICAgICAgPSAweDIwOyAvKiBTcGFjZSAqL1xudmFyIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPSAweDIxOyAvKiAhICovXG52YXIgQ0hBUl9ET1VCTEVfUVVPVEUgICAgICAgICA9IDB4MjI7IC8qIFwiICovXG52YXIgQ0hBUl9TSEFSUCAgICAgICAgICAgICAgICA9IDB4MjM7IC8qICMgKi9cbnZhciBDSEFSX1BFUkNFTlQgICAgICAgICAgICAgID0gMHgyNTsgLyogJSAqL1xudmFyIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgPSAweDI2OyAvKiAmICovXG52YXIgQ0hBUl9TSU5HTEVfUVVPVEUgICAgICAgICA9IDB4Mjc7IC8qICcgKi9cbnZhciBDSEFSX0FTVEVSSVNLICAgICAgICAgICAgID0gMHgyQTsgLyogKiAqL1xudmFyIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPSAweDJDOyAvKiAsICovXG52YXIgQ0hBUl9NSU5VUyAgICAgICAgICAgICAgICA9IDB4MkQ7IC8qIC0gKi9cbnZhciBDSEFSX0NPTE9OICAgICAgICAgICAgICAgID0gMHgzQTsgLyogOiAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG5cbnZhciBFU0NBUEVfU0VRVUVOQ0VTID0ge307XG5cbkVTQ0FQRV9TRVFVRU5DRVNbMHgwMF0gICA9ICdcXFxcMCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDddICAgPSAnXFxcXGEnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA4XSAgID0gJ1xcXFxiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOV0gICA9ICdcXFxcdCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEFdICAgPSAnXFxcXG4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBCXSAgID0gJ1xcXFx2JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQ10gICA9ICdcXFxcZic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MERdICAgPSAnXFxcXHInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDFCXSAgID0gJ1xcXFxlJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMl0gICA9ICdcXFxcXCInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDVDXSAgID0gJ1xcXFxcXFxcJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg4NV0gICA9ICdcXFxcTic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4QTBdICAgPSAnXFxcXF8nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjhdID0gJ1xcXFxMJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XG5cblxudmFyIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYID0gW1xuICAneScsICdZJywgJ3llcycsICdZZXMnLCAnWUVTJywgJ29uJywgJ09uJywgJ09OJyxcbiAgJ24nLCAnTicsICdubycsICdObycsICdOTycsICdvZmYnLCAnT2ZmJywgJ09GRidcbl07XG5cblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlTWFwKHNjaGVtYSwgbWFwKSB7XG4gIHZhciByZXN1bHQsIGtleXMsIGluZGV4LCBsZW5ndGgsIHRhZywgc3R5bGUsIHR5cGU7XG5cbiAgaWYgKG51bGwgPT09IG1hcCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJlc3VsdCA9IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdGFnID0ga2V5c1tpbmRleF07XG4gICAgc3R5bGUgPSBTdHJpbmcobWFwW3RhZ10pO1xuXG4gICAgaWYgKCchIScgPT09IHRhZy5zbGljZSgwLCAyKSkge1xuICAgICAgdGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWcuc2xpY2UoMik7XG4gICAgfVxuXG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuc3R5bGVBbGlhc2VzLCBzdHlsZSkpIHtcbiAgICAgIHN0eWxlID0gdHlwZS5zdHlsZUFsaWFzZXNbc3R5bGVdO1xuICAgIH1cblxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGVuY29kZUhleChjaGFyYWN0ZXIpIHtcbiAgdmFyIHN0cmluZywgaGFuZGxlLCBsZW5ndGg7XG5cbiAgc3RyaW5nID0gY2hhcmFjdGVyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gIGlmIChjaGFyYWN0ZXIgPD0gMHhGRikge1xuICAgIGhhbmRsZSA9ICd4JztcbiAgICBsZW5ndGggPSAyO1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkYpIHtcbiAgICBoYW5kbGUgPSAndSc7XG4gICAgbGVuZ3RoID0gNDtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGRkZGRikge1xuICAgIGhhbmRsZSA9ICdVJztcbiAgICBsZW5ndGggPSA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdjb2RlIHBvaW50IHdpdGhpbiBhIHN0cmluZyBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiAweEZGRkZGRkZGJyk7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgaGFuZGxlICsgY29tbW9uLnJlcGVhdCgnMCcsIGxlbmd0aCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMuaW5kZW50ICAgICAgPSBNYXRoLm1heCgxLCAob3B0aW9uc1snaW5kZW50J10gfHwgMikpO1xuICB0aGlzLnNraXBJbnZhbGlkID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgICA9IChjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ10pO1xuICB0aGlzLnN0eWxlTWFwICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLmV4cGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEV4cGxpY2l0O1xuXG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpIHtcbiAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIHN0YXRlLmluZGVudCAqIGxldmVsKTtcbn1cblxuZnVuY3Rpb24gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHIpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIHR5cGU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW2luZGV4XTtcblxuICAgIGlmICh0eXBlLnJlc29sdmUoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZVNjYWxhcihzdGF0ZSwgb2JqZWN0KSB7XG4gIHZhciBpc1F1b3RlZCwgY2hlY2twb2ludCwgcG9zaXRpb24sIGxlbmd0aCwgY2hhcmFjdGVyLCBmaXJzdDtcblxuICBzdGF0ZS5kdW1wID0gJyc7XG4gIGlzUXVvdGVkID0gZmFsc2U7XG4gIGNoZWNrcG9pbnQgPSAwO1xuICBmaXJzdCA9IG9iamVjdC5jaGFyQ29kZUF0KDApIHx8IDA7XG5cbiAgaWYgKC0xICE9PSBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWC5pbmRleE9mKG9iamVjdCkpIHtcbiAgICAvLyBFbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIFlBTUwgMS4wLzEuMSBsb2FkZXJzLlxuICAgIGlzUXVvdGVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICgwID09PSBvYmplY3QubGVuZ3RoKSB7XG4gICAgLy8gUXVvdGUgZW1wdHkgc3RyaW5nXG4gICAgaXNRdW90ZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKENIQVJfU1BBQ0UgICAgPT09IGZpcnN0IHx8XG4gICAgICAgICAgICAgQ0hBUl9TUEFDRSAgICA9PT0gb2JqZWN0LmNoYXJDb2RlQXQob2JqZWN0Lmxlbmd0aCAtIDEpKSB7XG4gICAgaXNRdW90ZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKENIQVJfTUlOVVMgICAgPT09IGZpcnN0IHx8XG4gICAgICAgICAgICAgQ0hBUl9RVUVTVElPTiA9PT0gZmlyc3QpIHtcbiAgICAvLyBEb24ndCBjaGVjayBzZWNvbmQgc3ltYm9sIGZvciBzaW1wbGljaXR5XG4gICAgaXNRdW90ZWQgPSB0cnVlO1xuICB9XG5cbiAgZm9yIChwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IHBvc2l0aW9uIDwgbGVuZ3RoOyBwb3NpdGlvbiArPSAxKSB7XG4gICAgY2hhcmFjdGVyID0gb2JqZWN0LmNoYXJDb2RlQXQocG9zaXRpb24pO1xuXG4gICAgaWYgKCFpc1F1b3RlZCkge1xuICAgICAgaWYgKENIQVJfVEFCICAgICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfTElORV9GRUVEICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQVNURVJJU0sgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfVkVSVElDQUxfTElORSAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfUEVSQ0VOVCAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQ09NTUVSQ0lBTF9BVCAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfQ09MT04gICAgICAgICAgICAgICAgPT09IGNoYXJhY3RlciB8fFxuICAgICAgICAgIENIQVJfR1JBVkVfQUNDRU5UICAgICAgICAgPT09IGNoYXJhY3Rlcikge1xuICAgICAgICBpc1F1b3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEVTQ0FQRV9TRVFVRU5DRVNbY2hhcmFjdGVyXSB8fFxuICAgICAgICAhKCgweDAwMDIwIDw9IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPD0gMHgwMDAwN0UpIHx8XG4gICAgICAgICAgKDB4MDAwODUgPT09IGNoYXJhY3RlcikgICAgICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAoMHgwMDBBMCA8PSBjaGFyYWN0ZXIgJiYgY2hhcmFjdGVyIDw9IDB4MDBEN0ZGKSB8fFxuICAgICAgICAgICgweDBFMDAwIDw9IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIgPD0gMHgwMEZGRkQpIHx8XG4gICAgICAgICAgKDB4MTAwMDAgPD0gY2hhcmFjdGVyICYmIGNoYXJhY3RlciA8PSAweDEwRkZGRikpKSB7XG4gICAgICBzdGF0ZS5kdW1wICs9IG9iamVjdC5zbGljZShjaGVja3BvaW50LCBwb3NpdGlvbik7XG4gICAgICBzdGF0ZS5kdW1wICs9IEVTQ0FQRV9TRVFVRU5DRVNbY2hhcmFjdGVyXSB8fCBlbmNvZGVIZXgoY2hhcmFjdGVyKTtcbiAgICAgIGNoZWNrcG9pbnQgPSBwb3NpdGlvbiArIDE7XG4gICAgICBpc1F1b3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrcG9pbnQgPCBwb3NpdGlvbikge1xuICAgIHN0YXRlLmR1bXAgKz0gb2JqZWN0LnNsaWNlKGNoZWNrcG9pbnQsIHBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmICghaXNRdW90ZWQgJiYgdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdGF0ZS5kdW1wKSkge1xuICAgIGlzUXVvdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc1F1b3RlZCkge1xuICAgIHN0YXRlLmR1bXAgPSAnXCInICsgc3RhdGUuZHVtcCArICdcIic7XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RbaW5kZXhdLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBpZiAoMCAhPT0gaW5kZXgpIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLCAnO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAnWycgKyBfcmVzdWx0ICsgJ10nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0W2luZGV4XSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGlmICghY29tcGFjdCB8fCAwICE9PSBpbmRleCkge1xuICAgICAgICBfcmVzdWx0ICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHQgKz0gJy0gJyArIHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKDAgIT09IGluZGV4KSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICcsICc7XG4gICAgfVxuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wICsgJzogJztcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0VmFsdWUsIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ3snICsgX3Jlc3VsdCArICd9Jztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBleHBsaWNpdFBhaXIsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoIWNvbXBhY3QgfHwgMCAhPT0gaW5kZXgpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSAobnVsbCAhPT0gc3RhdGUudGFnICYmICc/JyAhPT0gc3RhdGUudGFnKSB8fFxuICAgICAgICAgICAgICAgICAgIChzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCk7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mICB8fCB0eXBlLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgKCF0eXBlLmluc3RhbmNlT2YgfHwgKCgnb2JqZWN0JyA9PT0gdHlwZW9mIG9iamVjdCkgJiYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUuaW5zdGFuY2VPZikpKSAmJlxuICAgICAgICAoIXR5cGUucHJlZGljYXRlICB8fCB0eXBlLnByZWRpY2F0ZShvYmplY3QpKSkge1xuXG4gICAgICBzdGF0ZS50YWcgPSBleHBsaWNpdCA/IHR5cGUudGFnIDogJz8nO1xuXG4gICAgICBpZiAodHlwZS5yZXByZXNlbnQpIHtcbiAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgaWYgKCdbb2JqZWN0IEZ1bmN0aW9uXScgPT09IF90b1N0cmluZy5jYWxsKHR5cGUucmVwcmVzZW50KSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudChvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCkge1xuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5kdW1wID0gb2JqZWN0O1xuXG4gIGlmICghZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBmYWxzZSkpIHtcbiAgICBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIHRydWUpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBfdG9TdHJpbmcuY2FsbChzdGF0ZS5kdW1wKTtcblxuICBpZiAoYmxvY2spIHtcbiAgICBibG9jayA9ICgwID4gc3RhdGUuZmxvd0xldmVsIHx8IHN0YXRlLmZsb3dMZXZlbCA+IGxldmVsKTtcbiAgfVxuXG4gIGlmICgobnVsbCAhPT0gc3RhdGUudGFnICYmICc/JyAhPT0gc3RhdGUudGFnKSB8fCAoMiAhPT0gc3RhdGUuaW5kZW50ICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9ICdbb2JqZWN0IE9iamVjdF0nID09PSB0eXBlIHx8ICdbb2JqZWN0IEFycmF5XScgPT09IHR5cGUsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKGR1cGxpY2F0ZSAmJiBzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICBzdGF0ZS5kdW1wID0gJypyZWZfJyArIGR1cGxpY2F0ZUluZGV4O1xuICB9IGVsc2Uge1xuICAgIGlmIChvYmplY3RPckFycmF5ICYmIGR1cGxpY2F0ZSAmJiAhc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgICBzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoJ1tvYmplY3QgT2JqZWN0XScgPT09IHR5cGUpIHtcbiAgICAgIGlmIChibG9jayAmJiAoMCAhPT0gT2JqZWN0LmtleXMoc3RhdGUuZHVtcCkubGVuZ3RoKSkge1xuICAgICAgICB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICgwID09PSBsZXZlbCA/ICdcXG4nIDogJycpICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IHR5cGUpIHtcbiAgICAgIGlmIChibG9jayAmJiAoMCAhPT0gc3RhdGUuZHVtcC5sZW5ndGgpKSB7XG4gICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICgwID09PSBsZXZlbCA/ICdcXG4nIDogJycpICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnW29iamVjdCBTdHJpbmddJyA9PT0gdHlwZSkge1xuICAgICAgaWYgKCc/JyAhPT0gc3RhdGUudGFnKSB7XG4gICAgICAgIHdyaXRlU2NhbGFyKHN0YXRlLCBzdGF0ZS5kdW1wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCd1bmFjY2VwdGFibGUga2luZCBvZiBhbiBvYmplY3QgdG8gZHVtcCAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKG51bGwgIT09IHN0YXRlLnRhZyAmJiAnPycgIT09IHN0YXRlLnRhZykge1xuICAgICAgc3RhdGUuZHVtcCA9ICchPCcgKyBzdGF0ZS50YWcgKyAnPiAnICsgc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhvYmplY3QsIHN0YXRlKSB7XG4gIHZhciBvYmplY3RzID0gW10sXG4gICAgICBkdXBsaWNhdGVzSW5kZXhlcyA9IFtdLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGR1cGxpY2F0ZXNJbmRleGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBzdGF0ZS5kdXBsaWNhdGVzLnB1c2gob2JqZWN0c1tkdXBsaWNhdGVzSW5kZXhlc1tpbmRleF1dKTtcbiAgfVxuICBzdGF0ZS51c2VkRHVwbGljYXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKSB7XG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwob2JqZWN0KSxcbiAgICAgIG9iamVjdEtleUxpc3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAobnVsbCAhPT0gb2JqZWN0ICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqZWN0KSB7XG4gICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBpZiAoLTEgIT09IGluZGV4KSB7XG4gICAgICBpZiAoLTEgPT09IGR1cGxpY2F0ZXNJbmRleGVzLmluZGV4T2YoaW5kZXgpKSB7XG4gICAgICAgIGR1cGxpY2F0ZXNJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICBcbiAgICAgIGlmKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3RbaW5kZXhdLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3Rbb2JqZWN0S2V5TGlzdFtpbmRleF1dLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHVtcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUob3B0aW9ucyk7XG5cbiAgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIGlmICh3cml0ZU5vZGUoc3RhdGUsIDAsIGlucHV0LCB0cnVlLCB0cnVlKSkge1xuICAgIHJldHVybiBzdGF0ZS5kdW1wICsgJ1xcbic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2FmZUR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGR1bXAoaW5wdXQsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgID0gZHVtcDtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wID0gc2FmZUR1bXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbihyZWFzb24sIG1hcmspIHtcbiAgdGhpcy5uYW1lICAgID0gJ1lBTUxFeGNlcHRpb24nO1xuICB0aGlzLnJlYXNvbiAgPSByZWFzb247XG4gIHRoaXMubWFyayAgICA9IG1hcms7XG4gIHRoaXMubWVzc2FnZSA9IHRoaXMudG9TdHJpbmcoZmFsc2UpO1xufVxuXG5cbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICB2YXIgcmVzdWx0O1xuXG4gIHJlc3VsdCA9ICdKUy1ZQU1MOiAnICsgKHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJyk7XG5cbiAgaWYgKCFjb21wYWN0ICYmIHRoaXMubWFyaykge1xuICAgIHJlc3VsdCArPSAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWUFNTEV4Y2VwdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgTWFyayAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbWFyaycpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbnZhciBERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVEODAwLVxcdURGRkZcXHVGRkZFXFx1RkZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiAweDJDLyogLCAqLyA9PT0gYyB8fFxuICAgICAgICAgMHg1Qi8qIFsgKi8gPT09IGMgfHxcbiAgICAgICAgIDB4NUQvKiBdICovID09PSBjIHx8XG4gICAgICAgICAweDdCLyogeyAqLyA9PT0gYyB8fFxuICAgICAgICAgMHg3RC8qIH0gKi8gPT09IGM7XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgbGMgPSBjIHwgMHgyMDtcbiAgaWYgKCgweDYxLyogYSAqLyA8PSBsYykgJiYgKGxjIDw9IDB4NjYvKiBmICovKSkge1xuICAgIHJldHVybiBsYyAtIDB4NjEgKyAxMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZEhleExlbihjKSB7XG4gIGlmIChjID09PSAweDc4LyogeCAqLykgeyByZXR1cm4gMjsgfVxuICBpZiAoYyA9PT0gMHg3NS8qIHUgKi8pIHsgcmV0dXJuIDQ7IH1cbiAgaWYgKGMgPT09IDB4NTUvKiBVICovKSB7IHJldHVybiA4OyB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVjaW1hbENvZGUoYykge1xuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRXNjYXBlU2VxdWVuY2UoYykge1xuIHJldHVybiAoYyA9PT0gMHgzMC8qIDAgKi8pID8gJ1xceDAwJyA6XG4gICAgICAgIChjID09PSAweDYxLyogYSAqLykgPyAnXFx4MDcnIDpcbiAgICAgICAgKGMgPT09IDB4NjIvKiBiICovKSA/ICdcXHgwOCcgOlxuICAgICAgICAoYyA9PT0gMHg3NC8qIHQgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDA5LyogVGFiICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHg2RS8qIG4gKi8pID8gJ1xceDBBJyA6XG4gICAgICAgIChjID09PSAweDc2LyogdiAqLykgPyAnXFx4MEInIDpcbiAgICAgICAgKGMgPT09IDB4NjYvKiBmICovKSA/ICdcXHgwQycgOlxuICAgICAgICAoYyA9PT0gMHg3Mi8qIHIgKi8pID8gJ1xceDBEJyA6XG4gICAgICAgIChjID09PSAweDY1LyogZSAqLykgPyAnXFx4MUInIDpcbiAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgPyAnICcgOlxuICAgICAgICAoYyA9PT0gMHgyMi8qIFwiICovKSA/ICdcXHgyMicgOlxuICAgICAgICAoYyA9PT0gMHgyRi8qIC8gKi8pID8gJy8nIDpcbiAgICAgICAgKGMgPT09IDB4NUMvKiBcXCAqLykgPyAnXFx4NUMnIDpcbiAgICAgICAgKGMgPT09IDB4NEUvKiBOICovKSA/ICdcXHg4NScgOlxuICAgICAgICAoYyA9PT0gMHg1Ri8qIF8gKi8pID8gJ1xceEEwJyA6XG4gICAgICAgIChjID09PSAweDRDLyogTCAqLykgPyAnXFx1MjAyOCcgOlxuICAgICAgICAoYyA9PT0gMHg1MC8qIFAgKi8pID8gJ1xcdTIwMjknIDogJyc7XG59XG5cbnZhciBzaW1wbGVFc2NhcGVDaGVjayA9IG5ldyBBcnJheSgyNTYpOyAvLyBpbnRlZ2VyLCBmb3IgZmFzdCBhY2Nlc3NcbnZhciBzaW1wbGVFc2NhcGVNYXAgPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgc2ltcGxlRXNjYXBlQ2hlY2tbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKSA/IDEgOiAwO1xuICBzaW1wbGVFc2NhcGVNYXBbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKTtcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgdGhpcy5maWxlbmFtZSAgPSBvcHRpb25zWydmaWxlbmFtZSddICB8fCBudWxsO1xuICB0aGlzLnNjaGVtYSAgICA9IG9wdGlvbnNbJ3NjaGVtYSddICAgIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMub25XYXJuaW5nID0gb3B0aW9uc1snb25XYXJuaW5nJ10gfHwgbnVsbDtcbiAgdGhpcy5sZWdhY3kgICAgPSBvcHRpb25zWydsZWdhY3knXSAgICB8fCBmYWxzZTtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLnR5cGVNYXAgICAgICAgPSB0aGlzLnNjaGVtYS5jb21waWxlZFR5cGVNYXA7XG5cbiAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnBvc2l0aW9uICAgPSAwO1xuICB0aGlzLmxpbmUgICAgICAgPSAwO1xuICB0aGlzLmxpbmVTdGFydCAgPSAwO1xuICB0aGlzLmxpbmVJbmRlbnQgPSAwO1xuXG4gIHRoaXMuZG9jdW1lbnRzID0gW107XG5cbiAgLypcbiAgdGhpcy52ZXJzaW9uO1xuICB0aGlzLmNoZWNrTGluZUJyZWFrcztcbiAgdGhpcy50YWdNYXA7XG4gIHRoaXMuYW5jaG9yTWFwO1xuICB0aGlzLnRhZztcbiAgdGhpcy5hbmNob3I7XG4gIHRoaXMua2luZDtcbiAgdGhpcy5yZXN1bHQ7Ki9cblxufVxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBZQU1MRXhjZXB0aW9uKFxuICAgIG1lc3NhZ2UsXG4gICAgbmV3IE1hcmsoc3RhdGUuZmlsZW5hbWUsIHN0YXRlLmlucHV0LCBzdGF0ZS5wb3NpdGlvbiwgc3RhdGUubGluZSwgKHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0KSkpO1xufVxuXG5mdW5jdGlvbiB0aHJvd0Vycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHRocm93IGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB0aHJvd1dhcm5pbmcoc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdmFyIGVycm9yID0gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSk7XG5cbiAgaWYgKHN0YXRlLm9uV2FybmluZykge1xuICAgIHN0YXRlLm9uV2FybmluZy5jYWxsKG51bGwsIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5cbnZhciBkaXJlY3RpdmVIYW5kbGVycyA9IHtcblxuICAnWUFNTCc6IGZ1bmN0aW9uIGhhbmRsZVlhbWxEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICAgIGlmIChudWxsICE9PSBzdGF0ZS52ZXJzaW9uKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKDEgIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gL14oWzAtOV0rKVxcLihbMC05XSspJC8uZXhlYyhhcmdzWzBdKTtcblxuICAgICAgaWYgKG51bGwgPT09IG1hdGNoKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgICAgfVxuXG4gICAgICBtYWpvciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICAgIGlmICgxICE9PSBtYWpvcikge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUudmVyc2lvbiA9IGFyZ3NbMF07XG4gICAgICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSAobWlub3IgPCAyKTtcblxuICAgICAgaWYgKDEgIT09IG1pbm9yICYmIDIgIT09IG1pbm9yKSB7XG4gICAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vuc3VwcG9ydGVkIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICdUQUcnOiBmdW5jdGlvbiBoYW5kbGVUYWdEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgICBpZiAoMiAhPT0gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1RBRyBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IHR3byBhcmd1bWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICAgIHByZWZpeCA9IGFyZ3NbMV07XG5cbiAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiA8IF9sZW5ndGg7XG4gICAgICAgICAgIF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCEoMHgwOSA9PT0gX2NoYXJhY3RlciB8fFxuICAgICAgICAgICAgICAweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgdmFyIHNvdXJjZUtleXMsIGtleSwgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGlmICghY29tbW9uLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IG1lcmdlIG1hcHBpbmdzOyB0aGUgcHJvdmlkZWQgc291cmNlIG9iamVjdCBpcyB1bmFjY2VwdGFibGUnKTtcbiAgfVxuXG4gIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG5cbiAgICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSB7XG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAobnVsbCA9PT0gX3Jlc3VsdCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmICgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnID09PSBrZXlUYWcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MEEvKiBMRiAqLyA9PT0gY2gpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICB9IGVsc2UgaWYgKDB4MEQvKiBDUiAqLyA9PT0gY2gpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIGlmICgweDBBLyogTEYgKi8gPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBzdGF0ZS5saW5lICs9IDE7XG4gIHN0YXRlLmxpbmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBhbGxvd0NvbW1lbnRzLCBjaGVja0luZGVudCkge1xuICB2YXIgbGluZUJyZWFrcyA9IDAsXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlICgwICE9PSBjaCkge1xuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dDb21tZW50cyAmJiAweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSB3aGlsZSAoY2ggIT09IDB4MEEvKiBMRiAqLyAmJiBjaCAhPT0gMHgwRC8qIENSICovICYmIDAgIT09IGNoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKDB4MjAvKiBTcGFjZSAqLyA9PT0gY2gpIHtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgY2hlY2tJbmRlbnQpIHtcbiAgICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaW5lQnJlYWtzO1xufVxuXG5mdW5jdGlvbiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG4gIGlmICgoMHgyRC8qIC0gKi8gPT09IGNoIHx8IDB4MkUvKiAuICovID09PSBjaCkgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMSkgPT09IGNoICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbisgMikgPT09IGNoKSB7XG5cbiAgICBfcG9zaXRpb24gKz0gMztcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAwIHx8IGlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgY291bnQpIHtcbiAgaWYgKDEgPT09IGNvdW50KSB7XG4gICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgfSBlbHNlIGlmIChjb3VudCA+IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgY291bnQgLSAxKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCwgd2l0aGluRmxvd0NvbGxlY3Rpb24pIHtcbiAgdmFyIHByZWNlZGluZyxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoYXNQZW5kaW5nQ29udGVudCxcbiAgICAgIF9saW5lLFxuICAgICAgX2xpbmVTdGFydCxcbiAgICAgIF9saW5lSW5kZW50LFxuICAgICAgX2tpbmQgPSBzdGF0ZS5raW5kLFxuICAgICAgX3Jlc3VsdCA9IHN0YXRlLnJlc3VsdCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGlzX1dTX09SX0VPTChjaCkgICAgICAgICAgICAgfHxcbiAgICAgIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSAgICAgICAgfHxcbiAgICAgIDB4MjMvKiAjICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4MjYvKiAmICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4MkEvKiAqICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4MjEvKiAhICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4N0MvKiB8ICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4M0UvKiA+ICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4MjcvKiAnICovICAgICAgICAgICA9PT0gY2ggfHxcbiAgICAgIDB4MjIvKiBcIiAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDI1LyogJSAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDQwLyogQCAqLyAgICAgICAgICAgPT09IGNoIHx8XG4gICAgICAweDYwLyogYCAqLyAgICAgICAgICAgPT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKDB4M0YvKiA/ICovID09PSBjaCB8fCAweDJELyogLSAqLyA9PT0gY2gpIHtcbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICBpZiAoMHgzQS8qIDogKi8gPT09IGNoKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKzEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5raW5kID0gX2tpbmQ7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQ7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoMHgyNy8qICcgKi8gIT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgwICE9PSAoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICBpZiAoMHgyNy8qICcgKi8gPT09IGNoKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmICgweDI3LyogJyAqLyA9PT0gY2gpIHtcbiAgICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLCB0bXBFc2MsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDIyLyogXCIgKi8gIT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgwICE9PSAoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICBpZiAoMHgyMi8qIFwiICovID09PSBjaCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIGlmICgweDVDLyogXFwgKi8gPT09IGNoKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KTtcblxuICAgICAgICAvL1RPRE86IHJld29yayB0byBpbmxpbmUgZm4gd2l0aCBubyB0eXBlIGNhc3Q/XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgMjU2ICYmIHNpbXBsZUVzY2FwZUNoZWNrW2NoXSkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gc2ltcGxlRXNjYXBlTWFwW2NoXTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIGlmICgodG1wID0gZXNjYXBlZEhleExlbihjaCkpID4gMCkge1xuICAgICAgICBoZXhMZW5ndGggPSB0bXA7XG4gICAgICAgIGhleFJlc3VsdCA9IDA7XG5cbiAgICAgICAgZm9yICg7IGhleExlbmd0aCA+IDA7IGhleExlbmd0aC0tKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCh0bXAgPSBmcm9tSGV4Q29kZShjaCkpID49IDApIHtcbiAgICAgICAgICAgIGhleFJlc3VsdCA9IChoZXhSZXN1bHQgPDwgNCkgKyB0bXA7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGhleFJlc3VsdCk7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIGVzY2FwZSBzZXF1ZW5jZScpO1xuICAgICAgfVxuXG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIHJlYWROZXh0ID0gdHJ1ZSxcbiAgICAgIF9saW5lLFxuICAgICAgX3RhZyAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfcmVzdWx0LFxuICAgICAgX2FuY2hvciAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICB0ZXJtaW5hdG9yLFxuICAgICAgaXNQYWlyLFxuICAgICAgaXNFeHBsaWNpdFBhaXIsXG4gICAgICBpc01hcHBpbmcsXG4gICAgICBrZXlOb2RlLFxuICAgICAga2V5VGFnLFxuICAgICAgdmFsdWVOb2RlLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4NUIvKiBbICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4NUQvKiBdICovO1xuICAgIGlzTWFwcGluZyA9IGZhbHNlO1xuICAgIF9yZXN1bHQgPSBbXTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Qi8qIHsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg3RC8qIH0gKi87XG4gICAgaXNNYXBwaW5nID0gdHJ1ZTtcbiAgICBfcmVzdWx0ID0ge307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgIHN0YXRlLmtpbmQgPSBpc01hcHBpbmcgPyAnbWFwcGluZycgOiAnc2VxdWVuY2UnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKDB4M0YvKiA/ICovID09PSBjaCkge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgc3RhdGUubGluZSA9PT0gX2xpbmUpICYmIDB4M0EvKiA6ICovID09PSBjaCkge1xuICAgICAgaXNQYWlyID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChpc01hcHBpbmcpIHtcbiAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHQucHVzaChrZXlOb2RlKTtcbiAgICB9XG5cbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoMHgyQy8qICwgKi8gPT09IGNoKSB7XG4gICAgICByZWFkTmV4dCA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWROZXh0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgZm9sZGluZyxcbiAgICAgIGNob21waW5nICAgICAgID0gQ0hPTVBJTkdfQ0xJUCxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKDB4MkIvKiArICovID09PSBjaCB8fCAweDJELyogLSAqLyA9PT0gY2gpIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9ICgweDJCLyogKyAqLyA9PT0gY2gpID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmICgweDIzLyogIyAqLyA9PT0gY2gpIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKDAgIT09IGNoKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgICgweDIwLyogU3BhY2UgKi8gPT09IGNoKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfQ0xJUCkge1xuICAgICAgICBpZiAoZGV0ZWN0ZWRJbmRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHRoZSBzY2FsYXIgaXMgbm90IGVtcHR5LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCcmVhayB0aGlzIGB3aGlsZWAgY3ljbGUgYW5kIGdvIHRvIHRoZSBmdW5jaXRvbidzIGVwaWxvZ3VlLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRm9sZGVkIHN0eWxlOiB1c2UgZmFuY3kgcnVsZXMgdG8gaGFuZGxlIGxpbmUgYnJlYWtzLlxuICAgIGlmIChmb2xkaW5nKSB7XG5cbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gRW5kIG9mIG1vcmUtaW5kZW50ZWQgYmxvY2suXG4gICAgICB9IGVsc2UgaWYgKGF0TW9yZUluZGVudGVkKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7XG5cbiAgICAgIC8vIEp1c3Qgb25lIGxpbmUgYnJlYWsgLSBwZXJjZWl2ZSBhcyB0aGUgc2FtZSBsaW5lLlxuICAgICAgfSBlbHNlIGlmICgwID09PSBlbXB0eUxpbmVzKSB7XG4gICAgICAgIGlmIChkZXRlY3RlZEluZGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgc29tZSBzY2FsYXIgY29udGVudC5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgIC8vIFNldmVyYWwgbGluZSBicmVha3MgLSBwZXJjZWl2ZSBhcyBkaWZmZXJlbnQgbGluZXMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyk7XG4gICAgICB9XG5cbiAgICAvLyBMaXRlcmFsIHN0eWxlOiBqdXN0IGFkZCBleGFjdCBudW1iZXIgb2YgbGluZSBicmVha3MgYmV0d2VlbiBjb250ZW50IGxpbmVzLlxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIElmIGN1cnJlbnQgbGluZSBpc24ndCB0aGUgZmlyc3Qgb25lIC0gY291bnQgbGluZSBicmVhayBmcm9tIHRoZSBsYXN0IGNvbnRlbnQgbGluZS5cbiAgICAgIGlmIChkZXRlY3RlZEluZGVudCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpO1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgLSBjb3VudCBvbmx5IGVtcHR5IGxpbmVzLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICBlbXB0eUxpbmVzID0gMDtcbiAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoMCAhPT0gY2gpKVxuICAgIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG5cbiAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBfbGluZSxcbiAgICAgIF90YWcgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICA9IFtdLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgZGV0ZWN0ZWQgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoMCAhPT0gY2gpIHtcblxuICAgIGlmICgweDJELyogLSAqLyAhPT0gY2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmICghaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPD0gbm9kZUluZGVudCkge1xuICAgICAgICBfcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19JTiwgZmFsc2UsIHRydWUpO1xuICAgIF9yZXN1bHQucHVzaChzdGF0ZS5yZXN1bHQpO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoMCAhPT0gY2gpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgc2VxdWVuY2UgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdzZXF1ZW5jZSc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgICAgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICAgICAgPSB7fSxcbiAgICAgIGtleVRhZyAgICAgICAgPSBudWxsLFxuICAgICAga2V5Tm9kZSAgICAgICA9IG51bGwsXG4gICAgICB2YWx1ZU5vZGUgICAgID0gbnVsbCxcbiAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkICAgICAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlICgwICE9PSBjaCkge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cblxuICAgIC8vXG4gICAgLy8gRXhwbGljaXQgbm90YXRpb24gY2FzZS4gVGhlcmUgYXJlIHR3byBzZXBhcmF0ZSBibG9ja3M6XG4gICAgLy8gZmlyc3QgZm9yIHRoZSBrZXkgKGRlbm90ZWQgYnkgXCI/XCIpIGFuZCBzZWNvbmQgZm9yIHRoZSB2YWx1ZSAoZGVub3RlZCBieSBcIjpcIilcbiAgICAvL1xuICAgIGlmICgoMHgzRi8qID8gKi8gPT09IGNoIHx8IDB4M0EvKiA6ICovICA9PT0gY2gpICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmICgweDNGLyogPyAqLyA9PT0gY2gpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIC8vIGkuZS4gMHgzQS8qIDogKi8gPT09IGNoYXJhY3RlciBhZnRlciB0aGUgZXhwbGljaXQga2V5LlxuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbmNvbXBsZXRlIGV4cGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBrZXkgbm9kZSBpcyBtaXNzZWQnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nO1xuXG4gICAgLy9cbiAgICAvLyBJbXBsaWNpdCBub3RhdGlvbiBjYXNlLiBGbG93LXN0eWxlIG5vZGUgYXMgdGhlIGtleSBmaXJzdCwgdGhlbiBcIjpcIiwgYW5kIHRoZSB2YWx1ZS5cbiAgICAvL1xuICAgIH0gZWxzZSBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuXG4gICAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKDB4M0EvKiA6ICovID09PSBjaCkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICghaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICAgICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgICBhbGxvd0NvbXBhY3QgPSBmYWxzZTtcbiAgICAgICAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcblxuICAgICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhbiBpbXBsaWNpdCBtYXBwaW5nIHBhaXI7IGEgY29sb24gaXMgbWlzc2VkJyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhIGJsb2NrIG1hcHBpbmcgZW50cnk7IGEgbXVsdGlsaW5lIGtleSBtYXkgbm90IGJlIGFuIGltcGxpY2l0IGtleScpO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7IC8vIFJlYWRpbmcgaXMgZG9uZS4gR28gdG8gdGhlIGVwaWxvZ3VlLlxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQ29tbW9uIHJlYWRpbmcgY29kZSBmb3IgYm90aCBleHBsaWNpdCBhbmQgaW1wbGljaXQgbm90YXRpb25zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSB7XG4gICAgICBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfT1VULCB0cnVlLCBhbGxvd0NvbXBhY3QpKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50ICYmICgwICE9PSBjaCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBtYXBwaW5nIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gRXBpbG9ndWUuXG4gIC8vXG5cbiAgLy8gU3BlY2lhbCBjYXNlOiBsYXN0IG1hcHBpbmcncyBub2RlIGNvbnRhaW5zIG9ubHkgdGhlIGtleSBpbiBleHBsaWNpdCBub3RhdGlvbi5cbiAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoZSByZXN1bHRpbmcgbWFwcGluZy5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnbWFwcGluZyc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBkZXRlY3RlZDtcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBpc1ZlcmJhdGltID0gZmFsc2UsXG4gICAgICBpc05hbWVkICAgID0gZmFsc2UsXG4gICAgICB0YWdIYW5kbGUsXG4gICAgICB0YWdOYW1lLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoMHgyMS8qICEgKi8gIT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bGwgIT09IHN0YXRlLnRhZykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhIHRhZyBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICgweDNDLyogPCAqLyA9PT0gY2gpIHtcbiAgICBpc1ZlcmJhdGltID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIGlmICgweDIxLyogISAqLyA9PT0gY2gpIHtcbiAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICB0YWdIYW5kbGUgPSAnISEnO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2Uge1xuICAgIHRhZ0hhbmRsZSA9ICchJztcbiAgfVxuXG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoMCAhPT0gY2ggJiYgMHgzRS8qID4gKi8gIT09IGNoKTtcblxuICAgIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWcnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKDAgIT09IGNoICYmICFpc19XU19PUl9FT0woY2gpKSB7XG5cbiAgICAgIGlmICgweDIxLyogISAqLyA9PT0gY2gpIHtcbiAgICAgICAgaWYgKCFpc05hbWVkKSB7XG4gICAgICAgICAgdGFnSGFuZGxlID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uIC0gMSwgc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QodGFnSGFuZGxlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWVkIHRhZyBoYW5kbGUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNOYW1lZCA9IHRydWU7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUy50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBmbG93IGluZGljYXRvciBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ05hbWUgJiYgIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHRhZ05hbWUpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVyczogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCB0YWdIYW5kbGUpKSB7XG4gICAgc3RhdGUudGFnID0gc3RhdGUudGFnTWFwW3RhZ0hhbmRsZV0gKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoJyEnID09PSB0YWdIYW5kbGUpIHtcbiAgICBzdGF0ZS50YWcgPSAnIScgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoJyEhJyA9PT0gdGFnSGFuZGxlKSB7XG4gICAgc3RhdGUudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZGVjbGFyZWQgdGFnIGhhbmRsZSBcIicgKyB0YWdIYW5kbGUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKDB4MjYvKiAmICovICE9PSBjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYW4gYW5jaG9yIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfV1NfT1JfRU9MKGNoKSAmJiAhaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBfcG9zaXRpb24pIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZSBvZiBhbiBhbmNob3Igbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgc3RhdGUuYW5jaG9yID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQWxpYXMoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiwgYWxpYXMsXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGgsXG4gICAgICBpbnB1dCA9IHN0YXRlLmlucHV0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoMHgyQS8qICogKi8gIT09IGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoMCAhPT0gY2ggJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIXN0YXRlLmFuY2hvck1hcC5oYXNPd25Qcm9wZXJ0eShhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgYXROZXdMaW5lICA9IGZhbHNlLFxuICAgICAgaXNJbmRlbnRlZCA9IHRydWUsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlLFxuICAgICAgZmxvd0luZGVudCxcbiAgICAgIGJsb2NrSW5kZW50LFxuICAgICAgX3Jlc3VsdDtcblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaXNJbmRlbnRlZCA9IGZhbHNlO1xuXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaXNJbmRlbnRlZCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaXNJbmRlbnRlZCkge1xuICAgIHdoaWxlIChyZWFkVGFnUHJvcGVydHkoc3RhdGUpIHx8IHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGlzSW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpc0luZGVudGVkID0gZmFsc2U7XG4gICAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYWxsb3dCbG9ja1N0eWxlcztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpc0luZGVudGVkIHx8IENPTlRFWFRfQkxPQ0tfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgIGlmIChDT05URVhUX0ZMT1dfSU4gPT09IG5vZGVDb250ZXh0IHx8IENPTlRFWFRfRkxPV19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgICBmbG93SW5kZW50ID0gcGFyZW50SW5kZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBmbG93SW5kZW50ID0gcGFyZW50SW5kZW50ICsgMTtcbiAgICB9XG5cbiAgICBibG9ja0luZGVudCA9IHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0O1xuXG4gICAgaWYgKGlzSW5kZW50ZWQpIHtcbiAgICAgIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiZcbiAgICAgICAgICAocmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KSB8fFxuICAgICAgICAgICByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBibG9ja0luZGVudCwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoYWxsb3dCbG9ja1NjYWxhcnMgJiYgcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkgfHxcbiAgICAgICAgICAgIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpIHx8XG4gICAgICAgICAgICByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVhZEFsaWFzKHN0YXRlKSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlLnRhZyB8fCBudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhbGlhcyBub2RlIHNob3VsZCBub3QgaGF2ZSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChudWxsID09PSBzdGF0ZS50YWcpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGUuYW5jaG9yKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGFzQ29udGVudCA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyAmJiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYmxvY2tJbmRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChudWxsICE9PSBzdGF0ZS50YWcgJiYgJyEnICE9PSBzdGF0ZS50YWcpIHtcbiAgICBpZiAoJz8nID09PSBzdGF0ZS50YWcpIHtcbiAgICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7XG4gICAgICAgICAgIHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTtcbiAgICAgICAgICAgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbdHlwZUluZGV4XTtcblxuICAgICAgICAvLyBJbXBsaWNpdCByZXNvbHZpbmcgaXMgbm90IGFsbG93ZWQgZm9yIG5vbi1zY2FsYXIgdHlwZXMsIGFuZCAnPydcbiAgICAgICAgLy8gbm9uLXNwZWNpZmljIHRhZyBpcyBvbmx5IGFzc2lnbmVkIHRvIHBsYWluIHNjYWxhcnMuIFNvLCBpdCBpc24ndFxuICAgICAgICAvLyBuZWVkZWQgdG8gY2hlY2sgZm9yICdraW5kJyBjb25mb3JtaXR5LlxuXG4gICAgICAgIGlmICh0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQpO1xuICAgICAgICAgIHN0YXRlLnRhZyA9IHR5cGUudGFnO1xuICAgICAgICAgIGlmIChudWxsICE9PSBzdGF0ZS5hbmNob3IpIHtcbiAgICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudHlwZU1hcCwgc3RhdGUudGFnKSkge1xuICAgICAgdHlwZSA9IHN0YXRlLnR5cGVNYXBbc3RhdGUudGFnXTtcblxuICAgICAgaWYgKG51bGwgIT09IHN0YXRlLnJlc3VsdCAmJiB0eXBlLmtpbmQgIT09IHN0YXRlLmtpbmQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8JyArIHN0YXRlLnRhZyArICc+IGV4cGxpY2l0IHRhZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlLmFuY2hvcikge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gdGFnICE8JyArIHN0YXRlLnRhZyArICc+Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGwgIT09IHN0YXRlLnRhZyB8fCBudWxsICE9PSBzdGF0ZS5hbmNob3IgfHwgaGFzQ29udGVudDtcbn1cblxuZnVuY3Rpb24gcmVhZERvY3VtZW50KHN0YXRlKSB7XG4gIHZhciBkb2N1bWVudFN0YXJ0ID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBfcG9zaXRpb24sXG4gICAgICBkaXJlY3RpdmVOYW1lLFxuICAgICAgZGlyZWN0aXZlQXJncyxcbiAgICAgIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIHN0YXRlLnZlcnNpb24gPSBudWxsO1xuICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSBzdGF0ZS5sZWdhY3k7XG4gIHN0YXRlLnRhZ01hcCA9IHt9O1xuICBzdGF0ZS5hbmNob3JNYXAgPSB7fTtcblxuICB3aGlsZSAoMCAhPT0gKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gMCB8fCAweDI1LyogJSAqLyAhPT0gY2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlICgwICE9PSBjaCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKDAgIT09IGNoKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKDB4MjMvKiAjICovID09PSBjaCkge1xuICAgICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgICB3aGlsZSAoMCAhPT0gY2ggJiYgIWlzX0VPTChjaCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgICB3aGlsZSAoMCAhPT0gY2ggJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RpdmVBcmdzLnB1c2goc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbikpO1xuICAgIH1cblxuICAgIGlmICgwICE9PSBjaCkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpcmVjdGl2ZUhhbmRsZXJzLCBkaXJlY3RpdmVOYW1lKSkge1xuICAgICAgZGlyZWN0aXZlSGFuZGxlcnNbZGlyZWN0aXZlTmFtZV0oc3RhdGUsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bmtub3duIGRvY3VtZW50IGRpcmVjdGl2ZSBcIicgKyBkaXJlY3RpdmVOYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9XG5cbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmICgwID09PSBzdGF0ZS5saW5lSW5kZW50ICYmXG4gICAgICAweDJELyogLSAqLyA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgJiZcbiAgICAgIDB4MkQvKiAtICovID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSkgJiZcbiAgICAgIDB4MkQvKiAtICovID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMikpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICB9IGVsc2UgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgY29tcG9zZU5vZGUoc3RhdGUsIHN0YXRlLmxpbmVJbmRlbnQgLSAxLCBDT05URVhUX0JMT0NLX09VVCwgZmFsc2UsIHRydWUpO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmNoZWNrTGluZUJyZWFrcyAmJlxuICAgICAgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChzdGF0ZS5pbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XG4gIH1cblxuICBzdGF0ZS5kb2N1bWVudHMucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcblxuICAgIGlmICgweDJFLyogLiAqLyA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdlbmQgb2YgdGhlIHN0cmVhbSBvciBhIGRvY3VtZW50IHNlcGFyYXRvciBpcyBleHBlY3RlZCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoMCAhPT0gaW5wdXQubGVuZ3RoICYmXG4gICAgICAweDBBLyogTEYgKi8gIT09IGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgJiZcbiAgICAgIDB4MEQvKiBDUiAqLyAhPT0gaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSkge1xuICAgIGlucHV0ICs9ICdcXG4nO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKGlucHV0LCBvcHRpb25zKTtcblxuICBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3Qoc3RhdGUuaW5wdXQpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZSBzdHJlYW0gY29udGFpbnMgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzJyk7XG4gIH1cblxuICAvLyBVc2UgMCBhcyBzdHJpbmcgdGVybWluYXRvci4gVGhhdCBzaWduaWZpY2FudGx5IHNpbXBsaWZpZXMgYm91bmRzIGNoZWNrLlxuICBzdGF0ZS5pbnB1dCArPSAnXFwwJztcblxuICB3aGlsZSAoMHgyMC8qIFNwYWNlICovID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkge1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgKz0gMTtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAxO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgcmVhZERvY3VtZW50KHN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5kb2N1bWVudHM7XG59XG5cblxuZnVuY3Rpb24gbG9hZEFsbChpbnB1dCwgaXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpLCBpbmRleCwgbGVuZ3RoO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkb2N1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGl0ZXJhdG9yKGRvY3VtZW50c1tpbmRleF0pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZChpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyksIGluZGV4LCBsZW5ndGg7XG5cbiAgaWYgKDAgPT09IGRvY3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKDEgPT09IGRvY3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZScpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2FmZUxvYWRBbGwoaW5wdXQsIG91dHB1dCwgb3B0aW9ucykge1xuICBsb2FkQWxsKGlucHV0LCBvdXRwdXQsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xufVxuXG5cbmZ1bmN0aW9uIHNhZmVMb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBsb2FkKGlucHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICA9IGxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICA9IGxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZEFsbCA9IHNhZmVMb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWQgICAgPSBzYWZlTG9hZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5mdW5jdGlvbiBNYXJrKG5hbWUsIGJ1ZmZlciwgcG9zaXRpb24sIGxpbmUsIGNvbHVtbikge1xuICB0aGlzLm5hbWUgICAgID0gbmFtZTtcbiAgdGhpcy5idWZmZXIgICA9IGJ1ZmZlcjtcbiAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB0aGlzLmxpbmUgICAgID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gICA9IGNvbHVtbjtcbn1cblxuXG5NYXJrLnByb3RvdHlwZS5nZXRTbmlwcGV0ID0gZnVuY3Rpb24gZ2V0U25pcHBldChpbmRlbnQsIG1heExlbmd0aCkge1xuICB2YXIgaGVhZCwgc3RhcnQsIHRhaWwsIGVuZCwgc25pcHBldDtcblxuICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpbmRlbnQgPSBpbmRlbnQgfHwgNDtcbiAgbWF4TGVuZ3RoID0gbWF4TGVuZ3RoIHx8IDc1O1xuXG4gIGhlYWQgPSAnJztcbiAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChzdGFydCA+IDAgJiYgLTEgPT09ICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KHN0YXJ0IC0gMSkpKSB7XG4gICAgc3RhcnQgLT0gMTtcbiAgICBpZiAodGhpcy5wb3NpdGlvbiAtIHN0YXJ0ID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgaGVhZCA9ICcgLi4uICc7XG4gICAgICBzdGFydCArPSA1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdGFpbCA9ICcnO1xuICBlbmQgPSB0aGlzLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChlbmQgPCB0aGlzLmJ1ZmZlci5sZW5ndGggJiYgLTEgPT09ICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGVuZCkpKSB7XG4gICAgZW5kICs9IDE7XG4gICAgaWYgKGVuZCAtIHRoaXMucG9zaXRpb24gPiAobWF4TGVuZ3RoIC8gMiAtIDEpKSB7XG4gICAgICB0YWlsID0gJyAuLi4gJztcbiAgICAgIGVuZCAtPSA1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc25pcHBldCA9IHRoaXMuYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIHJldHVybiBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50KSArIGhlYWQgKyBzbmlwcGV0ICsgdGFpbCArICdcXG4nICtcbiAgICAgICAgIGNvbW1vbi5yZXBlYXQoJyAnLCBpbmRlbnQgKyB0aGlzLnBvc2l0aW9uIC0gc3RhcnQgKyBoZWFkLmxlbmd0aCkgKyAnXic7XG59O1xuXG5cbk1hcmsucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICB2YXIgc25pcHBldCwgd2hlcmUgPSAnJztcblxuICBpZiAodGhpcy5uYW1lKSB7XG4gICAgd2hlcmUgKz0gJ2luIFwiJyArIHRoaXMubmFtZSArICdcIiAnO1xuICB9XG5cbiAgd2hlcmUgKz0gJ2F0IGxpbmUgJyArICh0aGlzLmxpbmUgKyAxKSArICcsIGNvbHVtbiAnICsgKHRoaXMuY29sdW1uICsgMSk7XG5cbiAgaWYgKCFjb21wYWN0KSB7XG4gICAgc25pcHBldCA9IHRoaXMuZ2V0U25pcHBldCgpO1xuXG4gICAgaWYgKHNuaXBwZXQpIHtcbiAgICAgIHdoZXJlICs9ICc6XFxuJyArIHNuaXBwZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdoZXJlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcms7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIFR5cGUgICAgICAgICAgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuXG5mdW5jdGlvbiBjb21waWxlTGlzdChzY2hlbWEsIG5hbWUsIHJlc3VsdCkge1xuICB2YXIgZXhjbHVkZSA9IFtdO1xuXG4gIHNjaGVtYS5pbmNsdWRlLmZvckVhY2goZnVuY3Rpb24gKGluY2x1ZGVkU2NoZW1hKSB7XG4gICAgcmVzdWx0ID0gY29tcGlsZUxpc3QoaW5jbHVkZWRTY2hlbWEsIG5hbWUsIHJlc3VsdCk7XG4gIH0pO1xuXG4gIHNjaGVtYVtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50VHlwZSkge1xuICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2aW91c1R5cGUsIHByZXZpb3VzSW5kZXgpIHtcbiAgICAgIGlmIChwcmV2aW91c1R5cGUudGFnID09PSBjdXJyZW50VHlwZS50YWcpIHtcbiAgICAgICAgZXhjbHVkZS5wdXNoKHByZXZpb3VzSW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdWx0LnB1c2goY3VycmVudFR5cGUpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gLTEgPT09IGV4Y2x1ZGUuaW5kZXhPZihpbmRleCk7XG4gIH0pO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBpbGVNYXAoLyogbGlzdHMuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9LCBpbmRleCwgbGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3RUeXBlKHR5cGUpIHtcbiAgICByZXN1bHRbdHlwZS50YWddID0gdHlwZTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFyZ3VtZW50c1tpbmRleF0uZm9yRWFjaChjb2xsZWN0VHlwZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIFNjaGVtYShkZWZpbml0aW9uKSB7XG4gIHRoaXMuaW5jbHVkZSAgPSBkZWZpbml0aW9uLmluY2x1ZGUgIHx8IFtdO1xuICB0aGlzLmltcGxpY2l0ID0gZGVmaW5pdGlvbi5pbXBsaWNpdCB8fCBbXTtcbiAgdGhpcy5leHBsaWNpdCA9IGRlZmluaXRpb24uZXhwbGljaXQgfHwgW107XG5cbiAgdGhpcy5pbXBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUubG9hZEtpbmQgJiYgJ3NjYWxhcicgIT09IHR5cGUubG9hZEtpbmQpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdUaGVyZSBpcyBhIG5vbi1zY2FsYXIgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gSW1wbGljaXQgcmVzb2x2aW5nIG9mIHN1Y2ggdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuY29tcGlsZWRJbXBsaWNpdCA9IGNvbXBpbGVMaXN0KHRoaXMsICdpbXBsaWNpdCcsIFtdKTtcbiAgdGhpcy5jb21waWxlZEV4cGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2V4cGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkVHlwZU1hcCAgPSBjb21waWxlTWFwKHRoaXMuY29tcGlsZWRJbXBsaWNpdCwgdGhpcy5jb21waWxlZEV4cGxpY2l0KTtcbn1cblxuXG5TY2hlbWEuREVGQVVMVCA9IG51bGw7XG5cblxuU2NoZW1hLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYSgpIHtcbiAgdmFyIHNjaGVtYXMsIHR5cGVzO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICBjYXNlIDE6XG4gICAgc2NoZW1hcyA9IFNjaGVtYS5ERUZBVUxUO1xuICAgIHR5cGVzID0gYXJndW1lbnRzWzBdO1xuICAgIGJyZWFrO1xuXG4gIGNhc2UgMjpcbiAgICBzY2hlbWFzID0gYXJndW1lbnRzWzBdO1xuICAgIHR5cGVzID0gYXJndW1lbnRzWzFdO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIFNjaGVtYS5jcmVhdGUgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHNjaGVtYXMgPSBjb21tb24udG9BcnJheShzY2hlbWFzKTtcbiAgdHlwZXMgPSBjb21tb24udG9BcnJheSh0eXBlcyk7XG5cbiAgaWYgKCFzY2hlbWFzLmV2ZXJ5KGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYTsgfSkpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2Ygc3VwZXIgc2NoZW1hcyAob3IgYSBzaW5nbGUgU2NoZW1hIG9iamVjdCkgY29udGFpbnMgYSBub24tU2NoZW1hIG9iamVjdC4nKTtcbiAgfVxuXG4gIGlmICghdHlwZXMuZXZlcnkoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUgaW5zdGFuY2VvZiBUeXBlOyB9KSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBZQU1MIHR5cGVzIChvciBhIHNpbmdsZSBUeXBlIG9iamVjdCkgY29udGFpbnMgYSBub24tVHlwZSBvYmplY3QuJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNjaGVtYSh7XG4gICAgaW5jbHVkZTogc2NoZW1hcyxcbiAgICBleHBsaWNpdDogdHlwZXNcbiAgfSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hO1xuIiwiLy8gU3RhbmRhcmQgWUFNTCdzIENvcmUgc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODA0OTIzXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgQ29yZSBzY2hlbWEgaGFzIG5vIGRpc3RpbmN0aW9ucyBmcm9tIEpTT04gc2NoZW1hIGlzIEpTLVlBTUwuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9qc29uJylcbiAgXVxufSk7XG4iLCIvLyBKUy1ZQU1MJ3MgZGVmYXVsdCBzY2hlbWEgZm9yIGBsb2FkYCBmdW5jdGlvbi5cbi8vIEl0IGlzIG5vdCBkZXNjcmliZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vXG4vLyBUaGlzIHNjaGVtYSBpcyBiYXNlZCBvbiBKUy1ZQU1MJ3MgZGVmYXVsdCBzYWZlIHNjaGVtYSBhbmQgaW5jbHVkZXNcbi8vIEphdmFTY3JpcHQtc3BlY2lmaWMgdHlwZXM6ICEhanMvdW5kZWZpbmVkLCAhIWpzL3JlZ2V4cCBhbmQgISFqcy9mdW5jdGlvbi5cbi8vXG4vLyBBbHNvIHRoaXMgc2NoZW1hIGlzIHVzZWQgYXMgZGVmYXVsdCBiYXNlIHNjaGVtYSBhdCBgU2NoZW1hLmNyZWF0ZWAgZnVuY3Rpb24uXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYS5ERUZBVUxUID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2RlZmF1bHRfc2FmZScpXG4gIF0sXG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy91bmRlZmluZWQnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL3JlZ2V4cCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvZnVuY3Rpb24nKVxuICBdXG59KTtcbiIsIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYHNhZmVMb2FkYCBmdW5jdGlvbi5cbi8vIEl0IGlzIG5vdCBkZXNjcmliZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vXG4vLyBUaGlzIHNjaGVtYSBpcyBiYXNlZCBvbiBzdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEgYW5kIGluY2x1ZGVzIG1vc3Qgb2Zcbi8vIGV4dHJhIHR5cGVzIGRlc2NyaWJlZCBhdCBZQU1MIHRhZyByZXBvc2l0b3J5LiAoaHR0cDovL3lhbWwub3JnL3R5cGUvKVxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vY29yZScpXG4gIF0sXG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS90aW1lc3RhbXAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL21lcmdlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2JpbmFyeScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvb21hcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvcGFpcnMnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NldCcpXG4gIF1cbn0pO1xuIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEZhaWxzYWZlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMjM0NlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3N0cicpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2VxJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tYXAnKVxuICBdXG59KTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBKU09OIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMzIzMVxuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIHRoaXMgc2NoZW1hIGlzIG5vdCBzdWNoIHN0cmljdCBhcyBkZWZpbmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vLyBJdCBhbGxvd3MgbnVtYmVycyBpbiBiaW5hcnkgbm90YWlvbiwgdXNlIGBOdWxsYCBhbmQgYE5VTExgIGFzIGBudWxsYCwgZXRjLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vZmFpbHNhZmUnKVxuICBdLFxuICBpbXBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvbnVsbCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvYm9vbCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvaW50JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9mbG9hdCcpXG4gIF1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG5cbnZhciBUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMgPSBbXG4gICdraW5kJyxcbiAgJ3Jlc29sdmUnLFxuICAnY29uc3RydWN0JyxcbiAgJ2luc3RhbmNlT2YnLFxuICAncHJlZGljYXRlJyxcbiAgJ3JlcHJlc2VudCcsXG4gICdkZWZhdWx0U3R5bGUnLFxuICAnc3R5bGVBbGlhc2VzJ1xuXTtcblxudmFyIFlBTUxfTk9ERV9LSU5EUyA9IFtcbiAgJ3NjYWxhcicsXG4gICdzZXF1ZW5jZScsXG4gICdtYXBwaW5nJ1xuXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlQWxpYXNlcyhtYXApIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChudWxsICE9PSBtYXApIHtcbiAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBtYXBbc3R5bGVdLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJlc3VsdFtTdHJpbmcoYWxpYXMpXSA9IHN0eWxlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBUeXBlKHRhZywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKC0xID09PSBUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMuaW5kZXhPZihuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1Vua25vd24gb3B0aW9uIFwiJyArIG5hbWUgKyAnXCIgaXMgbWV0IGluIGRlZmluaXRpb24gb2YgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRPRE86IEFkZCB0YWcgZm9ybWF0IGNoZWNrLlxuICB0aGlzLnRhZyAgICAgICAgICA9IHRhZztcbiAgdGhpcy5raW5kICAgICAgICAgPSBvcHRpb25zWydraW5kJ10gICAgICAgICB8fCBudWxsO1xuICB0aGlzLnJlc29sdmUgICAgICA9IG9wdGlvbnNbJ3Jlc29sdmUnXSAgICAgIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gIHRoaXMuY29uc3RydWN0ICAgID0gb3B0aW9uc1snY29uc3RydWN0J10gICAgfHwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGE7IH07XG4gIHRoaXMuaW5zdGFuY2VPZiAgID0gb3B0aW9uc1snaW5zdGFuY2VPZiddICAgfHwgbnVsbDtcbiAgdGhpcy5wcmVkaWNhdGUgICAgPSBvcHRpb25zWydwcmVkaWNhdGUnXSAgICB8fCBudWxsO1xuICB0aGlzLnJlcHJlc2VudCAgICA9IG9wdGlvbnNbJ3JlcHJlc2VudCddICAgIHx8IG51bGw7XG4gIHRoaXMuZGVmYXVsdFN0eWxlID0gb3B0aW9uc1snZGVmYXVsdFN0eWxlJ10gfHwgbnVsbDtcbiAgdGhpcy5zdHlsZUFsaWFzZXMgPSBjb21waWxlU3R5bGVBbGlhc2VzKG9wdGlvbnNbJ3N0eWxlQWxpYXNlcyddIHx8IG51bGwpO1xuXG4gIGlmICgtMSA9PT0gWUFNTF9OT0RFX0tJTkRTLmluZGV4T2YodGhpcy5raW5kKSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmtub3duIGtpbmQgXCInICsgdGhpcy5raW5kICsgJ1wiIGlzIHNwZWNpZmllZCBmb3IgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGU7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24uXG4vLyBTaW5jZSB3ZSBtYWtlIGJyb3dzZXJpZmllciB0byBpZ25vcmUgYGJ1ZmZlcmAgbW9kdWxlLCBOb2RlQnVmZmVyIHdpbGwgYmUgdW5kZWZpbmVkXG52YXIgTm9kZUJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBUeXBlICAgICAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5cbi8vIFsgNjQsIDY1LCA2NiBdIC0+IFsgcGFkZGluZywgQ1IsIExGIF1cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyJztcblxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIHZhciBjb2RlLCBpZHgsIGJpdGxlbiA9IDAsIGxlbiA9IDAsIG1heCA9IGRhdGEubGVuZ3RoLCBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgb25lIGJ5IG9uZS5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCArKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTtcblxuICAgIC8vIFNraXAgQ1IvTEZcbiAgICBpZiAoY29kZSA+IDY0KSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBGYWlsIG9uIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGJpdGxlbiArPSA2O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHNvdXJjZSB3YXMgY29ycnVwdGVkXG4gIHJldHVybiAoYml0bGVuICUgOCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCaW5hcnkoZGF0YSkge1xuICB2YXIgY29kZSwgaWR4LCB0YWlsYml0cyxcbiAgICAgIGlucHV0ID0gZGF0YS5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVAsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBtYXAuaW5kZXhPZihpbnB1dC5jaGFyQXQoaWR4KSk7XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsYml0cyA9IChtYXggJSA0KSo2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIC8vIFdyYXAgaW50byBCdWZmZXIgZm9yIE5vZGVKUyBhbmQgbGVhdmUgQXJyYXkgZm9yIGJyb3dzZXJcbiAgaWYgKE5vZGVCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IE5vZGVCdWZmZXIocmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmplY3QpIHtcbiAgcmV0dXJuIE5vZGVCdWZmZXIgJiYgTm9kZUJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJpbmFyeSxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQmluYXJ5LFxuICBwcmVkaWNhdGU6IGlzQmluYXJ5LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxCaW5hcnlcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSA0ICYmIChkYXRhID09PSAndHJ1ZScgfHwgZGF0YSA9PT0gJ1RydWUnIHx8IGRhdGEgPT09ICdUUlVFJykpIHx8XG4gICAgICAgICAobWF4ID09PSA1ICYmIChkYXRhID09PSAnZmFsc2UnIHx8IGRhdGEgPT09ICdGYWxzZScgfHwgZGF0YSA9PT0gJ0ZBTFNFJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQm9vbGVhbihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAndHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUcnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RSVUUnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqZWN0KSB7XG4gIHJldHVybiAnW29iamVjdCBCb29sZWFuXScgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCb29sZWFuLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCb29sZWFuLFxuICBwcmVkaWNhdGU6IGlzQm9vbGVhbixcbiAgcmVwcmVzZW50OiB7XG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RSVUUnIDogJ0ZBTFNFJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUcnVlJyA6ICdGYWxzZSc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBZQU1MX0ZMT0FUX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFxuICAnXig/OlstK10/KD86WzAtOV1bMC05X10qKVxcXFwuWzAtOV9dKig/OltlRV1bLStdWzAtOV0rKT8nICtcbiAgJ3xcXFxcLlswLTlfXSsoPzpbZUVdWy0rXVswLTldKyk/JyArXG4gICd8Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcXFwuWzAtOV9dKicgK1xuICAnfFstK10/XFxcXC4oPzppbmZ8SW5mfElORiknICtcbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICB2YXIgdmFsdWUsIHNpZ24sIGJhc2UsIGRpZ2l0cztcblxuICBpZiAoIVlBTUxfRkxPQVRfUEFUVEVSTi50ZXN0KGRhdGEpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sRmxvYXQoZGF0YSkge1xuICB2YXIgdmFsdWUsIHNpZ24sIGJhc2UsIGRpZ2l0cztcblxuICB2YWx1ZSAgPSBkYXRhLnJlcGxhY2UoL18vZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gIHNpZ24gICA9ICctJyA9PT0gdmFsdWVbMF0gPyAtMSA6IDE7XG4gIGRpZ2l0cyA9IFtdO1xuXG4gIGlmICgwIDw9ICcrLScuaW5kZXhPZih2YWx1ZVswXSkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICB9XG5cbiAgaWYgKCcuaW5mJyA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm4gKDEgPT09IHNpZ24pID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gIH0gZWxzZSBpZiAoJy5uYW4nID09PSB2YWx1ZSkge1xuICAgIHJldHVybiBOYU47XG5cbiAgfSBlbHNlIGlmICgwIDw9IHZhbHVlLmluZGV4T2YoJzonKSkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VGbG9hdCh2LCAxMCkpO1xuICAgIH0pO1xuXG4gICAgdmFsdWUgPSAwLjA7XG4gICAgYmFzZSA9IDE7XG5cbiAgICBkaWdpdHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgdmFsdWUgKz0gZCAqIGJhc2U7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxGbG9hdChvYmplY3QsIHN0eWxlKSB7XG4gIGlmIChpc05hTihvYmplY3QpKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgIGNhc2UgJ2xvd2VyY2FzZSc6XG4gICAgICByZXR1cm4gJy5uYW4nO1xuICAgIGNhc2UgJ3VwcGVyY2FzZSc6XG4gICAgICByZXR1cm4gJy5OQU4nO1xuICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICByZXR1cm4gJy5OYU4nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgcmV0dXJuICcuaW5mJztcbiAgICBjYXNlICd1cHBlcmNhc2UnOlxuICAgICAgcmV0dXJuICcuSU5GJztcbiAgICBjYXNlICdjYW1lbGNhc2UnOlxuICAgICAgcmV0dXJuICcuSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgY2FzZSAnbG93ZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLS5pbmYnO1xuICAgIGNhc2UgJ3VwcGVyY2FzZSc6XG4gICAgICByZXR1cm4gJy0uSU5GJztcbiAgICBjYXNlICdjYW1lbGNhc2UnOlxuICAgICAgcmV0dXJuICctLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKSB7XG4gICAgcmV0dXJuICctMC4wJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKDEwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKCdbb2JqZWN0IE51bWJlcl0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgJiZcbiAgICAgICAgICgwICE9PSBvYmplY3QgJSAxIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGgsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBoYXNEaWdpdHMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmICghbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNoID0gZGF0YVtpbmRleF07XG5cbiAgLy8gc2lnblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICAvLyAwXG4gICAgaWYgKGluZGV4KzEgPT09IG1heCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcblxuICAgIC8vIGJhc2UgMiwgYmFzZSA4LCBiYXNlIDE2XG5cbiAgICBpZiAoY2ggPT09ICdiJykge1xuICAgICAgLy8gYmFzZSAyXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFpc0hleENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHM7XG4gICAgfVxuXG4gICAgLy8gYmFzZSA4XG4gICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgaWYgKGNoID09PSAnXycpIHsgY29udGludWU7IH1cbiAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNEaWdpdHM7XG4gIH1cblxuICAvLyBiYXNlIDEwIChleGNlcHQgMCkgb3IgYmFzZSA2MFxuXG4gIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgaWYgKGNoID09PSAnXycpIHsgY29udGludWU7IH1cbiAgICBpZiAoY2ggPT09ICc6JykgeyBicmVhazsgfVxuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH1cblxuICBpZiAoIWhhc0RpZ2l0cykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBpZiAhYmFzZTYwIC0gZG9uZTtcbiAgaWYgKGNoICE9PSAnOicpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBiYXNlNjAgYWxtb3N0IG5vdCB1c2VkLCBubyBuZWVkcyB0byBvcHRpbWl6ZVxuICByZXR1cm4gL14oOlswLTVdP1swLTldKSskLy50ZXN0KGRhdGEuc2xpY2UoaW5kZXgpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLCBzaWduID0gMSwgY2gsIGJhc2UsIGRpZ2l0cyA9IFtdO1xuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKTtcbiAgfVxuXG4gIGNoID0gdmFsdWVbMF07XG5cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGlmIChjaCA9PT0gJy0nKSB7IHNpZ24gPSAtMTsgfVxuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgY2ggPSB2YWx1ZVswXTtcbiAgfVxuXG4gIGlmICgnMCcgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ2InKSB7XG4gICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAyKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHtcbiAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgOCk7XG5cbiAgfVxuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUludCh2LCAxMCkpO1xuICAgIH0pO1xuXG4gICAgdmFsdWUgPSAwO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IChkICogYmFzZSk7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcblxuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqZWN0KSB7XG4gIHJldHVybiAoJ1tvYmplY3QgTnVtYmVyXScgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpKSAmJlxuICAgICAgICAgKDAgPT09IG9iamVjdCAlIDEgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6aW50Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxJbnRlZ2VyLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxJbnRlZ2VyLFxuICBwcmVkaWNhdGU6IGlzSW50ZWdlcixcbiAgcmVwcmVzZW50OiB7XG4gICAgYmluYXJ5OiAgICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcwYicgKyBvYmplY3QudG9TdHJpbmcoMik7IH0sXG4gICAgb2N0YWw6ICAgICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcwJyAgKyBvYmplY3QudG9TdHJpbmcoOCk7IH0sXG4gICAgZGVjaW1hbDogICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICAgICAgICBvYmplY3QudG9TdHJpbmcoMTApOyB9LFxuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMHgnICsgb2JqZWN0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2RlY2ltYWwnLFxuICBzdHlsZUFsaWFzZXM6IHtcbiAgICBiaW5hcnk6ICAgICAgWyAyLCAgJ2JpbicgXSxcbiAgICBvY3RhbDogICAgICAgWyA4LCAgJ29jdCcgXSxcbiAgICBkZWNpbWFsOiAgICAgWyAxMCwgJ2RlYycgXSxcbiAgICBoZXhhZGVjaW1hbDogWyAxNiwgJ2hleCcgXVxuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVzcHJpbWE7XG5cbi8vIEJyb3dzZXJpZmllZCB2ZXJzaW9uIGRvZXMgbm90IGhhdmUgZXNwcmltYVxuLy9cbi8vIDEuIEZvciBub2RlLmpzIGp1c3QgcmVxdWlyZSBtb2R1bGUgYXMgZGVwc1xuLy8gMi4gRm9yIGJyb3dzZXIgdHJ5IHRvIHJlcXVpcmUgbXVkdWxlIHZpYSBleHRlcm5hbCBBTUQgc3lzdGVtLlxuLy8gICAgSWYgbm90IGZvdW5kIC0gdHJ5IHRvIGZhbGxiYWNrIHRvIHdpbmRvdy5lc3ByaW1hLiBJZiBub3Rcbi8vICAgIGZvdW5kIHRvbyAtIHRoZW4gZmFpbCB0byBwYXJzZS5cbi8vXG50cnkge1xuICBlc3ByaW1hID0gcmVxdWlyZSgnZXNwcmltYScpO1xufSBjYXRjaCAoXykge1xuICAvKmdsb2JhbCB3aW5kb3cgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IGVzcHJpbWEgPSB3aW5kb3cuZXNwcmltYTsgfVxufVxuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbihkYXRhKSB7XG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxuICAgICAgICBwYXJhbXMgPSBbXSxcbiAgICAgICAgYm9keTtcblxuICAgIGlmICgnUHJvZ3JhbScgICAgICAgICAgICAgIT09IGFzdC50eXBlICAgICAgICAgfHxcbiAgICAgICAgMSAgICAgICAgICAgICAgICAgICAgICE9PSBhc3QuYm9keS5sZW5ndGggIHx8XG4gICAgICAgICdFeHByZXNzaW9uU3RhdGVtZW50JyAhPT0gYXN0LmJvZHlbMF0udHlwZSB8fFxuICAgICAgICAnRnVuY3Rpb25FeHByZXNzaW9uJyAgIT09IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgLypqc2xpbnQgZXZpbDp0cnVlKi9cblxuICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxuICAgICAgcGFyYW1zID0gW10sXG4gICAgICBib2R5O1xuXG4gIGlmICgnUHJvZ3JhbScgICAgICAgICAgICAgIT09IGFzdC50eXBlICAgICAgICAgfHxcbiAgICAgIDEgICAgICAgICAgICAgICAgICAgICAhPT0gYXN0LmJvZHkubGVuZ3RoICB8fFxuICAgICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICE9PSBhc3QuYm9keVswXS50eXBlIHx8XG4gICAgICAnRnVuY3Rpb25FeHByZXNzaW9uJyAgIT09IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcGFyYW1zLnB1c2gocGFyYW0ubmFtZSk7XG4gIH0pO1xuXG4gIGJvZHkgPSBhc3QuYm9keVswXS5leHByZXNzaW9uLmJvZHkucmFuZ2U7XG5cbiAgLy8gRXNwcmltYSdzIHJhbmdlcyBpbmNsdWRlIHRoZSBmaXJzdCAneycgYW5kIHRoZSBsYXN0ICd9JyBjaGFyYWN0ZXJzIG9uXG4gIC8vIGZ1bmN0aW9uIGV4cHJlc3Npb25zLiBTbyBjdXQgdGhlbSBvdXQuXG4gIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCBzb3VyY2Uuc2xpY2UoYm9keVswXSsxLCBib2R5WzFdLTEpKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiAnW29iamVjdCBGdW5jdGlvbl0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvZnVuY3Rpb24nLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdEZ1bmN0aW9uLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRGdW5jdGlvbixcbiAgcHJlZGljYXRlOiBpc0Z1bmN0aW9uLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRGdW5jdGlvblxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCAgID0gL1xcLyhbZ2ltXSopJC8uZXhlYyhkYXRhKSxcbiAgICAgIG1vZGlmaWVycyA9ICcnO1xuXG4gIC8vIGlmIHJlZ2V4cCBzdGFydHMgd2l0aCAnLycgaXQgY2FuIGhhdmUgbW9kaWZpZXJzIGFuZCBtdXN0IGJlIHByb3Blcmx5IGNsb3NlZFxuICAvLyBgL2Zvby9naW1gIC0gbW9kaWZpZXJzIHRhaWwgY2FuIGJlIG1heGltdW0gMyBjaGFyc1xuICBpZiAoJy8nID09PSByZWdleHBbMF0pIHtcbiAgICBpZiAodGFpbCkge1xuICAgICAgbW9kaWZpZXJzID0gdGFpbFsxXTtcbiAgICB9XG5cbiAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA+IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLy8gaWYgZXhwcmVzc2lvbiBzdGFydHMgd2l0aCAvLCBpcyBzaG91bGQgYmUgcHJvcGVybHkgdGVybWluYXRlZFxuICAgIGlmIChyZWdleHBbcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxXSAhPT0gJy8nKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgcmVnZXhwID0gcmVnZXhwLnNsaWNlKDEsIHJlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBkdW1teSA9IG5ldyBSZWdFeHAocmVnZXhwLCBtb2RpZmllcnMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgdmFyIHJlZ2V4cCA9IGRhdGEsXG4gICAgICB0YWlsICAgPSAvXFwvKFtnaW1dKikkLy5leGVjKGRhdGEpLFxuICAgICAgbW9kaWZpZXJzID0gJyc7XG5cbiAgLy8gYC9mb28vZ2ltYCAtIHRhaWwgY2FuIGJlIG1heGltdW0gNCBjaGFyc1xuICBpZiAoJy8nID09PSByZWdleHBbMF0pIHtcbiAgICBpZiAodGFpbCkge1xuICAgICAgbW9kaWZpZXJzID0gdGFpbFsxXTtcbiAgICB9XG4gICAgcmVnZXhwID0gcmVnZXhwLnNsaWNlKDEsIHJlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIG1vZGlmaWVycyk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRSZWdFeHAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnLycgKyBvYmplY3Quc291cmNlICsgJy8nO1xuXG4gIGlmIChvYmplY3QuZ2xvYmFsKSB7XG4gICAgcmVzdWx0ICs9ICdnJztcbiAgfVxuXG4gIGlmIChvYmplY3QubXVsdGlsaW5lKSB7XG4gICAgcmVzdWx0ICs9ICdtJztcbiAgfVxuXG4gIGlmIChvYmplY3QuaWdub3JlQ2FzZSkge1xuICAgIHJlc3VsdCArPSAnaSc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IFJlZ0V4cF0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvcmVnZXhwJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cCxcbiAgcHJlZGljYXRlOiBpc1JlZ0V4cCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmplY3QpIHtcbiAgcmV0dXJuICd1bmRlZmluZWQnID09PSB0eXBlb2Ygb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy91bmRlZmluZWQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBwcmVkaWNhdGU6IGlzVW5kZWZpbmVkLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWRcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywge1xuICBraW5kOiAnbWFwcGluZydcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiAnPDwnID09PSBkYXRhO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTWVyZ2UsXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTnVsbChkYXRhKSB7XG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gMSAmJiBkYXRhID09PSAnficpIHx8XG4gICAgICAgICAobWF4ID09PSA0ICYmIChkYXRhID09PSAnbnVsbCcgfHwgZGF0YSA9PT0gJ051bGwnIHx8IGRhdGEgPT09ICdOVUxMJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChvYmplY3QpIHtcbiAgcmV0dXJuIG51bGwgPT09IG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ34nOyAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ251bGwnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05VTEwnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ051bGwnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgcGFpckhhc0tleSA9IGZhbHNlO1xuXG4gICAgaWYgKCdbb2JqZWN0IE9iamVjdF0nICE9PSBfdG9TdHJpbmcuY2FsbChwYWlyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSB7XG4gICAgICAgICAgcGFpckhhc0tleSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKC0xID09PSBvYmplY3RLZXlzLmluZGV4T2YocGFpcktleSkpIHtcbiAgICAgIG9iamVjdEtleXMucHVzaChwYWlyS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE9tYXBcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoJ1tvYmplY3QgT2JqZWN0XScgIT09IF90b1N0cmluZy5jYWxsKHBhaXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgaWYgKDEgIT09IGtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxQYWlycyhkYXRhKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFBhaXJzLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxQYWlyc1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZSdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KGRhdGEpIHtcbiAgdmFyIGtleSwgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBpZiAobnVsbCAhPT0gb2JqZWN0W2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxTZXRcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywge1xuICBraW5kOiAnc2NhbGFyJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcbiAgJyg/Oig/OltUdF18WyBcXFxcdF0rKScgICAgICAgICAgICAgICsgLy8gLi4uXG4gICcoWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNF0gaG91clxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzZdIHNlY29uZFxuICAnKD86XFxcXC4oWzAtOV0qKSk/JyAgICAgICAgICAgICAgICAgKyAvLyBbN10gZnJhY3Rpb25cbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuICAnKD86OihbMC05XVswLTldKSk/KSk/KT8kJyk7ICAgICAgICAgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICB2YXIgbWF0Y2gsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbiA9IDAsXG4gICAgICBkZWx0YSA9IG51bGwsIHR6X2hvdXIsIHR6X21pbnV0ZSwgZGF0ZTtcblxuICBtYXRjaCA9IFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpO1xuXG4gIGlmIChudWxsID09PSBtYXRjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24gPSAwLFxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGU7XG5cbiAgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcblxuICBpZiAobnVsbCA9PT0gbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGUgcmVzb2x2ZSBlcnJvcicpO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFsxXSB5ZWFyIFsyXSBtb250aCBbM10gZGF5XG5cbiAgeWVhciA9ICsobWF0Y2hbMV0pO1xuICBtb250aCA9ICsobWF0Y2hbMl0pIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxuICBkYXkgPSArKG1hdGNoWzNdKTtcblxuICBpZiAoIW1hdGNoWzRdKSB7IC8vIG5vIGhvdXJcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs0XSBob3VyIFs1XSBtaW51dGUgWzZdIHNlY29uZCBbN10gZnJhY3Rpb25cblxuICBob3VyID0gKyhtYXRjaFs0XSk7XG4gIG1pbnV0ZSA9ICsobWF0Y2hbNV0pO1xuICBzZWNvbmQgPSArKG1hdGNoWzZdKTtcblxuICBpZiAobWF0Y2hbN10pIHtcbiAgICBmcmFjdGlvbiA9IG1hdGNoWzddLnNsaWNlKDAsIDMpO1xuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCAzKSB7IC8vIG1pbGxpLXNlY29uZHNcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICB9XG4gICAgZnJhY3Rpb24gPSArZnJhY3Rpb247XG4gIH1cblxuICAvLyBtYXRjaDogWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91ciBbMTFdIHR6X21pbnV0ZVxuXG4gIGlmIChtYXRjaFs5XSkge1xuICAgIHR6X2hvdXIgPSArKG1hdGNoWzEwXSk7XG4gICAgdHpfbWludXRlID0gKyhtYXRjaFsxMV0gfHwgMCk7XG4gICAgZGVsdGEgPSAodHpfaG91ciAqIDYwICsgdHpfbWludXRlKSAqIDYwMDAwOyAvLyBkZWx0YSBpbiBtaWxpLXNlY29uZHNcbiAgICBpZiAoJy0nID09PSBtYXRjaFs5XSkge1xuICAgICAgZGVsdGEgPSAtZGVsdGE7XG4gICAgfVxuICB9XG5cbiAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbikpO1xuXG4gIGlmIChkZWx0YSkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIGRlbHRhKTtcbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sVGltZXN0YW1wKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sVGltZXN0YW1wLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAsXG4gIGluc3RhbmNlT2Y6IERhdGUsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbFRpbWVzdGFtcFxufSk7XG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTEgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLypqc2xpbnQgYml0d2lzZTp0cnVlIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIGVzcHJpbWE6dHJ1ZSwgZGVmaW5lOnRydWUsIGV4cG9ydHM6dHJ1ZSwgd2luZG93OiB0cnVlLFxudGhyb3dFcnJvcjogdHJ1ZSwgY3JlYXRlTGl0ZXJhbDogdHJ1ZSwgZ2VuZXJhdGVTdGF0ZW1lbnQ6IHRydWUsXG5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uOiB0cnVlLCBwYXJzZUJsb2NrOiB0cnVlLCBwYXJzZUV4cHJlc3Npb246IHRydWUsXG5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb246IHRydWUsIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uOiB0cnVlLFxucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzOiB0cnVlLCBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcjogdHJ1ZSxcbnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbjogdHJ1ZSxcbnBhcnNlU3RhdGVtZW50OiB0cnVlLCBwYXJzZVNvdXJjZUVsZW1lbnQ6IHRydWUgKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLFxuICAgIC8vIFJoaW5vLCBhbmQgcGxhaW4gYnJvd3NlciBsb2FkaW5nLlxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoKHJvb3QuZXNwcmltYSA9IHt9KSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBUb2tlbixcbiAgICAgICAgVG9rZW5OYW1lLFxuICAgICAgICBTeW50YXgsXG4gICAgICAgIFByb3BlcnR5S2luZCxcbiAgICAgICAgTWVzc2FnZXMsXG4gICAgICAgIFJlZ2V4LFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHN0cmljdCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxpbmVOdW1iZXIsXG4gICAgICAgIGxpbmVTdGFydCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBleHRyYTtcblxuICAgIFRva2VuID0ge1xuICAgICAgICBCb29sZWFuTGl0ZXJhbDogMSxcbiAgICAgICAgRU9GOiAyLFxuICAgICAgICBJZGVudGlmaWVyOiAzLFxuICAgICAgICBLZXl3b3JkOiA0LFxuICAgICAgICBOdWxsTGl0ZXJhbDogNSxcbiAgICAgICAgTnVtZXJpY0xpdGVyYWw6IDYsXG4gICAgICAgIFB1bmN0dWF0b3I6IDcsXG4gICAgICAgIFN0cmluZ0xpdGVyYWw6IDhcbiAgICB9O1xuXG4gICAgVG9rZW5OYW1lID0ge307XG4gICAgVG9rZW5OYW1lW1Rva2VuLkJvb2xlYW5MaXRlcmFsXSA9ICdCb29sZWFuJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uRU9GXSA9ICc8ZW5kPic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLklkZW50aWZpZXJdID0gJ0lkZW50aWZpZXInO1xuICAgIFRva2VuTmFtZVtUb2tlbi5LZXl3b3JkXSA9ICdLZXl3b3JkJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uTnVsbExpdGVyYWxdID0gJ051bGwnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5OdW1lcmljTGl0ZXJhbF0gPSAnTnVtZXJpYyc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlB1bmN0dWF0b3JdID0gJ1B1bmN0dWF0b3InO1xuICAgIFRva2VuTmFtZVtUb2tlbi5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuXG4gICAgU3ludGF4ID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6ICdCcmVha1N0YXRlbWVudCcsXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXG4gICAgICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgSWZTdGF0ZW1lbnQ6ICdJZlN0YXRlbWVudCcsXG4gICAgICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxuICAgICAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcbiAgICAgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnXG4gICAgfTtcblxuICAgIFByb3BlcnR5S2luZCA9IHtcbiAgICAgICAgRGF0YTogMSxcbiAgICAgICAgR2V0OiAyLFxuICAgICAgICBTZXQ6IDRcbiAgICB9O1xuXG4gICAgLy8gRXJyb3IgbWVzc2FnZXMgc2hvdWxkIGJlIGlkZW50aWNhbCB0byBWOC5cbiAgICBNZXNzYWdlcyA9IHtcbiAgICAgICAgVW5leHBlY3RlZFRva2VuOiAgJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgICAgICBVbmV4cGVjdGVkTnVtYmVyOiAgJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcbiAgICAgICAgVW5leHBlY3RlZFN0cmluZzogICdVbmV4cGVjdGVkIHN0cmluZycsXG4gICAgICAgIFVuZXhwZWN0ZWRJZGVudGlmaWVyOiAgJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxuICAgICAgICBVbmV4cGVjdGVkRU9TOiAgJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcbiAgICAgICAgTmV3bGluZUFmdGVyVGhyb3c6ICAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93JyxcbiAgICAgICAgSW52YWxpZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcbiAgICAgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAgJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxuICAgICAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAgJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXG4gICAgICAgIEludmFsaWRMSFNJbkZvckluOiAgJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcbiAgICAgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcbiAgICAgICAgTm9DYXRjaE9yRmluYWxseTogICdNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5JyxcbiAgICAgICAgVW5rbm93bkxhYmVsOiAnVW5kZWZpbmVkIGxhYmVsIFxcJyUwXFwnJyxcbiAgICAgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxuICAgICAgICBJbGxlZ2FsQ29udGludWU6ICdJbGxlZ2FsIGNvbnRpbnVlIHN0YXRlbWVudCcsXG4gICAgICAgIElsbGVnYWxCcmVhazogJ0lsbGVnYWwgYnJlYWsgc3RhdGVtZW50JyxcbiAgICAgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXG4gICAgICAgIFN0cmljdE1vZGVXaXRoOiAgJ1N0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnQnLFxuICAgICAgICBTdHJpY3RDYXRjaFZhcmlhYmxlOiAgJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RWYXJOYW1lOiAgJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFBhcmFtTmFtZTogICdQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFBhcmFtRHVwZTogJ1N0cmljdCBtb2RlIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzJyxcbiAgICAgICAgU3RyaWN0RnVuY3Rpb25OYW1lOiAgJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgICAgU3RyaWN0RGVsZXRlOiAgJ0RlbGV0ZSBvZiBhbiB1bnF1YWxpZmllZCBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLicsXG4gICAgICAgIFN0cmljdER1cGxpY2F0ZVByb3BlcnR5OiAgJ0R1cGxpY2F0ZSBkYXRhIHByb3BlcnR5IGluIG9iamVjdCBsaXRlcmFsIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgQWNjZXNzb3JEYXRhUHJvcGVydHk6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIGRhdGEgYW5kIGFjY2Vzc29yIHByb3BlcnR5IHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICAgIEFjY2Vzc29yR2V0U2V0OiAgJ09iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBtdWx0aXBsZSBnZXQvc2V0IGFjY2Vzc29ycyB3aXRoIHRoZSBzYW1lIG5hbWUnLFxuICAgICAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAgJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBTdHJpY3RMSFNQb3N0Zml4OiAgJ1Bvc3RmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdExIU1ByZWZpeDogICdQcmVmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFJlc2VydmVkV29yZDogICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnXG4gICAgfTtcblxuICAgIC8vIFNlZSBhbHNvIHRvb2xzL2dlbmVyYXRlLXVuaWNvZGUtcmVnZXgucHkuXG4gICAgUmVnZXggPSB7XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiBuZXcgUmVnRXhwKCdbXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNdJyksXG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NjlcXHUwNjZlLVxcdTA2ZDNcXHUwNmQ1LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZThcXHUwNmVhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMC1cXHUwNzRhXFx1MDc0ZC1cXHUwN2IxXFx1MDdjMC1cXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgyZFxcdTA4NDAtXFx1MDg1YlxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTgxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJjLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZVxcdTA5ZDdcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllM1xcdTA5ZTYtXFx1MDlmMVxcdTBhMDEtXFx1MGEwM1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTY2LVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmMtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZDBcXHUwYWUwLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzYy1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI3MVxcdTBiODJcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDBcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZC1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzU4XFx1MGM1OVxcdTBjNjAtXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiYy1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2RlXFx1MGNlMC1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGNmMVxcdTBjZjJcXHUwZDAyXFx1MGQwM1xcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2QtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZVxcdTBkNTdcXHUwZDYwLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDdhLVxcdTBkN2ZcXHUwZDgyXFx1MGQ4M1xcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUwMS1cXHUwZTNhXFx1MGU0MC1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjlcXHUwZWJiLVxcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZS1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5ZFxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzVkLVxcdTEzNWZcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdkM1xcdTE3ZDdcXHUxN2RjXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExYlxcdTFhMjAtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYTdcXHUxYjAwLVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiZjNcXHUxYzAwLVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzRkLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZjZcXHUxZDAwLVxcdTFkZTZcXHUxZGZjLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ3Zi1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmRlMC1cXHUyZGZmXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyZlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlhXFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjJiXFx1YTY0MC1cXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY3Zi1cXHVhNjk3XFx1YTY5Zi1cXHVhNmYxXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODI3XFx1YTg0MC1cXHVhODczXFx1YTg4MC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGY3XFx1YThmYlxcdWE5MDAtXFx1YTkyZFxcdWE5MzAtXFx1YTk1M1xcdWE5NjAtXFx1YTk3Y1xcdWE5ODAtXFx1YTljMFxcdWE5Y2YtXFx1YTlkOVxcdWFhMDAtXFx1YWEzNlxcdWFhNDAtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTdiXFx1YWE4MC1cXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVmXFx1YWFmMi1cXHVhYWY2XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYxMC1cXHVmZjE5XFx1ZmYyMS1cXHVmZjNhXFx1ZmYzZlxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY10nKVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgLy8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XG4gICAgLy8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXG4gICAgLy8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cblxuICAgIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbGljZVNvdXJjZShmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gc291cmNlLnNsaWNlKGZyb20sIHRvKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mICdlc3ByaW1hJ1swXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2xpY2VTb3VyY2UgPSBmdW5jdGlvbiBzbGljZUFycmF5U291cmNlKGZyb20sIHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnNsaWNlKGZyb20sIHRvKS5qb2luKCcnKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3ODknLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWZBQkNERUYnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG5cbiAgICAvLyA3LjIgV2hpdGUgU3BhY2VcblxuICAgIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAnICcpIHx8IChjaCA9PT0gJ1xcdTAwMDknKSB8fCAoY2ggPT09ICdcXHUwMDBCJykgfHxcbiAgICAgICAgICAgIChjaCA9PT0gJ1xcdTAwMEMnKSB8fCAoY2ggPT09ICdcXHUwMEEwJykgfHxcbiAgICAgICAgICAgIChjaC5jaGFyQ29kZUF0KDApID49IDB4MTY4MCAmJlxuICAgICAgICAgICAgICdcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1RkVGRicuaW5kZXhPZihjaCkgPj0gMCk7XG4gICAgfVxuXG4gICAgLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuICAgIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHInIHx8IGNoID09PSAnXFx1MjAyOCcgfHwgY2ggPT09ICdcXHUyMDI5Jyk7XG4gICAgfVxuXG4gICAgLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAnJCcpIHx8IChjaCA9PT0gJ18nKSB8fCAoY2ggPT09ICdcXFxcJykgfHxcbiAgICAgICAgICAgIChjaCA+PSAnYScgJiYgY2ggPD0gJ3onKSB8fCAoY2ggPj0gJ0EnICYmIGNoIDw9ICdaJykgfHxcbiAgICAgICAgICAgICgoY2guY2hhckNvZGVBdCgwKSA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGNoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAnJCcpIHx8IChjaCA9PT0gJ18nKSB8fCAoY2ggPT09ICdcXFxcJykgfHxcbiAgICAgICAgICAgIChjaCA+PSAnYScgJiYgY2ggPD0gJ3onKSB8fCAoY2ggPj0gJ0EnICYmIGNoIDw9ICdaJykgfHxcbiAgICAgICAgICAgICgoY2ggPj0gJzAnKSAmJiAoY2ggPD0gJzknKSkgfHxcbiAgICAgICAgICAgICgoY2guY2hhckNvZGVBdCgwKSA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoY2gpKTtcbiAgICB9XG5cbiAgICAvLyA3LjYuMS4yIEZ1dHVyZSBSZXNlcnZlZCBXb3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNGdXR1cmVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuXG4gICAgICAgIC8vIEZ1dHVyZSByZXNlcnZlZCB3b3Jkcy5cbiAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBjYXNlICdlbnVtJzpcbiAgICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgICAgY2FzZSAnZXh0ZW5kcyc6XG4gICAgICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICAgIGNhc2UgJ3N1cGVyJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG5cbiAgICAgICAgLy8gU3RyaWN0IE1vZGUgcmVzZXJ2ZWQgd29yZHMuXG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzdHJpY3RlZFdvcmQoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIC8vIDcuNi4xLjEgS2V5d29yZHNcblxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZChpZCkge1xuICAgICAgICB2YXIga2V5d29yZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBrZXl3b3JkID0gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAga2V5d29yZCA9IChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8IChpZCA9PT0gJ3RyeScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fCAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fCAoaWQgPT09ICd0aHJvdycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fCAoaWQgPT09ICdzd2l0Y2gnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBrZXl3b3JkID0gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBrZXl3b3JkID0gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXl3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgLy8gRnV0dXJlIHJlc2VydmVkIHdvcmRzLlxuICAgICAgICAvLyAnY29uc3QnIGlzIHNwZWNpYWxpemVkIGFzIEtleXdvcmQgaW4gVjguXG4gICAgICAgIGNhc2UgJ2NvbnN0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIEZvciBjb21wYXRpYmxpdHkgdG8gU3BpZGVyTW9ua2V5IGFuZCBFUy5uZXh0XG4gICAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0Z1dHVyZVJlc2VydmVkV29yZChpZCk7XG4gICAgfVxuXG4gICAgLy8gNy40IENvbW1lbnRzXG5cbiAgICBmdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIGNoLCBibG9ja0NvbW1lbnQsIGxpbmVDb21tZW50O1xuXG4gICAgICAgIGJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICBsaW5lQ29tbWVudCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAobGluZUNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2tDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4ICsgMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgbGluZUNvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBibG9ja0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAgJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XG4gICAgICAgIHZhciBpLCBsZW4sIGNoLCBjb2RlID0gMDtcblxuICAgICAgICBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgICAgdmFyIGNoLCBzdGFydCwgaWQsIHJlc3RvcmU7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSAhPT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlkID0gY2g7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICBpZCA9ICd1JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gIT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgIGlkICs9ICd1JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLklkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzS2V5d29yZChpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uS2V5d29yZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyA3LjguMSBOdWxsIExpdGVyYWxzXG5cbiAgICAgICAgaWYgKGlkID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVsbExpdGVyYWwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNy44LjIgQm9vbGVhbiBMaXRlcmFsc1xuXG4gICAgICAgIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLkJvb2xlYW5MaXRlcmFsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBUb2tlbi5JZGVudGlmaWVyLFxuICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNy43IFB1bmN0dWF0b3JzXG5cbiAgICBmdW5jdGlvbiBzY2FuUHVuY3R1YXRvcigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5kZXgsXG4gICAgICAgICAgICBjaDEgPSBzb3VyY2VbaW5kZXhdLFxuICAgICAgICAgICAgY2gyLFxuICAgICAgICAgICAgY2gzLFxuICAgICAgICAgICAgY2g0O1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuXG4gICAgICAgIGlmIChjaDEgPT09ICc7JyB8fCBjaDEgPT09ICd7JyB8fCBjaDEgPT09ICd9Jykge1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2gxLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJywnIHx8IGNoMSA9PT0gJygnIHx8IGNoMSA9PT0gJyknKSB7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaDEsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb3QgKC4pIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxuICAgICAgICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXG5cbiAgICAgICAgY2gyID0gc291cmNlW2luZGV4ICsgMV07XG4gICAgICAgIGlmIChjaDEgPT09ICcuJyAmJiAhaXNEZWNpbWFsRGlnaXQoY2gyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2VbaW5kZXgrK10sXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQZWVrIG1vcmUgY2hhcmFjdGVycy5cblxuICAgICAgICBjaDMgPSBzb3VyY2VbaW5kZXggKyAyXTtcbiAgICAgICAgY2g0ID0gc291cmNlW2luZGV4ICsgM107XG5cbiAgICAgICAgLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvcjogPj4+PVxuXG4gICAgICAgIGlmIChjaDEgPT09ICc+JyAmJiBjaDIgPT09ICc+JyAmJiBjaDMgPT09ICc+Jykge1xuICAgICAgICAgICAgaWYgKGNoNCA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJz4+Pj0nLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJz0nICYmIGNoMiA9PT0gJz0nICYmIGNoMyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPT09JyxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaDEgPT09ICchJyAmJiBjaDIgPT09ICc9JyAmJiBjaDMgPT09ICc9Jykge1xuICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogJyE9PScsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2gxID09PSAnPicgJiYgY2gyID09PSAnPicgJiYgY2gzID09PSAnPicpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc+Pj4nLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJzwnICYmIGNoMiA9PT0gJzwnICYmIGNoMyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPDw9JyxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaDEgPT09ICc+JyAmJiBjaDIgPT09ICc+JyAmJiBjaDMgPT09ICc9Jykge1xuICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz4+PScsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLWNoYXJhY3RlciBwdW5jdHVhdG9yczogPD0gPj0gPT0gIT0gKysgLS0gPDwgPj4gJiYgfHxcbiAgICAgICAgLy8gKz0gLT0gKj0gJT0gJj0gfD0gXj0gLz1cblxuICAgICAgICBpZiAoY2gyID09PSAnPScpIHtcbiAgICAgICAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKGNoMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoMSArIGNoMixcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2gxID09PSBjaDIgJiYgKCcrLTw+JnwnLmluZGV4T2YoY2gxKSA+PSAwKSkge1xuICAgICAgICAgICAgaWYgKCcrLTw+JnwnLmluZGV4T2YoY2gyKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2gxICsgY2gyLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZW1haW5pbmcgMS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG5cbiAgICAgICAgaWYgKCdbXTw+Ky0qJSZ8XiF+Pzo9LycuaW5kZXhPZihjaDEpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlW2luZGV4KytdLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gNy44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IChjaCA9PT0gJy4nKSxcbiAgICAgICAgICAgICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICBudW1iZXIgPSAnJztcbiAgICAgICAgaWYgKGNoICE9PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlciA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcblxuICAgICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxuICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWJlci5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSAweFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNoKSB8fCBpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bWJlciwgOCksXG4gICAgICAgICAgICAgICAgICAgICAgICBvY3RhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJyBzdWNoIGFzICcwOScgaXMgaWxsZWdhbC5cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICghaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2ggPSAnY2hhcmFjdGVyICcgKyBjaDtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gJzxlbmQ+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDcuOC40IFN0cmluZyBMaXRlcmFsc1xuXG4gICAgZnVuY3Rpb24gc2NhblN0cmluZ0xpdGVyYWwoKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJywgcXVvdGUsIHN0YXJ0LCBjaCwgY29kZSwgdW5lc2NhcGVkLCByZXN0b3JlLCBvY3RhbCA9IGZhbHNlO1xuXG4gICAgICAgIHF1b3RlID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLFxuICAgICAgICAgICAgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICsraW5kZXg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkID0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx4MEInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocXVvdGUgIT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uU3RyaW5nTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgICBvY3RhbDogb2N0YWwsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuUmVnRXhwKCkge1xuICAgICAgICB2YXIgc3RyLCBjaCwgc3RhcnQsIHBhdHRlcm4sIGZsYWdzLCB2YWx1ZSwgY2xhc3NNYXJrZXIgPSBmYWxzZSwgcmVzdG9yZSwgdGVybWluYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XG4gICAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAvLyBFQ01BLTI2MiA3LjguNVxuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICBwYXR0ZXJuID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XG5cbiAgICAgICAgZmxhZ3MgPSAnJztcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcmVzdG9yZSA8IGluZGV4OyArK3Jlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc291cmNlW3Jlc3RvcmVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpdGVyYWw6IHN0cixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgfHxcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQgfHxcbiAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgICB2YXIgY2gsIHRva2VuO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5FT0YsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW2luZGV4LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbiA9IHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICAgICAgaWYgKGNoID09PSAnXFwnJyB8fCBjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgcmV0dXJuIHNjYW5TdHJpbmdMaXRlcmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICcuJyB8fCBpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2VuID0gc2NhbklkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcblxuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpbmRleCA9IGJ1ZmZlci5yYW5nZVsxXTtcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBidWZmZXIubGluZU51bWJlcjtcbiAgICAgICAgICAgIGxpbmVTdGFydCA9IGJ1ZmZlci5saW5lU3RhcnQ7XG4gICAgICAgICAgICB0b2tlbiA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gYWR2YW5jZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb2thaGVhZCgpIHtcbiAgICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQ7XG5cbiAgICAgICAgaWYgKGJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGJ1ZmZlciA9IGFkdmFuY2UoKTtcbiAgICAgICAgaW5kZXggPSBwb3M7XG4gICAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgICBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgbGluZSB0ZXJtaW5hdG9yIGJlZm9yZSB0aGUgbmV4dCB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHBlZWtMaW5lVGVybWluYXRvcigpIHtcbiAgICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQsIGZvdW5kO1xuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIGZvdW5kID0gbGluZU51bWJlciAhPT0gbGluZTtcbiAgICAgICAgaW5kZXggPSBwb3M7XG4gICAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgICBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKHRva2VuLCBtZXNzYWdlRm9ybWF0KSB7XG4gICAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8lKFxcZCkvZyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2luZGV4XSB8fCAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4ubGluZU51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdMaW5lICcgKyB0b2tlbi5saW5lTnVtYmVyICsgJzogJyArIG1zZyk7XG4gICAgICAgICAgICBlcnJvci5pbmRleCA9IHRva2VuLnJhbmdlWzBdO1xuICAgICAgICAgICAgZXJyb3IubGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICAgICAgICBlcnJvci5jb2x1bW4gPSB0b2tlbi5yYW5nZVswXSAtIGxpbmVTdGFydCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgbGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgICAgZXJyb3IuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgZXJyb3IuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvclRvbGVyYW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3dFcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICAgIGZ1bmN0aW9uIHRocm93VW5leHBlY3RlZCh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkRU9TKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZElkZW50aWZpZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1dHVyZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJvb2xlYW5MaXRlcmFsLCBOdWxsTGl0ZXJhbCwgb3IgUHVuY3R1YXRvci5cbiAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICAgIGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQgfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cblxuICAgIGZ1bmN0aW9uIG1hdGNoKHZhbHVlKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICAgIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiB0b2tlbi52YWx1ZSA9PT0ga2V5d29yZDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBpcyBhbiBhc3NpZ25tZW50IG9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBtYXRjaEFzc2lnbigpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkKCksXG4gICAgICAgICAgICBvcCA9IHRva2VuLnZhbHVlO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy89JyB8fFxuICAgICAgICAgICAgb3AgPT09ICclPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJy09JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPj4+PScgfHxcbiAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxuICAgICAgICAgICAgb3AgPT09ICd8PSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBsaW5lO1xuXG4gICAgICAgIC8vIENhdGNoIHRoZSB2ZXJ5IGNvbW1vbiBjYXNlIGZpcnN0LlxuICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJzsnKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBpZiAobGluZU51bWJlciAhPT0gbGluZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLkVPRiAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHByb3ZpZGVkIGV4cHJlc3Npb24gaXMgTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuXG4gICAgZnVuY3Rpb24gaXNMZWZ0SGFuZFNpZGUoZXhwcikge1xuICAgICAgICByZXR1cm4gZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciB8fCBleHByLnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgIH1cblxuICAgIC8vIDExLjEuNCBBcnJheSBJbml0aWFsaXNlclxuXG4gICAgZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQXJyYXlFeHByZXNzaW9uLFxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTEuMS41IE9iamVjdCBJbml0aWFsaXNlclxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtLCBmaXJzdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QsIGJvZHk7XG5cbiAgICAgICAgcHJldmlvdXNTdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIGJvZHkgPSBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcbiAgICAgICAgaWYgKGZpcnN0ICYmIHN0cmljdCAmJiBpc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtWzBdLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoZmlyc3QsIE1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW0sXG4gICAgICAgICAgICBkZWZhdWx0czogW10sXG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgICAgIGdlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgZnJvbSBwYXJzZU9iamVjdFByb3BlcnR5KCksIHdoZXJlXG4gICAgICAgIC8vIEVPRiBhbmQgUHVuY3R1YXRvciB0b2tlbnMgYXJlIGFscmVhZHkgZmlsdGVyZWQgb3V0LlxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpdGVyYWwodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgbmFtZTogdG9rZW4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5KCkge1xuICAgICAgICB2YXIgdG9rZW4sIGtleSwgaWQsIHBhcmFtO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcblxuICAgICAgICAgICAgaWQgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG5cbiAgICAgICAgICAgIC8vIFByb3BlcnR5IEFzc2lnbm1lbnQ6IEdldHRlciBhbmQgU2V0dGVyLlxuXG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnICYmICFtYXRjaCgnOicpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnKCcpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZVByb3BlcnR5RnVuY3Rpb24oW10pLFxuICAgICAgICAgICAgICAgICAgICBraW5kOiAnZ2V0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiAhbWF0Y2goJzonKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdzZXQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0gPSBbIHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCkgXTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KCcpJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZVByb3BlcnR5RnVuY3Rpb24ocGFyYW0sIHRva2VuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdzZXQnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGtleTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdpbml0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAga2luZDogJ2luaXQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXSwgcHJvcGVydHksIG5hbWUsIGtpbmQsIG1hcCA9IHt9LCB0b1N0cmluZyA9IFN0cmluZztcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eSgpO1xuXG4gICAgICAgICAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHByb3BlcnR5LmtleS5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gdG9TdHJpbmcocHJvcGVydHkua2V5LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtpbmQgPSAocHJvcGVydHkua2luZCA9PT0gJ2luaXQnKSA/IFByb3BlcnR5S2luZC5EYXRhIDogKHByb3BlcnR5LmtpbmQgPT09ICdnZXQnKSA/IFByb3BlcnR5S2luZC5HZXQgOiBQcm9wZXJ0eUtpbmQuU2V0O1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcFtuYW1lXSA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCAhPT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXBbbmFtZV0gJiBraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yR2V0U2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBbbmFtZV0gfD0ga2luZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwW25hbWVdID0ga2luZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk9iamVjdEV4cHJlc3Npb24sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTEuMS42IFRoZSBHcm91cGluZyBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VHcm91cEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIDExLjEgUHJpbWFyeSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkKCksXG4gICAgICAgICAgICB0eXBlID0gdG9rZW4udHlwZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBuYW1lOiBsZXgoKS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpdGVyYWwobGV4KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5UaGlzRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMaXRlcmFsKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbCkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXBFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpdGVyYWwoc2NhblJlZ0V4cCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xuICAgIH1cblxuICAgIC8vIDExLjIgTGVmdC1IYW5kLVNpZGUgRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICBpZiAoIWlzSWRlbnRpZmllck5hbWUodG9rZW4pKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgbmFtZTogdG9rZW4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgICBleHBlY3QoJy4nKTtcblxuICAgICAgICByZXR1cm4gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb21wdXRlZE1lbWJlcigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTmV3RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnbmV3Jyk7XG5cbiAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxuICAgICAgICAgICAgY2FsbGVlOiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICdhcmd1bWVudHMnOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICBleHByWydhcmd1bWVudHMnXSA9IHBhcnNlQXJndW1lbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIGV4cHIgPSBtYXRjaEtleXdvcmQoJ25ldycpID8gcGFyc2VOZXdFeHByZXNzaW9uKCkgOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCcuJykgfHwgbWF0Y2goJ1snKSB8fCBtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiBleHByLFxuICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnRzJzogcGFyc2VBcmd1bWVudHMoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwciA9IG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24oKSA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJy4nKSB8fCBtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VDb21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VOb25Db21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjMgUG9zdGZpeCBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSwgdG9rZW47XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkgJiYgIXBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICAvLyAxMS4zLjEsIDExLjMuMlxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0TEhTUG9zdGZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVXBkYXRlRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjQgVW5hcnkgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBleHByO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIC8vIDExLjQuNCwgMTEuNC41XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RMSFNQcmVmaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVXBkYXRlRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogdG9rZW4udmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcHJlZml4OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJysnKSB8fCBtYXRjaCgnLScpIHx8IG1hdGNoKCd+JykgfHwgbWF0Y2goJyEnKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBsZXgoKS52YWx1ZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogcGFyc2VVbmFyeUV4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IHBhcnNlVW5hcnlFeHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAgcHJlZml4OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLm9wZXJhdG9yID09PSAnZGVsZXRlJyAmJiBleHByLmFyZ3VtZW50LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3REZWxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgIH1cblxuICAgIC8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnKicpIHx8IG1hdGNoKCcvJykgfHwgbWF0Y2goJyUnKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VVbmFyeUV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjYgQWRkaXRpdmUgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUFkZGl0aXZlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnKycpIHx8IG1hdGNoKCctJykpIHtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGxleCgpLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS43IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVNoaWZ0RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUFkZGl0aXZlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnPDwnKSB8fCBtYXRjaCgnPj4nKSB8fCBtYXRjaCgnPj4+JykpIHtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGxleCgpLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlQWRkaXRpdmVFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VSZWxhdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgICBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcblxuICAgICAgICBleHByID0gcGFyc2VTaGlmdEV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJzwnKSB8fCBtYXRjaCgnPicpIHx8IG1hdGNoKCc8PScpIHx8IG1hdGNoKCc+PScpIHx8IChwcmV2aW91c0FsbG93SW4gJiYgbWF0Y2hLZXl3b3JkKCdpbicpKSB8fCBtYXRjaEtleXdvcmQoJ2luc3RhbmNlb2YnKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VTaGlmdEV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjkgRXF1YWxpdHkgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUVxdWFsaXR5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZVJlbGF0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCc9PScpIHx8IG1hdGNoKCchPScpIHx8IG1hdGNoKCc9PT0nKSB8fCBtYXRjaCgnIT09JykpIHtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IGxleCgpLnZhbHVlLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlUmVsYXRpb25hbEV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjEwIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VCaXR3aXNlQU5ERXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUVxdWFsaXR5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnJicpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICcmJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJzZUVxdWFsaXR5RXhwcmVzc2lvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUJpdHdpc2VBTkRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCdeJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ14nLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlQml0d2lzZUFOREV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQml0d2lzZU9SRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUJpdHdpc2VYT1JFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCd8JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ3wnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlQml0d2lzZVhPUkV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjExIEJpbmFyeSBMb2dpY2FsIE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsQU5ERXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUJpdHdpc2VPUkV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJyYmJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTG9naWNhbEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICcmJicsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VCaXR3aXNlT1JFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxvZ2ljYWxPUkV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByID0gcGFyc2VMb2dpY2FsQU5ERXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnfHwnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ3x8JyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJzZUxvZ2ljYWxBTkRFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4xMiBDb25kaXRpb25hbCBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByLCBwcmV2aW91c0FsbG93SW4sIGNvbnNlcXVlbnQ7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlTG9naWNhbE9SRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNlcXVlbnQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgICAgZXhwZWN0KCc6Jyk7XG5cbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICB0ZXN0OiBleHByLFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQsXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlOiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4xMyBBc3NpZ25tZW50IE9wZXJhdG9yc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBleHByO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGV4cHIgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmIChtYXRjaEFzc2lnbigpKSB7XG4gICAgICAgICAgICAvLyBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uXG4gICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMTEuMTMuMVxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0TEhTQXNzaWdubWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBsZXgoKS52YWx1ZSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4xNCBDb21tYSBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBbIGV4cHIgXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByLmV4cHJlc3Npb25zLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDEyLjEgQmxvY2tcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50TGlzdCgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXSxcbiAgICAgICAgICAgIHN0YXRlbWVudDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgICAgICB2YXIgYmxvY2s7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgYmxvY2sgPSBwYXJzZVN0YXRlbWVudExpc3QoKTtcblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgYm9keTogYmxvY2tcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi4yIFZhcmlhYmxlIFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgbmFtZTogdG9rZW4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24oa2luZCkge1xuICAgICAgICB2YXIgaWQgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpLFxuICAgICAgICAgICAgaW5pdCA9IG51bGw7XG5cbiAgICAgICAgLy8gMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XG4gICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgICAgIGluaXQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBpbml0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpbml0OiBpbml0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChraW5kKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbihraW5kKSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9IHdoaWxlIChpbmRleCA8IGxlbmd0aCk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucztcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd2YXInKTtcblxuICAgICAgICBkZWNsYXJhdGlvbnMgPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRpb25zLFxuICAgICAgICAgICAga2luZDogJ3ZhcidcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBraW5kIG1heSBiZSBgY29uc3RgIG9yIGBsZXRgXG4gICAgLy8gQm90aCBhcmUgZXhwZXJpbWVudGFsIGFuZCBub3QgaW4gdGhlIHNwZWNpZmljYXRpb24geWV0LlxuICAgIC8vIHNlZSBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmNvbnN0XG4gICAgLy8gYW5kIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6bGV0XG4gICAgZnVuY3Rpb24gcGFyc2VDb25zdExldERlY2xhcmF0aW9uKGtpbmQpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucztcblxuICAgICAgICBleHBlY3RLZXl3b3JkKGtpbmQpO1xuXG4gICAgICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3Qoa2luZCk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRpb25zLFxuICAgICAgICAgICAga2luZDoga2luZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjMgRW1wdHkgU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVtcHR5U3RhdGVtZW50KCkge1xuICAgICAgICBleHBlY3QoJzsnKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkVtcHR5U3RhdGVtZW50XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIuNCBFeHByZXNzaW9uIFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIuNSBJZiBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlSWZTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGU7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnaWYnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgY29uc2VxdWVudCA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZWxzZScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZlN0YXRlbWVudCxcbiAgICAgICAgICAgIHRlc3Q6IHRlc3QsXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50LFxuICAgICAgICAgICAgYWx0ZXJuYXRlOiBhbHRlcm5hdGVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi42IEl0ZXJhdGlvbiBTdGF0ZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZURvV2hpbGVTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBib2R5LCB0ZXN0LCBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdkbycpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRG9XaGlsZVN0YXRlbWVudCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICB0ZXN0OiB0ZXN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXaGlsZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRlc3QsIGJvZHksIG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIG9sZEluSXRlcmF0aW9uID0gc3RhdGUuaW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gdHJ1ZTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguV2hpbGVTdGF0ZW1lbnQsXG4gICAgICAgICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbigpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbGV4KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KCksXG4gICAgICAgICAgICBraW5kOiB0b2tlbi52YWx1ZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRm9yU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgaW5pdCwgdGVzdCwgdXBkYXRlLCBsZWZ0LCByaWdodCwgYm9keSwgb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgaW5pdCA9IHRlc3QgPSB1cGRhdGUgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2ZvcicpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3ZhcicpIHx8IG1hdGNoS2V5d29yZCgnbGV0JykpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5pdCA9IHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluaXQuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbml0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdpbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0xlZnRIYW5kU2lkZShpbml0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JJbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3QoJzsnKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Gb3JTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgICAgICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZvckluU3RhdGVtZW50LFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBlYWNoOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjcgVGhlIGNvbnRpbnVlIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb250aW51ZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBsYWJlbCA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY29udGludWUnKTtcblxuICAgICAgICAvLyBPcHRpbWl6ZSB0aGUgbW9zdCBjb21tb24gZm9ybTogJ2NvbnRpbnVlOycuXG4gICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAnOycpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ29udGludWVTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIGlmICghc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Db250aW51ZVN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBsYWJlbDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBsYWJlbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVua25vd25MYWJlbCwgbGFiZWwubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICFzdGF0ZS5pbkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQ29udGludWVTdGF0ZW1lbnQsXG4gICAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi44IFRoZSBicmVhayBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgbGFiZWwgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2JyZWFrJyk7XG5cbiAgICAgICAgLy8gT3B0aW1pemUgdGhlIG1vc3QgY29tbW9uIGZvcm06ICdicmVhazsnLlxuICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJzsnKSB7XG4gICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQnJlYWtTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIGlmICghKHN0YXRlLmluSXRlcmF0aW9uIHx8IHN0YXRlLmluU3dpdGNoKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJyZWFrU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGxhYmVsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJyZWFrU3RhdGVtZW50LFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIuOSBUaGUgcmV0dXJuIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgYXJndW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xuXG4gICAgICAgIGlmICghc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncmV0dXJuJyBmb2xsb3dlZCBieSBhIHNwYWNlIGFuZCBhbiBpZGVudGlmaWVyIGlzIHZlcnkgY29tbW9uLlxuICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlW2luZGV4ICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlJldHVyblN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUmV0dXJuU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpICYmIHRva2VuLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQsXG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgd2l0aCBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2l0aFN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIG9iamVjdCwgYm9keTtcblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdE1vZGVXaXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3dpdGgnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBvYmplY3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LldpdGhTdGF0ZW1lbnQsXG4gICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgc3dpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciB0ZXN0LFxuICAgICAgICAgICAgY29uc2VxdWVudCA9IFtdLFxuICAgICAgICAgICAgc3RhdGVtZW50O1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0ZXN0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcbiAgICAgICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJzonKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpIHx8IG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpIHx8IG1hdGNoS2V5d29yZCgnY2FzZScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zZXF1ZW50LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguU3dpdGNoQ2FzZSxcbiAgICAgICAgICAgIHRlc3Q6IHRlc3QsXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBkaXNjcmltaW5hbnQsIGNhc2VzLCBjbGF1c2UsIG9sZEluU3dpdGNoLCBkZWZhdWx0Rm91bmQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgZGlzY3JpbWluYW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgY2FzZXMgPSBbXTtcblxuICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgZGlzY3JpbWluYW50OiBkaXNjcmltaW5hbnQsXG4gICAgICAgICAgICAgICAgY2FzZXM6IGNhc2VzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb2xkSW5Td2l0Y2ggPSBzdGF0ZS5pblN3aXRjaDtcbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSB0cnVlO1xuICAgICAgICBkZWZhdWx0Rm91bmQgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGF1c2UgPSBwYXJzZVN3aXRjaENhc2UoKTtcbiAgICAgICAgICAgIGlmIChjbGF1c2UudGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2VzLnB1c2goY2xhdXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gb2xkSW5Td2l0Y2g7XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQsXG4gICAgICAgICAgICBkaXNjcmltaW5hbnQ6IGRpc2NyaW1pbmFudCxcbiAgICAgICAgICAgIGNhc2VzOiBjYXNlc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjEzIFRoZSB0aHJvdyBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlVGhyb3dTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBhcmd1bWVudDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCd0aHJvdycpO1xuXG4gICAgICAgIGlmIChwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTmV3bGluZUFmdGVyVGhyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5UaHJvd1N0YXRlbWVudCxcbiAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjE0IFRoZSB0cnkgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNhdGNoQ2xhdXNlKCkge1xuICAgICAgICB2YXIgcGFyYW07XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY2F0Y2gnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgIC8vIDEyLjE0LjFcbiAgICAgICAgaWYgKHN0cmljdCAmJiBpc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdENhdGNoVmFyaWFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYXRjaENsYXVzZSxcbiAgICAgICAgICAgIHBhcmFtOiBwYXJhbSxcbiAgICAgICAgICAgIGJvZHk6IHBhcnNlQmxvY2soKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHJ5U3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgYmxvY2ssIGhhbmRsZXJzID0gW10sIGZpbmFsaXplciA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgndHJ5Jyk7XG5cbiAgICAgICAgYmxvY2sgPSBwYXJzZUJsb2NrKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnY2F0Y2gnKSkge1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChwYXJzZUNhdGNoQ2xhdXNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgnZmluYWxseScpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGZpbmFsaXplciA9IHBhcnNlQmxvY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDAgJiYgIWZpbmFsaXplcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuTm9DYXRjaE9yRmluYWxseSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LlRyeVN0YXRlbWVudCxcbiAgICAgICAgICAgIGJsb2NrOiBibG9jayxcbiAgICAgICAgICAgIGd1YXJkZWRIYW5kbGVyczogW10sXG4gICAgICAgICAgICBoYW5kbGVyczogaGFuZGxlcnMsXG4gICAgICAgICAgICBmaW5hbGl6ZXI6IGZpbmFsaXplclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjE1IFRoZSBkZWJ1Z2dlciBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQoKSB7XG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2RlYnVnZ2VyJyk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRGVidWdnZXJTdGF0ZW1lbnRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMiBTdGF0ZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkKCksXG4gICAgICAgICAgICBleHByLFxuICAgICAgICAgICAgbGFiZWxlZEJvZHk7XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFbXB0eVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQmxvY2soKTtcbiAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnYnJlYWsnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUJyZWFrU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdjb250aW51ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ29udGludWVTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RlYnVnZ2VyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEZWJ1Z2dlclN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnZG8nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURvV2hpbGVTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zvcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRm9yU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAnaWYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlmU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVJldHVyblN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3Rocm93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUaHJvd1N0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAndHJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUcnlTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3Zhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVmFyaWFibGVTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3doaWxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VXaGlsZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnd2l0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2l0aFN0YXRlbWVudCgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICAvLyAxMi4xMiBMYWJlbGxlZCBTdGF0ZW1lbnRzXG4gICAgICAgIGlmICgoZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikgJiYgbWF0Y2goJzonKSkge1xuICAgICAgICAgICAgbGV4KCk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5SZWRlY2xhcmF0aW9uLCAnTGFiZWwnLCBleHByLm5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5sYWJlbFNldFtleHByLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhYmVsZWRCb2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5sYWJlbFNldFtleHByLm5hbWVdO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5MYWJlbGVkU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBleHByLFxuICAgICAgICAgICAgICAgIGJvZHk6IGxhYmVsZWRCb2R5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMyBGdW5jdGlvbiBEZWZpbml0aW9uXG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQsXG4gICAgICAgICAgICBvbGRMYWJlbFNldCwgb2xkSW5JdGVyYXRpb24sIG9sZEluU3dpdGNoLCBvbGRJbkZ1bmN0aW9uQm9keTtcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUVsZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aXZlID0gc2xpY2VTb3VyY2UodG9rZW4ucmFuZ2VbMF0gKyAxLCB0b2tlbi5yYW5nZVsxXSAtIDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChmaXJzdFJlc3RyaWN0ZWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvbGRMYWJlbFNldCA9IHN0YXRlLmxhYmVsU2V0O1xuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBvbGRJblN3aXRjaCA9IHN0YXRlLmluU3dpdGNoO1xuICAgICAgICBvbGRJbkZ1bmN0aW9uQm9keSA9IHN0YXRlLmluRnVuY3Rpb25Cb2R5O1xuXG4gICAgICAgIHN0YXRlLmxhYmVsU2V0ID0ge307XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluRnVuY3Rpb25Cb2R5ID0gdHJ1ZTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgICAgc3RhdGUubGFiZWxTZXQgPSBvbGRMYWJlbFNldDtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSBvbGRJblN3aXRjaDtcbiAgICAgICAgc3RhdGUuaW5GdW5jdGlvbkJvZHkgPSBvbGRJbkZ1bmN0aW9uQm9keTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgYm9keTogc291cmNlRWxlbWVudHNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHZhciBpZCwgcGFyYW0sIHBhcmFtcyA9IFtdLCBib2R5LCB0b2tlbiwgc3RyaWN0ZWQsIGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSwgcHJldmlvdXNTdHJpY3QsIHBhcmFtU2V0O1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHBhcmFtU2V0ID0ge307XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgICAgIHBhcmFtID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbVNldCwgdG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtU2V0LCB0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgcGFyYW1TZXRbcGFyYW0ubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBib2R5ID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmljdCAmJiBzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAgICAgZ2VuZXJhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgaWQgPSBudWxsLCBzdHJpY3RlZCwgZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlLCBwYXJhbSwgcGFyYW1zID0gW10sIGJvZHksIHByZXZpb3VzU3RyaWN0LCBwYXJhbVNldDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xuXG4gICAgICAgIGlmICghbWF0Y2goJygnKSkge1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgICAgIGlkID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHBhcmFtU2V0ID0ge307XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgICAgIHBhcmFtID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbVNldCwgdG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtU2V0LCB0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgcGFyYW1TZXRbcGFyYW0ubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBib2R5ID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmljdCAmJiBzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHN0cmljdGVkLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHJlc3Q6IG51bGwsXG4gICAgICAgICAgICBnZW5lcmF0b3I6IGZhbHNlLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxNCBQcm9ncmFtXG5cbiAgICBmdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnQoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUNvbnN0TGV0RGVjbGFyYXRpb24odG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU291cmNlRWxlbWVudHMoKSB7XG4gICAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQ7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHNsaWNlU291cmNlKHRva2VuLnJhbmdlWzBdICsgMSwgdG9rZW4ucmFuZ2VbMV0gLSAxKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xuICAgICAgICAgICAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VFbGVtZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVByb2dyYW0oKSB7XG4gICAgICAgIHZhciBwcm9ncmFtO1xuICAgICAgICBzdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgcHJvZ3JhbSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Qcm9ncmFtLFxuICAgICAgICAgICAgYm9keTogcGFyc2VTb3VyY2VFbGVtZW50cygpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSBuZWVkZWQgb25seSB3aGVuIHRoZSBvcHRpb24gdG8gcHJlc2VydmVcbiAgICAvLyB0aGUgY29tbWVudHMgaXMgYWN0aXZlLlxuXG4gICAgZnVuY3Rpb24gYWRkQ29tbWVudCh0eXBlLCB2YWx1ZSwgc3RhcnQsIGVuZCwgbG9jKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInLCAnQ29tbWVudCBtdXN0IGhhdmUgdmFsaWQgcG9zaXRpb24nKTtcblxuICAgICAgICAvLyBCZWNhdXNlIHRoZSB3YXkgdGhlIGFjdHVhbCB0b2tlbiBpcyBzY2FubmVkLCBvZnRlbiB0aGUgY29tbWVudHNcbiAgICAgICAgLy8gKGlmIGFueSkgYXJlIHNraXBwZWQgdHdpY2UgZHVyaW5nIHRoZSBsZXhpY2FsIGFuYWx5c2lzLlxuICAgICAgICAvLyBUaHVzLCB3ZSBuZWVkIHRvIHNraXAgYWRkaW5nIGEgY29tbWVudCBpZiB0aGUgY29tbWVudCBhcnJheSBhbHJlYWR5XG4gICAgICAgIC8vIGhhbmRsZWQgaXQuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudHNbZXh0cmEuY29tbWVudHMubGVuZ3RoIC0gMV0ucmFuZ2VbMV0gPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLmNvbW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGVuZF0sXG4gICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuQ29tbWVudCgpIHtcbiAgICAgICAgdmFyIGNvbW1lbnQsIGNoLCBsb2MsIHN0YXJ0LCBibG9ja0NvbW1lbnQsIGxpbmVDb21tZW50O1xuXG4gICAgICAgIGNvbW1lbnQgPSAnJztcbiAgICAgICAgYmxvY2tDb21tZW50ID0gZmFsc2U7XG4gICAgICAgIGxpbmVDb21tZW50ID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChsaW5lQ29tbWVudCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgLSAxXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxpbmVDb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXggLSAxLCBsb2MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbGVuZ3RoIC0gbGluZVN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgbGVuZ3RoLCBsb2MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChibG9ja0NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXggKyAxXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9ICdcXHJcXG4nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50LnN1YnN0cigwLCBjb21tZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29tbWVudCgnQmxvY2snLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBsaW5lQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0xpbmUnLCBjb21tZW50LCBzdGFydCwgaW5kZXgsIGxvYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgLSAyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZVNwYWNlKGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyQ29tbWVudExvY2F0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZW50cnksIGNvbW1lbnQsIGNvbW1lbnRzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4dHJhLmNvbW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGV4dHJhLmNvbW1lbnRzW2ldO1xuICAgICAgICAgICAgY29tbWVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlbnRyeS50eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQucmFuZ2UgPSBlbnRyeS5yYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50LmxvYyA9IGVudHJ5LmxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBleHRyYS5jb21tZW50cyA9IGNvbW1lbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RUb2tlbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBsb2MsIHRva2VuLCByYW5nZSwgdmFsdWU7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0b2tlbiA9IGV4dHJhLmFkdmFuY2UoKTtcbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgcmFuZ2UgPSBbdG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdXTtcbiAgICAgICAgICAgIHZhbHVlID0gc2xpY2VTb3VyY2UodG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdKTtcbiAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbk5hbWVbdG9rZW4udHlwZV0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29sbGVjdFJlZ2V4KCkge1xuICAgICAgICB2YXIgcG9zLCBsb2MsIHJlZ2V4LCB0b2tlbjtcblxuICAgICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgICBsb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2V4ID0gZXh0cmEuc2NhblJlZ0V4cCgpO1xuICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHRva2VuLCB3aGljaCBpcyBsaWtlbHkgJy8nIG9yICcvPSdcbiAgICAgICAgaWYgKGV4dHJhLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodG9rZW4ucmFuZ2VbMF0gPT09IHBvcyAmJiB0b2tlbi50eXBlID09PSAnUHVuY3R1YXRvcicpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICcvJyB8fCB0b2tlbi52YWx1ZSA9PT0gJy89Jykge1xuICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0cmEudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ1JlZ3VsYXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgcmFuZ2U6IFtwb3MsIGluZGV4XSxcbiAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJUb2tlbkxvY2F0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZW50cnksIHRva2VuLCB0b2tlbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXh0cmEudG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBlbnRyeSA9IGV4dHJhLnRva2Vuc1tpXTtcbiAgICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVudHJ5LnR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ucmFuZ2UgPSBlbnRyeS5yYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5sb2MgPSBlbnRyeS5sb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBleHRyYS50b2tlbnMgPSB0b2tlbnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTGl0ZXJhbCh0b2tlbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkxpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSYXdMaXRlcmFsKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlbi52YWx1ZSxcbiAgICAgICAgICAgIHJhdzogc2xpY2VTb3VyY2UodG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uTWFya2VyKCkge1xuICAgICAgICB2YXIgbWFya2VyID0ge307XG5cbiAgICAgICAgbWFya2VyLnJhbmdlID0gW2luZGV4LCBpbmRleF07XG4gICAgICAgIG1hcmtlci5sb2MgPSB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG1hcmtlci5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlWzFdID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLmxvYy5lbmQubGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLmxvYy5lbmQuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgbWFya2VyLmFwcGx5R3JvdXAgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5ncm91cFJhbmdlID0gW3RoaXMucmFuZ2VbMF0sIHRoaXMucmFuZ2VbMV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICAgIG5vZGUuZ3JvdXBMb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxvYy5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxvYy5zdGFydC5jb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxvYy5lbmQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sb2MuZW5kLmNvbHVtblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBtYXJrZXIuYXBwbHkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yYW5nZSA9IFt0aGlzLnJhbmdlWzBdLCB0aGlzLnJhbmdlWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICBub2RlLmxvYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubG9jLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMubG9jLnN0YXJ0LmNvbHVtblxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubG9jLmVuZC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxvYy5lbmQuY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2tHcm91cEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBtYXJrZXIsIGV4cHI7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIG1hcmtlci5lbmQoKTtcbiAgICAgICAgbWFya2VyLmFwcGx5R3JvdXAoZXhwcik7XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2tMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgbWFya2VyLCBleHByO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICAgICAgZXhwciA9IG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24oKSA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJy4nKSB8fCBtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VDb21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuZW5kKCk7XG4gICAgICAgICAgICAgICAgbWFya2VyLmFwcGx5KGV4cHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGV4cHIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1hcmtlci5lbmQoKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuYXBwbHkoZXhwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFja0xlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICAgIHZhciBtYXJrZXIsIGV4cHI7XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcblxuICAgICAgICBleHByID0gbWF0Y2hLZXl3b3JkKCduZXcnKSA/IHBhcnNlTmV3RXhwcmVzc2lvbigpIDogcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnLicpIHx8IG1hdGNoKCdbJykgfHwgbWF0Y2goJygnKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZTogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50cyc6IHBhcnNlQXJndW1lbnRzKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1hcmtlci5lbmQoKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuYXBwbHkoZXhwcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWFya2VyLmVuZCgpO1xuICAgICAgICAgICAgICAgIG1hcmtlci5hcHBseShleHByKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VOb25Db21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuZW5kKCk7XG4gICAgICAgICAgICAgICAgbWFya2VyLmFwcGx5KGV4cHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyR3JvdXAobm9kZSkge1xuICAgICAgICB2YXIgbiwgaSwgZW50cnk7XG5cbiAgICAgICAgbiA9IChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG5vZGUpID09PSAnW29iamVjdCBBcnJheV0nKSA/IFtdIDoge307XG4gICAgICAgIGZvciAoaSBpbiBub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAnZ3JvdXBSYW5nZScgJiYgaSAhPT0gJ2dyb3VwTG9jJykge1xuICAgICAgICAgICAgICAgIGVudHJ5ID0gbm9kZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkgPT09IG51bGwgfHwgdHlwZW9mIGVudHJ5ICE9PSAnb2JqZWN0JyB8fCBlbnRyeSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICBuW2ldID0gZW50cnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbltpXSA9IGZpbHRlckdyb3VwKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcFRyYWNraW5nRnVuY3Rpb24ocmFuZ2UsIGxvYykge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGFyc2VGdW5jdGlvbikge1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0JpbmFyeShub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gU3ludGF4LkJpbmFyeUV4cHJlc3Npb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZpc2l0KG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQsIGVuZDtcblxuICAgICAgICAgICAgICAgIGlmIChpc0JpbmFyeShub2RlLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0KG5vZGUubGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0JpbmFyeShub2RlLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpdChub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdC5ncm91cFJhbmdlIHx8IG5vZGUucmlnaHQuZ3JvdXBSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBub2RlLmxlZnQuZ3JvdXBSYW5nZSA/IG5vZGUubGVmdC5ncm91cFJhbmdlWzBdIDogbm9kZS5sZWZ0LnJhbmdlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gbm9kZS5yaWdodC5ncm91cFJhbmdlID8gbm9kZS5yaWdodC5ncm91cFJhbmdlWzFdIDogbm9kZS5yaWdodC5yYW5nZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBbc3RhcnQsIGVuZF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUucmFuZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5vZGUubGVmdC5yYW5nZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IG5vZGUucmlnaHQucmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJhbmdlID0gW3N0YXJ0LCBlbmRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdC5ncm91cExvYyB8fCBub2RlLnJpZ2h0Lmdyb3VwTG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG5vZGUubGVmdC5ncm91cExvYyA/IG5vZGUubGVmdC5ncm91cExvYy5zdGFydCA6IG5vZGUubGVmdC5sb2Muc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBub2RlLnJpZ2h0Lmdyb3VwTG9jID8gbm9kZS5yaWdodC5ncm91cExvYy5lbmQgOiBub2RlLnJpZ2h0LmxvYy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxvYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUubG9jID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUubGVmdC5sb2Muc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBub2RlLnJpZ2h0LmxvYy5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlciwgbm9kZTtcblxuICAgICAgICAgICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgICAgICAgICBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgbWFya2VyLmVuZCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlICYmIHR5cGVvZiBub2RlLnJhbmdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuYXBwbHkobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxvYyAmJiB0eXBlb2Ygbm9kZS5sb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5hcHBseShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNCaW5hcnkobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGNoKCkge1xuXG4gICAgICAgIHZhciB3cmFwVHJhY2tpbmc7XG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBleHRyYS5za2lwQ29tbWVudCA9IHNraXBDb21tZW50O1xuICAgICAgICAgICAgc2tpcENvbW1lbnQgPSBzY2FuQ29tbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYS5yYXcpIHtcbiAgICAgICAgICAgIGV4dHJhLmNyZWF0ZUxpdGVyYWwgPSBjcmVhdGVMaXRlcmFsO1xuICAgICAgICAgICAgY3JlYXRlTGl0ZXJhbCA9IGNyZWF0ZVJhd0xpdGVyYWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEucmFuZ2UgfHwgZXh0cmEubG9jKSB7XG5cbiAgICAgICAgICAgIGV4dHJhLnBhcnNlR3JvdXBFeHByZXNzaW9uID0gcGFyc2VHcm91cEV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24gPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGw7XG4gICAgICAgICAgICBwYXJzZUdyb3VwRXhwcmVzc2lvbiA9IHRyYWNrR3JvdXBFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gdHJhY2tMZWZ0SGFuZFNpZGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsID0gdHJhY2tMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsO1xuXG4gICAgICAgICAgICB3cmFwVHJhY2tpbmcgPSB3cmFwVHJhY2tpbmdGdW5jdGlvbihleHRyYS5yYW5nZSwgZXh0cmEubG9jKTtcblxuICAgICAgICAgICAgZXh0cmEucGFyc2VBZGRpdGl2ZUV4cHJlc3Npb24gPSBwYXJzZUFkZGl0aXZlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24gPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VCaXR3aXNlQU5ERXhwcmVzc2lvbiA9IHBhcnNlQml0d2lzZUFOREV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUJpdHdpc2VPUkV4cHJlc3Npb24gPSBwYXJzZUJpdHdpc2VPUkV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUJpdHdpc2VYT1JFeHByZXNzaW9uID0gcGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlQmxvY2sgPSBwYXJzZUJsb2NrO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VDYXRjaENsYXVzZSA9IHBhcnNlQ2F0Y2hDbGF1c2U7XG4gICAgICAgICAgICBleHRyYS5wYXJzZUNvbXB1dGVkTWVtYmVyID0gcGFyc2VDb21wdXRlZE1lbWJlcjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUNvbnN0TGV0RGVjbGFyYXRpb24gPSBwYXJzZUNvbnN0TGV0RGVjbGFyYXRpb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUVxdWFsaXR5RXhwcmVzc2lvbiA9IHBhcnNlRXF1YWxpdHlFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VFeHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VGb3JWYXJpYWJsZURlY2xhcmF0aW9uID0gcGFyc2VGb3JWYXJpYWJsZURlY2xhcmF0aW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uID0gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24gPSBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlTG9naWNhbEFOREV4cHJlc3Npb24gPSBwYXJzZUxvZ2ljYWxBTkRFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VMb2dpY2FsT1JFeHByZXNzaW9uID0gcGFyc2VMb2dpY2FsT1JFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24gPSBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlTmV3RXhwcmVzc2lvbiA9IHBhcnNlTmV3RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eTtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlT2JqZWN0UHJvcGVydHkgPSBwYXJzZU9iamVjdFByb3BlcnR5O1xuICAgICAgICAgICAgZXh0cmEucGFyc2VPYmplY3RQcm9wZXJ0eUtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXk7XG4gICAgICAgICAgICBleHRyYS5wYXJzZVBvc3RmaXhFeHByZXNzaW9uID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VQcm9ncmFtID0gcGFyc2VQcm9ncmFtO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VQcm9wZXJ0eUZ1bmN0aW9uID0gcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VSZWxhdGlvbmFsRXhwcmVzc2lvbiA9IHBhcnNlUmVsYXRpb25hbEV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZVN0YXRlbWVudCA9IHBhcnNlU3RhdGVtZW50O1xuICAgICAgICAgICAgZXh0cmEucGFyc2VTaGlmdEV4cHJlc3Npb24gPSBwYXJzZVNoaWZ0RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlU3dpdGNoQ2FzZSA9IHBhcnNlU3dpdGNoQ2FzZTtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlVW5hcnlFeHByZXNzaW9uID0gcGFyc2VVbmFyeUV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24gPSBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZVZhcmlhYmxlSWRlbnRpZmllciA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyO1xuXG4gICAgICAgICAgICBwYXJzZUFkZGl0aXZlRXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUFkZGl0aXZlRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VCaXR3aXNlQU5ERXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUJpdHdpc2VBTkRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlQml0d2lzZU9SRXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUJpdHdpc2VPUkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUJpdHdpc2VYT1JFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlQmxvY2sgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VCbG9jayk7XG4gICAgICAgICAgICBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKTtcbiAgICAgICAgICAgIHBhcnNlQ2F0Y2hDbGF1c2UgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VDYXRjaENsYXVzZSk7XG4gICAgICAgICAgICBwYXJzZUNvbXB1dGVkTWVtYmVyID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlQ29tcHV0ZWRNZW1iZXIpO1xuICAgICAgICAgICAgcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VDb25zdExldERlY2xhcmF0aW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlQ29uc3RMZXREZWNsYXJhdGlvbik7XG4gICAgICAgICAgICBwYXJzZUVxdWFsaXR5RXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUVxdWFsaXR5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUZvclZhcmlhYmxlRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbik7XG4gICAgICAgICAgICBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcocGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlTG9naWNhbEFOREV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VMb2dpY2FsQU5ERXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUxvZ2ljYWxPUkV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VMb2dpY2FsT1JFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlTmV3RXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZU5ld0V4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VOb25Db21wdXRlZFByb3BlcnR5ID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSk7XG4gICAgICAgICAgICBwYXJzZU9iamVjdFByb3BlcnR5ID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlT2JqZWN0UHJvcGVydHkpO1xuICAgICAgICAgICAgcGFyc2VPYmplY3RQcm9wZXJ0eUtleSA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZU9iamVjdFByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VQb3N0Zml4RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZVByaW1hcnlFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VQcm9ncmFtID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlUHJvZ3JhbSk7XG4gICAgICAgICAgICBwYXJzZVByb3BlcnR5RnVuY3Rpb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIHBhcnNlUmVsYXRpb25hbEV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VSZWxhdGlvbmFsRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZVN0YXRlbWVudCA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZVN0YXRlbWVudCk7XG4gICAgICAgICAgICBwYXJzZVNoaWZ0RXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZVNoaWZ0RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZVN3aXRjaENhc2UgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VTd2l0Y2hDYXNlKTtcbiAgICAgICAgICAgIHBhcnNlVW5hcnlFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBleHRyYS5hZHZhbmNlID0gYWR2YW5jZTtcbiAgICAgICAgICAgIGV4dHJhLnNjYW5SZWdFeHAgPSBzY2FuUmVnRXhwO1xuXG4gICAgICAgICAgICBhZHZhbmNlID0gY29sbGVjdFRva2VuO1xuICAgICAgICAgICAgc2NhblJlZ0V4cCA9IGNvbGxlY3RSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVucGF0Y2goKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXh0cmEuc2tpcENvbW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNraXBDb21tZW50ID0gZXh0cmEuc2tpcENvbW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEucmF3KSB7XG4gICAgICAgICAgICBjcmVhdGVMaXRlcmFsID0gZXh0cmEuY3JlYXRlTGl0ZXJhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRyYS5yYW5nZSB8fCBleHRyYS5sb2MpIHtcbiAgICAgICAgICAgIHBhcnNlQWRkaXRpdmVFeHByZXNzaW9uID0gZXh0cmEucGFyc2VBZGRpdGl2ZUV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gZXh0cmEucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlQml0d2lzZUFOREV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUJpdHdpc2VBTkRFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VCaXR3aXNlT1JFeHByZXNzaW9uID0gZXh0cmEucGFyc2VCaXR3aXNlT1JFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlQml0d2lzZVhPUkV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUJsb2NrID0gZXh0cmEucGFyc2VCbG9jaztcbiAgICAgICAgICAgIHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyA9IGV4dHJhLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cztcbiAgICAgICAgICAgIHBhcnNlQ2F0Y2hDbGF1c2UgPSBleHRyYS5wYXJzZUNhdGNoQ2xhdXNlO1xuICAgICAgICAgICAgcGFyc2VDb21wdXRlZE1lbWJlciA9IGV4dHJhLnBhcnNlQ29tcHV0ZWRNZW1iZXI7XG4gICAgICAgICAgICBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VDb25zdExldERlY2xhcmF0aW9uID0gZXh0cmEucGFyc2VDb25zdExldERlY2xhcmF0aW9uO1xuICAgICAgICAgICAgcGFyc2VFcXVhbGl0eUV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUVxdWFsaXR5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbiA9IGV4dHJhLnBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGV4dHJhLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uID0gZXh0cmEucGFyc2VGdW5jdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUdyb3VwRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlR3JvdXBFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gZXh0cmEucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsID0gZXh0cmEucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsO1xuICAgICAgICAgICAgcGFyc2VMb2dpY2FsQU5ERXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlTG9naWNhbEFOREV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUxvZ2ljYWxPUkV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUxvZ2ljYWxPUkV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VOZXdFeHByZXNzaW9uID0gZXh0cmEucGFyc2VOZXdFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VOb25Db21wdXRlZFByb3BlcnR5ID0gZXh0cmEucGFyc2VOb25Db21wdXRlZFByb3BlcnR5O1xuICAgICAgICAgICAgcGFyc2VPYmplY3RQcm9wZXJ0eSA9IGV4dHJhLnBhcnNlT2JqZWN0UHJvcGVydHk7XG4gICAgICAgICAgICBwYXJzZU9iamVjdFByb3BlcnR5S2V5ID0gZXh0cmEucGFyc2VPYmplY3RQcm9wZXJ0eUtleTtcbiAgICAgICAgICAgIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBleHRyYS5wYXJzZVByaW1hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VQb3N0Zml4RXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlUG9zdGZpeEV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZVByb2dyYW0gPSBleHRyYS5wYXJzZVByb2dyYW07XG4gICAgICAgICAgICBwYXJzZVByb3BlcnR5RnVuY3Rpb24gPSBleHRyYS5wYXJzZVByb3BlcnR5RnVuY3Rpb247XG4gICAgICAgICAgICBwYXJzZVJlbGF0aW9uYWxFeHByZXNzaW9uID0gZXh0cmEucGFyc2VSZWxhdGlvbmFsRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlU3RhdGVtZW50ID0gZXh0cmEucGFyc2VTdGF0ZW1lbnQ7XG4gICAgICAgICAgICBwYXJzZVNoaWZ0RXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlU2hpZnRFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VTd2l0Y2hDYXNlID0gZXh0cmEucGFyc2VTd2l0Y2hDYXNlO1xuICAgICAgICAgICAgcGFyc2VVbmFyeUV4cHJlc3Npb24gPSBleHRyYS5wYXJzZVVuYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbiA9IGV4dHJhLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHBhcnNlVmFyaWFibGVJZGVudGlmaWVyID0gZXh0cmEucGFyc2VWYXJpYWJsZUlkZW50aWZpZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnNjYW5SZWdFeHAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFkdmFuY2UgPSBleHRyYS5hZHZhbmNlO1xuICAgICAgICAgICAgc2NhblJlZ0V4cCA9IGV4dHJhLnNjYW5SZWdFeHA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcHJvZ3JhbSwgdG9TdHJpbmc7XG5cbiAgICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycgJiYgIShjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlID0gY29kZTtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgICBsaW5lU3RhcnQgPSAwO1xuICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICBidWZmZXIgPSBudWxsO1xuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG4gICAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBpblN3aXRjaDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICAgICAgZXh0cmEubG9jID0gKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYztcbiAgICAgICAgICAgIGV4dHJhLnJhdyA9ICh0eXBlb2Ygb3B0aW9ucy5yYXcgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYXc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuY29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVswXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZmlyc3QgdG8gY29udmVydCB0byBhIHN0cmluZy4gVGhpcyBpcyBnb29kIGFzIGZhc3QgcGF0aFxuICAgICAgICAgICAgICAgIC8vIGZvciBvbGQgSUUgd2hpY2ggdW5kZXJzdGFuZHMgc3RyaW5nIGluZGV4aW5nIGZvciBzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscyBvbmx5IGFuZCBub3QgZm9yIHN0cmluZyBvYmplY3QuXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gY29kZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgYWNjZXNzaW5nIHRoZSBjaGFyYWN0ZXJzIHZpYSBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVswXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gc3RyaW5nVG9BcnJheShjb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXRjaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IHBhcnNlUHJvZ3JhbSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5jb21tZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJDb21tZW50TG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmNvbW1lbnRzID0gZXh0cmEuY29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS50b2tlbnMgPSBleHRyYS50b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSB8fCBleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtLmJvZHkgPSBmaWx0ZXJHcm91cChwcm9ncmFtLmJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdW5wYXRjaCgpO1xuICAgICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIC8vIFN5bmMgd2l0aCBwYWNrYWdlLmpzb24uXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gJzEuMC40JztcblxuICAgIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxuICAgIC8vIERlZXAgY29weS5cbiAgICBleHBvcnRzLlN5bnRheCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lLCB0eXBlcyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChuYW1lIGluIFN5bnRheCkge1xuICAgICAgICAgICAgaWYgKFN5bnRheC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHR5cGVzW25hbWVdID0gU3ludGF4W25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZnJlZXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHR5cGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9KCkpO1xuXG59KSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLypcclxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxyXG4qXHJcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxyXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuKi9cclxuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xyXG4gICAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWxmID0ge307XHJcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XHJcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gV2UgY2FuJ3QgYnVpbGQgYSByZWFsIG1ldGhvZCB3aXRob3V0IGEgY29uc29sZSB0byBsb2cgdG9cclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgc2VsZlttZXRob2ROYW1lXS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcclxuICAgICAgICBcInRyYWNlXCIsXHJcbiAgICAgICAgXCJkZWJ1Z1wiLFxyXG4gICAgICAgIFwiaW5mb1wiLFxyXG4gICAgICAgIFwid2FyblwiLFxyXG4gICAgICAgIFwiZXJyb3JcIlxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xyXG4gICAgICAgICAgICBzZWxmW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgPyBub29wIDogc2VsZi5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xyXG4gICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVsnbG9nbGV2ZWwnXSA9IGxldmVsTmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuXHJcbiAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IFwibG9nbGV2ZWw9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcclxuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZFBlcnNpc3RlZExldmVsKCkge1xyXG4gICAgICAgIHZhciBzdG9yZWRMZXZlbDtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlWydsb2dsZXZlbCddO1xyXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvbG9nbGV2ZWw9KFteO10rKS8uZXhlYyh3aW5kb3cuZG9jdW1lbnQuY29va2llKVsxXTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSBcIldBUk5cIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgICpcclxuICAgICAqIFB1YmxpYyBBUElcclxuICAgICAqXHJcbiAgICAgKi9cclxuXHJcbiAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcclxuICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xyXG5cclxuICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBsZXZlbCkge1xyXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcclxuICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XHJcbiAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5UKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XHJcbiAgICBzZWxmLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxyXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBzZWxmKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9O1xyXG5cclxuICAgIGxvYWRQZXJzaXN0ZWRMZXZlbCgpO1xyXG4gICAgcmV0dXJuIHNlbGY7XHJcbn0pKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHdoaXRlTGlzdCA9IFsnbm90JywgJ2FueScsICdhbGwnLCAnbm9uZSddO1xyXG5cclxuXHJcbmZ1bmN0aW9uIG5vdE51bGwoeCkgIHsgcmV0dXJuIHggIT0gbnVsbDsgfVxyXG5mdW5jdGlvbiB0b1N0cmluZyh4KSB7IHJldHVybiB4LnRvU3RyaW5nKCk7IH1cclxuZnVuY3Rpb24gd3JhcCh4KSAgICAgeyByZXR1cm4gJygnICsgeCArICcpJzt9XHJcblxyXG5mdW5jdGlvbiBtYXliZVF1b3RlKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb29rVXAoa2V5KSB7XHJcbiAgICBpZiAoa2V5Lmxhc3RJbmRleE9mKCckJykgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gJ2NvbnRleHQuJyArIGtleS5zdWJzdHJpbmcoMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ2NvbnRleHQuZmVhdHVyZS5wcm9wZXJ0aWVzLicgKyBrZXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51bGxWYWx1ZShrZXksIHZhbHVlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6ICdudWxsVmFsdWUnLFxyXG4gICAgICAgIGtleToga2V5LFxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnIHRydWUgJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9wZXJ0eUVxdWFsKGtleSwgdmFsdWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ3Byb3BlcnR5RXF1YWwnLFxyXG4gICAgICAgIG9wdDogJz09PScgLFxyXG4gICAgICAgIGtleToga2V5LFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gd3JhcChtYXliZVF1b3RlKHRoaXMudmFsdWUpICsgJyAnICsgdGhpcy5vcHQgKyAnICcgKyBsb29rVXAoa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJvcGVydHlPcihrZXksIHZhbHVlcykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAncHJvcGVydHlPcicsXHJcbiAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwcm9wZXJ0eUVxdWFsKGtleSwgeCk7IH0pLFxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHRoaXMudmFsdWVzLm1hcCh0b1N0cmluZykuam9pbignIHx8ICcpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBub3Qoa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAnbm90UHJvcGVydHknLFxyXG4gICAgICAgIGtleToga2V5LFxyXG4gICAgICAgIHZhbHVlOiBwYXJzZUZpbHRlcih2YWx1ZSksXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICchJyArIHdyYXAodGhpcy52YWx1ZS50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBub25lKGtleSwgdmFsdWVzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6ICdub25lJyxcclxuICAgICAgICB2YWx1ZXM6IGFueShudWxsLCB2YWx1ZXMpLFxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnIScgKyB3cmFwKHRoaXMudmFsdWVzLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByaW50TmVzdGVkKHZhbHVlcywgam9pbmVyKSB7XHJcbiAgICByZXR1cm4gd3JhcCh2YWx1ZXMuZmlsdGVyKG5vdE51bGwpLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHguam9pbignICYmICcpKTtcclxuICAgIH0pLmpvaW4oJyAnICsgam9pbmVyICsgJyAnKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFueShfLCB2YWx1ZXMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ2FueScsXHJcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMubWFwKHBhcnNlRmlsdGVyKSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJpbnROZXN0ZWQodGhpcy52YWx1ZXMsICd8fCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFsbChfLCB2YWx1ZXMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ2FsbCcsXHJcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMuZmlsdGVyKG5vdE51bGwpLm1hcChwYXJzZUZpbHRlciksXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByaW50TmVzdGVkKHRoaXMudmFsdWVzLCAnJiYnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9wZXJ0eU1hdGNoZXNCb29sZWFuKGtleSwgdmFsdWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ3Byb3BlcnR5TWF0Y2hlc0Jvb2xlYW4nLFxyXG4gICAgICAgIGtleToga2V5LFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gd3JhcChsb29rVXAodGhpcy5rZXkpICsgKHRoaXMudmFsdWUgPyAnICE9ICcgOiAnID09ICcpICArICdudWxsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZ2VNYXRjaChrZXksIHZhbHVlcykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAncmFuZ2VNYXRjaCcsXHJcbiAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZXMubWF4KSB7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCcnICsgbG9va1VwKGtleSkgKyAnIDwgJyArIHRoaXMudmFsdWVzLm1heCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlcy5taW4pIHtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goJycgKyBsb29rVXAoa2V5KSArICcgPj0gJyArIHRoaXMudmFsdWVzLm1pbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB3cmFwKGV4cHJlc3Npb25zLmpvaW4oJyAmJiAnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VGaWx0ZXIoZmlsdGVyKSB7XHJcbiAgICB2YXIgZmlsdGVyQVNUID0gW107XHJcblxyXG4gICAgLy8gRnVuY3Rpb24gZmlsdGVyXHJcbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGZpbHRlckFTVC5wdXNoKHdyYXAoZmlsdGVyLnRvU3RyaW5nKCkgKyAnKGNvbnRleHQpJykpO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJBU1Q7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT2JqZWN0IGZpbHRlclxyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmaWx0ZXIpO1xyXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGlkeCkge1xyXG5cclxuICAgICAgICB2YXIgdmFsdWUgPSBmaWx0ZXJba2V5XSxcclxuICAgICAgICAgICAgdHlwZSAgPSB0eXBlb2YgdmFsdWU7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKHByb3BlcnR5RXF1YWwoa2V5LCB2YWx1ZSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIGZpbHRlckFTVC5wdXNoKHByb3BlcnR5TWF0Y2hlc0Jvb2xlYW4oa2V5LCB2YWx1ZSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChudWxsVmFsdWUoa2V5LCB2YWx1ZSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAod2hpdGVMaXN0LmluZGV4T2Yoa2V5KSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ25vdCc6XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChub3Qoa2V5LCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2FueSc6XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChhbnkoa2V5LCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChhbGwoa2V5LCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxyXG4gICAgICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gobm9uZShrZXksIHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIFdoaXRlTGlzdGVkIHByb3BlcnR5OiAnICsga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgZmlsdGVyQVNULnB1c2gocHJvcGVydHlPcihrZXksIHZhbHVlKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5tYXggfHwgdmFsdWUubWluKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJBU1QucHVzaChyYW5nZU1hdGNoKGtleSwgdmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBRdWVyeSBzeXRuYXg6ICcgKyB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGtleXMubGVuZ3RoID09PSAwID8gWyd0cnVlJ10gOiBmaWx0ZXJBU1Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlclRvU3RyaW5nKGZpbHRlckFTVCkge1xyXG4gICAgcmV0dXJuIHdyYXAoZmlsdGVyQVNULmpvaW4oJyAmJiAnKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hdGNoKGZpbHRlcikge1xyXG4gICAgaWYgKGZpbHRlciA9PSBudWxsKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9OyB9XHJcbiAgICAvLyBqc2hpbnQgZXZpbDogdHJ1ZVxyXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbignY29udGV4dCcsICdyZXR1cm4gJyArIGZpbHRlclRvU3RyaW5nKHBhcnNlRmlsdGVyKGZpbHRlcikpICsgJzsnKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBtYXRjaDogbWF0Y2gsXHJcbiAgICBmaWx0ZXJUb1N0cmluZzogZmlsdGVyVG9TdHJpbmcsXHJcbiAgICBwYXJzZUZpbHRlcjogcGFyc2VGaWx0ZXJcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBsaWdodHdlaWdodCBCdWZmZXIgc2hpbSBmb3IgcGJmIGJyb3dzZXIgYnVpbGRcbi8vIGJhc2VkIG9uIGNvZGUgZnJvbSBnaXRodWIuY29tL2Zlcm9zcy9idWZmZXIgKE1JVC1saWNlbnNlZClcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG5cbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpO1xuXG52YXIgQnVmZmVyTWV0aG9kcztcblxuZnVuY3Rpb24gQnVmZmVyKGxlbmd0aCkge1xuICAgIHZhciBhcnI7XG4gICAgaWYgKGxlbmd0aCAmJiBsZW5ndGgubGVuZ3RoKSB7XG4gICAgICAgIGFyciA9IGxlbmd0aDtcbiAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCB8fCAwKTtcbiAgICBpZiAoYXJyKSBidWYuc2V0KGFycik7XG5cbiAgICBidWYucmVhZFVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy5yZWFkVUludDMyTEU7XG4gICAgYnVmLndyaXRlVUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlVUludDMyTEU7XG4gICAgYnVmLnJlYWRJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy5yZWFkSW50MzJMRTtcbiAgICBidWYud3JpdGVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZUludDMyTEU7XG4gICAgYnVmLnJlYWRGbG9hdExFID0gQnVmZmVyTWV0aG9kcy5yZWFkRmxvYXRMRTtcbiAgICBidWYud3JpdGVGbG9hdExFID0gQnVmZmVyTWV0aG9kcy53cml0ZUZsb2F0TEU7XG4gICAgYnVmLnJlYWREb3VibGVMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZERvdWJsZUxFO1xuICAgIGJ1Zi53cml0ZURvdWJsZUxFID0gQnVmZmVyTWV0aG9kcy53cml0ZURvdWJsZUxFO1xuICAgIGJ1Zi50b1N0cmluZyA9IEJ1ZmZlck1ldGhvZHMudG9TdHJpbmc7XG4gICAgYnVmLndyaXRlID0gQnVmZmVyTWV0aG9kcy53cml0ZTtcbiAgICBidWYuc2xpY2UgPSBCdWZmZXJNZXRob2RzLnNsaWNlO1xuICAgIGJ1Zi5jb3B5ID0gQnVmZmVyTWV0aG9kcy5jb3B5O1xuXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWU7XG4gICAgcmV0dXJuIGJ1Zjtcbn1cblxudmFyIGxhc3RTdHIsIGxhc3RTdHJFbmNvZGVkO1xuXG5CdWZmZXJNZXRob2RzID0ge1xuICAgIHJlYWRVSW50MzJMRTogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXNbcG9zXSkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMl0gPDwgMTYpKSArXG4gICAgICAgICAgICAodGhpc1twb3MgKyAzXSAqIDB4MTAwMDAwMCk7XG4gICAgfSxcblxuICAgIHdyaXRlVUludDMyTEU6IGZ1bmN0aW9uKHZhbCwgcG9zKSB7XG4gICAgICAgIHRoaXNbcG9zXSA9IHZhbDtcbiAgICAgICAgdGhpc1twb3MgKyAxXSA9ICh2YWwgPj4+IDgpO1xuICAgICAgICB0aGlzW3BvcyArIDJdID0gKHZhbCA+Pj4gMTYpO1xuICAgICAgICB0aGlzW3BvcyArIDNdID0gKHZhbCA+Pj4gMjQpO1xuICAgIH0sXG5cbiAgICByZWFkSW50MzJMRTogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXNbcG9zXSkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMl0gPDwgMTYpKSArXG4gICAgICAgICAgICAodGhpc1twb3MgKyAzXSA8PCAyNCk7XG4gICAgfSxcblxuICAgIHJlYWRGbG9hdExFOiAgZnVuY3Rpb24ocG9zKSB7IHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgcG9zLCB0cnVlLCAyMywgNCk7IH0sXG4gICAgcmVhZERvdWJsZUxFOiBmdW5jdGlvbihwb3MpIHsgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBwb3MsIHRydWUsIDUyLCA4KTsgfSxcblxuICAgIHdyaXRlRmxvYXRMRTogIGZ1bmN0aW9uKHZhbCwgcG9zKSB7IHJldHVybiBpZWVlNzU0LndyaXRlKHRoaXMsIHZhbCwgcG9zLCB0cnVlLCAyMywgNCk7IH0sXG4gICAgd3JpdGVEb3VibGVMRTogZnVuY3Rpb24odmFsLCBwb3MpIHsgcmV0dXJuIGllZWU3NTQud3JpdGUodGhpcywgdmFsLCBwb3MsIHRydWUsIDUyLCA4KTsgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgc3RyID0gJycsXG4gICAgICAgICAgICB0bXAgPSAnJztcblxuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMubGVuZ3RoLCBlbmQgfHwgdGhpcy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGNoIDw9IDB4N0YpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gZGVjb2RlVVJJQ29tcG9uZW50KHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG1wICs9ICclJyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBkZWNvZGVVUklDb21wb25lbnQodG1wKTtcblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cbiAgICB3cml0ZTogZnVuY3Rpb24oc3RyLCBwb3MpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gc3RyID09PSBsYXN0U3RyID8gbGFzdFN0ckVuY29kZWQgOiBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1twb3MgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbihidWYsIHBvcykge1xuICAgICAgICBwb3MgPSBwb3MgfHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQnVmZmVyTWV0aG9kcy53cml0ZUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlVUludDMyTEU7XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgbGFzdFN0ciA9IHN0cjtcbiAgICBsYXN0U3RyRW5jb2RlZCA9IGVuY29kZVN0cmluZyhzdHIpO1xuICAgIHJldHVybiBsYXN0U3RyRW5jb2RlZC5sZW5ndGg7XG59O1xuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcbiAgICByZXR1cm4gISEoYnVmICYmIGJ1Zi5faXNCdWZmZXIpO1xufTtcblxuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHN0cikge1xuICAgIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoLFxuICAgICAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGMsIGxlYWQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIGNvZGUgcG9pbnRcblxuICAgICAgICBpZiAoYyA+IDB4RDdGRiAmJiBjIDwgMHhFMDAwKSB7XG5cbiAgICAgICAgICAgIGlmIChsZWFkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPCAweERDMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGxlYWQgLSAweEQ4MDAgPDwgMTAgfCBjIC0gMHhEQzAwIHwgMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjID4gMHhEQkZGIHx8IChpICsgMSA9PT0gbGVuZ3RoKSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICBlbHNlIGxlYWQgPSBjO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChsZWFkKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgbGVhZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODApIGJ5dGVzLnB1c2goYyk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkgYnl0ZXMucHVzaChjID4+IDB4NiB8IDB4QzAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDEwMDAwKSBieXRlcy5wdXNoKGMgPj4gMHhDIHwgMHhFMCwgYyA+PiAweDYgJiAweDNGIHwgMHg4MCwgYyAmIDB4M0YgfCAweDgwKTtcbiAgICAgICAgZWxzZSBieXRlcy5wdXNoKGMgPj4gMHgxMiB8IDB4RjAsIGMgPj4gMHhDICYgMHgzRiB8IDB4ODAsIGMgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYmY7XG5cbnZhciBCdWZmZXIgPSBnbG9iYWwuQnVmZmVyIHx8IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbmZ1bmN0aW9uIFBiZihidWYpIHtcbiAgICB0aGlzLmJ1ZiA9ICFCdWZmZXIuaXNCdWZmZXIoYnVmKSA/IG5ldyBCdWZmZXIoYnVmIHx8IDApIDogYnVmO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aDtcbn1cblxuUGJmLlZhcmludCAgPSAwOyAvLyB2YXJpbnQ6IGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG5QYmYuRml4ZWQ2NCA9IDE7IC8vIDY0LWJpdDogZG91YmxlLCBmaXhlZDY0LCBzZml4ZWQ2NFxuUGJmLkJ5dGVzICAgPSAyOyAvLyBsZW5ndGgtZGVsaW1pdGVkOiBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xuUGJmLkZpeGVkMzIgPSA1OyAvLyAzMi1iaXQ6IGZsb2F0LCBmaXhlZDMyLCBzZml4ZWQzMlxuXG52YXIgU0hJRlRfTEVGVF8zMiA9ICgxIDw8IDE2KSAqICgxIDw8IDE2KSxcbiAgICBTSElGVF9SSUdIVF8zMiA9IDEgLyBTSElGVF9MRUZUXzMyLFxuICAgIFBPV18yXzYzID0gTWF0aC5wb3coMiwgNjMpO1xuXG5QYmYucHJvdG90eXBlID0ge1xuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYnVmID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gPT09IFJFQURJTkcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHJlYWRGaWVsZHM6IGZ1bmN0aW9uKHJlYWRGaWVsZCwgcmVzdWx0LCBlbmQpIHtcbiAgICAgICAgZW5kID0gZW5kIHx8IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludCgpLFxuICAgICAgICAgICAgICAgIHRhZyA9IHZhbCA+PiAzLFxuICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhpcy5wb3M7XG5cbiAgICAgICAgICAgIHJlYWRGaWVsZCh0YWcsIHJlc3VsdCwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gc3RhcnRQb3MpIHRoaXMuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHJlYWRNZXNzYWdlOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkRmllbGRzKHJlYWRGaWVsZCwgcmVzdWx0LCB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zKTtcbiAgICB9LFxuXG4gICAgcmVhZEZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZFNGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgLy8gNjQtYml0IGludCBoYW5kbGluZyBpcyBiYXNlZCBvbiBnaXRodWIuY29tL2Rwdy9ub2RlLWJ1ZmZlci1tb3JlLWludHMgKE1JVC1saWNlbnNlZClcblxuICAgIHJlYWRGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcykgKyB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MgKyA0KSAqIFNISUZUX0xFRlRfMzI7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZEludDMyTEUodGhpcy5wb3MgKyA0KSAqIFNISUZUX0xFRlRfMzI7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRGbG9hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkRmxvYXRMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZERvdWJsZUxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZFZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBidWYgPSB0aGlzLmJ1ZixcbiAgICAgICAgICAgIHZhbCwgYiwgYjAsIGIxLCBiMiwgYjM7XG5cbiAgICAgICAgYjAgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMCA8IDB4ODApIHJldHVybiBiMDsgICAgICAgICAgICAgICAgIGIwID0gYjAgJiAweDdmO1xuICAgICAgICBiMSA9IGJ1Zlt0aGlzLnBvcysrXTsgaWYgKGIxIDwgMHg4MCkgcmV0dXJuIGIwIHwgYjEgPDwgNzsgICAgICAgYjEgPSAoYjEgJiAweDdmKSA8PCA3O1xuICAgICAgICBiMiA9IGJ1Zlt0aGlzLnBvcysrXTsgaWYgKGIyIDwgMHg4MCkgcmV0dXJuIGIwIHwgYjEgfCBiMiA8PCAxNDsgYjIgPSAoYjIgJiAweDdmKSA8PCAxNDtcbiAgICAgICAgYjMgPSBidWZbdGhpcy5wb3MrK107IGlmIChiMyA8IDB4ODApIHJldHVybiBiMCB8IGIxIHwgYjIgfCBiMyA8PCAyMTtcblxuICAgICAgICB2YWwgPSBiMCB8IGIxIHwgYjIgfCAoYjMgJiAweDdmKSA8PCAyMTtcblxuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4MTAwMDAwMDA7ICAgICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4ODAwMDAwMDAwOyAgICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4NDAwMDAwMDAwMDA7ICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4MjAwMDAwMDAwMDAwMDsgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4MTAwMDAwMDAwMDAwMDAwOyAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4ODAwMDAwMDAwMDAwMDAwMDsgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFyaW50IG5vdCBtb3JlIHRoYW4gMTAgYnl0ZXMnKTtcbiAgICB9LFxuXG4gICAgcmVhZFZhcmludDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5wb3MsXG4gICAgICAgICAgICB2YWwgPSB0aGlzLnJlYWRWYXJpbnQoKTtcblxuICAgICAgICBpZiAodmFsIDwgUE9XXzJfNjMpIHJldHVybiB2YWw7XG5cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zIC0gMjtcbiAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3Bvc10gPT09IDB4ZmYpIHBvcy0tO1xuICAgICAgICBpZiAocG9zIDwgc3RhcnRQb3MpIHBvcyA9IHN0YXJ0UG9zO1xuXG4gICAgICAgIHZhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zIC0gc3RhcnRQb3MgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiID0gfnRoaXMuYnVmW3N0YXJ0UG9zICsgaV0gJiAweDdmO1xuICAgICAgICAgICAgdmFsICs9IGkgPCA0ID8gYiA8PCBpICogNyA6IGIgKiBNYXRoLnBvdygyLCBpICogNyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLXZhbCAtIDE7XG4gICAgfSxcblxuICAgIHJlYWRTVmFyaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG51bSA9IHRoaXMucmVhZFZhcmludCgpO1xuICAgICAgICByZXR1cm4gbnVtICUgMiA9PT0gMSA/IChudW0gKyAxKSAvIC0yIDogbnVtIC8gMjsgLy8gemlnemFnIGVuY29kaW5nXG4gICAgfSxcblxuICAgIHJlYWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yZWFkVmFyaW50KCkpO1xuICAgIH0sXG5cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsXG4gICAgICAgICAgICBzdHIgPSB0aGlzLmJ1Zi50b1N0cmluZygndXRmOCcsIHRoaXMucG9zLCBlbmQpO1xuICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG4gICAgcmVhZEJ5dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsXG4gICAgICAgICAgICBidWZmZXIgPSB0aGlzLmJ1Zi5zbGljZSh0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfSxcblxuICAgIC8vIHZlcmJvc2UgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM7IGRvZXNuJ3QgYWZmZWN0IGd6aXBwZWQgc2l6ZVxuXG4gICAgcmVhZFBhY2tlZFZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRWYXJpbnQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZEJvb2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkQm9vbGVhbigpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGbG9hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGbG9hdCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWREb3VibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRG91YmxlKCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZEZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRml4ZWQzMigpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQzMigpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkNjQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkNjQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHNraXA6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YXIgdHlwZSA9IHZhbCAmIDB4NztcbiAgICAgICAgaWYgKHR5cGUgPT09IFBiZi5WYXJpbnQpIHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA+IDB4N2YpIHt9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5CeXRlcykgdGhpcy5wb3MgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zO1xuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuRml4ZWQzMikgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkNjQpIHRoaXMucG9zICs9IDg7XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdVbmltcGxlbWVudGVkIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9LFxuXG4gICAgLy8gPT09IFdSSVRJTkcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHdyaXRlVGFnOiBmdW5jdGlvbih0YWcsIHR5cGUpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludCgodGFnIDw8IDMpIHwgdHlwZSk7XG4gICAgfSxcblxuICAgIHJlYWxsb2M6IGZ1bmN0aW9uKG1pbikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMTY7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aCA8IHRoaXMucG9zICsgbWluKSBsZW5ndGggKj0gMjtcblxuICAgICAgICBpZiAobGVuZ3RoICE9PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmLmNvcHkoYnVmKTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICB3cml0ZUZpeGVkMzI6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkMzI6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDY0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50MzJMRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgdGhpcy5wb3MgKyA0KTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVTRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgdGhpcy5wb3MgKyA0KTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICB9LFxuXG4gICAgd3JpdGVWYXJpbnQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YWwgPSArdmFsO1xuXG4gICAgICAgIGlmICh2YWwgPD0gMHg3Zikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDEpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSB2YWw7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHgzZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMik7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAwKSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDcpICYgMHg3Zik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPD0gMHgxZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygzKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDApICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gNykgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAxNCkgJiAweDdmKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8PSAweGZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDApICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gNykgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAxNCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiAyMSkgJiAweDdmKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgd2hpbGUgKHZhbCA+PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKHZhbCAmIDB4ZmYpIHwgMHg4MDtcbiAgICAgICAgICAgICAgICB2YWwgLz0gMHg4MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygxKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gdmFsIHwgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyAtIHBvcyA+IDEwKSB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhcmludCBkb2VzblxcJ3QgZml0IGludG8gMTAgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3cml0ZVNWYXJpbnQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KHZhbCA8IDAgPyAtdmFsICogMiAtIDEgOiB2YWwgKiAyKTtcbiAgICB9LFxuXG4gICAgd3JpdGVCb29sZWFuOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChCb29sZWFuKHZhbCkpO1xuICAgIH0sXG5cbiAgICB3cml0ZVN0cmluZzogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuYnl0ZUxlbmd0aChzdHIpO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KGJ5dGVzKTtcbiAgICAgICAgdGhpcy5yZWFsbG9jKGJ5dGVzKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGUoc3RyLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IGJ5dGVzO1xuICAgIH0sXG5cbiAgICB3cml0ZUZsb2F0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUZsb2F0TEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRG91YmxlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZURvdWJsZUxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgIH0sXG5cbiAgICB3cml0ZUJ5dGVzOiBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQobGVuKTtcbiAgICAgICAgdGhpcy5yZWFsbG9jKGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHRoaXMuYnVmW3RoaXMucG9zKytdID0gYnVmZmVyW2ldO1xuICAgIH0sXG5cbiAgICB3cml0ZU1lc3NhZ2U6IGZ1bmN0aW9uKHRhZywgZm4sIG9iaikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcblxuICAgICAgICB0aGlzLnBvcysrOyAvLyByZXNlcnZlIDEgYnl0ZSBmb3Igc2hvcnQgbWVzc2FnZSBsZW5ndGhcblxuICAgICAgICAvLyB3cml0ZSB0aGUgbWVzc2FnZSBkaXJlY3RseSB0byB0aGUgYnVmZmVyIGFuZCBzZWUgaG93IG11Y2ggd2FzIHdyaXR0ZW5cbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGZuKG9iaiwgdGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnBvcyAtIHN0YXJ0UG9zO1xuXG4gICAgICAgIHZhciB2YXJpbnRMZW4gPVxuICAgICAgICAgICAgbGVuIDw9IDB4N2YgPyAxIDpcbiAgICAgICAgICAgIGxlbiA8PSAweDNmZmYgPyAyIDpcbiAgICAgICAgICAgIGxlbiA8PSAweDFmZmZmZiA/IDMgOlxuICAgICAgICAgICAgbGVuIDw9IDB4ZmZmZmZmZiA/IDQgOiBNYXRoLmNlaWwoTWF0aC5sb2cobGVuKSAvIChNYXRoLkxOMiAqIDcpKTtcblxuICAgICAgICAvLyBpZiAxIGJ5dGUgaXNuJ3QgZW5vdWdoIGZvciBlbmNvZGluZyBtZXNzYWdlIGxlbmd0aCwgc2hpZnQgdGhlIGRhdGEgdG8gdGhlIHJpZ2h0XG4gICAgICAgIGlmICh2YXJpbnRMZW4gPiAxKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2ModmFyaW50TGVuIC0gMSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5wb3MgLSAxOyBpID49IHN0YXJ0UG9zOyBpLS0pIHRoaXMuYnVmW2kgKyB2YXJpbnRMZW4gLSAxXSA9IHRoaXMuYnVmW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluYWxseSwgd3JpdGUgdGhlIG1lc3NhZ2UgbGVuZ3RoIGluIHRoZSByZXNlcnZlZCBwbGFjZSBhbmQgcmVzdG9yZSB0aGUgcG9zaXRpb25cbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcyAtIDE7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQobGVuKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgIH0sXG5cbiAgICB3cml0ZVBhY2tlZFZhcmludDogICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkVmFyaW50LCBhcnIpOyAgIH0sXG4gICAgd3JpdGVQYWNrZWRTVmFyaW50OiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNWYXJpbnQsIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkQm9vbGVhbjogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRCb29sZWFuLCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZEZsb2F0OiAgICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRmxvYXQsIGFycik7ICAgIH0sXG4gICAgd3JpdGVQYWNrZWREb3VibGU6ICAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZERvdWJsZSwgYXJyKTsgICB9LFxuICAgIHdyaXRlUGFja2VkRml4ZWQzMjogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGaXhlZDMyLCBhcnIpOyAgfSxcbiAgICB3cml0ZVBhY2tlZFNGaXhlZDMyOiBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkMzIsIGFycik7IH0sXG4gICAgd3JpdGVQYWNrZWRGaXhlZDY0OiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZpeGVkNjQsIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkU0ZpeGVkNjQ6IGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTRml4ZWQ2NCwgYXJyKTsgfSxcblxuICAgIHdyaXRlQnl0ZXNGaWVsZDogZnVuY3Rpb24odGFnLCBidWZmZXIpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG4gICAgICAgIHRoaXMud3JpdGVCeXRlcyhidWZmZXIpO1xuICAgIH0sXG4gICAgd3JpdGVGaXhlZDMyRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVGaXhlZDMyKHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVNGaXhlZDMyRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7XG4gICAgICAgIHRoaXMud3JpdGVTRml4ZWQzMih2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVGaXhlZDY0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7XG4gICAgICAgIHRoaXMud3JpdGVGaXhlZDY0KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVNGaXhlZDY0RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7XG4gICAgICAgIHRoaXMud3JpdGVTRml4ZWQ2NCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVWYXJpbnRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5WYXJpbnQpO1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVNWYXJpbnRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5WYXJpbnQpO1xuICAgICAgICB0aGlzLndyaXRlU1ZhcmludCh2YWwpO1xuICAgIH0sXG4gICAgd3JpdGVTdHJpbmdGaWVsZDogZnVuY3Rpb24odGFnLCBzdHIpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7XG4gICAgICAgIHRoaXMud3JpdGVTdHJpbmcoc3RyKTtcbiAgICB9LFxuICAgIHdyaXRlRmxvYXRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcbiAgICAgICAgdGhpcy53cml0ZUZsb2F0KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZURvdWJsZUZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkNjQpO1xuICAgICAgICB0aGlzLndyaXRlRG91YmxlKHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZUJvb2xlYW5GaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludEZpZWxkKHRhZywgQm9vbGVhbih2YWwpKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVBhY2tlZFZhcmludChhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVWYXJpbnQoYXJyW2ldKTsgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNWYXJpbnQoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTVmFyaW50KGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZsb2F0KGFyciwgcGJmKSAgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGbG9hdChhcnJbaV0pOyAgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZERvdWJsZShhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVEb3VibGUoYXJyW2ldKTsgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEJvb2xlYW4oYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVCb29sZWFuKGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZpeGVkMzIoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGaXhlZDMyKGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDMyKGFyciwgcGJmKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTRml4ZWQzMihhcnJbaV0pOyB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZpeGVkNjQoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGaXhlZDY0KGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDY0KGFyciwgcGJmKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTRml4ZWQ2NChhcnJbaV0pOyB9XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIi8qIVxuICogc3RyaXAtY29tbWVudHMgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3N0cmlwLWNvbW1lbnRzPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb24gU2NobGlua2VydCwgY29udHJpYnV0b3JzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWMnO1xuXG52YXIgcmVCbG9jayA9ICdcXFxcL1xcXFwqJztcbnZhciByZUJsb2NrSWdub3JlID0gJ1xcXFwvXFxcXCooPyFcXFxcKj9cXFxcISknO1xudmFyIHJlQmxvY2tFbmQgPSAnKC58W1xcXFxyXFxcXG5dfFxcXFxuKSo/XFxcXCpcXFxcL1xcXFxuP1xcXFxuPyc7XG52YXIgcmVMaW5lID0gLyhefFteXFxTXFxuXSkoPzpcXC9cXC8pKFtcXHNcXFNdKz8pJC9nbTtcbnZhciByZUxpbmVJZ25vcmUgPSAvKF58W15cXFNcXG5dKSg/OlxcL1xcL1teIV0pKFtcXHNcXFNdKz8pJC9nbTtcblxuXG4vKipcbiAqIFN0cmlwIGFsbCBjb21tZW50c1xuICpcbiAqIHslPSBkb2NzKFwic3RyaXBcIikgJX1cbiAqXG4gKiBAcGFyYW0gICB7U3RyaW5nfSBgc3RyYCAgZmlsZSBjb250ZW50cyBvciBzdHJpbmcgdG8gc3RyaXAuXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBgb3B0c2AgIG9wdGlvbnMgYXJlIHBhc3NlZCB0byBgLmJsb2NrYCwgYW5kIGAubGluZWBcbiAqIEByZXR1cm4gIHtTdHJpbmd9IFN0cmluZyB3aXRob3V0IGNvbW1lbnRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgc3RyaXAgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0ciwgb3B0cykge1xuICByZXR1cm4gc3RyID8gc3RyaXAuYmxvY2soc3RyaXAubGluZShzdHIsIG9wdHMpLCBvcHRzKSA6ICcnO1xufTtcblxuXG4vKipcbiAqIFN0cmlwIG9ubHkgYmxvY2sgY29tbWVudHMsIG9wdGlvbmFsbHkgbGVhdmluZyBwcm90ZWN0ZWQgY29tbWVudHNcbiAqIChlLmcuIGAvKiFgKSBpbnRhY3QuXG4gKlxuICogeyU9IGRvY3MoXCJibG9ja1wiKSAlfVxuICpcbiAqIEBwYXJhbSAgIHtTdHJpbmd9IGBzdHJgICBmaWxlIGNvbnRlbnQgb3Igc3RyaW5nIHRvIHN0cmlwIHRvXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBgb3B0c2AgIGlmIGBzYWZlOnRydWVgLCBzdHJpcCBvbmx5IGNvbW1lbnRzIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggYC8qIWAgb3IgYC8qKiFgXG4gKiBAcmV0dXJuICB7U3RyaW5nfSBTdHJpbmcgd2l0aG91dCBibG9jayBjb21tZW50cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuc3RyaXAuYmxvY2sgPSBmdW5jdGlvbihzdHIsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciByZSA9IG5ldyBSZWdFeHAocmVCbG9jayArIHJlQmxvY2tFbmQsICdnbScpO1xuICBpZihvcHRzLnNhZmUpIHtcbiAgICByZSA9IG5ldyBSZWdFeHAocmVCbG9ja0lnbm9yZSArIHJlQmxvY2tFbmQsICdnbScpO1xuICB9XG4gIHJldHVybiBzdHIgPyBzdHIucmVwbGFjZShyZSwgJycpIDogJyc7XG59O1xuXG5cbi8qKlxuICogU3RyaXAgb25seSBsaW5lIGNvbW1lbnRzXG4gKlxuICogeyU9IGRvY3MoXCJsaW5lXCIpICV9XG4gKlxuICogQHBhcmFtICAge1N0cmluZ30gYHN0cmAgIGZpbGUgY29udGVudCBvciBzdHJpbmcgdG8gc3RyaXAgdG9cbiAqIEBwYXJhbSAgIHtPYmplY3R9IGBvcHRzYCAgaWYgYHNhZmU6dHJ1ZWAsIHN0cmlwIGFsbCB0aGF0IG5vdCBzdGFydHMgd2l0aCBgLy8hYFxuICogQHJldHVybiAge1N0cmluZ30gU3RyaW5nIHdpdGhvdXQgbGluZSBjb21tZW50cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuc3RyaXAubGluZSA9IGZ1bmN0aW9uKHN0ciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHJlID0gcmVMaW5lO1xuICBpZihvcHRzLnNhZmUpIHtcbiAgICByZSA9IHJlTGluZUlnbm9yZTtcbiAgfVxuICByZXR1cm4gc3RyID8gc3RyLnJlcGxhY2UocmUsICcnKSA6ICcnO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGUgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlLmpzJyk7XG5tb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGVmZWF0dXJlLmpzJyk7XG5tb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlTGF5ZXIgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlbGF5ZXIuanMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVMYXllciA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZWxheWVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZTtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZShwYmYsIGVuZCkge1xuICAgIHRoaXMubGF5ZXJzID0gcGJmLnJlYWRGaWVsZHMocmVhZFRpbGUsIHt9LCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkVGlsZSh0YWcsIGxheWVycywgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMykge1xuICAgICAgICB2YXIgbGF5ZXIgPSBuZXcgVmVjdG9yVGlsZUxheWVyKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpO1xuICAgICAgICBpZiAobGF5ZXIubGVuZ3RoKSBsYXllcnNbbGF5ZXIubmFtZV0gPSBsYXllcjtcbiAgICB9XG59XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlRmVhdHVyZTtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZUZlYXR1cmUocGJmLCBlbmQsIGV4dGVudCwga2V5cywgdmFsdWVzKSB7XG4gICAgLy8gUHVibGljXG4gICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQ7XG4gICAgdGhpcy50eXBlID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9wYmYgPSBwYmY7XG4gICAgdGhpcy5fZ2VvbWV0cnkgPSAtMTtcbiAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICBwYmYucmVhZEZpZWxkcyhyZWFkRmVhdHVyZSwgdGhpcywgZW5kKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZlYXR1cmUodGFnLCBmZWF0dXJlLCBwYmYpIHtcbiAgICBpZiAodGFnID09IDEpIGZlYXR1cmUuX2lkID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT0gMikgcmVhZFRhZyhwYmYsIGZlYXR1cmUpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSAzKSBmZWF0dXJlLnR5cGUgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSA0KSBmZWF0dXJlLl9nZW9tZXRyeSA9IHBiZi5wb3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWcocGJmLCBmZWF0dXJlKSB7XG4gICAgdmFyIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIGtleSA9IGZlYXR1cmUuX2tleXNbcGJmLnJlYWRWYXJpbnQoKV0sXG4gICAgICAgICAgICB2YWx1ZSA9IGZlYXR1cmUuX3ZhbHVlc1twYmYucmVhZFZhcmludCgpXTtcbiAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG59XG5cblZlY3RvclRpbGVGZWF0dXJlLnR5cGVzID0gWydVbmtub3duJywgJ1BvaW50JywgJ0xpbmVTdHJpbmcnLCAnUG9seWdvbiddO1xuXG5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUubG9hZEdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBiZiA9IHRoaXMuX3BiZjtcbiAgICBwYmYucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MsXG4gICAgICAgIGNtZCA9IDEsXG4gICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgIHggPSAwLFxuICAgICAgICB5ID0gMCxcbiAgICAgICAgbGluZXMgPSBbXSxcbiAgICAgICAgbGluZTtcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY21kTGVuID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgICAgIGNtZCA9IGNtZExlbiAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZExlbiA+PiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoLS07XG5cbiAgICAgICAgaWYgKGNtZCA9PT0gMSB8fCBjbWQgPT09IDIpIHtcbiAgICAgICAgICAgIHggKz0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICB5ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuXG4gICAgICAgICAgICBpZiAoY21kID09PSAxKSB7IC8vIG1vdmVUb1xuICAgICAgICAgICAgICAgIGlmIChsaW5lKSBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZS5wdXNoKG5ldyBQb2ludCh4LCB5KSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjbWQgPT09IDcpIHtcbiAgICAgICAgICAgIGxpbmUucHVzaChsaW5lWzBdLmNsb25lKCkpOyAvLyBjbG9zZVBvbHlnb25cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGluZSkgbGluZXMucHVzaChsaW5lKTtcblxuICAgIHJldHVybiBsaW5lcztcbn07XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBiZiA9IHRoaXMuX3BiZjtcbiAgICBwYmYucG9zID0gdGhpcy5fZ2VvbWV0cnk7XG5cbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MsXG4gICAgICAgIGNtZCA9IDEsXG4gICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgIHggPSAwLFxuICAgICAgICB5ID0gMCxcbiAgICAgICAgeDEgPSBJbmZpbml0eSxcbiAgICAgICAgeDIgPSAtSW5maW5pdHksXG4gICAgICAgIHkxID0gSW5maW5pdHksXG4gICAgICAgIHkyID0gLUluZmluaXR5O1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRMZW4gPSBwYmYucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kTGVuICYgMHg3O1xuICAgICAgICAgICAgbGVuZ3RoID0gY21kTGVuID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICBpZiAoeCA8IHgxKSB4MSA9IHg7XG4gICAgICAgICAgICBpZiAoeCA+IHgyKSB4MiA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IHkxKSB5MSA9IHk7XG4gICAgICAgICAgICBpZiAoeSA+IHkyKSB5MiA9IHk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjbWQgIT09IDcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb21tYW5kICcgKyBjbWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG59O1xuXG5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUudG9HZW9KU09OID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBzaXplID0gdGhpcy5leHRlbnQgKiBNYXRoLnBvdygyLCB6KSxcbiAgICAgICAgeDAgPSB0aGlzLmV4dGVudCAqIHgsXG4gICAgICAgIHkwID0gdGhpcy5leHRlbnQgKiB5LFxuICAgICAgICBjb29yZHMgPSB0aGlzLmxvYWRHZW9tZXRyeSgpLFxuICAgICAgICB0eXBlID0gVmVjdG9yVGlsZUZlYXR1cmUudHlwZXNbdGhpcy50eXBlXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0gY29vcmRzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gbGluZVtqXSwgeTIgPSAxODAgLSAocC55ICsgeTApICogMzYwIC8gc2l6ZTtcbiAgICAgICAgICAgIGxpbmVbal0gPSBbXG4gICAgICAgICAgICAgICAgKHAueCArIHgwKSAqIDM2MCAvIHNpemUgLSAxODAsXG4gICAgICAgICAgICAgICAgMzYwIC8gTWF0aC5QSSAqIE1hdGguYXRhbihNYXRoLmV4cCh5MiAqIE1hdGguUEkgLyAxODApKSAtIDkwXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcgJiYgY29vcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF1bMF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXTtcbiAgICAgICAgdHlwZSA9ICdNdWx0aVBvaW50JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJyAmJiBjb29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3Jkc1swXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ011bHRpTGluZVN0cmluZyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3Jkc1xuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0aWVzOiB0aGlzLnByb3BlcnRpZXNcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgnLi92ZWN0b3J0aWxlZmVhdHVyZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVMYXllcjtcblxuZnVuY3Rpb24gVmVjdG9yVGlsZUxheWVyKHBiZiwgZW5kKSB7XG4gICAgLy8gUHVibGljXG4gICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW50ID0gNDA5NjtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5fcGJmID0gcGJmO1xuICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICB0aGlzLl9mZWF0dXJlcyA9IFtdO1xuXG4gICAgcGJmLnJlYWRGaWVsZHMocmVhZExheWVyLCB0aGlzLCBlbmQpO1xuXG4gICAgdGhpcy5sZW5ndGggPSB0aGlzLl9mZWF0dXJlcy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHJlYWRMYXllcih0YWcsIGxheWVyLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxNSkgbGF5ZXIudmVyc2lvbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAxKSBsYXllci5uYW1lID0gcGJmLnJlYWRTdHJpbmcoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIGxheWVyLmV4dGVudCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBsYXllci5fZmVhdHVyZXMucHVzaChwYmYucG9zKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDMpIGxheWVyLl9rZXlzLnB1c2gocGJmLnJlYWRTdHJpbmcoKSk7XG4gICAgZWxzZSBpZiAodGFnID09PSA0KSBsYXllci5fdmFsdWVzLnB1c2gocmVhZFZhbHVlTWVzc2FnZShwYmYpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFZhbHVlTWVzc2FnZShwYmYpIHtcbiAgICB2YXIgdmFsdWUgPSBudWxsLFxuICAgICAgICBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcztcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciB0YWcgPSBwYmYucmVhZFZhcmludCgpID4+IDM7XG5cbiAgICAgICAgdmFsdWUgPSB0YWcgPT09IDEgPyBwYmYucmVhZFN0cmluZygpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gMiA/IHBiZi5yZWFkRmxvYXQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDMgPyBwYmYucmVhZERvdWJsZSgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNCA/IHBiZi5yZWFkVmFyaW50NjQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDUgPyBwYmYucmVhZFZhcmludCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNiA/IHBiZi5yZWFkU1ZhcmludCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNyA/IHBiZi5yZWFkQm9vbGVhbigpIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHJldHVybiBmZWF0dXJlIGBpYCBmcm9tIHRoaXMgbGF5ZXIgYXMgYSBgVmVjdG9yVGlsZUZlYXR1cmVgXG5WZWN0b3JUaWxlTGF5ZXIucHJvdG90eXBlLmZlYXR1cmUgPSBmdW5jdGlvbihpKSB7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5fZmVhdHVyZXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ2ZlYXR1cmUgaW5kZXggb3V0IG9mIGJvdW5kcycpO1xuXG4gICAgdGhpcy5fcGJmLnBvcyA9IHRoaXMuX2ZlYXR1cmVzW2ldO1xuXG4gICAgdmFyIGVuZCA9IHRoaXMuX3BiZi5yZWFkVmFyaW50KCkgKyB0aGlzLl9wYmYucG9zO1xuICAgIHJldHVybiBuZXcgVmVjdG9yVGlsZUZlYXR1cmUodGhpcy5fcGJmLCBlbmQsIHRoaXMuZXh0ZW50LCB0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbn1cblxuUG9pbnQucHJvdG90eXBlID0ge1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7IH0sXG5cbiAgICBhZGQ6ICAgICBmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX2FkZChwKTsgICAgIH0sXG4gICAgc3ViOiAgICAgZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWIocCk7ICAgICB9LFxuICAgIG11bHQ6ICAgIGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdChrKTsgICAgfSxcbiAgICBkaXY6ICAgICBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX2RpdihrKTsgICAgIH0sXG4gICAgcm90YXRlOiAgZnVuY3Rpb24oYSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3RhdGUoYSk7ICB9LFxuICAgIG1hdE11bHQ6IGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fbWF0TXVsdChtKTsgfSxcbiAgICB1bml0OiAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fdW5pdCgpOyB9LFxuICAgIHBlcnA6ICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9wZXJwKCk7IH0sXG4gICAgcm91bmQ6ICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7IH0sXG5cbiAgICBtYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBwLnggJiZcbiAgICAgICAgICAgICAgIHRoaXMueSA9PT0gcC55O1xuICAgIH0sXG5cbiAgICBkaXN0OiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0U3FyKHApKTtcbiAgICB9LFxuXG4gICAgZGlzdFNxcjogZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgZHggPSBwLnggLSB0aGlzLngsXG4gICAgICAgICAgICBkeSA9IHAueSAtIHRoaXMueTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH0sXG5cbiAgICBhbmdsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICB9LFxuXG4gICAgYW5nbGVUbzogZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnkgLSBiLnksIHRoaXMueCAtIGIueCk7XG4gICAgfSxcblxuICAgIGFuZ2xlV2l0aDogZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmdsZVdpdGhTZXAoYi54LCBiLnkpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBhbmdsZSBvZiB0aGUgdHdvIHZlY3RvcnMsIHNvbHZpbmcgdGhlIGZvcm11bGEgZm9yIHRoZSBjcm9zcyBwcm9kdWN0IGEgeCBiID0gfGF8fGJ8c2luKM64KSBmb3IgzrguXG4gICAgYW5nbGVXaXRoU2VwOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKFxuICAgICAgICAgICAgdGhpcy54ICogeSAtIHRoaXMueSAqIHgsXG4gICAgICAgICAgICB0aGlzLnggKiB4ICsgdGhpcy55ICogeSk7XG4gICAgfSxcblxuICAgIF9tYXRNdWx0OiBmdW5jdGlvbihtKSB7XG4gICAgICAgIHZhciB4ID0gbVswXSAqIHRoaXMueCArIG1bMV0gKiB0aGlzLnksXG4gICAgICAgICAgICB5ID0gbVsyXSAqIHRoaXMueCArIG1bM10gKiB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWRkOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMueCArPSBwLng7XG4gICAgICAgIHRoaXMueSArPSBwLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfc3ViOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMueCAtPSBwLng7XG4gICAgICAgIHRoaXMueSAtPSBwLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfbXVsdDogZnVuY3Rpb24oaykge1xuICAgICAgICB0aGlzLnggKj0gaztcbiAgICAgICAgdGhpcy55ICo9IGs7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZGl2OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIHRoaXMueCAvPSBrO1xuICAgICAgICB0aGlzLnkgLz0gaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF91bml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZGl2KHRoaXMubWFnKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3BlcnA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgdGhpcy55ID0gdGhpcy54O1xuICAgICAgICB0aGlzLnggPSAteTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICB4ID0gY29zICogdGhpcy54IC0gc2luICogdGhpcy55LFxuICAgICAgICAgICAgeSA9IHNpbiAqIHRoaXMueCArIGNvcyAqIHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RzIFBvaW50IGZyb20gYW4gYXJyYXkgaWYgbmVjZXNzYXJ5XG5Qb2ludC5jb252ZXJ0ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGFbMF0sIGFbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG4iLCIvKmdsb2JhbCBDYW1lcmEgKi9cclxuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi9nbC9zaGFkZXJfcHJvZ3JhbSc7XHJcblxyXG5pbXBvcnQgZ2xNYXRyaXggZnJvbSAnZ2wtbWF0cml4JztcclxudmFyIG1hdDQgPSBnbE1hdHJpeC5tYXQ0O1xyXG52YXIgdmVjMyA9IGdsTWF0cml4LnZlYzM7XHJcblxyXG4vLyBBYnN0cmFjdCBiYXNlIGNsYXNzXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IobmFtZSwgc2NlbmUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICB0aGlzLnpvb20gPSBvcHRpb25zLnpvb207XHJcbiAgICAgICAgLy8gdGhpcy51cGRhdGVTY2VuZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIGNhbWVyYSBieSB0eXBlIG5hbWUsIGZhY3Rvcnktc3R5bGVcclxuICAgIHN0YXRpYyBjcmVhdGUobmFtZSwgc2NlbmUsIGNvbmZpZykge1xyXG4gICAgICAgIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnaXNvbWV0cmljJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXNvbWV0cmljQ2FtZXJhKG5hbWUsIHNjZW5lLCBjb25maWcpO1xyXG4gICAgICAgICAgICBjYXNlICdmbGF0JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxhdENhbWVyYShuYW1lLCBzY2VuZSwgY29uZmlnKTtcclxuICAgICAgICAgICAgY2FzZSAncGVyc3BlY3RpdmUnOlxyXG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKG5hbWUsIHNjZW5lLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgbWV0aG9kIGNhbGxlZCBvbmNlIHBlciBmcmFtZVxyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIC8vIHRoaXMudXBkYXRlU2NlbmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxsZWQgb25jZSBwZXIgZnJhbWUgcGVyIHByb2dyYW0gKGUuZy4gZm9yIG1haW4gcmVuZGVyIHBhc3MsIHRoZW4gZm9yIGVhY2ggYWRkaXRpb25hbCBwYXNzIGZvciBmZWF0dXJlIHNlbGVjdGlvbiwgZXRjLilcclxuICAgIHNldHVwUHJvZ3JhbShwcm9ncmFtKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgU3luYyBjYW1lcmEgcG9zaXRpb24gYW5kL29yIHpvb20gdG8gc2NlbmVcclxuICAgICAgICBwb3NpdGlvbjogW2xhdCwgbG5nXSBvciBbbGF0LCBsbmcsIHpvb21dXHJcbiAgICAgICAgem9vbTogem9vbVxyXG4gICAgKi9cclxuICAgIHVwZGF0ZVNjZW5lICgpIHtcclxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiB8fCB0aGlzLnpvb20pIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZpZXcgPSB7IGxuZzogdGhpcy5wb3NpdGlvblswXSwgbGF0OiB0aGlzLnBvc2l0aW9uWzFdLCB6b29tOiB0aGlzLnBvc2l0aW9uWzJdIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuem9vbSkge1xyXG4gICAgICAgICAgICAgICAgdmlldy56b29tID0gdGhpcy56b29tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuc2V0Vmlldyh2aWV3KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vKipcclxuICAgIFBlcnNwZWN0aXZlIG1hdHJpeCBwcm9qZWN0aW9uXHJcblxyXG4gICAgVGhpcyBpcyBhIHNwZWNpYWxpemVkIHBlcnNwZWN0aXZlIGNhbWVyYSB0aGF0LCBnaXZlbiBhIGRlc2lyZWQgY2FtZXJhIGZvY2FsIGxlbmd0aCAod2hpY2ggY2FuIGFsc28gdmFyeSBieSB6b29tIGxldmVsKSxcclxuICAgIGNvbnN0cmFpbnMgdGhlIGNhbWVyYSBoZWlnaHQgYWJvdmUgdGhlIGdyb3VuZCBwbGFuZSBzdWNoIHRoYXQgdGhlIGRpc3BsYXllZCBncm91bmQgYXJlYSBvZiB0aGUgbWFwIG1hdGNoZXMgdGhhdCBvZlxyXG4gICAgYSB0cmFkaXRpb25hbCB3ZWIgbWVyY2F0b3IgbWFwLiBUaGlzIG1lYW5zIHlvdSBjYW4gc2V0IHRoZSBjYW1lcmEgbG9jYXRpb24gYnkgW2xhdCwgbG5nLCB6b29tXSBhcyB5b3Ugd291bGQgYSB0eXBpY2FsXHJcbiAgICB3ZWIgbWVyY2F0b3IgbWFwLCB0aGVuIGFkanVzdCB0aGUgZm9jYWwgbGVuZ3RoIGFzIG5lZWRlZC5cclxuXHJcbiAgICBWYW5pc2hpbmcgcG9pbnQgY2FuIGFsc28gYmUgYWRqdXN0ZWQgdG8gYWNoaWV2ZSBkaWZmZXJlbnQgXCJ2aWV3aW5nIGFuZ2xlc1wiLCBlLmcuIGluc3RlYWQgb2YgbG9va2luZyBzdHJhaWdodCBkb3duIGludG9cclxuICAgIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LCB0aGUgY2FtZXJhIGFwcGVhcnMgdG8gYmUgdGlsdGVkIGF0IGFuIGFuZ2xlLiBGb3IgZXhhbXBsZTpcclxuXHJcbiAgICBbMCwgMF0gPSBsb29raW5nIHRvd2FyZHMgY2VudGVyIG9mIHZpZXdwb3J0XHJcbiAgICBbLTI1MCwgLTI1MF0gPSBsb29raW5nIDI1MCBwaXhlbHMgZnJvbSB0aGUgdmlld3BvcnQgY2VudGVyIHRvIHRoZSBsb3dlci1sZWZ0IGNvcm5lclxyXG4gICAgWzQwMCwgMF0gPSBsb29raW5nIDQwMCBwaXhlbHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSB2aWV3cG9ydCBjZW50ZXJcclxuKi9cclxuY2xhc3MgUGVyc3BlY3RpdmVDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjZW5lLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICBzdXBlcihuYW1lLCBzY2VuZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3BlcnNwZWN0aXZlJztcclxuXHJcbiAgICAgICAgLy8gYSBzaW5nbGUgc2NhbGFyLCBvciBwYWlycyBvZiBzdG9wcyBtYXBwaW5nIHpvb20gbGV2ZWxzLCBlLmcuIFt6b29tLCBmb2NhbCBsZW5ndGhdXHJcbiAgICAgICAgdGhpcy5mb2NhbF9sZW5ndGggPSBvcHRpb25zLmZvY2FsX2xlbmd0aDtcclxuICAgICAgICB0aGlzLmZvdiA9IG9wdGlvbnMuZm92O1xyXG4gICAgICAgIGlmICghdGhpcy5mb2NhbF9sZW5ndGggJiYgIXRoaXMuZm92KSB7XHJcbiAgICAgICAgICAgIC8vIERlZmF1bHQgZm9jYWwgbGVuZ3RoIHJhbmdlcyBieSB6b29tXHJcbiAgICAgICAgICAgIHRoaXMuZm9jYWxfbGVuZ3RoID0gW1sxNiwgMl0sIFsxNywgMi41XSwgWzE4LCAzXSwgWzE5LCA0XSwgWzIwLCA2XV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludCA9IG9wdGlvbnMudmFuaXNoaW5nX3BvaW50IHx8IFswLCAwXTsgLy8gW3gsIHldXHJcbiAgICAgICAgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tldyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uX21ldGVycyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52aWV3TWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vICdjYW1lcmEnIGlzIHRoZSBuYW1lIG9mIHRoZSBzaGFkZXIgYmxvY2ssIGUuZy4gZGV0ZXJtaW5lcyB3aGVyZSBpbiB0aGUgc2hhZGVyIHRoaXMgY29kZSBpcyBpbmplY3RlZFxyXG4gICAgICAgIFNoYWRlclByb2dyYW0ucmVwbGFjZUJsb2NrKCdjYW1lcmEnLCBgXHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB1X3Byb2plY3Rpb247XHJcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1X2V5ZTtcclxuICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIHVfdmFuaXNoaW5nX3BvaW50O1xyXG5cclxuICAgICAgICAgICAgdm9pZCBjYW1lcmFQcm9qZWN0aW9uIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHVfcHJvamVjdGlvbiAqIHBvc2l0aW9uO1xyXG4gICAgICAgICAgICB9YFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29uc3RyYWlucyB0aGUgY2FtZXJhIHNvIHRoYXQgdGhlIHZpZXdhYmxlIGFyZWEgbWF0Y2hlcyBnaXZlbiB0aGUgdmlld3BvcnQgaGVpZ2h0XHJcbiAgICAvLyAoaW4gd29ybGQgc3BhY2UsIGUuZy4gbWV0ZXJzKSwgZ2l2ZW4gZWl0aGVyIGEgY2FtZXJhIGZvY2FsIGxlbmd0aCBvciBmaWVsZC1vZi12aWV3XHJcbiAgICAvLyAoZm9jYWwgbGVuZ3RoIGlzIHVzZWQgaWYgYm90aCBhcmUgcGFzc2VkKS5cclxuICAgIGNvbnN0cmFpbkNhbWVyYSh7IHZpZXdfaGVpZ2h0LCBoZWlnaHQsIGZvY2FsX2xlbmd0aCwgZm92IH0pIHtcclxuICAgICAgICAvLyBTb2x2ZSBmb3IgY2FtZXJhIGhlaWdodFxyXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZm9jYWwgbGVuZ3RoLCBjYWxjdWxhdGUgRk9WXHJcbiAgICAgICAgICAgIGlmIChmb2NhbF9sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGZvdiA9IE1hdGguYXRhbigxIC8gZm9jYWxfbGVuZ3RoKSAqIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBGT1YsIGNhbGN1bGF0ZSBmb2NhbCBsZW5ndGhcclxuICAgICAgICAgICAgZWxzZSBpZiAoZm92KSB7XHJcbiAgICAgICAgICAgICAgICBmb3YgPSBmb3YgKiBNYXRoLlBJIC8gMTgwOyAvLyBjb252ZXJ0IEZPViBkZWdyZWVzIHRvIHJhZGlhbnNcclxuICAgICAgICAgICAgICAgIGZvY2FsX2xlbmd0aCA9IDEgLyBNYXRoLnRhbihmb3YgLyAyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGlzdGFuY2UgdGhhdCBjYW1lcmEgc2hvdWxkIGJlIGZyb20gZ3JvdW5kIHN1Y2ggdGhhdCBpdCBmaXRzIHRoZSBmaWVsZCBvZiB2aWV3IGV4cGVjdGVkXHJcbiAgICAgICAgICAgIC8vIGZvciBhIGNvbnZlbnRpb25hbCB3ZWIgbWVyY2F0b3IgbWFwIGF0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYW5kIGNhbWVyYSBmb2NhbCBsZW5ndGhcclxuICAgICAgICAgICAgaGVpZ2h0ID0gdmlld19oZWlnaHQgLyAyICogZm9jYWxfbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTb2x2ZSBmb3IgY2FtZXJhIGZvY2FsIGxlbmd0aCAvIGZpZWxkLW9mLXZpZXdcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9jYWxfbGVuZ3RoID0gMiAqIGhlaWdodCAvIHZpZXdfaGVpZ2h0O1xyXG4gICAgICAgICAgICBmb3YgPSBNYXRoLmF0YW4oMSAvIGZvY2FsX2xlbmd0aCkgKiAyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdmlld19oZWlnaHQsIGhlaWdodCwgZm9jYWxfbGVuZ3RoLCBmb3YgfTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNYXRyaWNlcygpIHtcclxuICAgICAgICAvLyBUT0RPOiBvbmx5IHJlLWNhbGN1bGF0ZSB0aGVzZSB2YXJzIHdoZW4gbmVjZXNzYXJ5XHJcblxyXG4gICAgICAgIC8vIEhlaWdodCBvZiB0aGUgdmlld3BvcnQgaW4gbWV0ZXJzIGF0IGN1cnJlbnQgem9vbVxyXG4gICAgICAgIHZhciB2aWV3cG9ydF9oZWlnaHQgPSB0aGlzLnNjZW5lLmNzc19zaXplLmhlaWdodCAqIEdlby5tZXRlcnNQZXJQaXhlbCh0aGlzLnNjZW5lLnpvb20pO1xyXG5cclxuICAgICAgICAvLyBDb21wdXRlIGNhbWVyYSBwcm9wZXJ0aWVzIHRvIGZpdCBkZXNpcmVkIHZpZXdcclxuICAgICAgICB2YXIgeyBoZWlnaHQsIGZvdiB9ID0gdGhpcy5jb25zdHJhaW5DYW1lcmEoe1xyXG4gICAgICAgICAgICB2aWV3X2hlaWdodDogdmlld3BvcnRfaGVpZ2h0LFxyXG4gICAgICAgICAgICBmb2NhbF9sZW5ndGg6IFV0aWxzLmludGVycG9sYXRlKHRoaXMuc2NlbmUuem9vbSwgdGhpcy5mb2NhbF9sZW5ndGgpLFxyXG4gICAgICAgICAgICBmb3Y6IFV0aWxzLmludGVycG9sYXRlKHRoaXMuc2NlbmUuem9vbSwgdGhpcy5mb3YpXHJcbiAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBWaWV3IG1hdHJpeFxyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IFt0aGlzLnNjZW5lLmNlbnRlcl9tZXRlcnMueCwgdGhpcy5zY2VuZS5jZW50ZXJfbWV0ZXJzLnksIGhlaWdodF07XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbl9tZXRlcnMgPSBwb3NpdGlvbjtcclxuXHJcbiAgICAgICAgLy8gbWF0NC5sb29rQXQodGhpcy52aWV3TWF0cml4LFxyXG4gICAgICAgIC8vICAgICB2ZWMzLmZyb21WYWx1ZXMoLi4ucG9zaXRpb24pLFxyXG4gICAgICAgIC8vICAgICB2ZWMzLmZyb21WYWx1ZXMocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCBoZWlnaHQgLSAxKSxcclxuICAgICAgICAvLyAgICAgdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApKTtcclxuICAgICAgICAvLyBFeGNsdWRlIGNhbWVyYSBoZWlnaHQgZnJvbSB2aWV3IG1hdHJpeFxyXG4gICAgICAgIG1hdDQubG9va0F0KHRoaXMudmlld01hdHJpeCxcclxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgMCksXHJcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIC0xKSxcclxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApKTtcclxuXHJcbiAgICAgICAgLy8gUHJvamVjdGlvbiBtYXRyaXhcclxuICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKHRoaXMucHJvamVjdGlvbk1hdHJpeCwgZm92LCB0aGlzLnNjZW5lLnZpZXdfYXNwZWN0LCAxLCBoZWlnaHQgKiAyKTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB2YW5pc2hpbmcgcG9pbnQgZnJvbSBwaXhlbHMgdG8gdmlld3BvcnQgc3BhY2VcclxuICAgICAgICB0aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzBdID0gdGhpcy52YW5pc2hpbmdfcG9pbnRbMF0gLyB0aGlzLnNjZW5lLmNzc19zaXplLndpZHRoO1xyXG4gICAgICAgIHRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXdbMV0gPSB0aGlzLnZhbmlzaGluZ19wb2ludFsxXSAvIHRoaXMuc2NlbmUuY3NzX3NpemUuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBBZGp1c3QgcHJvamVjdGlvbiBtYXRyaXggdG8gaW5jbHVkZSB2YW5pc2hpbmcgcG9pbnQgc2tld1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeFs4XSA9IC10aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzBdOyAvLyB6IGNvbHVtbiBvZiB4IHJvdywgZS5nLiBhbW91bnQgeiBza2V3cyB4XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzldID0gLXRoaXMudmFuaXNoaW5nX3BvaW50X3NrZXdbMV07IC8vIHogY29sdW1uIG9mIHkgcm93LCBlLmcuIGFtb3VudCB6IHNrZXdzIHlcclxuXHJcbiAgICAgICAgLy8gVHJhbnNsYXRlIGdlb21ldHJ5IGludG8gdGhlIGRpc3RhbmNlIHNvIHRoYXQgY2FtZXJhIGlzIGFwcHJvcHJpYXRlIGhlaWdodCBhYm92ZSBncm91bmRcclxuICAgICAgICAvLyBBZGRpdGlvbmFsbHksIGFkanVzdCB4eSB0byBjb21wZW5zYXRlIGZvciBhbnkgdmFuaXNoaW5nIHBvaW50IHNrZXcsIGUuZy4gbW92ZSBnZW9tZXRyeSBzbyB0aGF0IHRoZSBkaXNwbGF5ZWQgZ1xyXG4gICAgICAgIC8vIHBsYW5lIG9mIHRoZSBtYXAgbWF0Y2hlcyB0aGF0IGV4cGVjdGVkIGJ5IGEgdHJhZGl0aW9uYWwgd2ViIG1lcmNhdG9yIG1hcCBhdCB0aGlzIFtsYXQsIGxuZywgem9vbV0uXHJcbiAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgsXHJcbiAgICAgICAgICAgIHZlYzMuZnJvbVZhbHVlcyhcclxuICAgICAgICAgICAgICAgIHZpZXdwb3J0X2hlaWdodC8yICogdGhpcy5zY2VuZS52aWV3X2FzcGVjdCAqIC10aGlzLnZhbmlzaGluZ19wb2ludF9za2V3WzBdLFxyXG4gICAgICAgICAgICAgICAgdmlld3BvcnRfaGVpZ2h0LzIgKiAtdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tld1sxXSxcclxuICAgICAgICAgICAgICAgIDBcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEluY2x1ZGUgY2FtZXJhIGhlaWdodCBpbiBwcm9qZWN0aW9uIG1hdHJpeFxyXG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMucHJvamVjdGlvbk1hdHJpeCwgdGhpcy5wcm9qZWN0aW9uTWF0cml4LCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgLWhlaWdodCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBzdXBlci51cGRhdGUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpY2VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dXBQcm9ncmFtKHByb2dyYW0pIHtcclxuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJ01hdHJpeDRmdicsICd1X3Byb2plY3Rpb24nLCBmYWxzZSwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KTtcclxuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfZXllJywgMCwgMCwgdGhpcy5wb3NpdGlvbl9tZXRlcnNbMl0pO1xyXG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnMmZ2JywgJ3VfdmFuaXNoaW5nX3BvaW50JywgdGhpcy52YW5pc2hpbmdfcG9pbnRfc2tldyk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vLyBJc29tZXRyaWMtc3R5bGUgcHJvamVjdGlvblxyXG4vLyBOb3RlOiB0aGlzIGlzIGFjdHVhbGx5IGFuIFwiYXhvbm9tZXRyaWNcIiBwcm9qZWN0aW9uLCBidXQgSSdtIHVzaW5nIHRoZSBjb2xsb3F1aWFsIHRlcm0gaXNvbWV0cmljIGJlY2F1c2UgaXQgaXMgbW9yZSByZWNvZ25pemFibGUuXHJcbi8vIEFuIGlzb21ldHJpYyBwcm9qZWN0aW9uIGlzIGEgc3BlY2lmaWMgc3Vic2V0IG9mIGF4b25vbWV0cmljIHByb2plY3Rpb25zLlxyXG4vLyAnYXhpcycgZGV0ZXJtaW5lcyB0aGUgeHkgc2tldyBhcHBsaWVkIHRvIGEgdmVydGV4IGJhc2VkIG9uIGl0cyB6IGNvb3JkaW5hdGUsIGUuZy4gWzAsIDFdIGF4aXMgY2F1c2VzIGJ1aWxkaW5ncyB0byBiZSBkcmF3blxyXG4vLyBzdHJhaWdodCB1cHdhcmRzIG9uIHNjcmVlbiBhdCB0aGVpciB0cnVlIGhlaWdodCwgWzAsIC41XSB3b3VsZCBkcmF3IHRoZW0gdXAgYXQgaGFsZi1oZWlnaHQsIFsxLCAwXSB3b3VsZCBiZSBzaWRld2F5cywgZXRjLlxyXG5jbGFzcyBJc29tZXRyaWNDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjZW5lLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICBzdXBlcihuYW1lLCBzY2VuZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2lzb21ldHJpYyc7XHJcbiAgICAgICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzIHx8IHsgeDogMCwgeTogMSB9O1xyXG4gICAgICAgIGlmICh0aGlzLmF4aXMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXhpcyA9IHsgeDogdGhpcy5heGlzWzBdLCB5OiB0aGlzLmF4aXNbMV0gfTsgLy8gYWxsb3cgYXhpcyB0byBhbHNvIGJlIHBhc3NlZCBhcyAyLWVsZW0gYXJyYXlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb25fbWV0ZXJzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0X2hlaWdodCA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMudmlld01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuICAgICAgICAvLyAnY2FtZXJhJyBpcyB0aGUgbmFtZSBvZiB0aGUgc2hhZGVyIGJsb2NrLCBlLmcuIGRldGVybWluZXMgd2hlcmUgaW4gdGhlIHNoYWRlciB0aGlzIGNvZGUgaXMgaW5qZWN0ZWRcclxuICAgICAgICBTaGFkZXJQcm9ncmFtLnJlcGxhY2VCbG9jaygnY2FtZXJhJywgYFxyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDQgdV9wcm9qZWN0aW9uO1xyXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzMgdV9leWU7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3ZhbmlzaGluZ19wb2ludDtcclxuXHJcbiAgICAgICAgICAgIHZvaWQgY2FtZXJhUHJvamVjdGlvbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB1X3Byb2plY3Rpb24gKiBwb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uLnh5ICs9IHBvc2l0aW9uLnogKiB1X2lzb21ldHJpY19heGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldmVyc2UgeiBmb3IgZGVwdGggYnVmZmVyIHNvIHVwIGlzIG5lZ2F0aXZlLFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHNjYWxlIGRvd24gdmFsdWVzIHNvIG9iamVjdHMgaGlnaGVyIHRoYW4gb25lIHNjcmVlbiBoZWlnaHQgd2lsbCBub3QgZ2V0IGNsaXBwZWRcclxuICAgICAgICAgICAgICAgIC8vIHB1bGwgZm9yd2FyZCBzbGlnaHRseSB0byBhdm9pZCBnb2luZyBwYXN0IGZhciBjbGlwcGluZyBwbGFuZVxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24ueiA9IC1wb3NpdGlvbi56IC8gMTAwLiArIDEuIC0gMC4wMDE7XHJcbiAgICAgICAgICAgIH1gXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlKCk7XHJcblxyXG4gICAgICAgIHRoaXMudmlld3BvcnRfaGVpZ2h0ID0gdGhpcy5zY2VuZS5jc3Nfc2l6ZS5oZWlnaHQgKiBHZW8ubWV0ZXJzUGVyUGl4ZWwodGhpcy5zY2VuZS56b29tKTtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBbdGhpcy5zY2VuZS5jZW50ZXJfbWV0ZXJzLngsIHRoaXMuc2NlbmUuY2VudGVyX21ldGVycy55LCB0aGlzLnZpZXdwb3J0X2hlaWdodF07XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbl9tZXRlcnMgPSBwb3NpdGlvbjtcclxuXHJcbiAgICAgICAgLy8gVmlld1xyXG4gICAgICAgIG1hdDQuaWRlbnRpdHkodGhpcy52aWV3TWF0cml4KTtcclxuICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLnZpZXdNYXRyaXgsIHRoaXMudmlld01hdHJpeCwgdmVjMy5mcm9tVmFsdWVzKC1wb3NpdGlvblswXSwgLXBvc2l0aW9uWzFdLCAwKSk7XHJcblxyXG4gICAgICAgIC8vIFByb2plY3Rpb25cclxuICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMucHJvamVjdGlvbk1hdHJpeCk7XHJcblxyXG4gICAgICAgIC8vIGFwcGx5IGlzb21ldHJpYyBza2V3XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzhdID0gdGhpcy5heGlzLnggLyB0aGlzLnNjZW5lLnZpZXdfYXNwZWN0OyAgICAvLyB6IGNvbHVtbiBvZiB4IHJvdywgZS5nLiBhbW91bnQgeiBza2V3cyB4XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4WzldID0gdGhpcy5heGlzLnk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB6IGNvbHVtbiBvZiB4IHJvdywgZS5nLiBhbW91bnQgeiBza2V3cyB5XHJcblxyXG4gICAgICAgIC8vIGNvbnZlcnQgbWV0ZXJzIHRvIHZpZXdwb3J0XHJcbiAgICAgICAgbWF0NC5zY2FsZSh0aGlzLnByb2plY3Rpb25NYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCxcclxuICAgICAgICAgICAgdmVjMy5mcm9tVmFsdWVzKFxyXG4gICAgICAgICAgICAgICAgMiAvIHRoaXMuc2NlbmUudmlld3BvcnRfbWV0ZXJzLngsXHJcbiAgICAgICAgICAgICAgICAyIC8gdGhpcy5zY2VuZS52aWV3cG9ydF9tZXRlcnMueSxcclxuICAgICAgICAgICAgICAgIDIgLyB0aGlzLnNjZW5lLnZpZXdwb3J0X21ldGVycy55XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHNldHVwUHJvZ3JhbShwcm9ncmFtKSB7XHJcbiAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXg0ZnYnLCAndV9wcm9qZWN0aW9uJywgZmFsc2UsIHRoaXMucHJvamVjdGlvbk1hdHJpeCk7XHJcblxyXG4gICAgICAgIHByb2dyYW0udW5pZm9ybSgnM2YnLCAndV9leWUnLCAwLCAwLCB0aGlzLnZpZXdwb3J0X2hlaWdodCk7XHJcbiAgICAgICAgLy8gcHJvZ3JhbS51bmlmb3JtKCczZicsICd1X2V5ZScsIHRoaXMudmlld3BvcnRfaGVpZ2h0ICogdGhpcy5heGlzLngsIHRoaXMudmlld3BvcnRfaGVpZ2h0ICogdGhpcy5heGlzLnksIHRoaXMudmlld3BvcnRfaGVpZ2h0KTtcclxuICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzJmJywgJ3VfdmFuaXNoaW5nX3BvaW50JywgMCwgMCk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vLyBGbGF0IHByb2plY3Rpb24gKGUuZy4ganVzdCB0b3AtZG93biwgbm8gcGVyc3BlY3RpdmUpIC0gYSBkZWdlbmVyYXRlIGlzb21ldHJpYyBjYW1lcmFcclxuY2xhc3MgRmxhdENhbWVyYSBleHRlbmRzIElzb21ldHJpY0NhbWVyYSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IobmFtZSwgc2NlbmUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKG5hbWUsIHNjZW5lLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZmxhdCc7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIC8vIEF4aXMgaXMgZml4ZWQgdG8gKDAsIDApIGZvciBmbGF0IGNhbWVyYVxyXG4gICAgICAgIHRoaXMuYXhpcy54ID0gMDtcclxuICAgICAgICB0aGlzLmF4aXMueSA9IDA7XHJcblxyXG4gICAgICAgIHN1cGVyLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCIvKmpzaGludCB3b3JrZXI6IHRydWUgKi9cclxuLypnbG9iYWxzIERhdGFTb3VyY2UsIHRvcG9qc29uICovXHJcbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xyXG5pbXBvcnQge01ldGhvZE5vdEltcGxlbWVudGVkfSBmcm9tICcuL3V0aWxzL2Vycm9ycyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhU291cmNlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAoc291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IHNvdXJjZS5pZDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcclxuICAgICAgICB0aGlzLnVybCA9IHNvdXJjZS51cmw7XHJcbiAgICAgICAgLy8gb3Zlcnpvb20gd2lsbCBhcHBseSBmb3Igem9vbXMgaGlnaGVyIHRoYW4gdGhpc1xyXG4gICAgICAgIHRoaXMubWF4X3pvb20gPSBzb3VyY2UubWF4X3pvb20gfHwgR2VvLm1heF96b29tO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIHRpbGUgc291cmNlIGJ5IHR5cGUsIGZhY3Rvcnktc3R5bGVcclxuICAgIHN0YXRpYyBjcmVhdGUgKHNvdXJjZSkge1xyXG4gICAgICAgIGlmIChEYXRhU291cmNlLnR5cGVzW3NvdXJjZS50eXBlXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFTb3VyY2UudHlwZXNbc291cmNlLnR5cGVdKHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1lcmNhdG9yIHByb2plY3Rpb25cclxuICAgIHN0YXRpYyBwcm9qZWN0RGF0YSAoc291cmNlKSB7XHJcbiAgICAgICAgdmFyIHRpbWVyID0gK25ldyBEYXRlKCk7XHJcbiAgICAgICAgZm9yICh2YXIgdCBpbiBzb3VyY2UubGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1fZmVhdHVyZXMgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgZj0wOyBmIDwgbnVtX2ZlYXR1cmVzOyBmKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gc291cmNlLmxheWVyc1t0XS5mZWF0dXJlc1tmXTtcclxuICAgICAgICAgICAgICAgIEdlby50cmFuc2Zvcm1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBjb29yZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIFt4LCB5XSA9IEdlby5sYXRMbmdUb01ldGVycyhjb29yZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMF0gPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvb3JkWzFdID0geTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc291cmNlLmRlYnVnICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc291cmNlLmRlYnVnLnByb2plY3Rpb24gPSArbmV3IERhdGUoKSAtIHRpbWVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICBSZS1zY2FsZSBnZW9tZXRyaWVzIHdpdGhpbiBlYWNoIHNvdXJjZSB0byB0aGUgcmFuZ2UgWzAsIHNjYWxlXVxyXG4gICAgIFRPRE86IGNsaXAgdmVydGljZXMgYXQgZWRnZXM/IHJpZ2h0IG5vdyB2ZXJ0aWNlcyBjYW4gaGF2ZVxyXG4gICAgIHZhbHVlcyBvdXRzaWRlIFswLCBzY2FsZV0gKG92ZXIgb3IgdW5kZXIgYm91bmRzKTsgdGhpcyB3b3VsZFxyXG4gICAgIHBvc2UgYSBwcm9ibGVtIGlmIHdlIHdhbnRlZCB0byBiaW5hcnkgZW5jb2RlIHRoZSB2ZXJ0aWNlcyBpblxyXG4gICAgIGZld2VyIGJpdHMgKGUuZy4gMTIgYml0cyBlYWNoIGZvciBzY2FsZSBvZiA0MDk2KVxyXG4gICAgKi9cclxuICAgIHN0YXRpYyBzY2FsZURhdGEgKHNvdXJjZSwge2Nvb3Jkczoge3p9LCBtaW59KSB7XHJcbiAgICAgICAgZm9yICh2YXIgdCBpbiBzb3VyY2UubGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1fZmVhdHVyZXMgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgZj0wOyBmIDwgbnVtX2ZlYXR1cmVzOyBmKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gc291cmNlLmxheWVyc1t0XS5mZWF0dXJlc1tmXTtcclxuICAgICAgICAgICAgICAgIEdlby50cmFuc2Zvcm1HZW9tZXRyeShmZWF0dXJlLmdlb21ldHJ5LCBjb29yZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMF0gPSAoY29vcmRbMF0gLSBtaW4ueCkgKiBHZW8udW5pdHNfcGVyX21ldGVyW3pdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgd2lsbCBjcmVhdGUgbmVnYXRpdmUgeS1jb29yZHMsIGZvcmNlIHBvc2l0aXZlIGFzIGJlbG93IGluc3RlYWQ/IG9yLCBpZiBsYXRlciBzdG9yaW5nIHBvc2l0aXZlIGNvb3JkcyBpbiBiaXQtcGFja2VkIHZhbHVlcywgZmxpcCB0byBuZWdhdGl2ZSBpbiBwb3N0LXByb2Nlc3Npbmc/XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gPSAoY29vcmRbMV0gLSBtaW4ueSkgKiBHZW8udW5pdHNfcGVyX21ldGVyW3pdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvb3JkWzFdID0gKGNvb3JkWzFdIC0gdGlsZS5tYXgueSkgKiBHZW8udW5pdHNfcGVyX21ldGVyW3RpbGUuY29vcmRzLnpdOyAvLyBhbHRlcm5hdGUgdG8gZm9yY2UgeS1jb29yZHMgdG8gYmUgcG9zaXRpdmUsIHN1YnRyYWN0IHRpbGUgbWF4IGluc3RlYWQgb2YgbWluXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsb2FkKGRlc3QpIHsgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkKCdsb2FkJyk7IH1cclxuXHJcbiAgICAvLyBSZWdpc3RlciBhIG5ldyBkYXRhIHNvdXJjZSB0eXBlXHJcbiAgICBzdGF0aWMgcmVnaXN0ZXIodHlwZV9jbGFzcykge1xyXG4gICAgICAgIGlmICghdHlwZV9jbGFzcyB8fCAhdHlwZV9jbGFzcy50eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIERhdGFTb3VyY2UudHlwZXNbdHlwZV9jbGFzcy50eXBlXSA9IHR5cGVfY2xhc3M7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5EYXRhU291cmNlLnR5cGVzID0ge307IC8vIHNldCBvZiBzdXBwb3J0ZWQgZGF0YSBzb3VyY2UgY2xhc3NlcywgcmVmZXJlbmNlZCBieSB0eXBlIG5hbWVcclxuXHJcblxyXG4vKioqIEdlbmVyaWMgbmV0d29yayBsb2FkaW5nIHNvdXJjZSAtIGFic3RyYWN0IGNsYXNzICoqKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBOZXR3b3JrU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xyXG4gICAgICAgIHN1cGVyKHNvdXJjZSk7XHJcbiAgICAgICAgdGhpcy5yZXNwb25zZV90eXBlID0gXCJcIjsgLy8gdXNlIHRvIHNldCBleHBsaWNpdCBYSFIgdHlwZVxyXG4gICAgfVxyXG5cclxuICAgIGxvYWQgKGRlc3QpIHtcclxuICAgICAgICBsZXQgdXJsID0gdGhpcy5mb3JtYXRVcmwoZGVzdCk7XHJcblxyXG4gICAgICAgIGlmIChkZXN0LnNvdXJjZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZXN0LnNvdXJjZXMgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzb3VyY2UgPSBkZXN0LnNvdXJjZXNbdGhpcy5uYW1lXSA9IHt9O1xyXG5cclxuICAgICAgICBzb3VyY2UudXJsID0gdXJsO1xyXG4gICAgICAgIHNvdXJjZS5kZWJ1ZyA9IHt9O1xyXG4gICAgICAgIHNvdXJjZS5kZWJ1Zy5uZXR3b3JrID0gK25ldyBEYXRlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5lcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIEZvciB0ZXN0aW5nIG5ldHdvcmsgZXJyb3JzXHJcbiAgICAgICAgICAgIC8vIHZhciBwcm9taXNlID0gVXRpbHMuaW8odXJsLCA2MCAqIDEwMCwgdGhpcy5yZXNwb25zZV90eXBlKTtcclxuICAgICAgICAgICAgLy8gaWYgKE1hdGgucmFuZG9tKCkgPCAuNykge1xyXG4gICAgICAgICAgICAvLyAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KEVycm9yKCdmYWtlIGRhdGEgc291cmNlIGVycm9yJykpO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIC8vIHByb21pc2UudGhlbigoYm9keSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IFV0aWxzLmlvKHVybCwgNjAgKiAxMDAwLCB0aGlzLnJlc3BvbnNlX3R5cGUpO1xyXG4gICAgICAgICAgICBzb3VyY2UucmVxdWVzdCA9IHByb21pc2UucmVxdWVzdDtcclxuXHJcbiAgICAgICAgICAgIHByb21pc2UudGhlbigoYm9keSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc291cmNlLmRlYnVnLnJlc3BvbnNlX3NpemUgPSBib2R5Lmxlbmd0aCB8fCBib2R5LmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuZGVidWcubmV0d29yayA9ICtuZXcgRGF0ZSgpIC0gc291cmNlLmRlYnVnLm5ldHdvcms7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuZGVidWcucGFyc2luZyA9ICtuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVNvdXJjZURhdGEoZGVzdCwgc291cmNlLCBib2R5KTtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5kZWJ1Zy5wYXJzaW5nID0gK25ldyBEYXRlKCkgLSBzb3VyY2UuZGVidWcucGFyc2luZztcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdCk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgc291cmNlLmVycm9yID0gZXJyb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdCk7IC8vIHJlc29sdmUgcmVxdWVzdCBidXQgcGFzcyBhbG9uZyBlcnJvclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdWItY2xhc3NlcyBtdXN0IGltcGxlbWVudDpcclxuXHJcbiAgICBmb3JtYXRVcmwgKGRlc3QpIHtcclxuICAgICAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWQoJ2Zvcm1hdFVybCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlU291cmNlRGF0YSAoZGVzdCwgc291cmNlLCByZXBvbnNlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkKCdwYXJzZVNvdXJjZURhdGEnKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKiogR2VuZXJpYyBuZXR3b3JrIHRpbGUgbG9hZGluZyAtIGFic3RyYWN0IGNsYXNzICoqKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBOZXR3b3JrVGlsZVNvdXJjZSBleHRlbmRzIE5ldHdvcmtTb3VyY2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChzb3VyY2UpIHtcclxuICAgICAgICBzdXBlcihzb3VyY2UpO1xyXG5cclxuICAgICAgICB0aGlzLnRpbGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnVybF9ob3N0cyA9IG51bGw7XHJcbiAgICAgICAgdmFyIGhvc3RfbWF0Y2ggPSB0aGlzLnVybC5tYXRjaCgve3M6XFxbKFtefStdKylcXF19Lyk7XHJcbiAgICAgICAgaWYgKGhvc3RfbWF0Y2ggIT0gbnVsbCAmJiBob3N0X21hdGNoLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgdGhpcy51cmxfaG9zdHMgPSBob3N0X21hdGNoWzFdLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dF9ob3N0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0VXJsKHRpbGUpIHtcclxuICAgICAgICB2YXIgdXJsID0gdGhpcy51cmwucmVwbGFjZSgne3h9JywgdGlsZS5jb29yZHMueCkucmVwbGFjZSgne3l9JywgdGlsZS5jb29yZHMueSkucmVwbGFjZSgne3p9JywgdGlsZS5jb29yZHMueik7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnVybF9ob3N0cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC97czpcXFsoW159K10rKVxcXX0vLCB0aGlzLnVybF9ob3N0c1t0aGlzLm5leHRfaG9zdF0pO1xyXG4gICAgICAgICAgICB0aGlzLm5leHRfaG9zdCA9ICh0aGlzLm5leHRfaG9zdCArIDEpICUgdGhpcy51cmxfaG9zdHMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gR2VvSlNPTiBzdGFuZGFsb25lIChub24tdGlsZWQpIHNvdXJjZVxyXG4qL1xyXG5cclxuZXhwb3J0IGNsYXNzIEdlb0pTT05Tb3VyY2UgZXh0ZW5kcyBOZXR3b3JrU291cmNlIHtcclxuXHJcbiAgICBmb3JtYXRVcmwgKGRlc3QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cmw7XHJcbiAgICB9XHJcblxyXG4gICAgcGFyc2VTb3VyY2VEYXRhICh0aWxlLCBzb3VyY2UsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgc291cmNlLmxheWVycyA9IHsgX2RlZmF1bHQ6IEpTT04ucGFyc2UocmVzcG9uc2UpIH07XHJcbiAgICAgICAgRGF0YVNvdXJjZS5wcm9qZWN0RGF0YShzb3VyY2UpOyAvLyBtZXJjYXRvciBwcm9qZWN0aW9uXHJcbiAgICB9XHJcbn1cclxuXHJcbkdlb0pTT05Tb3VyY2UudHlwZSA9ICdHZW9KU09OJztcclxuRGF0YVNvdXJjZS5yZWdpc3RlcihHZW9KU09OU291cmNlKTtcclxuXHJcblxyXG4vKipcclxuIE1hcHplbi9PU00uVVMtc3R5bGUgR2VvSlNPTiB2ZWN0b3IgdGlsZXNcclxuIEBjbGFzcyBHZW9KU09OVGlsZVNvdXJjZVxyXG4qL1xyXG5leHBvcnQgY2xhc3MgR2VvSlNPTlRpbGVTb3VyY2UgZXh0ZW5kcyBOZXR3b3JrVGlsZVNvdXJjZSB7XHJcblxyXG4gICAgcGFyc2VTb3VyY2VEYXRhICh0aWxlLCBzb3VyY2UsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcclxuXHJcbiAgICAgICAgLy8gU2luZ2xlIGxheWVyIG9yIG11bHRpLWxheWVycz9cclxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnRmVhdHVyZScgfHwgZGF0YS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5sYXllcnMgPSB7IF9kZWZhdWx0OiBkYXRhIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzb3VyY2UubGF5ZXJzID0gZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIERhdGFTb3VyY2UucHJvamVjdERhdGEoc291cmNlKTsgLy8gbWVyY2F0b3IgcHJvamVjdGlvblxyXG4gICAgICAgIERhdGFTb3VyY2Uuc2NhbGVEYXRhKHNvdXJjZSwgdGlsZSk7IC8vIHJlLXNjYWxlIGZyb20gbWV0ZXJzIHRvIGxvY2FsIHRpbGUgY29vcmRzXHJcbiAgICB9XHJcbn1cclxuXHJcbkdlb0pTT05UaWxlU291cmNlLnR5cGUgPSAnR2VvSlNPTlRpbGVzJztcclxuRGF0YVNvdXJjZS5yZWdpc3RlcihHZW9KU09OVGlsZVNvdXJjZSk7XHJcblxyXG5cclxuLyoqKiBNYXB6ZW4vT1NNLlVTLXN0eWxlIFRvcG9KU09OIHZlY3RvciB0aWxlcyAqKiovXHJcbmV4cG9ydCBjbGFzcyBUb3BvSlNPTlRpbGVTb3VyY2UgZXh0ZW5kcyBOZXR3b3JrVGlsZVNvdXJjZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xyXG4gICAgICAgIHN1cGVyKHNvdXJjZSk7XHJcblxyXG4gICAgICAgIC8vIExvYWRzIFRvcG9KU09OIGxpYnJhcnkgZnJvbSBvZmZpY2lhbCBEMyBzb3VyY2Ugb24gZGVtYW5kXHJcbiAgICAgICAgLy8gTm90IGluY2x1ZGluZyBpbiBiYXNlIGxpYnJhcnkgdG8gYXZvaWQgdGhlIGV4dHJhIHdlaWdodFxyXG4gICAgICAgIC8vIE9ubHkgbG9hZGVkIGluIHdvcmtlciBzaW5jZSB0aGF0IGlzIHdoZXJlIGRhdGEgaXMgcHJvY2Vzc2VkXHJcbiAgICAgICAgaWYgKFV0aWxzLmlzV29ya2VyVGhyZWFkICYmIHR5cGVvZiB0b3BvanNvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGltcG9ydFNjcmlwdHMoJ2h0dHA6Ly9kM2pzLm9yZy90b3BvanNvbi52MS5taW4uanMnKTtcclxuICAgICAgICAgICAgICAgIGxvZy5pbmZvKCdUb3BvSlNPTlRpbGVTb3VyY2U6IGxvYWRlZCB0b3BvanNvbiBsaWJyYXJ5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGxvZy5lcnJvcignVG9wb0pTT05UaWxlU291cmNlOiBmYWlsZWQgdG8gbG9hZCBUb3BvSlNPTiBsaWJyYXJ5IScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlU291cmNlRGF0YSAodGlsZSwgc291cmNlLCByZXNwb25zZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdG9wb2pzb24gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRpbGUubGF5ZXJzID0ge307XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNvdXJjZS5sYXllcnMgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcclxuXHJcbiAgICAgICAgLy8gU2luZ2xlIGxheWVyXHJcbiAgICAgICAgaWYgKHNvdXJjZS5sYXllcnMub2JqZWN0cy52ZWN0aWxlcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5sYXllcnMgPSB7IF9kZWZhdWx0OiB0b3BvanNvbi5mZWF0dXJlKHNvdXJjZS5sYXllcnMsIHNvdXJjZS5sYXllcnMub2JqZWN0cy52ZWN0aWxlcykgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTXVsdGlwbGUgbGF5ZXJzXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsYXllcnMgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgdCBpbiBzb3VyY2UubGF5ZXJzLm9iamVjdHMpIHtcclxuICAgICAgICAgICAgICAgIGxheWVyc1t0XSA9IHRvcG9qc29uLmZlYXR1cmUoc291cmNlLmxheWVycywgc291cmNlLmxheWVycy5vYmplY3RzW3RdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzb3VyY2UubGF5ZXJzID0gbGF5ZXJzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgRGF0YVNvdXJjZS5wcm9qZWN0RGF0YShzb3VyY2UpOyAvLyBtZXJjYXRvciBwcm9qZWN0aW9uXHJcbiAgICAgICAgRGF0YVNvdXJjZS5zY2FsZURhdGEoc291cmNlLCB0aWxlKTsgLy8gcmUtc2NhbGUgZnJvbSBtZXRlcnMgdG8gbG9jYWwgdGlsZSBjb29yZHNcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblRvcG9KU09OVGlsZVNvdXJjZS50eXBlID0gJ1RvcG9KU09OVGlsZXMnO1xyXG5EYXRhU291cmNlLnJlZ2lzdGVyKFRvcG9KU09OVGlsZVNvdXJjZSk7XHJcblxyXG5cclxuXHJcbi8qKiogTWFwYm94IHZlY3RvciB0aWxlcyAqKiovXHJcblxyXG5leHBvcnQgY2xhc3MgTVZUU291cmNlIGV4dGVuZHMgTmV0d29ya1RpbGVTb3VyY2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChzb3VyY2UpIHtcclxuICAgICAgICBzdXBlcihzb3VyY2UpO1xyXG4gICAgICAgIHRoaXMucmVzcG9uc2VfdHlwZSA9IFwiYXJyYXlidWZmZXJcIjsgLy8gYmluYXJ5IGRhdGFcclxuICAgICAgICB0aGlzLlByb3RvYnVmID0gcmVxdWlyZSgncGJmJyk7XHJcbiAgICAgICAgdGhpcy5WZWN0b3JUaWxlID0gcmVxdWlyZSgndmVjdG9yLXRpbGUnKS5WZWN0b3JUaWxlOyAvLyBNYXBib3ggdmVjdG9yIHRpbGUgbGliXHJcbiAgICAgICAgdGhpcy5WZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJykuVmVjdG9yVGlsZUZlYXR1cmU7XHJcblxyXG4gICAgICAgIHRoaXMucGFkX3NjYWxlID0gc291cmNlLnBhZF9zY2FsZSB8fCAwLjAwMTsgLy8gc2NhbGUgdGlsZSB1cCBieSB0aGlzIGZhY3RvciAoMC4xJSkgdG8gY292ZXIgc2VhbXNcclxuICAgIH1cclxuXHJcbiAgICBwYXJzZVNvdXJjZURhdGEgKHRpbGUsIHNvdXJjZSwgcmVzcG9uc2UpIHtcclxuICAgICAgICAvLyBDb252ZXJ0IE1hcGJveCB2ZWN0b3IgdGlsZSB0byBHZW9KU09OXHJcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShyZXNwb25zZSk7XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyB0aGlzLlByb3RvYnVmKGRhdGEpO1xyXG4gICAgICAgIHNvdXJjZS5kYXRhID0gbmV3IHRoaXMuVmVjdG9yVGlsZShidWZmZXIpO1xyXG4gICAgICAgIHNvdXJjZS5sYXllcnMgPSB0aGlzLnRvR2VvSlNPTihzb3VyY2UuZGF0YSk7XHJcbiAgICAgICAgZGVsZXRlIHNvdXJjZS5kYXRhOyAvLyBjb21tZW50IG91dCB0byBzYXZlIHJhdyBkYXRhIGZvciBkZWJ1Z2dpbmdcclxuXHJcbiAgICAgICAgLy8gUG9zdC1wcm9jZXNzaW5nXHJcbiAgICAgICAgZm9yICh2YXIgdCBpbiBzb3VyY2UubGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1fZmVhdHVyZXMgPSBzb3VyY2UubGF5ZXJzW3RdLmZlYXR1cmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgZj0wOyBmIDwgbnVtX2ZlYXR1cmVzOyBmKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gc291cmNlLmxheWVyc1t0XS5mZWF0dXJlc1tmXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IE9TTSBpZFxyXG4gICAgICAgICAgICAgICAgR2VvLnRyYW5zZm9ybUdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIGNvb3JkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTbGlnaHRseSBzY2FsZSB1cCB0aWxlIHRvIGNvdmVyIHNlYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRbMF0gPSBNYXRoLnJvdW5kKGNvb3JkWzBdICogKDEgKyB0aGlzLnBhZF9zY2FsZSkgLSAoNDA5NiAqIHRoaXMucGFkX3NjYWxlLzIpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSA9IE1hdGgucm91bmQoY29vcmRbMV0gKiAoMSArIHRoaXMucGFkX3NjYWxlKSAtICg0MDk2ICogdGhpcy5wYWRfc2NhbGUvMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGbGlwIFkgY29vcmRcclxuICAgICAgICAgICAgICAgICAgICBjb29yZFsxXSA9IC1jb29yZFsxXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIExvb3AgdGhyb3VnaCBsYXllcnMvZmVhdHVyZXMgdXNpbmcgTWFwYm94IGxpYiBBUEksIGNvbnZlcnQgdG8gR2VvSlNPTiBmZWF0dXJlc1xyXG4gICAgLy8gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBrZXlzIGZvciBlYWNoIGxheWVyLCBlLmcuIHsgbGF5ZXI6IGdlb2pzb24gfVxyXG4gICAgdG9HZW9KU09OICh0aWxlKSB7XHJcbiAgICAgICAgdmFyIGxheWVycyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGwgaW4gdGlsZS5sYXllcnMpIHtcclxuICAgICAgICAgICAgdmFyIGxheWVyID0gdGlsZS5sYXllcnNbbF07XHJcbiAgICAgICAgICAgIHZhciBsYXllcl9nZW9qc29uID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVzOiBbXVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgZj0wOyBmIDwgbGF5ZXIubGVuZ3RoOyBmKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gbGF5ZXIuZmVhdHVyZShmKTtcclxuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlX2dlb2pzb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBmZWF0dXJlLnByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZV9nZW9qc29uLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZmVhdHVyZS5sb2FkR2VvbWV0cnkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHI9MDsgciA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgcisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJpbmcgPSBjb29yZGluYXRlc1tyXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjPTA7IGMgPCByaW5nLmxlbmd0aDsgYysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpbmdbY10gPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaW5nW2NdLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaW5nW2NdLnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLlZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW2ZlYXR1cmUudHlwZV0gPT09ICdQb2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID0gJ1BvaW50JztcclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5WZWN0b3JUaWxlRmVhdHVyZS50eXBlc1tmZWF0dXJlLnR5cGVdID09PSAnTGluZVN0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnR5cGUgPSAnTGluZVN0cmluZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID0gJ011bHRpTGluZVN0cmluZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5WZWN0b3JUaWxlRmVhdHVyZS50eXBlc1tmZWF0dXJlLnR5cGVdID09PSAnUG9seWdvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS50eXBlID0gJ1BvbHlnb24nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxheWVyX2dlb2pzb24uZmVhdHVyZXMucHVzaChmZWF0dXJlX2dlb2pzb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxheWVyc1tsXSA9IGxheWVyX2dlb2pzb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsYXllcnM7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5NVlRTb3VyY2UudHlwZSA9ICdNVlQnO1xyXG5EYXRhU291cmNlLnJlZ2lzdGVyKE1WVFNvdXJjZSk7XHJcbiIsIi8vIE1pc2NlbGxhbmVvdXMgZ2VvIGZ1bmN0aW9uc1xyXG5cclxudmFyIEdlbztcclxuZXhwb3J0IGRlZmF1bHQgR2VvID0ge307XHJcblxyXG4vLyBQcm9qZWN0aW9uIGNvbnN0YW50c1xyXG5HZW8udGlsZV9zaXplID0gMjU2O1xyXG5HZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyA9IDIwMDM3NTA4LjM0Mjc4OTI0NDtcclxuR2VvLm1pbl96b29tX21ldGVyc19wZXJfcGl4ZWwgPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyAqIDIgLyBHZW8udGlsZV9zaXplOyAvLyBtaW4gem9vbSBkcmF3cyB3b3JsZCBhcyAyIHRpbGVzIHdpZGVcclxuR2VvLm1ldGVyc19wZXJfcGl4ZWwgPSBbXTtcclxuR2VvLm1heF96b29tID0gMjA7XHJcbmZvciAodmFyIHo9MDsgeiA8PSBHZW8ubWF4X3pvb207IHorKykge1xyXG4gICAgR2VvLm1ldGVyc19wZXJfcGl4ZWxbel0gPSBHZW8ubWluX3pvb21fbWV0ZXJzX3Blcl9waXhlbCAvIE1hdGgucG93KDIsIHopO1xyXG59XHJcblxyXG5HZW8ubWV0ZXJzUGVyUGl4ZWwgPSBmdW5jdGlvbiAoem9vbSkge1xyXG4gICAgcmV0dXJuIEdlby5taW5fem9vbV9tZXRlcnNfcGVyX3BpeGVsIC8gTWF0aC5wb3coMiwgem9vbSk7XHJcbn07XHJcblxyXG4vLyBDb252ZXJzaW9uIGZ1bmN0aW9ucyBiYXNlZCBvbiBhbiBkZWZpbmVkIHRpbGUgc2NhbGVcclxuR2VvLnVuaXRzX3Blcl9tZXRlciA9IFtdO1xyXG5HZW8uc2V0VGlsZVNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcclxuICAgIEdlby50aWxlX3NjYWxlID0gc2NhbGU7XHJcbiAgICBHZW8udW5pdHNfcGVyX3BpeGVsID0gR2VvLnRpbGVfc2NhbGUgLyBHZW8udGlsZV9zaXplO1xyXG5cclxuICAgIGZvciAodmFyIHo9MDsgeiA8PSBHZW8ubWF4X3pvb207IHorKykge1xyXG4gICAgICAgIEdlby51bml0c19wZXJfbWV0ZXJbel0gPSBHZW8udGlsZV9zY2FsZSAvIChHZW8udGlsZV9zaXplICogR2VvLm1ldGVyc19wZXJfcGl4ZWxbel0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQ29udmVydCB0aWxlIGxvY2F0aW9uIHRvIG1lcmNhdG9yIG1ldGVycyAtIG11bHRpcGx5IGJ5IHBpeGVscyBwZXIgdGlsZSwgdGhlbiBieSBtZXRlcnMgcGVyIHBpeGVsLCBhZGp1c3QgZm9yIG1hcCBvcmlnaW5cclxuR2VvLm1ldGVyc0ZvclRpbGUgPSBmdW5jdGlvbiAodGlsZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiB0aWxlLnggKiBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyAqIDIgLyBNYXRoLnBvdygyLCB0aWxlLnopIC0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMsXHJcbiAgICAgICAgeTogLSh0aWxlLnkgKiBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycyAqIDIgLyBNYXRoLnBvdygyLCB0aWxlLnopIC0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMpXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAgIEdpdmVuIGEgcG9pbnQgaW4gbWVyY2F0b3IgbWV0ZXJzIGFuZCBhIHpvb20gbGV2ZWwsIHJldHVybiB0aGUgdGlsZSBYL1kvWiB0aGF0IHRoZSBwb2ludCBsaWVzIGluXHJcbiovXHJcbkdlby50aWxlRm9yTWV0ZXJzID0gZnVuY3Rpb24gKFt4LCB5XSwgem9vbSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBNYXRoLmZsb29yKCh4ICsgR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMpIC8gKEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzICogMiAvIE1hdGgucG93KDIsIHpvb20pKSksXHJcbiAgICAgICAgeTogTWF0aC5mbG9vcigoLXkgKyBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycykgLyAoR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgKiAyIC8gTWF0aC5wb3coMiwgem9vbSkpKSxcclxuICAgICAgICB6OiB6b29tXHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAgIENvbnZlcnQgbWVyY2F0b3IgbWV0ZXJzIHRvIGxhdC1sbmdcclxuKi9cclxuR2VvLm1ldGVyc1RvTGF0TG5nID0gZnVuY3Rpb24gKFt4LCB5XSkge1xyXG5cclxuICAgIHggLz0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnM7XHJcbiAgICB5IC89IEdlby5oYWxmX2NpcmN1bWZlcmVuY2VfbWV0ZXJzO1xyXG5cclxuICAgIHkgPSAoMiAqIE1hdGguYXRhbihNYXRoLmV4cCh5ICogTWF0aC5QSSkpIC0gKE1hdGguUEkgLyAyKSkgLyBNYXRoLlBJO1xyXG5cclxuICAgIHggKj0gMTgwO1xyXG4gICAgeSAqPSAxODA7XHJcblxyXG4gICAgcmV0dXJuIFt4LCB5XTtcclxufTtcclxuXHJcbi8qKlxyXG4gIENvbnZlcnQgbGF0LWxuZyB0byBtZXJjYXRvciBtZXRlcnNcclxuKi9cclxuR2VvLmxhdExuZ1RvTWV0ZXJzID0gZnVuY3Rpb24oW3gsIHldKSB7XHJcblxyXG4gICAgLy8gTGF0aXR1ZGVcclxuICAgIHkgPSBNYXRoLmxvZyhNYXRoLnRhbih5Kk1hdGguUEkvMzYwICsgTWF0aC5QSS80KSkgLyBNYXRoLlBJO1xyXG4gICAgeSAqPSBHZW8uaGFsZl9jaXJjdW1mZXJlbmNlX21ldGVycztcclxuXHJcbiAgICAvLyBMb25naXR1ZGVcclxuICAgIHggKj0gR2VvLmhhbGZfY2lyY3VtZmVyZW5jZV9tZXRlcnMgLyAxODA7XHJcblxyXG4gICAgcmV0dXJuIFt4LCB5XTtcclxufTtcclxuXHJcbi8vIFJ1biBhbiBpbi1wbGFjZSB0cmFuc2Zvcm0gZnVuY3Rpb24gb24gZWFjaCBjb29vcmRpbmF0ZSBpbiBhIEdlb0pTT04gZ2VvbWV0cnlcclxuR2VvLnRyYW5zZm9ybUdlb21ldHJ5ID0gZnVuY3Rpb24gKGdlb21ldHJ5LCB0cmFuc2Zvcm0pIHtcclxuICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XHJcbiAgICAgICAgdHJhbnNmb3JtKGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcclxuICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcclxuICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKGNvb3JkaW5hdGVzID0+IGNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xyXG4gICAgICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2gocG9seWdvbiA9PiB7XHJcbiAgICAgICAgICAgIHBvbHlnb24uZm9yRWFjaChjb29yZGluYXRlcyA9PiBjb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb25cclxufTtcclxuXHJcbkdlby5ib3hJbnRlcnNlY3QgPSBmdW5jdGlvbiAoYjEsIGIyKSB7XHJcbiAgICByZXR1cm4gIShcclxuICAgICAgICBiMi5zdy54ID4gYjEubmUueCB8fFxyXG4gICAgICAgIGIyLm5lLnggPCBiMS5zdy54IHx8XHJcbiAgICAgICAgYjIuc3cueSA+IGIxLm5lLnkgfHxcclxuICAgICAgICBiMi5uZS55IDwgYjEuc3cueVxyXG4gICAgKTtcclxufTtcclxuXHJcbi8vIEZpbmRzIHRoZSBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhIHBvbHlnb25cclxuR2VvLmZpbmRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChwb2x5Z29uKSB7XHJcbiAgICB2YXIgbWluX3ggPSBJbmZpbml0eSxcclxuICAgICAgICBtYXhfeCA9IC1JbmZpbml0eSxcclxuICAgICAgICBtaW5feSA9IEluZmluaXR5LFxyXG4gICAgICAgIG1heF95ID0gLUluZmluaXR5O1xyXG5cclxuICAgIC8vIE9ubHkgbmVlZCB0byBleGFtaW5lIG91dGVyIHJpbmcgKHBvbHlnb25bMF0pXHJcbiAgICB2YXIgbnVtX2Nvb3JkcyA9IHBvbHlnb25bMF0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgYz0wOyBjIDwgbnVtX2Nvb3JkczsgYysrKSB7XHJcbiAgICAgICAgdmFyIGNvb3JkID0gcG9seWdvblswXVtjXTtcclxuXHJcbiAgICAgICAgaWYgKGNvb3JkWzBdIDwgbWluX3gpIHtcclxuICAgICAgICAgICAgbWluX3ggPSBjb29yZFswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvb3JkWzFdIDwgbWluX3kpIHtcclxuICAgICAgICAgICAgbWluX3kgPSBjb29yZFsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvb3JkWzBdID4gbWF4X3gpIHtcclxuICAgICAgICAgICAgbWF4X3ggPSBjb29yZFswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvb3JkWzFdID4gbWF4X3kpIHtcclxuICAgICAgICAgICAgbWF4X3kgPSBjb29yZFsxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFttaW5feCwgbWluX3ksIG1heF94LCBtYXhfeV07XHJcbn07XHJcblxyXG4vLyBDb252ZXJ0IGdlb21ldHJ5IHR5cGUgdG8gb25lIG9mOiAncG9pbnQnLCAnbGluZScsICdwb2x5Z29uJ1xyXG5HZW8uZ2VvbWV0cnlUeXBlID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09ICdQb2x5Z29uJyB8fCB0eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xyXG4gICAgICAgIHJldHVybiAncG9seWdvbic7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycgfHwgdHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gJ2xpbmUnO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGUgPT09ICdQb2ludCcgfHwgdHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcbiAgICAgICAgcmV0dXJuICdwb2ludCc7XHJcbiAgICB9XHJcbn07XHJcbiIsIi8vIFdlYkdMIGNvbnN0YW50cyAtIG5lZWQgdG8gaW1wb3J0IHRoZXNlIHNlcGFyYXRlbHkgdG8gbWFrZSB0aGVtIGF2YWlsYWJsZSBpbiB0aGUgd2ViIHdvcmtlclxyXG5cclxudmFyIGdsO1xyXG5leHBvcnQgZGVmYXVsdCBnbCA9IHt9O1xyXG5cclxuLyogRGF0YVR5cGUgKi9cclxuZ2wuQllURSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDAwO1xyXG5nbC5VTlNJR05FRF9CWVRFICAgICAgICAgICAgICAgICAgPSAweDE0MDE7XHJcbmdsLlNIT1JUICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MTQwMjtcclxuZ2wuVU5TSUdORURfU0hPUlQgICAgICAgICAgICAgICAgID0gMHgxNDAzO1xyXG5nbC5JTlQgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDE0MDQ7XHJcbmdsLlVOU0lHTkVEX0lOVCAgICAgICAgICAgICAgICAgICA9IDB4MTQwNTtcclxuZ2wuRkxPQVQgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgxNDA2O1xyXG4iLCIvLyBXZWJHTCBjb250ZXh0IHdyYXBwZXJcclxuXHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5cclxudmFyIENvbnRleHQ7XHJcbmV4cG9ydCBkZWZhdWx0IENvbnRleHQgPSB7fTtcclxuXHJcbi8vIFNldHVwIGEgV2ViR0wgY29udGV4dFxyXG4vLyBJZiBubyBjYW52YXMgZWxlbWVudCBpcyBwcm92aWRlZCwgb25lIGlzIGNyZWF0ZWQgYW5kIGFkZGVkIHRvIHRoZSBkb2N1bWVudCBib2R5XHJcbkNvbnRleHQuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQgKGNhbnZhcywgb3B0aW9ucylcclxue1xyXG5cclxuICAgIHZhciBmdWxsc2NyZWVuID0gZmFsc2U7XHJcbiAgICBpZiAoY2FudmFzID09IG51bGwpIHtcclxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAwO1xyXG4gICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gMDtcclxuICAgICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gLTE7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xyXG4gICAgICAgIGZ1bGxzY3JlZW4gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRpb25zKTtcclxuICAgIGlmICghZ2wpIHtcclxuICAgICAgICBsb2cuZXJyb3IoXCJDb3VsZG4ndCBjcmVhdGUgV2ViR0wgY29udGV4dC4gWW91ciBicm93c2VyIHByb2JhYmx5IGRvZXNuJ3Qgc3VwcG9ydCBXZWJHTCBvciBpdCdzIHR1cm5lZCBvZmY/XCIpO1xyXG4gICAgICAgIGFsZXJ0KFwiQ291bGRuJ3QgY3JlYXRlIFdlYkdMIGNvbnRleHQuIFlvdXIgYnJvd3NlciBwcm9iYWJseSBkb2Vzbid0IHN1cHBvcnQgV2ViR0wgb3IgaXQncyB0dXJuZWQgb2ZmP1wiKTtcclxuICAgICAgICB0aHJvdyBcIkNvdWxkbid0IGNyZWF0ZSBXZWJHTCBjb250ZXh0XCI7XHJcbiAgICB9XHJcblxyXG4gICAgQ29udGV4dC5yZXNpemUoZ2wsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xyXG4gICAgaWYgKGZ1bGxzY3JlZW4gPT09IHRydWUpIHtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBDb250ZXh0LnJlc2l6ZShnbCwgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGdsO1xyXG59O1xyXG5cclxuQ29udGV4dC5yZXNpemUgPSBmdW5jdGlvbiAoZ2wsIHdpZHRoLCBoZWlnaHQpXHJcbntcclxuICAgIHZhciBkZXZpY2VfcGl4ZWxfcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgZ2wuY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG4gICAgZ2wuY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XHJcbiAgICBnbC5jYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5zdHlsZS53aWR0aCAqIGRldmljZV9waXhlbF9yYXRpbyk7XHJcbiAgICBnbC5jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZChnbC5jYW52YXMuc3R5bGUud2lkdGggKiBkZXZpY2VfcGl4ZWxfcmF0aW8pO1xyXG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcclxufTtcclxuIiwidmFyIEdMU0wgPSB7fTtcclxuZXhwb3J0IGRlZmF1bHQgR0xTTDtcclxuXHJcbi8qKlxyXG4gICAgUGFyc2UgdW5pZm9ybXMgZnJvbSBhIEpTIG9iamVjdCwgaW5mZXJzIHR5cGVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGVcclxuICAgIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBzZXQgdW5pZm9ybSB2YWx1ZXMgb24gYSBHTCBwcm9ncmFtLiBFYWNoIG9iamVjdCBpbiB0aGUgcmV0dXJuZWRcclxuICAgIGFycmF5IGhhcyB0aGUgZm9ybTpcclxuICAgIHsgdHlwZSwgbWV0aG9kLCBuYW1lLCB2YWx1ZSB9XHJcblxyXG4gICAgdHlwZTogdGhlIEdMIHVuaWZvcm0gdHlwZSwgc3VjaCBhcyAndmVjMycsICdmbG9hdCcsIGV0Yy5cclxuICAgIG1ldGhvZDogdGhlIEdMIHVuaWZvcm0gc2V0dGVyIG1ldGhvZCB0byB1c2UsIHN1Y2ggYXMgJzFmJywgJzNmdicsIGV0Yy5cclxuICAgIG5hbWU6IHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvZiB0aGUgR0wgdW5pZm9ybSBsb2NhdGlvbiwgZS5nLiAnYXJyYXlbMF0uZmllbGQnLCBldGMuXHJcbiAgICB2YWx1ZTogdGhlIHZhbHVlIHRvIGJlIHBhc3NlZCB0byB0aGUgR0wgdW5pZm9ybSBzZXR0ZXIgZm9yIHRoYXQgdHlwZSwgZS5nLiBbMSwgMiwgM10gZm9yIGEgdmVjM1xyXG5cclxuICAgIFRleHR1cmVzIGhhdmUgc3BlY2lhbCBiZWhhdmlvcjogdW5pZm9ybXMgd2l0aCBzdHJpbmcgdmFsdWVzIGFyZSB0cmVhdGVkIGFzIHRleHR1cmVzLCBhbmRcclxuICAgIHRoZSBzdHJpbmcgaXMgdXNlZCBhcyBhIHVuaXF1ZSB0ZXh0dXJlICdrZXknIHRvIGJlIGludGVycHJldGVkIGJ5IHRoZSBjYWxsZXIgKHdoaWNoIGlzIHJlc3BvbnNpYmxlXHJcbiAgICBmb3IgYWN0dWFsbHkgc2V0dGluZyB0aGUgdW5pZm9ybXMpLiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSB1c2VkIGFzIGEga2V5IGludG8gYSBkaWN0aW9uYXJ5IG9mXHJcbiAgICBrbm93biB0ZXh0dXJlIG5hbWVzLCBvciBpdCBjb3VsZCBzaW1wbHkgYmUgdXNlZCBhcyBhIFVSTCB0byBkeW5hbWljYWxseSBsb2FkIHRoZSB0ZXh0dXJlIGZyb20uXHJcbiovXHJcbkdMU0wucGFyc2VVbmlmb3JtcyA9IGZ1bmN0aW9uICh1bmlmb3JtcywgcHJlZml4ID0gbnVsbCkge1xyXG4gICAgdmFyIHBhcnNlZCA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIG5hbWUgaW4gdW5pZm9ybXMpIHtcclxuICAgICAgICB2YXIgdW5pZm9ybSA9IHVuaWZvcm1zW25hbWVdO1xyXG4gICAgICAgIHZhciB1O1xyXG5cclxuICAgICAgICBpZiAocHJlZml4KSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBwcmVmaXggKyAnLicgKyBuYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2luZ2xlIGZsb2F0XHJcbiAgICAgICAgaWYgKHR5cGVvZiB1bmlmb3JtID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBwYXJzZWQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnZmxvYXQnLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnMWYnLFxyXG4gICAgICAgICAgICAgICAgbmFtZSwgdmFsdWU6XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBcnJheTogdmVjdG9yLCBhcnJheSBvZiBmbG9hdHMsIGFycmF5IG9mIHRleHR1cmVzLCBvciBhcnJheSBvZiBzdHJ1Y3RzXHJcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh1bmlmb3JtKSkge1xyXG4gICAgICAgICAgICAvLyBOdW1lcmljIHZhbHVlc1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVuaWZvcm1bMF0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCB2ZWN0b3JzICh2ZWMyLCB2ZWMzLCB2ZWM0KVxyXG4gICAgICAgICAgICAgICAgaWYgKHVuaWZvcm0ubGVuZ3RoID49IDIgJiYgdW5pZm9ybS5sZW5ndGggPD0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZlYycgKyB1bmlmb3JtLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB1bmlmb3JtLmxlbmd0aCArICdmdicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmlmb3JtXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCBhcnJheVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodW5pZm9ybS5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmxvYXRbXScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJzFmdicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWzBdJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuaWZvcm1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFzc3VtZSBtYXRyaXggZm9yICh0eXBlb2YgPT0gRmxvYXQzMkFycmF5ICYmIGxlbmd0aCA9PSAxNik/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQXJyYXkgb2YgdGV4dHVyZXNcclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHVuaWZvcm1bMF0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHU9MDsgdSA8IHVuaWZvcm0ubGVuZ3RoOyB1KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzYW1wbGVyMkQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICcxaScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWycgKyB1ICsgJ10nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybVt1XVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFycmF5IG9mIGFycmF5cyAtIGJ1dCBvbmx5IGFycmF5cyBvZiB2ZWN0b3JzIGFyZSBhbGxvd2VkIGluIHRoaXMgY2FzZVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHVuaWZvcm1bMF0pICYmIHR5cGVvZiB1bmlmb3JtWzBdWzBdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgdmVjdG9ycyAodmVjMiwgdmVjMywgdmVjNClcclxuICAgICAgICAgICAgICAgIGlmICh1bmlmb3JtWzBdLmxlbmd0aCA+PSAyICYmIHVuaWZvcm1bMF0ubGVuZ3RoIDw9IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh1PTA7IHUgPCB1bmlmb3JtLmxlbmd0aDsgdSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2ZWMnICsgdW5pZm9ybVswXS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHVuaWZvcm1bdV0ubGVuZ3RoICsgJ2Z2JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgKyAnWycgKyB1ICsgJ10nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuaWZvcm1bdV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZWxzZSBlcnJvcj9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBcnJheSBvZiBzdHJ1Y3R1cmVzXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtWzBdID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh1PTA7IHUgPCB1bmlmb3JtLmxlbmd0aDsgdSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGVhY2ggc3RydWN0IGluIHRoZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wdXNoKC4uLkdMU0wucGFyc2VVbmlmb3Jtcyh1bmlmb3JtW3VdLCBuYW1lICsgJ1snICsgdSArICddJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEJvb2xlYW5cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdW5pZm9ybSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHBhcnNlZC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGV4dHVyZVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1bmlmb3JtID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBwYXJzZWQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2FtcGxlcjJEJyxcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogJzFpJyxcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3RydWN0dXJlXHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHVuaWZvcm0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIC8vIFNldCBlYWNoIGZpZWxkIGluIHRoZSBzdHJ1Y3RcclxuICAgICAgICAgICAgcGFyc2VkLnB1c2goLi4uR0xTTC5wYXJzZVVuaWZvcm1zKHVuaWZvcm0sIG5hbWUpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgbm9uLWZsb2F0IHR5cGVzPyAoaW50LCBldGMuKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJzZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICAgIEdlbmVyYXRlIGEgR0xTTCB2YXJpYWJsZSBkZWZpbml0aW9uIGZyb20gYSBKUyBvYmplY3RcclxuKi9cclxuR0xTTC5kZWZpbmVWYXJpYWJsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJlZml4ID0gbnVsbCkge1xyXG4gICAgdmFyIHR5cGUsIGFycmF5O1xyXG4gICAgdmFyIHN0cnVjdHMgPSAnJztcclxuICAgIHByZWZpeCA9IHByZWZpeCA/IHByZWZpeCArICdfJyArIG5hbWUgOiBuYW1lO1xyXG5cclxuICAgIC8vIFNpbmdsZSBmbG9hdFxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICB0eXBlID0gJ2Zsb2F0JztcclxuICAgIH1cclxuICAgIC8vIE11bHRpcGxlIGZsb2F0cyAtIHZlY3RvciBvciBhcnJheVxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAvLyBOdW1lcmljIHZhbHVlc1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVbMF0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIGZsb2F0IHZlY3RvcnMgKHZlYzIsIHZlYzMsIHZlYzQpXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gMiAmJiB2YWx1ZS5sZW5ndGggPD0gNCkge1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9ICd2ZWMnICsgdmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZsb2F0IGFycmF5XHJcbiAgICAgICAgICAgIGVsc2UgeyAvL2lmICh2YWx1ZS5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2Zsb2F0JztcclxuICAgICAgICAgICAgICAgIGFycmF5ID0gdmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGFzc3VtZSBtYXRyaXggZm9yICh0eXBlb2YgPT0gRmxvYXQzMkFycmF5ICYmIGxlbmd0aCA9PSAxNik/XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFycmF5IG9mIHRleHR1cmVzXHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlWzBdID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0eXBlID0gJ3NhbXBsZXIyRCc7XHJcbiAgICAgICAgICAgIGFycmF5ID0gdmFsdWUubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBcnJheSBvZiBhcnJheXMgLSBidXQgb25seSBhcnJheXMgb2YgdmVjdG9ycyBhcmUgYWxsb3dlZCBpbiB0aGlzIGNhc2VcclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSAmJiB0eXBlb2YgdmFsdWVbMF1bMF0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIGZsb2F0IHZlY3RvcnMgKHZlYzIsIHZlYzMsIHZlYzQpXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVswXS5sZW5ndGggPj0gMiAmJiB2YWx1ZVswXS5sZW5ndGggPD0gNCkge1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9ICd2ZWMnICsgdmFsdWVbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGVsc2UgZXJyb3I/XHJcbiAgICAgICAgICAgIGFycmF5ID0gdmFsdWVbMF0ubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBcnJheSBvZiBzdHJ1Y3R1cmVzXHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlWzBdID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB0eXBlID0gJ190eXBlXycgKyBwcmVmaXg7IC8vIGN1c3RvbSBzdHJ1Y3QgbmFtZVxyXG4gICAgICAgICAgICBhcnJheSA9IHZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgc3RydWN0cyArPSBHTFNMLmRlZmluZVN0cnVjdCh0eXBlLCB2YWx1ZVswXSwgcHJlZml4KSArICdcXG4nOyAvLyBidWlsZCAmIGFkZCB0byBsaXN0IG9mIGRlcGVuZGVudCBzdHJ1Y3RzXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQm9vbGVhblxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICB0eXBlID0gJ2Jvb2wnO1xyXG4gICAgfVxyXG4gICAgLy8gVGV4dHVyZVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHR5cGUgPSAnc2FtcGxlcjJEJztcclxuICAgIH1cclxuICAgIC8vIFN0cnVjdHVyZVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHR5cGUgPSAnX3R5cGVfJyArIHByZWZpeDsgLy8gY3VzdG9tIHN0cnVjdCBuYW1lXHJcbiAgICAgICAgc3RydWN0cyArPSBHTFNMLmRlZmluZVN0cnVjdCh0eXBlLCB2YWx1ZSwgcHJlZml4KSArICdcXG4nOyAvLyBidWlsZCAmIGFkZCB0byBsaXN0IG9mIGRlcGVuZGVudCBzdHJ1Y3RzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IHZhcmlhYmxlIGRlZmluaXRpb25cclxuICAgIHZhciB2YXJpYWJsZSA9ICcnO1xyXG4gICAgdmFyaWFibGUgKz0gYCR7dHlwZX0gJHtuYW1lfWA7XHJcbiAgICBpZiAoYXJyYXkpIHtcclxuICAgICAgICB2YXJpYWJsZSArPSBgWyR7YXJyYXl9XWA7XHJcbiAgICB9XHJcbiAgICB2YXJpYWJsZSArPSAnO1xcbic7XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSB2YXJpYWJsZSBkZWZpbml0aW9uIGl0c2VsZiwgYW5kIGFueSBkZXBlbmRlbnQgc3RydWN0IGRlZmluaXRpb25zXHJcbiAgICByZXR1cm4geyB2YXJpYWJsZSwgc3RydWN0cyB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBHZW5lcmF0ZSBhIEdMU0wgc3RydWN0dXJlIGRlZmluaXRpb24gZnJvbSBhIEpTIG9iamVjdFxyXG4qL1xyXG5HTFNMLmRlZmluZVN0cnVjdCA9IGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSwgcHJlZml4ID0gbnVsbCkge1xyXG4gICAgdmFyIHN0cnVjdCA9IGBzdHJ1Y3QgJHt0eXBlfSB7XFxuYDtcclxuICAgIHZhciBkZXBlbmRlbnRzID0gJyc7XHJcbiAgICBmb3IgKHZhciBmaWVsZCBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzdWJ2YXIgPSBHTFNMLmRlZmluZVZhcmlhYmxlKGZpZWxkLCB2YWx1ZVtmaWVsZF0sIHByZWZpeCk7XHJcbiAgICAgICAgc3RydWN0ICs9ICcgICAgJyArIHN1YnZhci52YXJpYWJsZTtcclxuICAgICAgICBkZXBlbmRlbnRzICs9IHN1YnZhci5zdHJ1Y3RzO1xyXG4gICAgfVxyXG4gICAgc3RydWN0ICs9ICd9O1xcbic7XHJcbiAgICBzdHJ1Y3QgPSBkZXBlbmRlbnRzICsgc3RydWN0O1xyXG4gICAgcmV0dXJuIHN0cnVjdDtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgR2VuZXJhdGUgYSBHTFNMIHVuaWZvcm0gZGVmaW5pdGlvbiBmcm9tIGEgSlMgb2JqZWN0XHJcbiovXHJcbkdMU0wuZGVmaW5lVW5pZm9ybSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgdmFyIGRlZiA9IEdMU0wuZGVmaW5lVmFyaWFibGUobmFtZSwgdmFsdWUpO1xyXG4gICAgZGVmID0gZGVmLnN0cnVjdHMgKyAndW5pZm9ybSAnICsgZGVmLnZhcmlhYmxlO1xyXG4gICAgcmV0dXJuIGRlZjtcclxufTtcclxuXHJcbi8qKlxyXG4gICAgQ2hlY2sgZm9yIGEgdW5pZm9ybSBkZWZpbml0aW9uIG9mICduYW1lJyBpbiB0aGUgcHJvdmlkZWQgR0xTTCBzb3VyY2VcclxuICAgIFNpbXBsZSByZWdleCBjaGVjayBmb3IgJ3VuaWZvcm0nIGtleXdvcmQgYW5kIHZhciBuYW1lLCBkb2VzIG5vdCBhdHRlbXB0IHRvIHBhcnNlL2V4dHJhY3QgR0xTTFxyXG4gICAgTk9URTogYXNzdW1lcyBjb21tZW50cyBoYXZlIGJlZW4gc3RyaXBwZWQgZnJvbSBzb3VyY2VcclxuKi9cclxuR0xTTC5pc1VuaWZvcm1EZWZpbmVkID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSkge1xyXG4gICAgLy8gTWF0Y2gsIGluIG9yZGVyOlxyXG4gICAgLy8gLSB0aGUga2V5d29yZCAndW5pZm9ybSdcclxuICAgIC8vIC0gYXQgbGVhc3Qgb25lIGNoYXJhY3RlciB0aGF0IGlzIGFueXRoaW5nIGV4Y2VwdCBhIHNlbWljb2xvbiwgO1xyXG4gICAgLy8gLSBvcHRpb25hbGx5LCBhbnl0aGluZyBlbmNsb3NlZCBpbiBjdXJseSBicmFjZXMsIHsgLi4uIH0gKGFuIGlubGluZSBzdHJ1Y3R1cmUgZGVmaW5pdGlvbiBjYW4gZ28gaGVyZSlcclxuICAgIC8vIC0gb3B0aW9uYWxseSwgYW55ICMgb2YgY2hhcmFjdGVycyB0aGF0IGlzIG5vdCBhIHNlbWljb2xvbiwgO1xyXG4gICAgLy8gLSB0aGUgbmFtZSBvZiB0aGUgdW5pZm9ybVxyXG5cclxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ3VuaWZvcm1bXjtdKyg/OntbXFxcXHNcXFxcU10qfSk/W147XSpcXFxcYicgKyBuYW1lICsgJ1xcXFxiJywgJ2cnKTtcclxuICAgIGlmIChzb3VyY2UubWF0Y2gocmUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICAgIENoZWNrIHRoYXQgYSBzeW1ib2wgaXMgcmVmZXJlbmNlZCBpbiB0aGUgR0xTTCBzb3VyY2VcclxuICAgIE5PVEU6IGFzc3VtZXMgY29tbWVudHMgaGF2ZSBiZWVuIHN0cmlwcGVkIGZyb20gc291cmNlXHJcbiovXHJcbkdMU0wuaXNTeW1ib2xSZWZlcmVuY2VkID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSkge1xyXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgbmFtZSArICdcXFxcYicsICdnJyk7XHJcbiAgICBpZiAoc291cmNlLnNlYXJjaChyZSkgPj0gMCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgICBFeHBhbmQgYSBzaW5nbGUgdmFsdWUgb3IgMi1lbGVtZW50IGFycmF5IGludG8gYSAzLWVsZW1lbnQgYXJyYXksIHdpdGggdGhlIGxhc3QgKCB6IClcclxuICAgIGNvb3JkaW5hdGUgZGVmYXVsdGluZyB0byAxICh3aXRoIG9wdGlvbiB0byBzcGVjaWZ5KS4gQWxzbyBydW5zIHBhcnNlRmxvYXQgdG8gdHJ5IHRvIG1haW50YWluXHJcbiAgICBkYXRhIGludGVncml0eS4gUmV0dXJucyBudWxsIGlmIGlucHV0IGNvdWxkbid0IGJlIHBhcnNlZC5cclxuKi9cclxuR0xTTC5leHBhbmRWZWMzID0gZnVuY3Rpb24gKHYsIHogPSAxKSB7XHJcbiAgICBsZXQgeDtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHYpICYmIHYubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgeCA9IFsuLi52LCB6XS5tYXAocGFyc2VGbG9hdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB4ID0gW3YsIHYsIHZdLm1hcChwYXJzZUZsb2F0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoeCAmJiB4LmV2ZXJ5KG4gPT4gdHlwZW9mIG4gPT09ICdudW1iZXInICYmICFpc05hTihuKSkpIHtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gICAgRXhwYW5kIGEgc2luZ2xlIHZhbHVlIG9yIDMtZWxlbWVudCBhcnJheSBpbnRvIGEgNC1lbGVtZW50IGFycmF5LCB3aXRoIHRoZSBsYXN0IChlLmcuIHcgb3IgYSlcclxuICAgIGNvb3JkaW5hdGUgZGVmYXVsdGluZyB0byAxICh3aXRoIG9wdGlvbiB0byBzcGVjaWZ5KS4gQWxzbyBydW5zIHBhcnNlRmxvYXQgdG8gdHJ5IHRvIG1haW50YWluXHJcbiAgICBkYXRhIGludGVncml0eS4gUmV0dXJucyBudWxsIGlmIGlucHV0IGNvdWxkbid0IGJlIHBhcnNlZC5cclxuKi9cclxuR0xTTC5leHBhbmRWZWM0ID0gZnVuY3Rpb24gKHYsIHcgPSAxKSB7XHJcbiAgICBsZXQgeDtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHYpICYmIHYubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgeCA9IFsuLi52LCB3XS5tYXAocGFyc2VGbG9hdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB4ID0gW3YsIHYsIHYsIHddLm1hcChwYXJzZUZsb2F0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoeCAmJiB4LmV2ZXJ5KG4gPT4gdHlwZW9mIG4gPT09ICdudW1iZXInICYmICFpc05hTihuKSkpIHtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4iLCIvKiBnbG9iYWwgU2hhZGVyUHJvZ3JhbSAqL1xyXG4vLyBHTCBwcm9ncmFtIHdyYXBwZXIgdG8gY2FjaGUgdW5pZm9ybSBsb2NhdGlvbnMvdmFsdWVzLCBkbyBjb21waWxlLXRpbWUgcHJlLXByb2Nlc3NpbmdcclxuLy8gKGluamVjdGluZyAjZGVmaW5lcyBhbmQgI3ByYWdtYSBibG9ja3MgaW50byBzaGFkZXJzKSwgZXRjLlxyXG5cclxuaW1wb3J0IEdMU0wgZnJvbSAnLi9nbHNsJztcclxuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi90ZXh0dXJlJztcclxuXHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgc3RyaXAgZnJvbSAnc3RyaXAtY29tbWVudHMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyUHJvZ3JhbSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZ2wsIHZlcnRleF9zb3VyY2UsIGZyYWdtZW50X3NvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8ga2V5L3ZhbHVlcyBpbnNlcnRlZCBhcyAjZGVmaW5lcyBpbnRvIHNoYWRlcnMgYXQgY29tcGlsZS10aW1lXHJcbiAgICAgICAgdGhpcy5kZWZpbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5kZWZpbmVzfHx7fSk7XHJcblxyXG4gICAgICAgIC8vIGtleS92YWx1ZXMgZm9yIGJsb2NrcyB0aGF0IGNhbiBiZSBpbmplY3RlZCBpbnRvIHNoYWRlcnMgYXQgY29tcGlsZS10aW1lXHJcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmJsb2Nrc3x8e30pO1xyXG5cclxuICAgICAgICAvLyBKUy1vYmplY3QgdW5pZm9ybXMgdGhhdCBhcmUgZXhwZWN0ZWQgYnkgdGhpcyBwcm9ncmFtXHJcbiAgICAgICAgLy8gSWYgdGhleSBhcmUgbm90IGZvdW5kIGluIHRoZSBleGlzdGluZyBzaGFkZXIgc291cmNlLCB0aGVpciB0eXBlcyB3aWxsIGJlIGluZmVycmVkIGFuZCBkZWZpbml0aW9uc1xyXG4gICAgICAgIC8vIGZvciBlYWNoIHdpbGwgYmUgaW5qZWN0ZWQuXHJcbiAgICAgICAgdGhpcy5kZXBlbmRlbnRfdW5pZm9ybXMgPSBvcHRpb25zLnVuaWZvcm1zO1xyXG5cclxuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge307IC8vIHByb2dyYW0gbG9jYXRpb25zIG9mIHVuaWZvcm1zLCBsYXppbHkgYWRkZWQgYXMgZWFjaCB1bmlmb3JtIGlzIHNldFxyXG4gICAgICAgIHRoaXMuYXR0cmlicyA9IHt9OyAvLyBwcm9ncmFtIGxvY2F0aW9ucyBvZiB2ZXJ0ZXggYXR0cmlidXRlcywgbGF6aWx5IGFkZGVkIGFzIGVhY2ggYXR0cmlidXRlIGlzIGFjY2Vzc2VkXHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4X3NvdXJjZSA9IHZlcnRleF9zb3VyY2U7XHJcbiAgICAgICAgdGhpcy5mcmFnbWVudF9zb3VyY2UgPSBmcmFnbWVudF9zb3VyY2U7XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBTaGFkZXJQcm9ncmFtLmlkKys7XHJcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5wcm9ncmFtc1t0aGlzLmlkXSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lOyAvLyBjYW4gcHJvdmlkZSBhIHByb2dyYW0gbmFtZSAodXNlZnVsIGZvciBkZWJ1Z2dpbmcpXHJcbiAgICB9XHJcblxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0obnVsbCk7XHJcbiAgICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge307XHJcbiAgICAgICAgdGhpcy5hdHRyaWJzID0ge307XHJcbiAgICAgICAgZGVsZXRlIFNoYWRlclByb2dyYW0ucHJvZ3JhbXNbdGhpcy5pZF07XHJcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZSBwcm9ncmFtIHdyYXBwZXIgd2l0aCBzaW1wbGUgc3RhdGUgY2FjaGVcclxuICAgIHVzZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFNoYWRlclByb2dyYW0uY3VycmVudCAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5jdXJyZW50ID0gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBjb21waWxlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBpbGluZykge1xyXG4gICAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoYFNoYWRlclByb2dyYW0uY29tcGlsZSgpOiBza2lwcGluZyBmb3IgJHt0aGlzLmlkfSAoJHt0aGlzLm5hbWV9KSBiZWNhdXNlIGFscmVhZHkgY29tcGlsaW5nYCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbXBpbGluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBDb3B5IHNvdXJjZXMgZnJvbSBwcmUtbW9kaWZpZWQgdGVtcGxhdGVcclxuICAgICAgICB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UgPSB0aGlzLnZlcnRleF9zb3VyY2U7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UgPSB0aGlzLmZyYWdtZW50X3NvdXJjZTtcclxuXHJcbiAgICAgICAgLy8gTWFrZSBsaXN0IG9mIGRlZmluZXMgdG8gYmUgaW5qZWN0ZWQgbGF0ZXJcclxuICAgICAgICB2YXIgZGVmaW5lcyA9IHRoaXMuYnVpbGREZWZpbmVMaXN0KCk7XHJcblxyXG4gICAgICAgIC8vIEluamVjdCB1c2VyLWRlZmluZWQgYmxvY2tzIChhcmJpdHJhcnkgY29kZSBwb2ludHMgbWF0Y2hpbmcgbmFtZWQgI3ByYWdtYXMpXHJcbiAgICAgICAgLy8gUmVwbGFjZSBhY2NvcmRpbmcgdG8gdGhpcyBwYXR0ZXJuOlxyXG4gICAgICAgIC8vICNwcmFnbWEgdGFuZ3JhbTogW2tleV1cclxuICAgICAgICAvLyBlLmcuICNwcmFnbWEgdGFuZ3JhbTogZ2xvYmFsXHJcblxyXG4gICAgICAgIC8vIEdhdGhlciBhbGwgYmxvY2sgY29kZSBzbmlwcGV0c1xyXG4gICAgICAgIHZhciBibG9ja3MgPSB0aGlzLmJ1aWxkU2hhZGVyQmxvY2tMaXN0KCk7XHJcbiAgICAgICAgdmFyIHJlZ2V4cDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGJsb2Nrcykge1xyXG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBibG9ja3Nba2V5XTtcclxuICAgICAgICAgICAgaWYgKCFibG9jayB8fCAoQXJyYXkuaXNBcnJheShibG9jaykgJiYgYmxvY2subGVuZ3RoID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpcnN0IGZpbmQgY29kZSByZXBsYWNlIHBvaW50cyBpbiBzaGFkZXJzXHJcbiAgICAgICAgICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ15cXFxccyojcHJhZ21hXFxcXHMrdGFuZ3JhbTpcXFxccysnICsga2V5ICsgJ1xcXFxzKiQnLCAnbScpO1xyXG4gICAgICAgICAgICB2YXIgaW5qZWN0X3ZlcnRleCA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5tYXRjaChyZWdleHApO1xyXG4gICAgICAgICAgICB2YXIgaW5qZWN0X2ZyYWdtZW50ID0gdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UubWF0Y2gocmVnZXhwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEF2b2lkIG5ldHdvcmsgcmVxdWVzdCBpZiBub3RoaW5nIHRvIHJlcGxhY2VcclxuICAgICAgICAgICAgaWYgKGluamVjdF92ZXJ0ZXggPT0gbnVsbCAmJiBpbmplY3RfZnJhZ21lbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEVhY2gga2V5IGNhbiBiZSBhIHNpbmdsZSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5nc1xyXG4gICAgICAgICAgICB2YXIgc291cmNlID0gYFxcbiR7YmxvY2t9XFxuYDtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmxvY2spKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb21iaW5lIGFsbCBibG9ja3MgaW50byBvbmUgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBibG9jay5yZWR1Y2UoKHByZXYsIGN1cikgPT4gYFxcbiR7cHJldn1cXG4ke2N1cn1cXG5gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5qZWN0XHJcbiAgICAgICAgICAgIGlmIChpbmplY3RfdmVydGV4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5yZXBsYWNlKHJlZ2V4cCwgc291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW5qZWN0X2ZyYWdtZW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UucmVwbGFjZShyZWdleHAsIHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBhICNkZWZpbmUgZm9yIHRoaXMgaW5qZWN0aW9uIHBvaW50XHJcbiAgICAgICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fQkxPQ0tfJyArIGtleS5yZXBsYWNlKC9bXFxzLV0rL2csICdfJykudG9VcHBlckNhc2UoKV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xlYW4tdXAgYW55ICNwcmFnbWFzIHRoYXQgd2VyZW4ndCByZXBsYWNlZCAodG8gcHJldmVudCBjb21waWxlciB3YXJuaW5ncylcclxuICAgICAgICByZWdleHAgPSBuZXcgUmVnRXhwKCdeXFxcXHMqI3ByYWdtYS4qJCcsICdnbScpO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSA9IHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZS5yZXBsYWNlKHJlZ2V4cCwgJycpO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UucmVwbGFjZShyZWdleHAsICcnKTtcclxuXHJcbiAgICAgICAgLy8gQnVpbGQgJiBpbmplY3QgZGVmaW5lc1xyXG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSAqYWZ0ZXIqIGNvZGUgaW5qZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBkZWZpbmVzIGZvciB3aGljaCBjb2RlIHBvaW50cyB3ZXJlIGluamVjdGVkXHJcbiAgICAgICAgZGVmaW5lc1snVEFOR1JBTV9WRVJURVhfU0hBREVSJ10gPSB0cnVlO1xyXG4gICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fRlJBR01FTlRfU0hBREVSJ10gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UgPSBTaGFkZXJQcm9ncmFtLmJ1aWxkRGVmaW5lU3RyaW5nKGRlZmluZXMpICsgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlO1xyXG5cclxuICAgICAgICBkZWZpbmVzWydUQU5HUkFNX1ZFUlRFWF9TSEFERVInXSA9IGZhbHNlO1xyXG4gICAgICAgIGRlZmluZXNbJ1RBTkdSQU1fRlJBR01FTlRfU0hBREVSJ10gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlID0gU2hhZGVyUHJvZ3JhbS5idWlsZERlZmluZVN0cmluZyhkZWZpbmVzKSArIHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlO1xyXG5cclxuICAgICAgICAvLyBEZXRlY3QgdW5pZm9ybSBkZWZpbml0aW9ucywgaW5qZWN0IGFueSBtaXNzaW5nIG9uZXNcclxuICAgICAgICB0aGlzLmVuc3VyZVVuaWZvcm1zKHRoaXMuZGVwZW5kZW50X3VuaWZvcm1zKTtcclxuXHJcbiAgICAgICAgLy8gSW5jbHVkZSBwcm9ncmFtIGluZm8gdXNlZnVsIGZvciBkZWJ1Z2dpbmdcclxuICAgICAgICB2YXIgaW5mbyA9ICh0aGlzLm5hbWUgPyAodGhpcy5uYW1lICsgJyAvIGlkICcgKyB0aGlzLmlkKSA6ICgnaWQgJyArIHRoaXMuaWQpKTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UgPSAnLy8gUHJvZ3JhbTogJyArIGluZm8gKyAnXFxuJyArIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZTtcclxuICAgICAgICB0aGlzLmNvbXB1dGVkX2ZyYWdtZW50X3NvdXJjZSA9ICcvLyBQcm9ncmFtOiAnICsgaW5mbyArICdcXG4nICsgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2U7XHJcblxyXG4gICAgICAgIC8vIENvbXBpbGUgJiBzZXQgdW5pZm9ybXMgdG8gY2FjaGVkIHZhbHVlc1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IFNoYWRlclByb2dyYW0udXBkYXRlUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnByb2dyYW0sIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZSwgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2goZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBpbGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgU2hhZGVyUHJvZ3JhbS5jb21waWxlKCk6IHByb2dyYW0gJHt0aGlzLmlkfSAoJHt0aGlzLm5hbWV9KSBlcnJvcjpgLCBlcnJvcikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51c2UoKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hVbmlmb3JtcygpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaEF0dHJpYnV0ZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIGxpc3Qgb2YgZGVmaW5lcyAoZ2xvYmFsLCB0aGVuIHByb2dyYW0tc3BlY2lmaWMpXHJcbiAgICBidWlsZERlZmluZUxpc3QoKSB7XHJcbiAgICAgICAgdmFyIGQsIGRlZmluZXMgPSB7fTtcclxuICAgICAgICBmb3IgKGQgaW4gU2hhZGVyUHJvZ3JhbS5kZWZpbmVzKSB7XHJcbiAgICAgICAgICAgIGRlZmluZXNbZF0gPSBTaGFkZXJQcm9ncmFtLmRlZmluZXNbZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoZCBpbiB0aGlzLmRlZmluZXMpIHtcclxuICAgICAgICAgICAgZGVmaW5lc1tkXSA9IHRoaXMuZGVmaW5lc1tkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZmluZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFrZSBsaXN0IG9mIHNoYWRlciBibG9ja3MgKGdsb2JhbCwgdGhlbiBwcm9ncmFtLXNwZWNpZmljKVxyXG4gICAgYnVpbGRTaGFkZXJCbG9ja0xpc3QoKSB7XHJcbiAgICAgICAgdmFyIGQsIGJsb2NrcyA9IHt9O1xyXG4gICAgICAgIGZvciAoZCBpbiBTaGFkZXJQcm9ncmFtLmJsb2Nrcykge1xyXG4gICAgICAgICAgICBibG9ja3NbZF0gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KFNoYWRlclByb2dyYW0uYmxvY2tzW2RdKSkge1xyXG4gICAgICAgICAgICAgICAgYmxvY2tzW2RdLnB1c2goLi4uU2hhZGVyUHJvZ3JhbS5ibG9ja3NbZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmxvY2tzW2RdID0gW1NoYWRlclByb2dyYW0uYmxvY2tzW2RdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGQgaW4gdGhpcy5ibG9ja3MpIHtcclxuICAgICAgICAgICAgYmxvY2tzW2RdID0gYmxvY2tzW2RdIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ibG9ja3NbZF0pKSB7XHJcbiAgICAgICAgICAgICAgICBibG9ja3NbZF0ucHVzaCguLi50aGlzLmJsb2Nrc1tkXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBibG9ja3NbZF0ucHVzaCh0aGlzLmJsb2Nrc1tkXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlY3QgdW5pZm9ybSBkZWZpbml0aW9ucywgaW5qZWN0IGFueSBtaXNzaW5nIG9uZXNcclxuICAgIGVuc3VyZVVuaWZvcm1zKHVuaWZvcm1zKSB7XHJcbiAgICAgICAgaWYgKCF1bmlmb3Jtcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdnMgPSBzdHJpcCh0aGlzLmNvbXB1dGVkX3ZlcnRleF9zb3VyY2UpO1xyXG4gICAgICAgIHZhciBmcyA9IHN0cmlwKHRoaXMuY29tcHV0ZWRfZnJhZ21lbnRfc291cmNlKTtcclxuICAgICAgICB2YXIgaW5qZWN0LCB2c19pbmplY3Rpb25zID0gW10sIGZzX2luamVjdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG1pc3NpbmcgdW5pZm9ybSBkZWZpbml0aW9uc1xyXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdW5pZm9ybXMpIHtcclxuICAgICAgICAgICAgaW5qZWN0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHZlcnRleCBzaGFkZXJcclxuICAgICAgICAgICAgaWYgKCFHTFNMLmlzVW5pZm9ybURlZmluZWQobmFtZSwgdnMpICYmIEdMU0wuaXNTeW1ib2xSZWZlcmVuY2VkKG5hbWUsIHZzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmplY3QgPSBHTFNMLmRlZmluZVVuaWZvcm0obmFtZSwgdW5pZm9ybXNbbmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBQcm9ncmFtICR7dGhpcy5uYW1lfTogJHtuYW1lfSBub3QgZGVmaW5lZCBpbiB2ZXJ0ZXggc2hhZGVyLCBpbmplY3Rpbmc6ICcke2luamVjdH0nYCk7XHJcbiAgICAgICAgICAgICAgICB2c19pbmplY3Rpb25zLnB1c2goaW5qZWN0KTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgICAgIGlmICghR0xTTC5pc1VuaWZvcm1EZWZpbmVkKG5hbWUsIGZzKSAmJiBHTFNMLmlzU3ltYm9sUmVmZXJlbmNlZChuYW1lLCBmcykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaW5qZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ID0gR0xTTC5kZWZpbmVVbmlmb3JtKG5hbWUsIHVuaWZvcm1zW25hbWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxvZy50cmFjZShgUHJvZ3JhbSAke3RoaXMubmFtZX06ICR7bmFtZX0gbm90IGRlZmluZWQgaW4gZnJhZ21lbnQgc2hhZGVyLCBpbmplY3Rpbmc6ICcke2luamVjdH0nYCk7XHJcbiAgICAgICAgICAgICAgICBmc19pbmplY3Rpb25zLnB1c2goaW5qZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5qZWN0IG1pc3NpbmcgdW5pZm9ybXNcclxuICAgICAgICAvLyBOT1RFOiB0aGVzZSBhcmUgaW5qZWN0ZWQgYXQgdGhlIHZlcnkgdG9wIG9mIHRoZSBzaGFkZXJzLCBldmVuIGJlZm9yZSBhbnkgI2RlZmluZXMgb3IgI3ByYWdtYXMgYXJlIGFkZGVkXHJcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBjYXVzZSBzb21lIGlzc3VlcyB3aXRoIGNlcnRhaW4gI3ByYWdtYXMsIG9yIG90aGVyIGZ1bmN0aW9ucyB0aGF0IG1pZ2h0IGV4cGVjdCAjZGVmaW5lc1xyXG4gICAgICAgIGlmICh2c19pbmplY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlZF92ZXJ0ZXhfc291cmNlID0gdnNfaW5qZWN0aW9ucy5qb2luKCdcXG4nKSArIHRoaXMuY29tcHV0ZWRfdmVydGV4X3NvdXJjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmc19pbmplY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2UgPSBmc19pbmplY3Rpb25zLmpvaW4oJ1xcbicpICsgdGhpcy5jb21wdXRlZF9mcmFnbWVudF9zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCB1bmlmb3JtcyBmcm9tIGEgSlMgb2JqZWN0LCB3aXRoIGluZmVycmVkIHR5cGVzXHJcbiAgICBzZXRVbmlmb3Jtcyh1bmlmb3JtcywgcmVzZXRfdGV4dHVyZV91bml0ID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb21waWxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPOiBvbmx5IHVwZGF0ZSB1bmlmb3JtcyB3aGVuIGNoYW5nZWRcclxuXHJcbiAgICAgICAgLy8gVGV4dHVyZSB1bml0cyBtdXN0IGJlIHRyYWNrZWQgYW5kIGluY3JlbWVudGVkIGVhY2ggdGltZSBhIHRleHR1cmUgc2FtcGxlciB1bmlmb3JtIGlzIHNldC5cclxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgdGV4dHVyZSB1bml0IGlzIHJlc2V0IHRvIDAgZWFjaCB0aW1lIHNldFVuaWZvcm1zIGlzIGNhbGxlZCwgYnV0IHRoZXkgY2FuXHJcbiAgICAgICAgLy8gYWxzbyBiZSBwcmVzZXJ2ZWQsIGZvciBleGFtcGxlIGluIGNhc2VzIHdoZXJlIG11bHRpcGxlIGNhbGxzIHRvIHNldFVuaWZvcm1zIGFyZSBleHBlY3RlZFxyXG4gICAgICAgIC8vIChlLmcuIHByb2dyYW0tc3BlY2lmaWMgdW5pZm9ybXMgZm9sbG93ZWQgYnkgbWVzaC1zcGVjaWZpYyBvbmVzKS5cclxuICAgICAgICBpZiAocmVzZXRfdGV4dHVyZV91bml0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZV91bml0ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBhcnNlIHVuaWZvcm0gdHlwZXMgYW5kIHZhbHVlcyBmcm9tIHRoZSBKUyBvYmplY3RcclxuICAgICAgICB2YXIgcGFyc2VkID0gR0xTTC5wYXJzZVVuaWZvcm1zKHVuaWZvcm1zKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IGVhY2ggdW5pZm9ybVxyXG4gICAgICAgIGZvciAodmFyIHVuaWZvcm0gb2YgcGFyc2VkKSB7XHJcbiAgICAgICAgICAgIGlmICh1bmlmb3JtLnR5cGUgPT09ICdzYW1wbGVyMkQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGV4dHVyZXMsIHdlIG5lZWQgdG8gdHJhY2sgdGV4dHVyZSB1bml0cywgc28gd2UgaGF2ZSBhIHNwZWNpYWwgc2V0dGVyXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRleHR1cmVVbmlmb3JtKHVuaWZvcm0ubmFtZSwgdW5pZm9ybS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm0odW5pZm9ybS5tZXRob2QsIHVuaWZvcm0ubmFtZSwgdW5pZm9ybS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FjaGUgc29tZSBvciBhbGwgdW5pZm9ybSB2YWx1ZXMgc28gdGhleSBjYW4gYmUgcmVzdG9yZWRcclxuICAgIHNhdmVVbmlmb3JtcyhzdWJzZXQpIHtcclxuICAgICAgICBsZXQgdW5pZm9ybXMgPSBzdWJzZXQgfHwgdGhpcy51bmlmb3JtcztcclxuICAgICAgICBmb3IgKGxldCB1IGluIHVuaWZvcm1zKSB7XHJcbiAgICAgICAgICAgIGxldCB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1t1XTtcclxuICAgICAgICAgICAgaWYgKHVuaWZvcm0pIHtcclxuICAgICAgICAgICAgICAgIHVuaWZvcm0uc2F2ZWRfdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2F2ZWRfdGV4dHVyZV91bml0ID0gdGhpcy50ZXh0dXJlX3VuaXQgfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXN0b3JlIHNvbWUgb3IgYWxsIHVuaWZvcm1zIHRvIHNhdmVkIHZhbHVlc1xyXG4gICAgcmVzdG9yZVVuaWZvcm1zKHN1YnNldCkge1xyXG4gICAgICAgIGxldCB1bmlmb3JtcyA9IHN1YnNldCB8fCB0aGlzLnVuaWZvcm1zO1xyXG4gICAgICAgIGZvciAobGV0IHUgaW4gdW5pZm9ybXMpIHtcclxuICAgICAgICAgICAgbGV0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW3VdO1xyXG4gICAgICAgICAgICBpZiAodW5pZm9ybSAmJiB1bmlmb3JtLnNhdmVkX3ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB1bmlmb3JtLnZhbHVlID0gdW5pZm9ybS5zYXZlZF92YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVW5pZm9ybSh1KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRleHR1cmVfdW5pdCA9IHRoaXMuc2F2ZWRfdGV4dHVyZV91bml0IHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IGEgdGV4dHVyZSB1bmlmb3JtLCBmaW5kcyB0ZXh0dXJlIGJ5IG5hbWUgb3IgY3JlYXRlcyBhIG5ldyBvbmVcclxuICAgIHNldFRleHR1cmVVbmlmb3JtKHVuaWZvcm1fbmFtZSwgdGV4dHVyZV9uYW1lKSB7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RleHR1cmVfbmFtZV07XHJcbiAgICAgICAgaWYgKHRleHR1cmUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5nbCwgdGV4dHVyZV9uYW1lKTtcclxuICAgICAgICAgICAgdGV4dHVyZS5sb2FkKHRleHR1cmVfbmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0ZXh0dXJlLmJpbmQodGhpcy50ZXh0dXJlX3VuaXQpO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybSgnMWknLCB1bmlmb3JtX25hbWUsIHRoaXMudGV4dHVyZV91bml0KTtcclxuICAgICAgICB0aGlzLnRleHR1cmVfdW5pdCsrOyAvLyBUT0RPOiB0cmFjayBtYXggdGV4dHVyZSB1bml0cyBhbmQgbG9nL3Rocm93IGVycm9yc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGV4OiBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3Bvc2l0aW9uJywgeCwgeSwgeik7XHJcbiAgICAvLyBUT0RPOiBvbmx5IHVwZGF0ZSB1bmlmb3JtcyB3aGVuIGNoYW5nZWRcclxuICAgIHVuaWZvcm0obWV0aG9kLCBuYW1lLCAuLi52YWx1ZSkgeyAvLyAndmFsdWUnIGlzIGEgbWV0aG9kLWFwcHJvcHJpYXRlIGFyZ3VtZW50cyBsaXN0XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudW5pZm9ybXNbbmFtZV0gPSB0aGlzLnVuaWZvcm1zW25hbWVdIHx8IHt9O1xyXG4gICAgICAgIGxldCB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1tuYW1lXTtcclxuICAgICAgICB1bmlmb3JtLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIGlmICh1bmlmb3JtLmxvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdW5pZm9ybS5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVuaWZvcm0ubWV0aG9kID0gJ3VuaWZvcm0nICsgbWV0aG9kO1xyXG4gICAgICAgIHVuaWZvcm0udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVVuaWZvcm0obmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IGEgc2luZ2xlIHVuaWZvcm1cclxuICAgIHVwZGF0ZVVuaWZvcm0obmFtZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb21waWxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07XHJcbiAgICAgICAgaWYgKCF1bmlmb3JtIHx8IHVuaWZvcm0ubG9jYXRpb24gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVzZSgpO1xyXG4gICAgICAgIHRoaXMuZ2xbdW5pZm9ybS5tZXRob2RdLmFwcGx5KHRoaXMuZ2wsIFt1bmlmb3JtLmxvY2F0aW9uXS5jb25jYXQodW5pZm9ybS52YWx1ZSkpOyAvLyBjYWxsIGFwcHJvcHJpYXRlIEdMIHVuaWZvcm0gbWV0aG9kIGFuZCBwYXNzIHRocm91Z2ggYXJndW1lbnRzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVmcmVzaCB1bmlmb3JtIGxvY2F0aW9ucyBhbmQgc2V0IHRvIGxhc3QgY2FjaGVkIHZhbHVlc1xyXG4gICAgcmVmcmVzaFVuaWZvcm1zKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb21waWxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciB1IGluIHRoaXMudW5pZm9ybXMpIHtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3Jtc1t1XS5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgdSk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVW5pZm9ybSh1KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVmcmVzaEF0dHJpYnV0ZXMoKSB7XHJcbiAgICAgICAgLy8gdmFyIGxlbiA9IHRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnByb2dyYW0sIHRoaXMuZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xyXG4gICAgICAgIC8vIGZvciAodmFyIGk9MDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgLy8gICAgIHZhciBhID0gdGhpcy5nbC5nZXRBY3RpdmVBdHRyaWIodGhpcy5wcm9ncmFtLCBpKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgdGhpcy5hdHRyaWJzID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IHRoZSBsb2NhdGlvbiBvZiBhIHZlcnRleCBhdHRyaWJ1dGVcclxuICAgIGF0dHJpYnV0ZShuYW1lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhdHRyaWIgPSAodGhpcy5hdHRyaWJzW25hbWVdID0gdGhpcy5hdHRyaWJzW25hbWVdIHx8IHt9KTtcclxuICAgICAgICBpZiAoYXR0cmliLmxvY2F0aW9uICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF0dHJpYjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGF0dHJpYi5uYW1lID0gbmFtZTtcclxuICAgICAgICBhdHRyaWIubG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XHJcblxyXG4gICAgICAgIC8vIHZhciBpbmZvID0gdGhpcy5nbC5nZXRBY3RpdmVBdHRyaWIodGhpcy5wcm9ncmFtLCBhdHRyaWIubG9jYXRpb24pO1xyXG4gICAgICAgIC8vIGF0dHJpYi50eXBlID0gaW5mby50eXBlO1xyXG4gICAgICAgIC8vIGF0dHJpYi5zaXplID0gaW5mby5zaXplO1xyXG5cclxuICAgICAgICByZXR1cm4gYXR0cmliO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbi8vIFN0YXRpYyBtZXRob2RzIGFuZCBzdGF0ZVxyXG5cclxuU2hhZGVyUHJvZ3JhbS5pZCA9IDA7ICAgICAgICAgICAvLyBhc3NpZ24gZWFjaCBwcm9ncmFtIGEgdW5pcXVlIGlkXHJcblNoYWRlclByb2dyYW0ucHJvZ3JhbXMgPSB7fTsgICAgLy8gcHJvZ3JhbXMsIGJ5IGlkXHJcblNoYWRlclByb2dyYW0uY3VycmVudCA9IG51bGw7ICAgLy8gY3VycmVudGx5IGJvdW5kIHByb2dyYW1cclxuXHJcbi8vIEdsb2JhbCBjb25maWcgYXBwbGllZCB0byBhbGwgcHJvZ3JhbXMgKGR1cGxpY2F0ZSBwcm9wZXJ0aWVzIGZvciBhIHNwZWNpZmljIHByb2dyYW0gd2lsbCB0YWtlIHByZWNlZGVuY2UpXHJcblNoYWRlclByb2dyYW0uZGVmaW5lcyA9IHt9O1xyXG5TaGFkZXJQcm9ncmFtLmJsb2NrcyA9IHt9O1xyXG5cclxuLy8gVHVybiBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIGludG8gc2luZ2xlIHN0cmluZyBvZiAjZGVmaW5lIHN0YXRlbWVudHNcclxuU2hhZGVyUHJvZ3JhbS5idWlsZERlZmluZVN0cmluZyA9IGZ1bmN0aW9uIChkZWZpbmVzKSB7XHJcbiAgICB2YXIgZGVmaW5lX3N0ciA9IFwiXCI7XHJcbiAgICBmb3IgKHZhciBkIGluIGRlZmluZXMpIHtcclxuICAgICAgICBpZiAoZGVmaW5lc1tkXSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmVzW2RdID09PSAnYm9vbGVhbicgJiYgZGVmaW5lc1tkXSA9PT0gdHJ1ZSkgeyAvLyBib29sZWFucyBhcmUgc2ltcGxlIGRlZmluZXMgd2l0aCBubyB2YWx1ZVxyXG4gICAgICAgICAgICBkZWZpbmVfc3RyICs9IFwiI2RlZmluZSBcIiArIGQgKyBcIlxcblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lc1tkXSA9PT0gJ251bWJlcicgJiYgTWF0aC5mbG9vcihkZWZpbmVzW2RdKSA9PT0gZGVmaW5lc1tkXSkgeyAvLyBpbnQgdG8gZmxvYXQgY29udmVyc2lvbiB0byBzYXRpc2Z5IEdMU0wgZmxvYXRzXHJcbiAgICAgICAgICAgIGRlZmluZV9zdHIgKz0gXCIjZGVmaW5lIFwiICsgZCArIFwiIFwiICsgZGVmaW5lc1tkXS50b0ZpeGVkKDEpICsgXCJcXG5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIGFueSBvdGhlciBmbG9hdCBvciBzdHJpbmcgdmFsdWVcclxuICAgICAgICAgICAgZGVmaW5lX3N0ciArPSBcIiNkZWZpbmUgXCIgKyBkICsgXCIgXCIgKyBkZWZpbmVzW2RdICsgXCJcXG5cIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVmaW5lX3N0cjtcclxufTtcclxuXHJcblNoYWRlclByb2dyYW0uYWRkQmxvY2sgPSBmdW5jdGlvbiAoa2V5LCAuLi5ibG9ja3MpIHtcclxuICAgIFNoYWRlclByb2dyYW0uYmxvY2tzW2tleV0gPSBTaGFkZXJQcm9ncmFtLmJsb2Nrc1trZXldIHx8IFtdO1xyXG4gICAgU2hhZGVyUHJvZ3JhbS5ibG9ja3Nba2V5XS5wdXNoKC4uLmJsb2Nrcyk7XHJcbn07XHJcblxyXG4vLyBSZW1vdmUgYWxsIGdsb2JhbCBzaGFkZXIgYmxvY2tzIGZvciBhIGdpdmVuIGtleVxyXG5TaGFkZXJQcm9ncmFtLnJlbW92ZUJsb2NrID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgU2hhZGVyUHJvZ3JhbS5ibG9ja3Nba2V5XSA9IFtdO1xyXG59O1xyXG5cclxuU2hhZGVyUHJvZ3JhbS5yZXBsYWNlQmxvY2sgPSBmdW5jdGlvbiAoa2V5LCAuLi5ibG9ja3MpIHtcclxuICAgIFNoYWRlclByb2dyYW0ucmVtb3ZlQmxvY2soa2V5KTtcclxuICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soa2V5LCAuLi5ibG9ja3MpO1xyXG59O1xyXG5cclxuLy8gQ29tcGlsZSAmIGxpbmsgYSBXZWJHTCBwcm9ncmFtIGZyb20gcHJvdmlkZWQgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXIgc291cmNlc1xyXG4vLyB1cGRhdGUgYSBwcm9ncmFtIGlmIG9uZSBpcyBwYXNzZWQgaW4uIENyZWF0ZSBvbmUgaWYgbm90LiBBbGVydCBhbmQgZG9uJ3QgdXBkYXRlIGFueXRoaW5nIGlmIHRoZSBzaGFkZXJzIGRvbid0IGNvbXBpbGUuXHJcblNoYWRlclByb2dyYW0udXBkYXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChnbCwgcHJvZ3JhbSwgdmVydGV4X3NoYWRlcl9zb3VyY2UsIGZyYWdtZW50X3NoYWRlcl9zb3VyY2UpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHZlcnRleF9zaGFkZXIgPSBTaGFkZXJQcm9ncmFtLmNyZWF0ZVNoYWRlcihnbCwgdmVydGV4X3NoYWRlcl9zb3VyY2UsIGdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgIHZhciBmcmFnbWVudF9zaGFkZXIgPSBTaGFkZXJQcm9ncmFtLmNyZWF0ZVNoYWRlcihnbCwgJyNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZW5kaWZcXG5cXG4nICsgZnJhZ21lbnRfc2hhZGVyX3NvdXJjZSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgIH1cclxuICAgIGNhdGNoKGVycikge1xyXG4gICAgICAgIGxvZy5lcnJvcihlcnIpO1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxuXHJcbiAgICBnbC51c2VQcm9ncmFtKG51bGwpO1xyXG4gICAgaWYgKHByb2dyYW0gIT0gbnVsbCkge1xyXG4gICAgICAgIHZhciBvbGRfc2hhZGVycyA9IGdsLmdldEF0dGFjaGVkU2hhZGVycyhwcm9ncmFtKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2xkX3NoYWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZ2wuZGV0YWNoU2hhZGVyKHByb2dyYW0sIG9sZF9zaGFkZXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZlcnRleF9zaGFkZXIgPT0gbnVsbCB8fCBmcmFnbWVudF9zaGFkZXIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xyXG4gICAgfVxyXG5cclxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhfc2hhZGVyKTtcclxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudF9zaGFkZXIpO1xyXG5cclxuICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhfc2hhZGVyKTtcclxuICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudF9zaGFkZXIpO1xyXG5cclxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG5cclxuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcclxuICAgICAgICB2YXIgcHJvZ3JhbV9lcnJvciA9IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgYFdlYkdMIHByb2dyYW0gZXJyb3I6XHJcbiAgICAgICAgICAgIFZBTElEQVRFX1NUQVRVUzogJHtnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyl9XHJcbiAgICAgICAgICAgIEVSUk9SOiAke2dsLmdldEVycm9yKCl9XHJcbiAgICAgICAgICAgIC0tLSBWZXJ0ZXggU2hhZGVyIC0tLVxyXG4gICAgICAgICAgICAke3ZlcnRleF9zaGFkZXJfc291cmNlfVxyXG4gICAgICAgICAgICAtLS0gRnJhZ21lbnQgU2hhZGVyIC0tLVxyXG4gICAgICAgICAgICAke2ZyYWdtZW50X3NoYWRlcl9zb3VyY2V9YCk7XHJcbiAgICAgICAgbG9nLmVycm9yKHByb2dyYW1fZXJyb3IpO1xyXG4gICAgICAgIHRocm93IHByb2dyYW1fZXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByb2dyYW07XHJcbn07XHJcblxyXG4vLyBDb21waWxlIGEgdmVydGV4IG9yIGZyYWdtZW50IHNoYWRlciBmcm9tIHByb3ZpZGVkIHNvdXJjZVxyXG5TaGFkZXJQcm9ncmFtLmNyZWF0ZVNoYWRlciA9IGZ1bmN0aW9uIChnbCwgc291cmNlLCB0eXBlKSB7XHJcbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG5cclxuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XHJcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcblxyXG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICB2YXIgc2hhZGVyX2Vycm9yID1cclxuICAgICAgICAgICAgXCJXZWJHTCBzaGFkZXIgZXJyb3I6XFxuXCIgK1xyXG4gICAgICAgICAgICAodHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/IFwiVkVSVEVYXCIgOiBcIkZSQUdNRU5UXCIpICsgXCIgU0hBREVSOlxcblwiICtcclxuICAgICAgICAgICAgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xyXG4gICAgICAgIHRocm93IHNoYWRlcl9lcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2hhZGVyO1xyXG59O1xyXG4iLCIvLyBHZW5lcmF0ZWQgZnJvbSBHTFNMIGZpbGVzLCBkb24ndCBlZGl0IVxudmFyIHNoYWRlclNvdXJjZXMgPSB7fTtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9hbWJpZW50TGlnaHQnXSA9XG5cIi8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIkV4cGVjdGVkIGdsb2JhbHM6XFxuXCIgK1xuXCJsaWdodF9hY2N1bXVsYXRvcl8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIiovXFxuXCIgK1xuXCJcXG5cIiArXG5cInN0cnVjdCBBbWJpZW50TGlnaHQge1xcblwiICtcblwiICAgIHZlYzQgYW1iaWVudDtcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTGlnaHQoaW4gQW1iaWVudExpZ2h0IF9saWdodCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCIgICAgbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCArPSBfbGlnaHQuYW1iaWVudDtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2RpcmVjdGlvbmFsTGlnaHQnXSA9XG5cIi8qXFxuXCIgK1xuXCJcXG5cIiArXG5cIkV4cGVjdGVkIGdsb2JhbHM6XFxuXCIgK1xuXCJtYXRlcmlhbFxcblwiICtcblwibGlnaHRfYWNjdW11bGF0b3JfKlxcblwiICtcblwiXFxuXCIgK1xuXCIqL1xcblwiICtcblwiXFxuXCIgK1xuXCJzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XFxuXCIgK1xuXCIgICAgdmVjNCBhbWJpZW50O1xcblwiICtcblwiICAgIHZlYzQgZGlmZnVzZTtcXG5cIiArXG5cIiAgICB2ZWM0IHNwZWN1bGFyO1xcblwiICtcblwiICAgIHZlYzMgZGlyZWN0aW9uO1xcblwiICtcblwifTtcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBjYWxjdWxhdGVMaWdodChpbiBEaXJlY3Rpb25hbExpZ2h0IF9saWdodCwgaW4gdmVjMyBfZXllVG9Qb2ludCwgaW4gdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICs9IF9saWdodC5hbWJpZW50O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZmxvYXQgbkRvdFZQID0gY2xhbXAoZG90KF9ub3JtYWwsIC1ub3JtYWxpemUoX2xpZ2h0LmRpcmVjdGlvbikpLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXFxuXCIgK1xuXCIgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgKz0gX2xpZ2h0LmRpZmZ1c2UgKiBuRG90VlA7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUlxcblwiICtcblwiICAgICAgICBmbG9hdCBwZiA9IDAuMDtcXG5cIiArXG5cIiAgICAgICAgaWYgKG5Eb3RWUCA+IDAuMCkge1xcblwiICtcblwiICAgICAgICAgICAgdmVjMyByZWZsZWN0VmVjdG9yID0gcmVmbGVjdChub3JtYWxpemUoX2xpZ2h0LmRpcmVjdGlvbiksIF9ub3JtYWwpO1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZXllRG90UiA9IG1heChkb3Qobm9ybWFsaXplKF9leWVUb1BvaW50KSwgcmVmbGVjdFZlY3RvciksIDAuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBwZiA9IHBvdyhleWVEb3RSLCBtYXRlcmlhbC5zaGluaW5lc3MpO1xcblwiICtcblwiICAgICAgICB9XFxuXCIgK1xuXCIgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyICs9IF9saWdodC5zcGVjdWxhciAqIHBmO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvbGF5ZXJfb3JkZXInXSA9XG5cIi8vIEFwcGx5IGxheWVyIG9yZGVyaW5nIHRvIGF2b2lkIHotZmlnaHRpbmdcXG5cIiArXG5cInZvaWQgYXBwbHlMYXllck9yZGVyIChmbG9hdCBsYXllciwgaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcblwiICtcblwiICAgIHBvc2l0aW9uLnogLT0gbGF5ZXIgKiBUQU5HUkFNX0xBWUVSX0RFTFRBICogcG9zaXRpb24udztcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL21hdGVyaWFsJ10gPVxuXCIvKlxcblwiICtcblwiXFxuXCIgK1xuXCJEZWZpbmVzIGdsb2JhbHM6XFxuXCIgK1xuXCJtYXRlcmlhbFxcblwiICtcblwibGlnaHRfYWNjdW11bGF0b3JfKlxcblwiICtcblwiXFxuXCIgK1xuXCIqL1xcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIE1BVEVSSUFMU1xcblwiICtcblwiLy9cXG5cIiArXG5cInN0cnVjdCBNYXRlcmlhbCB7XFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05cXG5cIiArXG5cIiAgICAgICAgdmVjNCBlbWlzc2lvbjtcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRVxcblwiICtcblwiICAgICAgICAgICAgdmVjMyBlbWlzc2lvblNjYWxlO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRcXG5cIiArXG5cIiAgICAgICAgdmVjNCBhbWJpZW50O1xcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgYW1iaWVudFNjYWxlO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcXG5cIiArXG5cIiAgICAgICAgdmVjNCBkaWZmdXNlO1xcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgICAgIHZlYzMgZGlmZnVzZVNjYWxlO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXFxuXCIgK1xuXCIgICAgICAgIHZlYzQgc3BlY3VsYXI7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHNoaW5pbmVzcztcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAgICAgdmVjMyBzcGVjdWxhclNjYWxlO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgdmVjMyBub3JtYWxTY2FsZTtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgbm9ybWFsQW1vdW50O1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifTtcXG5cIiArXG5cIlxcblwiICtcblwiLy8gTm90ZTogdW5pZm9ybSBpcyBjb3BpZWQgdG8gYSBnbG9iYWwgaW5zdGFuY2UgdG8gYWxsb3cgbW9kaWZpY2F0aW9uXFxuXCIgK1xuXCJ1bmlmb3JtIE1hdGVyaWFsIHVfbWF0ZXJpYWw7XFxuXCIgK1xuXCJNYXRlcmlhbCBtYXRlcmlhbCA9IHVfbWF0ZXJpYWw7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVcXG5cIiArXG5cInVuaWZvcm0gc2FtcGxlcjJEIHVfbWF0ZXJpYWxfZW1pc3Npb25fdGV4dHVyZTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVcXG5cIiArXG5cInVuaWZvcm0gc2FtcGxlcjJEIHVfbWF0ZXJpYWxfYW1iaWVudF90ZXh0dXJlO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRVxcblwiICtcblwidW5pZm9ybSBzYW1wbGVyMkQgdV9tYXRlcmlhbF9kaWZmdXNlX3RleHR1cmU7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRVxcblwiICtcblwidW5pZm9ybSBzYW1wbGVyMkQgdV9tYXRlcmlhbF9zcGVjdWxhcl90ZXh0dXJlO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X21hdGVyaWFsX25vcm1hbF90ZXh0dXJlO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIEdsb2JhbCBsaWdodCBhY2N1bXVsYXRvcnMgZm9yIGVhY2ggcHJvcGVydHlcXG5cIiArXG5cInZlYzQgbGlnaHRfYWNjdW11bGF0b3JfYW1iaWVudCA9IHZlYzQoMC4wKTtcXG5cIiArXG5cInZlYzQgbGlnaHRfYWNjdW11bGF0b3JfZGlmZnVzZSA9IHZlYzQoMC4wKTtcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXFxuXCIgK1xuXCIgICAgdmVjNCBsaWdodF9hY2N1bXVsYXRvcl9zcGVjdWxhciA9IHZlYzQoMC4wKTtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1RFWFRVUkVfU1BIRVJFTUFQXFxuXCIgK1xuXCJ2ZWM0IGdldFNwaGVyZU1hcCAoaW4gc2FtcGxlcjJEIF90ZXgsIGluIHZlYzMgX2V5ZVRvUG9pbnQsIGluIHZlYzMgX25vcm1hbCwgaW4gdmVjMiBfc2tldykge1xcblwiICtcblwiICAgIHZlYzMgZXllID0gbm9ybWFsaXplKF9leWVUb1BvaW50KTtcXG5cIiArXG5cIiAgICBleWUueHkgLT0gX3NrZXc7XFxuXCIgK1xuXCIgICAgZXllID0gbm9ybWFsaXplKGV5ZSk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICB2ZWMzIHIgPSByZWZsZWN0KGV5ZSwgX25vcm1hbCk7XFxuXCIgK1xuXCIgICAgci56ICs9IDEuMDtcXG5cIiArXG5cIiAgICBmbG9hdCBtID0gMi4gKiBsZW5ndGgocik7XFxuXCIgK1xuXCIgICAgdmVjMiB1diA9IHIueHkgLyBtICsgLjU7XFxuXCIgK1xuXCIgICAgcmV0dXJuIHRleHR1cmUyRChfdGV4LCB1dik7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFX1RSSVBMQU5BUlxcblwiICtcblwidmVjMyBnZXRUcmlQbGFuYXJCbGVuZCAoaW4gdmVjMyBfbm9ybWFsKSB7XFxuXCIgK1xuXCIgICAgdmVjMyBibGVuZGluZyA9IGFicyhfbm9ybWFsKTtcXG5cIiArXG5cIiAgICBibGVuZGluZyA9IG5vcm1hbGl6ZShtYXgoYmxlbmRpbmcsIDAuMDAwMDEpKTtcXG5cIiArXG5cIiAgICBmbG9hdCBiID0gKGJsZW5kaW5nLnggKyBibGVuZGluZy55ICsgYmxlbmRpbmcueik7XFxuXCIgK1xuXCIgICAgcmV0dXJuIGJsZW5kaW5nIC8gYjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlxcblwiICtcblwidmVjNCBnZXRUcmlQbGFuYXIgKGluIHNhbXBsZXIyRCBfdGV4LCBpbiB2ZWMzIF9wb3MsIGluIHZlYzMgX25vcm1hbCwgaW4gdmVjMyBfc2NhbGUpIHtcXG5cIiArXG5cIiAgICB2ZWMzIGJsZW5kaW5nID0gZ2V0VHJpUGxhbmFyQmxlbmQoX25vcm1hbCk7XFxuXCIgK1xuXCIgICAgdmVjNCB4YXhpcyA9IHRleHR1cmUyRChfdGV4LCBmcmFjdChfcG9zLnl6ICogX3NjYWxlLngpKTtcXG5cIiArXG5cIiAgICB2ZWM0IHlheGlzID0gdGV4dHVyZTJEKF90ZXgsIGZyYWN0KF9wb3MueHogKiBfc2NhbGUueSkpO1xcblwiICtcblwiICAgIHZlYzQgemF4aXMgPSB0ZXh0dXJlMkQoX3RleCwgZnJhY3QoX3Bvcy54eSAqIF9zY2FsZS56KSk7XFxuXCIgK1xuXCIgICAgcmV0dXJuICB4YXhpcyAqIGJsZW5kaW5nLnggKyB5YXhpcyAqIGJsZW5kaW5nLnkgKyB6YXhpcyAqIGJsZW5kaW5nLno7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFX1BMQU5BUlxcblwiICtcblwidmVjNCBnZXRQbGFuYXIgKGluIHNhbXBsZXIyRCBfdGV4LCBpbiB2ZWMzIF9wb3MsIGluIHZlYzIgX3NjYWxlKSB7XFxuXCIgK1xuXCIgICAgcmV0dXJuIHRleHR1cmUyRCggX3RleCwgZnJhY3QoX3Bvcy54eSAqIF9zY2FsZS54KSApO1xcblwiICtcblwifVxcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTm9ybWFsIChpbm91dCB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIiAgICAvLyBHZXQgTk9STUFMTUFQXFxuXCIgK1xuXCIgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRV9VVlxcblwiICtcblwiICAgIF9ub3JtYWwgKz0gdGV4dHVyZTJEKHVfbWF0ZXJpYWxfbm9ybWFsX3RleHR1cmUsIGZyYWN0KHZfdGV4Y29vcmQqbWF0ZXJpYWwubm9ybWFsU2NhbGUueHkpKS5yZ2IqMi4wLTEuMDtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFX1BMQU5BUlxcblwiICtcblwiICAgIHZlYzMgbm9ybWFsVGV4ID0gZ2V0UGxhbmFyKHVfbWF0ZXJpYWxfbm9ybWFsX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBtYXRlcmlhbC5ub3JtYWxTY2FsZS54eSkucmdiKjIuMC0xLjA7XFxuXCIgK1xuXCIgICAgX25vcm1hbCArPSBub3JtYWxUZXg7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9OT1JNQUxfVEVYVFVSRV9UUklQTEFOQVJcXG5cIiArXG5cIiAgICB2ZWMzIG5vcm1hbFRleCA9IGdldFRyaVBsYW5hcih1X21hdGVyaWFsX25vcm1hbF90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgX25vcm1hbCwgbWF0ZXJpYWwubm9ybWFsU2NhbGUpLnJnYioyLjAtMS4wO1xcblwiICtcblwiICAgIF9ub3JtYWwgKz0gbm9ybWFsVGV4O1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgX25vcm1hbCA9IG5vcm1hbGl6ZShfbm9ybWFsKTtcXG5cIiArXG5cIn1cXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIGNhbGN1bGF0ZU1hdGVyaWFsIChpbiB2ZWMzIF9leWVUb1BvaW50LCBpbm91dCB2ZWMzIF9ub3JtYWwpIHtcXG5cIiArXG5cIiAgICAvLyBnZXQgRU1JU1NJT04gVEVYVFVSRU1BUFxcblwiICtcblwiICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRVxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFX1VWXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmVtaXNzaW9uICo9IHRleHR1cmUyRCh1X21hdGVyaWFsX2VtaXNzaW9uX3RleHR1cmUsdl90ZXhjb29yZCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OX1RFWFRVUkVfUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmVtaXNzaW9uICo9IGdldFBsYW5hcih1X21hdGVyaWFsX2VtaXNzaW9uX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBtYXRlcmlhbC5lbWlzc2lvblNjYWxlLnh5KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRU1JU1NJT05fVEVYVFVSRV9UUklQTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZW1pc3Npb24gKj0gZ2V0VHJpUGxhbmFyKHVfbWF0ZXJpYWxfZW1pc3Npb25fdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIF9ub3JtYWwsIG1hdGVyaWFsLmVtaXNzaW9uU2NhbGUpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9FTUlTU0lPTl9URVhUVVJFX1NQSEVSRU1BUFxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5lbWlzc2lvbiAqPSBnZXRTcGhlcmVNYXAodV9tYXRlcmlhbF9lbWlzc2lvbl90ZXh0dXJlLCBfZXllVG9Qb2ludCwgX25vcm1hbCwgdV92YW5pc2hpbmdfcG9pbnQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIGdldCBBTUJJRU5UIFRFWFRVUkVNQVBcXG5cIiArXG5cIiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRVxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVfVVZcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuYW1iaWVudCAqPSB0ZXh0dXJlMkQodV9tYXRlcmlhbF9hbWJpZW50X3RleHR1cmUsdl90ZXhjb29yZCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRfVEVYVFVSRV9QTEFOQVJcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuYW1iaWVudCAqPSBnZXRQbGFuYXIodV9tYXRlcmlhbF9hbWJpZW50X3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBtYXRlcmlhbC5hbWJpZW50U2NhbGUueHkpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9BTUJJRU5UX1RFWFRVUkVfVFJJUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmFtYmllbnQgKj0gZ2V0VHJpUGxhbmFyKHVfbWF0ZXJpYWxfYW1iaWVudF90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgX25vcm1hbCwgbWF0ZXJpYWwuYW1iaWVudFNjYWxlKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfQU1CSUVOVF9URVhUVVJFX1NQSEVSRU1BUFxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5hbWJpZW50ICo9IGdldFNwaGVyZU1hcCh1X21hdGVyaWFsX2FtYmllbnRfdGV4dHVyZSwgX2V5ZVRvUG9pbnQsIF9ub3JtYWwsIHVfdmFuaXNoaW5nX3BvaW50KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBnZXQgRElGRlVTRSBURVhUVVJFTUFQXFxuXCIgK1xuXCIgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFX1VWXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmRpZmZ1c2UgKj0gdGV4dHVyZTJEKHVfbWF0ZXJpYWxfZGlmZnVzZV90ZXh0dXJlLHZfdGV4Y29vcmQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkVfUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLmRpZmZ1c2UgKj0gZ2V0UGxhbmFyKHVfbWF0ZXJpYWxfZGlmZnVzZV90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgbWF0ZXJpYWwuZGlmZnVzZVNjYWxlLnh5KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFX1RSSVBMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5kaWZmdXNlICo9IGdldFRyaVBsYW5hcih1X21hdGVyaWFsX2RpZmZ1c2VfdGV4dHVyZSwgdl93b3JsZF9wb3NpdGlvbi54eXosIF9ub3JtYWwsIG1hdGVyaWFsLmRpZmZ1c2VTY2FsZSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VfVEVYVFVSRV9TUEhFUkVNQVBcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuZGlmZnVzZSAqPSBnZXRTcGhlcmVNYXAodV9tYXRlcmlhbF9kaWZmdXNlX3RleHR1cmUsIF9leWVUb1BvaW50LCBfbm9ybWFsLCB1X3ZhbmlzaGluZ19wb2ludCk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gZ2V0IFNQRUNVTEFSIFRFWFRVUkVNQVBcXG5cIiArXG5cIiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRV9VVlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5zcGVjdWxhciAqPSB0ZXh0dXJlMkQodV9tYXRlcmlhbF9zcGVjdWxhcl90ZXh0dXJlLHZfdGV4Y29vcmQpO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9TUEVDVUxBUl9URVhUVVJFX1BMQU5BUlxcblwiICtcblwiICAgICAgICBtYXRlcmlhbC5zcGVjdWxhciAqPSBnZXRQbGFuYXIodV9tYXRlcmlhbF9zcGVjdWxhcl90ZXh0dXJlLCB2X3dvcmxkX3Bvc2l0aW9uLnh5eiwgbWF0ZXJpYWwuc3BlY3VsYXJTY2FsZS54eSk7XFxuXCIgK1xuXCIgICAgICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSX1RFWFRVUkVfVFJJUExBTkFSXFxuXCIgK1xuXCIgICAgICAgIG1hdGVyaWFsLnNwZWN1bGFyICo9IGdldFRyaVBsYW5hcih1X21hdGVyaWFsX3NwZWN1bGFyX3RleHR1cmUsIHZfd29ybGRfcG9zaXRpb24ueHl6LCBfbm9ybWFsLCBtYXRlcmlhbC5zcGVjdWxhclNjYWxlKTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfU1BFQ1VMQVJfVEVYVFVSRV9TUEhFUkVNQVBcXG5cIiArXG5cIiAgICAgICAgbWF0ZXJpYWwuc3BlY3VsYXIgKj0gZ2V0U3BoZXJlTWFwKHVfbWF0ZXJpYWxfc3BlY3VsYXJfdGV4dHVyZSwgX2V5ZVRvUG9pbnQsIF9ub3JtYWwsIHVfdmFuaXNoaW5nX3BvaW50KTtcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9wb2ludExpZ2h0J10gPVxuXCIvKlxcblwiICtcblwiXFxuXCIgK1xuXCJFeHBlY3RlZCBnbG9iYWxzOlxcblwiICtcblwibWF0ZXJpYWxcXG5cIiArXG5cImxpZ2h0X2FjY3VtdWxhdG9yXypcXG5cIiArXG5cIlxcblwiICtcblwiKi9cXG5cIiArXG5cIlxcblwiICtcblwic3RydWN0IFBvaW50TGlnaHQge1xcblwiICtcblwiICAgIHZlYzQgYW1iaWVudDtcXG5cIiArXG5cIiAgICB2ZWM0IGRpZmZ1c2U7XFxuXCIgK1xuXCIgICAgdmVjNCBzcGVjdWxhcjtcXG5cIiArXG5cIiAgICB2ZWM0IHBvc2l0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UXFxuXCIgK1xuXCIgICAgZmxvYXQgYXR0ZW51YXRpb25FeHBvbmVudDtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVU1xcblwiICtcblwiICAgIGZsb2F0IGlubmVyUmFkaXVzO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgZmxvYXQgb3V0ZXJSYWRpdXM7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIn07XFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgY2FsY3VsYXRlTGlnaHQoaW4gUG9pbnRMaWdodCBfbGlnaHQsIGluIHZlYzMgX2V5ZVRvUG9pbnQsIGluIHZlYzMgX25vcm1hbCkge1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZmxvYXQgZGlzdCA9IGxlbmd0aChfbGlnaHQucG9zaXRpb24ueHl6IC0gX2V5ZVRvUG9pbnQpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQ29tcHV0ZSB2ZWN0b3IgZnJvbSBzdXJmYWNlIHRvIGxpZ2h0IHBvc2l0aW9uXFxuXCIgK1xuXCIgICAgdmVjMyBWUCA9IChfbGlnaHQucG9zaXRpb24ueHl6IC0gX2V5ZVRvUG9pbnQpIC8gZGlzdDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIE5vcm1hbGl6ZSB0aGUgdmVjdG9yIGZyb20gc3VyZmFjZSB0byBsaWdodCBwb3NpdGlvblxcblwiICtcblwiICAgIGZsb2F0IG5Eb3RWUCA9IGNsYW1wKGRvdChWUCwgX25vcm1hbCksIDAuMCwgMS4wKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEF0dGVudWF0aW9uIGRlZmF1bHRzXFxuXCIgK1xuXCIgICAgZmxvYXQgYXR0ZW51YXRpb24gPSAxLjA7XFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVFxcblwiICtcblwiICAgICAgICBmbG9hdCBSaW4gPSAxLjA7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IGUgPSBfbGlnaHQuYXR0ZW51YXRpb25FeHBvbmVudDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgUmluID0gX2xpZ2h0LmlubmVyUmFkaXVzO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgUmRpZmYgPSBfbGlnaHQub3V0ZXJSYWRpdXMtUmluO1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKG1heCgwLjAsZGlzdC1SaW4pL1JkaWZmLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC0ocG93KGQsZSkpO1xcblwiICtcblwiICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgLy8gSWYgbm8gb3V0ZXIgaXMgcHJvdmlkZSBiZWhhdmVzIGxpa2U6XFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBodHRwczovL2ltZG9pbmdpdHdyb25nLndvcmRwcmVzcy5jb20vMjAxMS8wMS8zMS9saWdodC1hdHRlbnVhdGlvbi9cXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGQgPSBtYXgoMC4wLGRpc3QtUmluKS9SaW4rMS4wO1xcblwiICtcblwiICAgICAgICAgICAgYXR0ZW51YXRpb24gPSBjbGFtcCgxLjAvKHBvdyhkLGUpKSwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZWxzZVxcblwiICtcblwiICAgICAgICBmbG9hdCBSaW4gPSAwLjA7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIFJpbiA9IF9saWdodC5pbm5lclJhZGl1cztcXG5cIiArXG5cIiAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgUmRpZmYgPSBfbGlnaHQub3V0ZXJSYWRpdXMtUmluO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IGQgPSBjbGFtcChtYXgoMC4wLGRpc3QtUmluKS9SZGlmZiwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wLWQqZDtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgLy8gSWYgbm8gb3V0ZXIgaXMgcHJvdmlkZSBiZWhhdmVzIGxpa2U6XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9pbWRvaW5naXR3cm9uZy53b3JkcHJlc3MuY29tLzIwMTEvMDEvMzEvbGlnaHQtYXR0ZW51YXRpb24vXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IG1heCgwLjAsZGlzdC1SaW4pL1JpbisxLjA7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSBjbGFtcCgxLjAvZCwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IGQgPSBjbGFtcChkaXN0L19saWdodC5vdXRlclJhZGl1cywgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wLWQqZDtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjA7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDb21wdXRlciBhY2N1bXVsYXRvcnNcXG5cIiArXG5cIiAgICBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICs9IF9saWdodC5hbWJpZW50ICogYXR0ZW51YXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXFxuXCIgK1xuXCIgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgKz0gX2xpZ2h0LmRpZmZ1c2UgKiBuRG90VlAgKiBhdHRlbnVhdGlvbjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHBmID0gMC4wOyAvLyBwb3dlciBmYWN0b3IgZm9yIHNoaW55IHNwZWN1bGFyc1xcblwiICtcblwiICAgICAgICBpZiAobkRvdFZQID4gMC4wKSB7XFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIHJlZmxlY3RWZWN0b3IgPSByZWZsZWN0KC1WUCwgX25vcm1hbCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBleWVEb3RSID0gbWF4KDAuMCwgZG90KC1ub3JtYWxpemUoX2V5ZVRvUG9pbnQpLCByZWZsZWN0VmVjdG9yKSk7XFxuXCIgK1xuXCIgICAgICAgICAgICBwZiA9IHBvdyhleWVEb3RSLCBtYXRlcmlhbC5zaGluaW5lc3MpO1xcblwiICtcblwiICAgICAgICB9XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgbGlnaHRfYWNjdW11bGF0b3Jfc3BlY3VsYXIgKz0gX2xpZ2h0LnNwZWN1bGFyICogcGYgKiBhdHRlbnVhdGlvbjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl9mcmFnbWVudCddID1cblwiLy8gRnJhZ21lbnQgc2hhZGVyIGZvciBmZWF0dXJlIHNlbGVjdGlvbiBwYXNzZXNcXG5cIiArXG5cIi8vIFJlbmRlcnMgaW4gc2lsaG91ZXR0ZSBhY2NvcmRpbmcgdG8gc2VsZWN0aW9uIChwaWNraW5nKSBjb2xvciwgb3IgYmxhY2sgaWYgbm9uZSBkZWZpbmVkXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX0ZFQVRVUkVfU0VMRUNUSU9OXFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWM0IHZfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cInZvaWQgbWFpbiAodm9pZCkge1xcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX0ZFQVRVUkVfU0VMRUNUSU9OXFxuXCIgK1xuXCIgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4sIDAuLCAwLiwgMS4pO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc2VsZWN0aW9uX2dsb2JhbHMnXSA9XG5cIi8vIFZlcnRleCBhdHRyaWJ1dGUgKyB2YXJ5aW5nIGZvciBmZWF0dXJlIHNlbGVjdGlvblxcblwiICtcblwiI2lmIGRlZmluZWQoVEFOR1JBTV9GRUFUVVJFX1NFTEVDVElPTikgJiYgZGVmaW5lZChUQU5HUkFNX1ZFUlRFWF9TSEFERVIpXFxuXCIgK1xuXCIgICAgYXR0cmlidXRlIHZlYzQgYV9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWM0IHZfc2VsZWN0aW9uX2NvbG9yO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zZWxlY3Rpb25fdmVydGV4J10gPVxuXCIvLyBTZWxlY3Rpb24gcGFzcy1zcGVjaWZpYyByZW5kZXJpbmdcXG5cIiArXG5cIiNpZiBkZWZpbmVkKFRBTkdSQU1fRkVBVFVSRV9TRUxFQ1RJT04pICYmIGRlZmluZWQoVEFOR1JBTV9WRVJURVhfU0hBREVSKVxcblwiICtcblwiICAgIGlmIChhX3NlbGVjdGlvbl9jb2xvci5yZ2IgPT0gdmVjMygwLikpIHtcXG5cIiArXG5cIiAgICAgICAgLy8gRGlzY2FyZCBieSBmb3JjaW5nIGludmFsaWQgdHJpYW5nbGUgaWYgd2VcXCdyZSBpbiB0aGUgZmVhdHVyZVxcblwiICtcblwiICAgICAgICAvLyBzZWxlY3Rpb24gcGFzcyBidXQgaGF2ZSBubyBzZWxlY3Rpb24gaW5mb1xcblwiICtcblwiICAgICAgICAvLyBUT0RPOiBpbiBzb21lIGNhc2VzIHdlIG1heSBhY3R1YWxseSB3YW50IG5vbi1zZWxlY3RhYmxlIGZlYXR1cmVzIHRvIG9jY2x1ZGUgc2VsZWN0YWJsZSBvbmVzP1xcblwiICtcblwiICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMC4sIDAuLCAwLiwgMS4pO1xcblwiICtcblwiICAgICAgICByZXR1cm47XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiICAgIHZfc2VsZWN0aW9uX2NvbG9yID0gYV9zZWxlY3Rpb25fY29sb3I7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NwaGVyaWNhbF9lbnZpcm9ubWVudF9tYXAnXSA9XG5cIi8vIFNwaGVyaWNhbCBlbnZpcm9ubWVudCBtYXBcXG5cIiArXG5cIi8vIEJhc2VkIG9uOiBodHRwOi8vd3d3LmNsaWNrdG9yZWxlYXNlLmNvbS9ibG9nL2NyZWF0aW5nLXNwaGVyaWNhbC1lbnZpcm9ubWVudC1tYXBwaW5nLXNoYWRlclxcblwiICtcblwiXFxuXCIgK1xuXCIvLyB2aWV3OiBsb2NhdGlvbiBvZiBjYW1lcmFcXG5cIiArXG5cIi8vIHBvc2l0aW9uOiBsb2NhdGlvbiBvZiBjdXJyZW50IHBvaW50IG9uIHN1cmZhY2VcXG5cIiArXG5cIi8vIG5vcm1hbDogbm9ybWFsIG9mIGN1cnJlbnQgcG9pbnQgb24gc3VyZmFjZVxcblwiICtcblwiLy8gc2tldzogc2tld2luZyBmYWN0b3IgKHVzZWQgdG8gY29tcGVuc2F0ZSBmb3IgYWx0ZXJlZCB2YW5pc2hpbmcgcG9pbnQpXFxuXCIgK1xuXCIvLyBlbnZtYXA6IHNwaGVyaWNhbCBlbnZpcm9ubWVudCBtYXAgdGV4dHVyZVxcblwiICtcblwiXFxuXCIgK1xuXCJ2ZWM0IHNwaGVyaWNhbEVudmlyb25tZW50TWFwKHZlYzMgdmlldywgdmVjMyBwb3NpdGlvbiwgdmVjMyBub3JtYWwsIHZlYzIgc2tldywgc2FtcGxlcjJEIGVudm1hcCkge1xcblwiICtcblwiICAgIC8vIE5vcm1hbGl6ZWQgdmVjdG9yIGZyb20gY2FtZXJhIHRvIHN1cmZhY2VcXG5cIiArXG5cIiAgICB2ZWMzIGV5ZSA9IG5vcm1hbGl6ZShwb3NpdGlvbi54eXogLSB2aWV3Lnh5eik7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTa2V3XFxuXCIgK1xuXCIgICAgZXllLnh5IC09IHNrZXc7XFxuXCIgK1xuXCIgICAgZXllID0gbm9ybWFsaXplKGV5ZSk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBSZWZsZWN0aW9uIG9mIGV5ZSBvZmYgb2Ygc3VyZmFjZSBub3JtYWxcXG5cIiArXG5cIiAgICB2ZWMzIHIgPSByZWZsZWN0KGV5ZSwgbm9ybWFsKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIE1hcCByZWZsZWN0ZWQgdmVjdG9yIG9udG8gdGhlIHN1cmZhY2Ugb2YgYSBzcGhlcmVcXG5cIiArXG5cIiAgICByLnogKz0gMS47XFxuXCIgK1xuXCIgICAgZmxvYXQgbSA9IDIuICogbGVuZ3RoKHIpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQWRqdXN0IHh5IHRvIGFjY291bnQgZm9yIHNwaGVyaWNhbCBzaGFwZSwgYW5kIGNlbnRlciBpbiBtaWRkbGUgb2YgdGV4dHVyZVxcblwiICtcblwiICAgIHZlYzIgdXYgPSByLnh5IC8gbSArIC41O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gU2FtcGxlIHRoZSBlbnZpcm9ubWVudCBtYXBcXG5cIiArXG5cIiAgICByZXR1cm4gdGV4dHVyZTJEKGVudm1hcCwgdXYpO1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc3BvdExpZ2h0J10gPVxuXCIvKlxcblwiICtcblwiXFxuXCIgK1xuXCJFeHBlY3RlZCBnbG9iYWxzOlxcblwiICtcblwibWF0ZXJpYWxcXG5cIiArXG5cImxpZ2h0X2FjY3VtdWxhdG9yXypcXG5cIiArXG5cIlxcblwiICtcblwiKi9cXG5cIiArXG5cIlxcblwiICtcblwic3RydWN0IFNwb3RMaWdodCB7XFxuXCIgK1xuXCIgICAgdmVjNCBhbWJpZW50O1xcblwiICtcblwiICAgIHZlYzQgZGlmZnVzZTtcXG5cIiArXG5cIiAgICB2ZWM0IHNwZWN1bGFyO1xcblwiICtcblwiICAgIHZlYzQgcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fRVhQT05FTlRcXG5cIiArXG5cIiAgICBmbG9hdCBhdHRlbnVhdGlvbkV4cG9uZW50O1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTXFxuXCIgK1xuXCIgICAgZmxvYXQgaW5uZXJSYWRpdXM7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVNcXG5cIiArXG5cIiAgICBmbG9hdCBvdXRlclJhZGl1cztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgdmVjMyBkaXJlY3Rpb247XFxuXCIgK1xuXCIgICAgZmxvYXQgc3BvdENvc0N1dG9mZjtcXG5cIiArXG5cIiAgICBmbG9hdCBzcG90RXhwb25lbnQ7XFxuXCIgK1xuXCJ9O1xcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIGNhbGN1bGF0ZUxpZ2h0KGluIFNwb3RMaWdodCBfbGlnaHQsIGluIHZlYzMgX2V5ZVRvUG9pbnQsIGluIHZlYzMgX25vcm1hbCkge1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZmxvYXQgZGlzdCA9IGxlbmd0aChfbGlnaHQucG9zaXRpb24ueHl6IC0gX2V5ZVRvUG9pbnQpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQ29tcHV0ZSB2ZWN0b3IgZnJvbSBzdXJmYWNlIHRvIGxpZ2h0IHBvc2l0aW9uXFxuXCIgK1xuXCIgICAgdmVjMyBWUCA9IChfbGlnaHQucG9zaXRpb24ueHl6IC0gX2V5ZVRvUG9pbnQpIC8gZGlzdDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIG5vcm1hbCAuIGxpZ2h0IGRpcmVjdGlvblxcblwiICtcblwiICAgIGZsb2F0IG5Eb3RWUCA9IGNsYW1wKGRvdChfbm9ybWFsLCBWUCksIDAuMCwgMS4wKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEF0dGVudWF0aW9uIGRlZmF1bHRzXFxuXCIgK1xuXCIgICAgZmxvYXQgYXR0ZW51YXRpb24gPSAxLjA7XFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9FWFBPTkVOVFxcblwiICtcblwiICAgICAgICBmbG9hdCBSaW4gPSAxLjA7XFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IGUgPSBfbGlnaHQuYXR0ZW51YXRpb25FeHBvbmVudDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0lOTkVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgUmluID0gX2xpZ2h0LmlubmVyUmFkaXVzO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgUmRpZmYgPSBfbGlnaHQub3V0ZXJSYWRpdXMtUmluO1xcblwiICtcblwiICAgICAgICAgICAgZmxvYXQgZCA9IGNsYW1wKG1heCgwLjAsZGlzdC1SaW4pL1JkaWZmLCAwLjAsIDEuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBhdHRlbnVhdGlvbiA9IDEuMC0ocG93KGQsZSkpO1xcblwiICtcblwiICAgICAgICAjZWxzZVxcblwiICtcblwiICAgICAgICAgICAgLy8gSWYgbm8gb3V0ZXIgaXMgcHJvdmlkZSBiZWhhdmVzIGxpa2U6XFxuXCIgK1xuXCIgICAgICAgICAgICAvLyBodHRwczovL2ltZG9pbmdpdHdyb25nLndvcmRwcmVzcy5jb20vMjAxMS8wMS8zMS9saWdodC1hdHRlbnVhdGlvbi9cXG5cIiArXG5cIiAgICAgICAgICAgIGZsb2F0IGQgPSBtYXgoMC4wLGRpc3QtUmluKS9SaW4rMS4wO1xcblwiICtcblwiICAgICAgICAgICAgYXR0ZW51YXRpb24gPSBjbGFtcCgxLjAvKHBvdyhkLGUpKSwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAjZWxzZVxcblwiICtcblwiICAgICAgICBmbG9hdCBSaW4gPSAwLjA7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAgICAgI2lmZGVmIFRBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9JTk5FUl9SQURJVVNcXG5cIiArXG5cIiAgICAgICAgICAgIFJpbiA9IF9saWdodC5pbm5lclJhZGl1cztcXG5cIiArXG5cIiAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fT1VURVJfUkFESVVTXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgUmRpZmYgPSBfbGlnaHQub3V0ZXJSYWRpdXMtUmluO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IGQgPSBjbGFtcChtYXgoMC4wLGRpc3QtUmluKS9SZGlmZiwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wLWQqZDtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgLy8gSWYgbm8gb3V0ZXIgaXMgcHJvdmlkZSBiZWhhdmVzIGxpa2U6XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9pbWRvaW5naXR3cm9uZy53b3JkcHJlc3MuY29tLzIwMTEvMDEvMzEvbGlnaHQtYXR0ZW51YXRpb24vXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgZmxvYXQgZCA9IG1heCgwLjAsZGlzdC1SaW4pL1JpbisxLjA7XFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSBjbGFtcCgxLjAvZCwgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAjaWZkZWYgVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX09VVEVSX1JBRElVU1xcblwiICtcblwiICAgICAgICAgICAgICAgIGZsb2F0IGQgPSBjbGFtcChkaXN0L19saWdodC5vdXRlclJhZGl1cywgMC4wLCAxLjApO1xcblwiICtcblwiICAgICAgICAgICAgICAgIGF0dGVudWF0aW9uID0gMS4wLWQqZDtcXG5cIiArXG5cIiAgICAgICAgICAgICNlbHNlXFxuXCIgK1xuXCIgICAgICAgICAgICAgICAgYXR0ZW51YXRpb24gPSAxLjA7XFxuXCIgK1xuXCIgICAgICAgICAgICAjZW5kaWZcXG5cIiArXG5cIiAgICAgICAgI2VuZGlmXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBzcG90bGlnaHQgYXR0ZW51YXRpb24gZmFjdG9yXFxuXCIgK1xuXCIgICAgZmxvYXQgc3BvdEF0dGVudWF0aW9uID0gMC4wO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gU2VlIGlmIHBvaW50IG9uIHN1cmZhY2UgaXMgaW5zaWRlIGNvbmUgb2YgaWxsdW1pbmF0aW9uXFxuXCIgK1xuXCIgICAgZmxvYXQgc3BvdERvdCA9IGNsYW1wKGRvdCgtVlAsIG5vcm1hbGl6ZShfbGlnaHQuZGlyZWN0aW9uKSksIDAuMCwgMS4wKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGlmIChzcG90RG90ID49IF9saWdodC5zcG90Q29zQ3V0b2ZmKSB7XFxuXCIgK1xuXCIgICAgICAgIHNwb3RBdHRlbnVhdGlvbiA9IHBvdyhzcG90RG90LCBfbGlnaHQuc3BvdEV4cG9uZW50KTtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICs9IF9saWdodC5hbWJpZW50ICogYXR0ZW51YXRpb24gKiBzcG90QXR0ZW51YXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWZkZWYgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFXFxuXCIgK1xuXCIgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX2RpZmZ1c2UgKz0gX2xpZ2h0LmRpZmZ1c2UgKiBuRG90VlAgKiBhdHRlbnVhdGlvbiAqIHNwb3RBdHRlbnVhdGlvbjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXFxuXCIgK1xuXCIgICAgICAgIC8vIFBvd2VyIGZhY3RvciBmb3Igc2hpbnkgc3BlY3VsYXJzXFxuXCIgK1xuXCIgICAgICAgIGZsb2F0IHBmID0gMC4wO1xcblwiICtcblwiICAgICAgICBpZiAobkRvdFZQID4gMC4wKSB7XFxuXCIgK1xuXCIgICAgICAgICAgICB2ZWMzIHJlZmxlY3RWZWN0b3IgPSByZWZsZWN0KC1WUCwgX25vcm1hbCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBmbG9hdCBleWVEb3RSID0gbWF4KGRvdCgtbm9ybWFsaXplKF9leWVUb1BvaW50KSwgcmVmbGVjdFZlY3RvciksIDAuMCk7XFxuXCIgK1xuXCIgICAgICAgICAgICBwZiA9IHBvdyhleWVEb3RSLCBtYXRlcmlhbC5zaGluaW5lc3MpO1xcblwiICtcblwiICAgICAgICB9XFxuXCIgK1xuXCIgICAgICAgIGxpZ2h0X2FjY3VtdWxhdG9yX3NwZWN1bGFyICs9IF9saWdodC5zcGVjdWxhciAqIHBmICogYXR0ZW51YXRpb24gKiBzcG90QXR0ZW51YXRpb247XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snc3R5bGVzL3BvaW50cy9wb2ludHNfZnJhZ21lbnQnXSA9XG5cInVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWV0ZXJzX3Blcl9waXhlbDtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfdGltZTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X21hcF9wb3NpdGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X3RpbGVfb3JpZ2luO1xcblwiICtcblwiXFxuXCIgK1xuXCJ1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxuXCIgK1xuXCJcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblwiICtcblwidmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxuXCIgK1xuXCJcXG5cIiArXG5cIi8vIEFscGhhIGRpc2NhcmQgdGhyZXNob2xkIChzdWJzdGl0dXRlIGZvciBhbHBoYSBibGVuZGluZylcXG5cIiArXG5cIiNpZm5kZWYgVEFOR1JBTV9BTFBIQV9ESVNDQVJEXFxuXCIgK1xuXCIjZGVmaW5lIFRBTkdSQU1fQUxQSEFfRElTQ0FSRCAwLjVcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBBbHBoYSBmYWRlIHJhbmdlIGZvciBlZGdlcyBvZiBwb2ludHNcXG5cIiArXG5cIiNpZm5kZWYgVEFOR1JBTV9GQURFX1JBTkdFXFxuXCIgK1xuXCIjZGVmaW5lIFRBTkdSQU1fRkFERV9SQU5HRSAuMTVcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiI2RlZmluZSBUQU5HUkFNX0ZBREVfU1RBUlQgKDEuIC0gVEFOR1JBTV9GQURFX1JBTkdFKVxcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGdsb2JhbFxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4gKHZvaWQpIHtcXG5cIiArXG5cIiAgICB2ZWM0IGNvbG9yID0gdl9jb2xvcjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFwcGx5IGEgdGV4dHVyZVxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX1BPSU5UX1RFWFRVUkVcXG5cIiArXG5cIiAgICAgICAgY29sb3IgKj0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXhjb29yZCk7XFxuXCIgK1xuXCIgICAgLy8gRHJhdyBhIHBvaW50XFxuXCIgK1xuXCIgICAgI2Vsc2VcXG5cIiArXG5cIiAgICAgICAgLy8gRmFkZSBhbHBoYSBuZWFyIGNpcmNsZSBlZGdlXFxuXCIgK1xuXCIgICAgICAgIHZlYzIgdXYgPSB2X3RleGNvb3JkICogMi4gLSAxLjtcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgZGlzdCA9IGxlbmd0aCh1dik7XFxuXCIgK1xuXCIgICAgICAgIGNvbG9yLmEgPSBjbGFtcCgxLiAtIChzbW9vdGhzdGVwKDAuLCBUQU5HUkFNX0ZBREVfUkFOR0UsIChkaXN0IC0gVEFOR1JBTV9GQURFX1NUQVJUKSkgLyBUQU5HUkFNX0ZBREVfUkFOR0UpLCAwLiwgMS4pO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gSWYgYmxlbmRpbmcgaXMgb2ZmLCB1c2UgYWxwaGEgZGlzY2FyZCBhcyBhIGxvd2VyLXF1YWxpdHkgc3Vic3RpdHV0ZVxcblwiICtcblwiICAgICNpZm5kZWYgVEFOR1JBTV9CTEVORF9PVkVSTEFZXFxuXCIgK1xuXCIgICAgICAgIGlmIChjb2xvci5hIDwgVEFOR1JBTV9BTFBIQV9ESVNDQVJEKSB7XFxuXCIgK1xuXCIgICAgICAgICAgICBkaXNjYXJkO1xcblwiICtcblwiICAgICAgICB9XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGNvbG9yXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBmaWx0ZXJcXG5cIiArXG5cIlxcblwiICtcblwiICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcblwiICtcblwifVxcblwiICtcblwiXCI7XG5cbnNoYWRlclNvdXJjZXNbJ3N0eWxlcy9wb2ludHMvcG9pbnRzX3ZlcnRleCddID1cblwidW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV90aW1lO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfbWFwX3Bvc2l0aW9uO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfdGlsZV9vcmlnaW47XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWV0ZXJzX3Blcl9waXhlbDtcXG5cIiArXG5cIlxcblwiICtcblwidW5pZm9ybSBtYXQ0IHVfbW9kZWw7XFxuXCIgK1xuXCJ1bmlmb3JtIG1hdDQgdV9tb2RlbFZpZXc7XFxuXCIgK1xuXCJcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjNCBhX3NoYXBlO1xcblwiICtcblwiYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5cIiArXG5cImF0dHJpYnV0ZSB2ZWMyIGFfdGV4Y29vcmQ7XFxuXCIgK1xuXCIjaWZkZWYgVEFOR1JBTV9PUkRFUl9BVFRSSUJVVEVcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgZmxvYXQgYV9sYXllcjtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cIiArXG5cInZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcXG5cIiArXG5cIlxcblwiICtcblwidmVjMiByb3RhdGUyRCh2ZWMyIF9zdCwgZmxvYXQgX2FuZ2xlKSB7XFxuXCIgK1xuXCIgICAgcmV0dXJuIG1hdDIoY29zKF9hbmdsZSksLXNpbihfYW5nbGUpLFxcblwiICtcblwiICAgICAgICAgICAgICAgIHNpbihfYW5nbGUpLGNvcyhfYW5nbGUpKSAqIF9zdDtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluKCkge1xcblwiICtcblwiICAgIC8vIEFkZHMgdmVydGV4IHNoYWRlciBzdXBwb3J0IGZvciBmZWF0dXJlIHNlbGVjdGlvblxcblwiICtcblwiICAgICNwcmFnbWEgdGFuZ3JhbTogZmVhdHVyZS1zZWxlY3Rpb24tdmVydGV4XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICB2X2NvbG9yID0gYV9jb2xvcjtcXG5cIiArXG5cIiAgICB2X3RleGNvb3JkID0gYV90ZXhjb29yZDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFBvc2l0aW9uXFxuXCIgK1xuXCIgICAgdmVjNCBwb3NpdGlvbiA9IHVfbW9kZWxWaWV3ICogdmVjNChhX3Bvc2l0aW9uLCAxLik7XFxuXCIgK1xuXCIgICAgdmVjNCBzaGFwZSA9IGFfc2hhcGU7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IHBvc2l0aW9uXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICBjYW1lcmFQcm9qZWN0aW9uKHBvc2l0aW9uKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX09SREVSX0FUVFJJQlVURVxcblwiICtcblwiICAgICAgICBhcHBseUxheWVyT3JkZXIoYV9sYXllciwgcG9zaXRpb24pO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gQXBwbHkgc2NhbGluZyBpbiBzY3JlZW4gc3BhY2VcXG5cIiArXG5cIiAgICBmbG9hdCB6c2NhbGUgPSBmcmFjdCh1X21hcF9wb3NpdGlvbi56KSAqIChzaGFwZS53ICogMjU2LiAtIDEuKSArIDEuO1xcblwiICtcblwiICAgIC8vIGZsb2F0IHpzY2FsZSA9IGxvZyhmcmFjdCh1X21hcF9wb3NpdGlvbi56KSArIDEuKSAvIGxvZygyLikgKiAoc2hhcGUudyAtIDEuKSArIDEuO1xcblwiICtcblwiICAgIHBvc2l0aW9uLnh5ICs9IHJvdGF0ZTJEKHNoYXBlLnh5ICogMjU2LiAqIHpzY2FsZSwgcmFkaWFucyhzaGFwZS56ICogMzYwLikpICogMi4gKiBwb3NpdGlvbi53IC8gdV9yZXNvbHV0aW9uO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5zaGFkZXJTb3VyY2VzWydzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfZnJhZ21lbnQnXSA9XG5cInVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWV0ZXJzX3Blcl9waXhlbDtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfdGltZTtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X21hcF9wb3NpdGlvbjtcXG5cIiArXG5cInVuaWZvcm0gdmVjMyB1X3RpbGVfb3JpZ2luO1xcblwiICtcblwiXFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl9wb3NpdGlvbjtcXG5cIiArXG5cInZhcnlpbmcgdmVjMyB2X25vcm1hbDtcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblwiICtcblwidmFyeWluZyB2ZWM0IHZfd29ybGRfcG9zaXRpb247XFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1RFWFRVUkVfQ09PUkRTXFxuXCIgK1xuXCIgICAgdmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gRGVmaW5lIGEgd3JhcCB2YWx1ZSBmb3Igd29ybGQgY29vcmRpbmF0ZXMgKGFsbG93cyBtb3JlIHByZWNpc2lvbiBhdCBoaWdoZXIgem9vbXMpXFxuXCIgK1xuXCIvLyBlLmcuIGF0IHdyYXAgMTAwMCwgdGhlIHdvcmxkIHNwYWNlIHdpbGwgd3JhcCBldmVyeSAxMDAwIG1ldGVyc1xcblwiICtcblwiI2lmIGRlZmluZWQoVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQKVxcblwiICtcblwiICAgIHZlYzIgd29ybGRfcG9zaXRpb25fYW5jaG9yID0gdmVjMihmbG9vcih1X3RpbGVfb3JpZ2luIC8gVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQKSAqIFRBTkdSQU1fV09STERfUE9TSVRJT05fV1JBUCk7XFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDb252ZXJ0IGJhY2sgdG8gYWJzb2x1dGUgd29ybGQgcG9zaXRpb24gaWYgbmVlZGVkXFxuXCIgK1xuXCIgICAgdmVjNCBhYnNvbHV0ZVdvcmxkUG9zaXRpb24gKCkge1xcblwiICtcblwiICAgICAgICByZXR1cm4gdmVjNCh2X3dvcmxkX3Bvc2l0aW9uLnh5ICsgd29ybGRfcG9zaXRpb25fYW5jaG9yLCB2X3dvcmxkX3Bvc2l0aW9uLnosIHZfd29ybGRfcG9zaXRpb24udyk7XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiI2Vsc2VcXG5cIiArXG5cIiAgICB2ZWM0IGFic29sdXRlV29ybGRQb3NpdGlvbiAoKSB7XFxuXCIgK1xuXCIgICAgICAgIHJldHVybiB2X3dvcmxkX3Bvc2l0aW9uO1xcblwiICtcblwiICAgIH1cXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWClcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzQgdl9saWdodGluZztcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGNhbWVyYVxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBtYXRlcmlhbFxcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBsaWdodGluZ1xcblwiICtcblwiI3ByYWdtYSB0YW5ncmFtOiBnbG9iYWxcXG5cIiArXG5cIlxcblwiICtcblwidm9pZCBtYWluICh2b2lkKSB7XFxuXCIgK1xuXCIgICAgdmVjNCBjb2xvciA9IHZfY29sb3I7XFxuXCIgK1xuXCIgICAgdmVjMyBub3JtYWwgPSB2X25vcm1hbDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX05PUk1BTF9URVhUVVJFXFxuXCIgK1xuXCIgICAgICAgIGNhbGN1bGF0ZU5vcm1hbChub3JtYWwpO1xcblwiICtcblwiICAgICNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTW9kaWZ5IG5vcm1hbCBiZWZvcmUgbGlnaHRpbmdcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IG5vcm1hbFxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgLy8gTW9kaWZ5IGNvbG9yIGFuZCBtYXRlcmlhbCBwcm9wZXJ0aWVzIGJlZm9yZSBsaWdodGluZ1xcblwiICtcblwiICAgICNpZiAhZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWClcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGNvbG9yXFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAjaWYgZGVmaW5lZChUQU5HUkFNX0xJR0hUSU5HX0ZSQUdNRU5UKVxcblwiICtcblwiICAgICAgICBjb2xvciA9IGNhbGN1bGF0ZUxpZ2h0aW5nKHZfcG9zaXRpb24ueHl6IC0gdV9leWUsIG5vcm1hbCwgY29sb3IpO1xcblwiICtcblwiICAgICNlbGlmIGRlZmluZWQoVEFOR1JBTV9MSUdIVElOR19WRVJURVgpXFxuXCIgK1xuXCIgICAgICAgIGNvbG9yID0gdl9saWdodGluZztcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIE1vZGlmeSBjb2xvciBhZnRlciBsaWdodGluZyAoZmlsdGVyLWxpa2UgZWZmZWN0cyB0aGF0IGRvblxcJ3QgcmVxdWlyZSBhIGFkZGl0aW9uYWwgcmVuZGVyIHBhc3NlcylcXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IGZpbHRlclxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuXCIgK1xuXCJ9XFxuXCIgK1xuXCJcIjtcblxuc2hhZGVyU291cmNlc1snc3R5bGVzL3BvbHlnb25zL3BvbHlnb25zX3ZlcnRleCddID1cblwidW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV90aW1lO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfbWFwX3Bvc2l0aW9uO1xcblwiICtcblwidW5pZm9ybSB2ZWMzIHVfdGlsZV9vcmlnaW47XFxuXCIgK1xuXCJ1bmlmb3JtIGZsb2F0IHVfbWV0ZXJzX3Blcl9waXhlbDtcXG5cIiArXG5cInVuaWZvcm0gZmxvYXQgdV9kZXZpY2VfcGl4ZWxfcmF0aW87XFxuXCIgK1xuXCJcXG5cIiArXG5cInVuaWZvcm0gbWF0NCB1X21vZGVsO1xcblwiICtcblwidW5pZm9ybSBtYXQ0IHVfbW9kZWxWaWV3O1xcblwiICtcblwidW5pZm9ybSBtYXQzIHVfbm9ybWFsTWF0cml4O1xcblwiICtcblwiXFxuXCIgK1xuXCJhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xcblwiICtcblwiYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5cIiArXG5cImF0dHJpYnV0ZSBmbG9hdCBhX2xheWVyO1xcblwiICtcblwiXFxuXCIgK1xuXCIvLyBPcHRpb25hbCBub3JtYWwgYXR0cmlidXRlLCBvdGhlcndpc2UgZGVmYXVsdCB0byB1cFxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fTk9STUFMX0FUVFJJQlVURVxcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWMzIGFfbm9ybWFsO1xcblwiICtcblwiICAgICNkZWZpbmUgVEFOR1JBTV9OT1JNQUwgYV9ub3JtYWxcXG5cIiArXG5cIiNlbHNlXFxuXCIgK1xuXCIgICAgI2RlZmluZSBUQU5HUkFNX05PUk1BTCB2ZWMzKDAuLCAwLiwgMS4pXFxuXCIgK1xuXCIjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiLy8gT3B0aW9uYWwgZHluYW1pYyBsaW5lIGV4dHJ1c2lvblxcblwiICtcblwiI2lmZGVmIFRBTkdSQU1fRVhUUlVERV9MSU5FU1xcblwiICtcblwiICAgIGF0dHJpYnV0ZSB2ZWMzIGFfZXh0cnVkZTtcXG5cIiArXG5cIiAgICBhdHRyaWJ1dGUgdmVjMiBhX3NjYWxlO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cInZhcnlpbmcgdmVjNCB2X3Bvc2l0aW9uO1xcblwiICtcblwidmFyeWluZyB2ZWMzIHZfbm9ybWFsO1xcblwiICtcblwidmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXCIgK1xuXCJ2YXJ5aW5nIHZlYzQgdl93b3JsZF9wb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiLy8gT3B0aW9uYWwgdGV4dHVyZSBVVnNcXG5cIiArXG5cIiNpZmRlZiBUQU5HUkFNX1RFWFRVUkVfQ09PUkRTXFxuXCIgK1xuXCIgICAgYXR0cmlidXRlIHZlYzIgYV90ZXhjb29yZDtcXG5cIiArXG5cIiAgICB2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXG5cIiArXG5cIiNlbmRpZlxcblwiICtcblwiXFxuXCIgK1xuXCIvLyBEZWZpbmUgYSB3cmFwIHZhbHVlIGZvciB3b3JsZCBjb29yZGluYXRlcyAoYWxsb3dzIG1vcmUgcHJlY2lzaW9uIGF0IGhpZ2hlciB6b29tcylcXG5cIiArXG5cIi8vIGUuZy4gYXQgd3JhcCAxMDAwLCB0aGUgd29ybGQgc3BhY2Ugd2lsbCB3cmFwIGV2ZXJ5IDEwMDAgbWV0ZXJzXFxuXCIgK1xuXCIjaWYgZGVmaW5lZChUQU5HUkFNX1dPUkxEX1BPU0lUSU9OX1dSQVApXFxuXCIgK1xuXCIgICAgdmVjMiB3b3JsZF9wb3NpdGlvbl9hbmNob3IgPSB2ZWMyKGZsb29yKHVfdGlsZV9vcmlnaW4gLyBUQU5HUkFNX1dPUkxEX1BPU0lUSU9OX1dSQVApICogVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIENvbnZlcnQgYmFjayB0byBhYnNvbHV0ZSB3b3JsZCBwb3NpdGlvbiBpZiBuZWVkZWRcXG5cIiArXG5cIiAgICB2ZWM0IGFic29sdXRlV29ybGRQb3NpdGlvbiAoKSB7XFxuXCIgK1xuXCIgICAgICAgIHJldHVybiB2ZWM0KHZfd29ybGRfcG9zaXRpb24ueHkgKyB3b3JsZF9wb3NpdGlvbl9hbmNob3IsIHZfd29ybGRfcG9zaXRpb24ueiwgdl93b3JsZF9wb3NpdGlvbi53KTtcXG5cIiArXG5cIiAgICB9XFxuXCIgK1xuXCIjZWxzZVxcblwiICtcblwiICAgIHZlYzQgYWJzb2x1dGVXb3JsZFBvc2l0aW9uICgpIHtcXG5cIiArXG5cIiAgICAgICAgcmV0dXJuIHZfd29ybGRfcG9zaXRpb247XFxuXCIgK1xuXCIgICAgfVxcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgIHZhcnlpbmcgdmVjNCB2X2xpZ2h0aW5nO1xcblwiICtcblwiI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiNwcmFnbWEgdGFuZ3JhbTogY2FtZXJhXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IG1hdGVyaWFsXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGxpZ2h0aW5nXFxuXCIgK1xuXCIjcHJhZ21hIHRhbmdyYW06IGdsb2JhbFxcblwiICtcblwiXFxuXCIgK1xuXCJ2b2lkIG1haW4oKSB7XFxuXCIgK1xuXCIgICAgLy8gQWRkcyB2ZXJ0ZXggc2hhZGVyIHN1cHBvcnQgZm9yIGZlYXR1cmUgc2VsZWN0aW9uXFxuXCIgK1xuXCIgICAgI3ByYWdtYSB0YW5ncmFtOiBmZWF0dXJlLXNlbGVjdGlvbi12ZXJ0ZXhcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFRleHR1cmUgVVZzXFxuXCIgK1xuXCIgICAgI2lmZGVmIFRBTkdSQU1fVEVYVFVSRV9DT09SRFNcXG5cIiArXG5cIiAgICAgICAgdl90ZXhjb29yZCA9IGFfdGV4Y29vcmQ7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBQb3NpdGlvblxcblwiICtcblwiICAgIHZlYzQgcG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuKTtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICNpZmRlZiBUQU5HUkFNX0VYVFJVREVfTElORVNcXG5cIiArXG5cIiAgICAgICAgdmVjMiBleHRydWRlID0gYV9leHRydWRlLnh5O1xcblwiICtcblwiICAgICAgICBmbG9hdCB3aWR0aCA9IGFfZXh0cnVkZS56O1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIEtlZXAgbGluZSB3aWR0aCBjb25zdGFudCBpbiBzY3JlZW4tc3BhY2VcXG5cIiArXG5cIiAgICAgICAgZmxvYXQgenNjYWxlID0gdV90aWxlX29yaWdpbi56IC0gdV9tYXBfcG9zaXRpb24uejtcXG5cIiArXG5cIiAgICAgICAgd2lkdGggKj0gcG93KDIuLCB6c2NhbGUpO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIFNtb290aGx5IGludGVycG9sYXRlIGxpbmUgd2lkdGggYmV0d2VlbiB6b29tc1xcblwiICtcblwiICAgICAgICBpZiAoenNjYWxlID49IDAuKSB7XFxuXCIgK1xuXCIgICAgICAgICAgICB3aWR0aCA9IG1peCh3aWR0aCwgd2lkdGggKiBhX3NjYWxlLnggKiAyNTYuLCB6c2NhbGUpO1xcblwiICtcblwiICAgICAgICB9XFxuXCIgK1xuXCIgICAgICAgIGVsc2Uge1xcblwiICtcblwiICAgICAgICAgICAgd2lkdGggPSBtaXgod2lkdGgsIHdpZHRoICogYV9zY2FsZS55ICogMjU2LiwgLXpzY2FsZSk7XFxuXCIgK1xuXCIgICAgICAgIH1cXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBNb2RpZnkgbGluZSB3aWR0aCBiZWZvcmUgZXh0cnVzaW9uXFxuXCIgK1xuXCIgICAgICAgICNwcmFnbWEgdGFuZ3JhbTogd2lkdGhcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICBwb3NpdGlvbi54eSArPSBleHRydWRlICogd2lkdGg7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBXb3JsZCBjb29yZGluYXRlcyBmb3IgM2QgcHJvY2VkdXJhbCB0ZXh0dXJlc1xcblwiICtcblwiICAgIHZfd29ybGRfcG9zaXRpb24gPSB1X21vZGVsICogcG9zaXRpb247XFxuXCIgK1xuXCIgICAgI2lmIGRlZmluZWQoVEFOR1JBTV9XT1JMRF9QT1NJVElPTl9XUkFQKVxcblwiICtcblwiICAgICAgICB2X3dvcmxkX3Bvc2l0aW9uLnh5IC09IHdvcmxkX3Bvc2l0aW9uX2FuY2hvcjtcXG5cIiArXG5cIiAgICAjZW5kaWZcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIEFkanVzdCBmb3IgdGlsZSBhbmQgdmlldyBwb3NpdGlvblxcblwiICtcblwiICAgIHBvc2l0aW9uID0gdV9tb2RlbFZpZXcgKiBwb3NpdGlvbjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIE1vZGlmeSBwb3NpdGlvbiBiZWZvcmUgY2FtZXJhIHByb2plY3Rpb25cXG5cIiArXG5cIiAgICAjcHJhZ21hIHRhbmdyYW06IHBvc2l0aW9uXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBTZXR1cCB2YXJ5aW5nc1xcblwiICtcblwiICAgIHZfcG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIiAgICB2X25vcm1hbCA9IG5vcm1hbGl6ZSh1X25vcm1hbE1hdHJpeCAqIFRBTkdSQU1fTk9STUFMKTtcXG5cIiArXG5cIiAgICB2X2NvbG9yID0gYV9jb2xvcjtcXG5cIiArXG5cIlxcblwiICtcblwiICAgIC8vIFZlcnRleCBsaWdodGluZ1xcblwiICtcblwiICAgICNpZiBkZWZpbmVkKFRBTkdSQU1fTElHSFRJTkdfVkVSVEVYKVxcblwiICtcblwiICAgICAgICB2ZWM0IGNvbG9yID0gYV9jb2xvcjtcXG5cIiArXG5cIiAgICAgICAgdmVjMyBub3JtYWwgPSBUQU5HUkFNX05PUk1BTDtcXG5cIiArXG5cIlxcblwiICtcblwiICAgICAgICAvLyBNb2RpZnkgbm9ybWFsIGJlZm9yZSBsaWdodGluZ1xcblwiICtcblwiICAgICAgICAjcHJhZ21hIHRhbmdyYW06IG5vcm1hbFxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIC8vIE1vZGlmeSBjb2xvciBhbmQgbWF0ZXJpYWwgcHJvcGVydGllcyBiZWZvcmUgbGlnaHRpbmdcXG5cIiArXG5cIiAgICAgICAgI3ByYWdtYSB0YW5ncmFtOiBjb2xvclxcblwiICtcblwiXFxuXCIgK1xuXCIgICAgICAgIHZfbGlnaHRpbmcgPSBjYWxjdWxhdGVMaWdodGluZyhwb3NpdGlvbi54eXosIG5vcm1hbCwgY29sb3IpO1xcblwiICtcblwiICAgICAgICB2X2NvbG9yID0gY29sb3I7XFxuXCIgK1xuXCIgICAgI2VuZGlmXFxuXCIgK1xuXCJcXG5cIiArXG5cIiAgICAvLyBDYW1lcmFcXG5cIiArXG5cIiAgICBjYW1lcmFQcm9qZWN0aW9uKHBvc2l0aW9uKTtcXG5cIiArXG5cIiAgICBhcHBseUxheWVyT3JkZXIoYV9sYXllciwgcG9zaXRpb24pO1xcblwiICtcblwiXFxuXCIgK1xuXCIgICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cIiArXG5cIn1cXG5cIiArXG5cIlwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWRlclNvdXJjZXM7XG4iLCIvKmdsb2JhbCBUZXh0dXJlICovXHJcbi8vIFRleHR1cmUgbWFuYWdlbWVudFxyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgc3Vic2NyaWJlTWl4aW4gZnJvbSAnLi4vdXRpbHMvc3Vic2NyaWJlJztcclxuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuLi91dGlscy93b3JrZXJfYnJva2VyJztcclxuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL3N0eWxlcy9idWlsZGVycyc7XHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5cclxuLy8gR0wgdGV4dHVyZSB3cmFwcGVyIG9iamVjdCBmb3Iga2VlcGluZyB0cmFjayBvZiBhIGdsb2JhbCBzZXQgb2YgdGV4dHVyZXMsIGtleWVkIGJ5IGEgdW5pcXVlIHVzZXItZGVmaW5lZCBuYW1lXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmUge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGdsLCBuYW1lLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsOyAgICAgIC8vIGFuIEltYWdlIG9iamVjdC9lbGVtZW50IHRoYXQgaXMgdGhlIHNvdXJjZSBmb3IgdGhpcyB0ZXh0dXJlXHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsOyAgICAgLy8gYSBDYW52YXMgb2JqZWN0L2VsZW1lbnQgdGhhdCBpcyB0aGUgc291cmNlIGZvciB0aGlzIHRleHR1cmVcclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBudWxsOyAgICAvLyBhIFByb21pc2Ugb2JqZWN0IHRvIHRyYWNrIHRoZSBsb2FkaW5nIHN0YXRlIG9mIHRoaXMgdGV4dHVyZVxyXG5cclxuICAgICAgICAvLyBEZWZhdWx0IHRvIGEgMS1waXhlbCBibGFjayB0ZXh0dXJlIHNvIHdlIGNhbiBzYWZlbHkgcmVuZGVyIHdoaWxlIHdlIHdhaXQgZm9yIGFuIGltYWdlIHRvIGxvYWRcclxuICAgICAgICAvLyBTZWU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk3MjIyNDcvd2ViZ2wtd2FpdC1mb3ItdGV4dHVyZS10by1sb2FkXHJcbiAgICAgICAgdGhpcy5zZXREYXRhKDEsIDEsIG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAyNTVdKSwgeyBmaWx0ZXJpbmc6ICduZWFyZXN0JyB9KTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIHN1cHBvcnQgZm9yIG5vbi1VUkwgc291cmNlczogY2FudmFzL3ZpZGVvIGVsZW1lbnRzLCByYXcgcGl4ZWwgYnVmZmVyc1xyXG5cclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyaW5nID0gb3B0aW9ucy5maWx0ZXJpbmc7XHJcblxyXG4gICAgICAgIC8vIERlc3Ryb3kgcHJldmlvdXMgdGV4dHVyZSBpZiBwcmVzZW50XHJcbiAgICAgICAgaWYgKFRleHR1cmUudGV4dHVyZXNbdGhpcy5uYW1lXSkge1xyXG4gICAgICAgICAgICBUZXh0dXJlLnRleHR1cmVzW3RoaXMubmFtZV0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgVGV4dHVyZS50ZXh0dXJlc1t0aGlzLm5hbWVdID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5zcHJpdGVzID0gb3B0aW9ucy5zcHJpdGVzO1xyXG4gICAgICAgIHRoaXMudGV4Y29vcmRzID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVzdHJveSBhIHNpbmdsZSB0ZXh0dXJlIGluc3RhbmNlXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmUpO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZGF0YTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgICAgIGRlbGV0ZSBUZXh0dXJlLnRleHR1cmVzW3RoaXMubmFtZV07XHJcbiAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGJpbmQodW5pdCkge1xyXG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdW5pdCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTAgKyB1bml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdW5iaW5kKCkge1xyXG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMb2FkcyBhIHRleHR1cmUgZnJvbSBhIFVSTFxyXG4gICAgbG9hZCh1cmwsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZS5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGV4dHVyZUZpbHRlcmluZyhvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlU3ByaXRlcygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDsgLy8gbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggb3RoZXIgdHlwZXNcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5pbWFnZS5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGVycm9yL3Byb21pc2UgcmVqZWN0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXRzIHRleHR1cmUgdG8gYSByYXcgaW1hZ2UgYnVmZmVyXHJcbiAgICBzZXREYXRhKHdpZHRoLCBoZWlnaHQsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG5cclxuICAgICAgICB0aGlzLmltYWdlID0gbnVsbDsgLy8gbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggb3RoZXIgdHlwZXNcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZUZpbHRlcmluZyhvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXRzIHRoZSB0ZXh0dXJlIHRvIHRyYWNrIGEgY2FudmFzIGVsZW1lbnRcclxuICAgIHNldENhbnZhcyhjYW52YXMsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcclxuICAgICAgICB0aGlzLnVwZGF0ZShvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnNldFRleHR1cmVGaWx0ZXJpbmcob3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsOyAvLyBtdXR1YWxseSBleGNsdXNpdmUgd2l0aCBvdGhlciB0eXBlc1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBsb2FkcyBjdXJyZW50IGltYWdlIG9yIGJ1ZmZlciB0byB0aGUgR1BVIChjYW4gYmUgdXNlZCB0byB1cGRhdGUgYW5pbWF0ZWQgdGV4dHVyZXMgb24gdGhlIGZseSlcclxuICAgIHVwZGF0ZShvcHRpb25zID0ge30pIHtcclxuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIChvcHRpb25zLlVOUEFDS19GTElQX1lfV0VCR0wgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlKSk7XHJcbiAgICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgb3B0aW9ucy5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wgfHwgZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBJbWFnZSBlbGVtZW50XHJcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UgJiYgdGhpcy5pbWFnZS5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5pbWFnZS53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmltYWdlLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgdGhpcy5pbWFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbnZhcyBlbGVtZW50XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgdGhpcy5jYW52YXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSYXcgaW1hZ2UgYnVmZmVyXHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy53aWR0aCAmJiB0aGlzLmhlaWdodCkgeyAvLyBOT1RFOiB0aGlzLmRhdGEgY2FuIGJlIG51bGwsIHRvIHplcm8gb3V0IHRleHR1cmVcclxuICAgICAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBUZXh0dXJlLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZXMgYXBwcm9wcmlhdGUgZmlsdGVyaW5nIG1vZGVcclxuICAgIHNldFRleHR1cmVGaWx0ZXJpbmcob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdGlvbnMuZmlsdGVyaW5nID0gb3B0aW9ucy5maWx0ZXJpbmcgfHwgdGhpcy5maWx0ZXJpbmcgfHwgJ2xpbmVhcic7IC8vIGRlZmF1bHQgdG8gbWlwbWFwcyBmb3IgcG93ZXItb2YtMiB0ZXh0dXJlc1xyXG5cclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG5cclxuICAgICAgICAvLyBGb3IgcG93ZXItb2YtMiB0ZXh0dXJlcywgdGhlIGZvbGxvd2luZyBwcmVzZXRzIGFyZSBhdmFpbGFibGU6XHJcbiAgICAgICAgLy8gbWlwbWFwOiBsaW5lYXIgYmxlbmQgZnJvbSBuZWFyZXN0IG1pcFxyXG4gICAgICAgIC8vIGxpbmVhcjogbGluZWFyIGJsZW5kIGZyb20gb3JpZ2luYWwgaW1hZ2UgKG5vIG1pcHMpXHJcbiAgICAgICAgLy8gbmVhcmVzdDogbmVhcmVzdCBwaXhlbCBmcm9tIG9yaWdpbmFsIGltYWdlIChubyBtaXBzLCAnYmxvY2t5JyBsb29rKVxyXG4gICAgICAgIGlmIChVdGlscy5pc1Bvd2VyT2YyKHRoaXMud2lkdGgpICYmIFV0aWxzLmlzUG93ZXJPZjIodGhpcy5oZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG93ZXJfb2ZfMiA9IHRydWU7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1MgfHwgKG9wdGlvbnMucmVwZWF0ICYmIGdsLlJFUEVBVCkgfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1QgfHwgKG9wdGlvbnMucmVwZWF0ICYmIGdsLlJFUEVBVCkgfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcblxyXG4gICAgICAgICAgICAvLyBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBvcHRpb25zLlRFWFRVUkVfV1JBUF9TIHx8IGdsLlJFUEVBVCk7XHJcbiAgICAgICAgICAgIC8vIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIG9wdGlvbnMuVEVYVFVSRV9XUkFQX1QgfHwgZ2wuUkVQRUFUKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlcmluZyA9PT0gJ21pcG1hcCcpIHtcclxuICAgICAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBNSVBNQVAnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyaW5nID0gJ21pcG1hcCc7XHJcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVIpOyAvLyBUT0RPOiB1c2UgdHJpbGluZWFyIGZpbHRlcmluZyBieSBkZWZ1YWx0IGluc3RlYWQ/XHJcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZmlsdGVyaW5nID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKCdwb3dlci1vZi0yIExJTkVBUicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJpbmcgPSAnbGluZWFyJztcclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5maWx0ZXJpbmcgPT09ICduZWFyZXN0Jykge1xyXG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKCdwb3dlci1vZi0yIE5FQVJFU1QnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyaW5nID0gJ25lYXJlc3QnO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBXZWJHTCBoYXMgc3RyaWN0IHJlcXVpcmVtZW50cyBvbiBub24tcG93ZXItb2YtMiB0ZXh0dXJlczpcclxuICAgICAgICAgICAgLy8gTm8gbWlwbWFwcyBhbmQgbXVzdCBjbGFtcCB0byBlZGdlXHJcbiAgICAgICAgICAgIHRoaXMucG93ZXJfb2ZfMiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXJpbmcgPT09ICduZWFyZXN0Jykge1xyXG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKCdwb3dlci1vZi0yIE5FQVJFU1QnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyaW5nID0gJ25lYXJlc3QnO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgeyAvLyBkZWZhdWx0IHRvIGxpbmVhciBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcclxuICAgICAgICAgICAgICAgIGxvZy50cmFjZSgncG93ZXItb2YtMiBMSU5FQVInKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyaW5nID0gJ2xpbmVhcic7XHJcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVuYmluZCgpO1xyXG4gICAgICAgIFRleHR1cmUudHJpZ2dlcigndXBkYXRlJywgdGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJlLWNhbGMgc3ByaXRlIHJlZ2lvbnMgZm9yIGEgdGV4dHVyZSBzcHJpdGUgaW4gVVYgWzAsIDFdIHNwYWNlXHJcbiAgICBjYWxjdWxhdGVTcHJpdGVzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgcyBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLnNwcml0ZXNbc107XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFwIFswLCAwXSB0byBbMSwgMV0gY29vcmRzIHRvIHRoZSBhcHByb3ByaWF0ZSBzcHJpdGUgc3ViLWFyZWEgb2YgdGhlIHRleHR1cmVcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4Y29vcmRzW3NdID0gQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlKFxyXG4gICAgICAgICAgICAgICAgICAgIFtzcHJpdGVbMF0sIHNwcml0ZVsxXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgW3Nwcml0ZVsyXSwgc3ByaXRlWzNdXSxcclxuICAgICAgICAgICAgICAgICAgICBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbi8vIFN0YXRpYy9jbGFzcyBtZXRob2RzIGFuZCBzdGF0ZVxyXG5cclxuLy8gRGVzdHJveSBhbGwgdGV4dHVyZSBpbnN0YW5jZXMgZm9yIGEgZ2l2ZW4gR0wgY29udGV4dFxyXG5UZXh0dXJlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZ2wpIHtcclxuICAgIHZhciB0ZXh0dXJlcyA9IE9iamVjdC5rZXlzKFRleHR1cmUudGV4dHVyZXMpO1xyXG4gICAgZm9yICh2YXIgdCBvZiB0ZXh0dXJlcykge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0XTtcclxuICAgICAgICBpZiAodGV4dHVyZS5nbCA9PT0gZ2wpIHtcclxuICAgICAgICAgICAgbG9nLnRyYWNlKGBkZXN0cm95aW5nIFRleHR1cmUgJHt0ZXh0dXJlLm5hbWV9YCk7XHJcbiAgICAgICAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8vIEdldCBzcHJpdGUgc3ViLWFyZWEgdG8gdXNlIGZvciB0ZXh0dXJlIGNvb3JkaW5hdGVzIChkZWZhdWx0IGlzIFswLCAxXSlcclxuVGV4dHVyZS5nZXRTcHJpdGVUZXhjb29yZHMgPSBmdW5jdGlvbiAodGV4bmFtZSwgc3ByaXRlKSB7XHJcbiAgICBsZXQgdGV4dHVyZSA9IFRleHR1cmUudGV4dHVyZXNbdGV4bmFtZV07XHJcbiAgICByZXR1cm4gdGV4dHVyZSAmJiB0ZXh0dXJlLnRleGNvb3Jkc1tzcHJpdGVdO1xyXG59O1xyXG5cclxuLy8gQ3JlYXRlIGEgc2V0IG9mIHRleHR1cmVzIGtleWVkIGluIGFuIG9iamVjdFxyXG4vLyBPcHRpb25hbGx5IGxvYWQgZWFjaCBpZiBpdCBoYXMgYSBVUkwgc3BlY2lmaWVkXHJcblRleHR1cmUuY3JlYXRlRnJvbU9iamVjdCA9IGZ1bmN0aW9uIChnbCwgdGV4dHVyZXMpIHtcclxuICAgIGxldCBsb2FkaW5nID0gW107XHJcbiAgICBpZiAodGV4dHVyZXMpIHtcclxuICAgICAgICBmb3IgKGxldCB0ZXhuYW1lIGluIHRleHR1cmVzKSB7XHJcbiAgICAgICAgICAgIGxldCBjb25maWcgPSB0ZXh0dXJlc1t0ZXhuYW1lXTtcclxuICAgICAgICAgICAgaWYgKCFUZXh0dXJlLnRleHR1cmVzW3RleG5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGdsLCB0ZXhuYW1lLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy51cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nLnB1c2godGV4dHVyZS5sb2FkKGNvbmZpZy51cmwsIGNvbmZpZykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGxvYWRpbmcpO1xyXG59O1xyXG5cclxuLy8gR2V0IG1ldGFkYXRhIGZvciBhIHRleHR1cmUgYnkgbmFtZVxyXG4vLyBSZXR1cm5zIHZpYSBwcm9taXNlLCBpbiBjYXNlIHRleHR1cmUgaXMgc3RpbGwgbG9hZGluZ1xyXG4vLyBDYW4gYmUgY2FsbGVkIG9uIG1haW4gdGhyZWFkIGZyb20gd29ya2VyLCB0byBzeW5jIHRleHR1cmUgaW5mbyB0byB3b3JrZXJcclxuVGV4dHVyZS5nZXRJbmZvID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIC8vIEdldCBpbmZvIGZvciBhbGwgdGV4dHVyZXMgYnkgZGVmYXVsdFxyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgbmFtZSA9IE9iamVjdC5rZXlzKFRleHR1cmUudGV4dHVyZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBtdWx0aXBsZSB0ZXh0dXJlc1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobmFtZS5tYXAobiA9PiBUZXh0dXJlLmdldEluZm8obikpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgc2luZ2xlIHRleHR1cmVcclxuICAgIHZhciB0ZXggPSBUZXh0dXJlLnRleHR1cmVzW25hbWVdO1xyXG4gICAgaWYgKHRleCkge1xyXG4gICAgICAgIC8vIFdhaXQgZm9yIHRoaXMgdGV4dHVyZSB0byBmaW5pc2ggbG9hZGluZywgb3IgcmV0dXJuIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgdmFyIGxvYWRpbmcgPSB0ZXgubG9hZGluZyB8fCBQcm9taXNlLnJlc29sdmUodGV4KTtcclxuICAgICAgICByZXR1cm4gbG9hZGluZy50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3Vic2V0IG9mIHRleHR1cmUgaW5mb1xyXG4gICAgICAgICAgICAvLyAoY29tcGF0aWJsZSB3L3N0cnVjdHVyZWQgY2xvbmluZywgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gYSB3b3JrZXIpXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiB0ZXgubmFtZSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXgud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleC5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBzcHJpdGVzOiB0ZXguc3ByaXRlcyxcclxuICAgICAgICAgICAgICAgIHRleGNvb3JkczogdGV4LnRleGNvb3JkcyxcclxuICAgICAgICAgICAgICAgIGZpbHRlcmluZzogdGV4LmZpbHRlcmluZyxcclxuICAgICAgICAgICAgICAgIHBvd2VyX29mXzI6IHRleC5wb3dlcl9vZl8yLFxyXG4gICAgICAgICAgICAgICAgdmFsaWQ6IHRleC52YWxpZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTm8gdGV4dHVyZSBmb3VuZFxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBTeW5jIHRleHR1cmUgaW5mbyB0byB3b3JrZXJcclxuLy8gQ2FsbGVkIGZyb20gd29ya2VyLCBnZXRzIGluZm8gb24gb25lIG9yIG1vcmUgdGV4dHVyZXMgaW5mbyBmcm9tIG1haW4gdGhyZWFkIHZpYSByZW1vdGUgY2FsbCwgdGhlbiBzdG9yZXMgaXRcclxuLy8gbG9jYWxseSBpbiB3b3JrZXIuICd0ZXh0dXJlcycgY2FuIGJlIGFuIGFycmF5IG9mIHRleHR1cmUgbmFtZXMgdG8gc3luYywgb3IgaWYgbnVsbCwgYWxsIHRleHR1cmVzIGFyZSBzeW5jZWQuXHJcblRleHR1cmUuc3luY1RleHR1cmVzVG9Xb3JrZXIgPSBmdW5jdGlvbiAobmFtZXMpIHtcclxuICAgIHJldHVybiBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UoJ1RleHR1cmUnLCAnZ2V0SW5mbycsIG5hbWVzKS5cclxuICAgICAgICB0aGVuKHRleHR1cmVzID0+IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgdGV4IG9mIHRleHR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBUZXh0dXJlLnRleHR1cmVzW3RleC5uYW1lXSA9IHRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZS50ZXh0dXJlcztcclxuICAgICAgICB9KTtcclxufTtcclxuXHJcbi8vIEdsb2JhbCBzZXQgb2YgdGV4dHVyZXMsIGJ5IG5hbWVcclxuVGV4dHVyZS50ZXh0dXJlcyA9IHt9O1xyXG5cclxuc3Vic2NyaWJlTWl4aW4oVGV4dHVyZSk7XHJcbiIsIi8vIENyZWF0ZXMgYSBWZXJ0ZXggQXJyYXkgT2JqZWN0IGlmIHRoZSBleHRlbnNpb24gaXMgYXZhaWxhYmxlLCBvciBmYWxscyBiYWNrIG9uIHN0YW5kYXJkIGF0dHJpYnV0ZSBjYWxsc1xyXG5cclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcblxyXG52YXIgVmVydGV4QXJyYXlPYmplY3Q7XHJcbmV4cG9ydCBkZWZhdWx0IFZlcnRleEFycmF5T2JqZWN0ID0ge307XHJcblxyXG5WZXJ0ZXhBcnJheU9iamVjdC5kaXNhYmxlZCA9IGZhbHNlOyAvLyBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIFZBT3MgZXZlbiBpZiBleHRlbnNpb24gaXMgYXZhaWxhYmxlXHJcblZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyA9IG51bGw7IC8vIGN1cnJlbnRseSBib3VuZCBWQU9cclxuXHJcblZlcnRleEFycmF5T2JqZWN0LmluaXQgPSBmdW5jdGlvbiAoZ2wpIHtcclxuICAgIGlmIChWZXJ0ZXhBcnJheU9iamVjdC5leHQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChWZXJ0ZXhBcnJheU9iamVjdC5kaXNhYmxlZCAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5leHQgPSBnbC5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChWZXJ0ZXhBcnJheU9iamVjdC5leHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsb2cuaW5mbygnVmVydGV4IEFycmF5IE9iamVjdCBleHRlbnNpb24gYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFZlcnRleEFycmF5T2JqZWN0LmRpc2FibGVkICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKCdWZXJ0ZXggQXJyYXkgT2JqZWN0IGV4dGVuc2lvbiBOT1QgYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2cud2FybignVmVydGV4IEFycmF5IE9iamVjdCBleHRlbnNpb24gZm9yY2UgZGlzYWJsZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5WZXJ0ZXhBcnJheU9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoc2V0dXAsIHRlYXJkb3duKSB7XHJcbiAgICBsZXQgdmFvID0ge307XHJcbiAgICB2YW8uc2V0dXAgPSBzZXR1cDtcclxuICAgIHZhby50ZWFyZG93biA9IHRlYXJkb3duO1xyXG5cclxuICAgIGxldCBleHQgPSBWZXJ0ZXhBcnJheU9iamVjdC5leHQ7XHJcbiAgICBpZiAoZXh0ICE9IG51bGwpIHtcclxuICAgICAgICB2YW8uX3ZhbyA9IGV4dC5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xyXG4gICAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVModmFvLl92YW8pO1xyXG4gICAgICAgIHZhby5zZXR1cCgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFvLnNldHVwKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbztcclxufTtcclxuXHJcblZlcnRleEFycmF5T2JqZWN0LmJpbmQgPSBmdW5jdGlvbiAodmFvKSB7XHJcbiAgICBsZXQgZXh0ID0gVmVydGV4QXJyYXlPYmplY3QuZXh0O1xyXG4gICAgaWYgKHZhbyAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGV4dCAhPSBudWxsICYmIHZhby5fdmFvICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyh2YW8uX3Zhbyk7XHJcbiAgICAgICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3ZhbyA9IHZhbztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhby5zZXR1cCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChleHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChWZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8gIT0gbnVsbCAmJiB0eXBlb2YgVmVydGV4QXJyYXlPYmplY3QuYm91bmRfdmFvLnRlYXJkb3duID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIFZlcnRleEFycmF5T2JqZWN0LmJvdW5kX3Zhby50ZWFyZG93bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5ib3VuZF92YW8gPSBudWxsO1xyXG4gICAgfVxyXG59O1xyXG4iLCIvKiBnbG9iYWwgVkJPTWVzaCAqL1xyXG4vLyBNYW5hZ2UgcmVuZGVyaW5nIGZvciBwcmltaXRpdmVzXHJcbmltcG9ydCBHTFNMIGZyb20gJy4vZ2xzbCc7XHJcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4vc2hhZGVyX3Byb2dyYW0nO1xyXG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL3RleHR1cmUnO1xyXG5pbXBvcnQgVmVydGV4QXJyYXlPYmplY3QgZnJvbSAnLi92YW8nO1xyXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuXHJcbi8vIEEgc2luZ2xlIG1lc2gvVkJPLCBkZXNjcmliZWQgYnkgYSB2ZXJ0ZXggbGF5b3V0LCB0aGF0IGNhbiBiZSBkcmF3biB3aXRoIG9uZSBvciBtb3JlIHByb2dyYW1zXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZCT01lc2ggIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgdmVydGV4X2RhdGEsIHZlcnRleF9sYXlvdXQsIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMudmVydGV4X2RhdGEgPSB2ZXJ0ZXhfZGF0YTsgLy8gdHlwZWQgYXJyYXlcclxuICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQgPSB2ZXJ0ZXhfbGF5b3V0O1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLmRyYXdfbW9kZSA9IG9wdGlvbnMuZHJhd19tb2RlIHx8IHRoaXMuZ2wuVFJJQU5HTEVTO1xyXG4gICAgICAgIHRoaXMuZGF0YV91c2FnZSA9IG9wdGlvbnMuZGF0YV91c2FnZSB8fCB0aGlzLmdsLlNUQVRJQ19EUkFXO1xyXG4gICAgICAgIHRoaXMudmVydGljZXNfcGVyX2dlb21ldHJ5ID0gMzsgLy8gVE9ETzogc3VwcG9ydCBsaW5lcywgc3RyaXAsIGZhbiwgZXRjLlxyXG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSBvcHRpb25zLnVuaWZvcm1zO1xyXG4gICAgICAgIHRoaXMucmV0YWluID0gb3B0aW9ucy5yZXRhaW4gfHwgZmFsc2U7IC8vIHdoZXRoZXIgdG8gcmV0YWluIG1lc2ggZGF0YSBpbiBDUFUgYWZ0ZXIgdXBsb2FkaW5nIHRvIEdQVVxyXG5cclxuICAgICAgICB0aGlzLnZlcnRleF9jb3VudCA9IHRoaXMudmVydGV4X2RhdGEuYnl0ZUxlbmd0aCAvIHRoaXMudmVydGV4X2xheW91dC5zdHJpZGU7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeV9jb3VudCA9IHRoaXMudmVydGV4X2NvdW50IC8gdGhpcy52ZXJ0aWNlc19wZXJfZ2VvbWV0cnk7XHJcbiAgICAgICAgdGhpcy52YW9zID0gbmV3IE1hcCgpOyAvLyBtYXAgb2YgVmVydGV4QXJyYXlPYmplY3RzLCBrZXllZCBieSBwcm9ncmFtXHJcblxyXG4gICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIpO1xyXG4gICAgICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhfZGF0YSwgdGhpcy5kYXRhX3VzYWdlKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnJldGFpbikge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy52ZXJ0ZXhfZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVuZGVyLCBieSBkZWZhdWx0IHdpdGggY3VycmVudGx5IGJvdW5kIHByb2dyYW0sIG9yIG90aGVyd2lzZSB3aXRoIG9wdGlvbmFsbHkgcHJvdmlkZWQgb25lXHJcbiAgICByZW5kZXIob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fcmVuZGVyX3NldHVwID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcl9zZXR1cCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBvcHRpb25zLnByb2dyYW0gfHwgU2hhZGVyUHJvZ3JhbS5jdXJyZW50O1xyXG4gICAgICAgIHByb2dyYW0udXNlKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnVuaWZvcm1zKSB7XHJcbiAgICAgICAgICAgIHByb2dyYW0uc2F2ZVVuaWZvcm1zKHRoaXMudW5pZm9ybXMpO1xyXG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1zKHRoaXMudW5pZm9ybXMsIGZhbHNlKTsgLy8gZG9uJ3QgcmVzZXQgdGV4dHVyZSB1bml0XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmJpbmQocHJvZ3JhbSk7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgZWxlbWVudCBhcnJheSBtb2RlXHJcbiAgICAgICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZHJhd19tb2RlLCAwLCB0aGlzLnZlcnRleF9jb3VudCk7XHJcbiAgICAgICAgVmVydGV4QXJyYXlPYmplY3QuYmluZChudWxsKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybXMpIHtcclxuICAgICAgICAgICAgcHJvZ3JhbS5yZXN0b3JlVW5pZm9ybXModGhpcy51bmlmb3Jtcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCaW5kIGJ1ZmZlcnMgYW5kIHZlcnRleCBhdHRyaWJ1dGVzIHRvIHByZXBhcmUgZm9yIHJlbmRlcmluZ1xyXG4gICAgYmluZChwcm9ncmFtKSB7XHJcbiAgICAgICAgLy8gQmluZCBWQU8gZm9yIHRoaXMgcHJvZ2FtLCBvciBjcmVhdGUgb25lXHJcbiAgICAgICAgbGV0IHZhbyA9IHRoaXMudmFvcy5nZXQocHJvZ3JhbSk7XHJcbiAgICAgICAgaWYgKHZhbykge1xyXG4gICAgICAgICAgICBWZXJ0ZXhBcnJheU9iamVjdC5iaW5kKHZhbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZhb3Muc2V0KHByb2dyYW0sIFZlcnRleEFycmF5T2JqZWN0LmNyZWF0ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4X2xheW91dC5lbmFibGUodGhpcy5nbCwgcHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGxvZy50cmFjZSgnVkJPTWVzaC5kZXN0cm95OiBkZWxldGUgYnVmZmVyJyArICh0aGlzLnZlcnRleF9kYXRhID8gYCBvZiBzaXplICR7dGhpcy52ZXJ0ZXhfZGF0YS5ieXRlTGVuZ3RofWAgOiAnJykpO1xyXG5cclxuICAgICAgICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnZlcnRleF9kYXRhO1xyXG5cclxuICAgICAgICAvLyBGcmVlIHRleHR1cmUgdW5pZm9ybXMgdGhhdCBhcmUgb3duZWQgYnkgdGhpcyBtZXNoXHJcbiAgICAgICAgZm9yIChsZXQge3R5cGUsIHZhbHVlfSBvZiBHTFNMLnBhcnNlVW5pZm9ybXModGhpcy51bmlmb3JtcykpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzYW1wbGVyMkQnICYmIFRleHR1cmUudGV4dHVyZXNbdmFsdWVdKSB7XHJcbiAgICAgICAgICAgICAgICBUZXh0dXJlLnRleHR1cmVzW3ZhbHVlXS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCIvKiBnbG9iYWwgVmVydGV4RGF0YSAqL1xyXG5cclxuaW1wb3J0IGdsIGZyb20gJy4vY29uc3RhbnRzJzsgLy8gd2ViIHdvcmtlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gR0wgY29udGV4dCwgc28gaW1wb3J0IGFsbCBHTCBjb25zdGFudHNcclxuaW1wb3J0IHtsb2d9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbi8vIE1hcHMgR0wgdHlwZXMgdG8gSlMgYXJyYXkgdHlwZXNcclxubGV0IGFycmF5X3R5cGVzID0ge1xyXG4gICAgW2dsLkZMT0FUXTogRmxvYXQzMkFycmF5LFxyXG4gICAgW2dsLkJZVEVdOiBJbnQ4QXJyYXksXHJcbiAgICBbZ2wuVU5TSUdORURfQllURV06IFVpbnQ4QXJyYXksXHJcbiAgICBbZ2wuSU5UXTogSW50MzJBcnJheSxcclxuICAgIFtnbC5VTlNJR05FRF9JTlRdOiBVaW50MzJBcnJheSxcclxuICAgIFtnbC5TSE9SVF06IEludDE2QXJyYXksXHJcbiAgICBbZ2wuVU5TSUdORURfU0hPUlRdOiBVaW50MTZBcnJheVxyXG59O1xyXG5cclxuLy8gQW4gaW50ZXJtZWRpYXJ5IG9iamVjdCB0aGF0IGhvbGRzIHZlcnRleCBkYXRhIGluIHR5cGVkIGFycmF5cywgYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gdmVydGV4IGxheW91dFxyXG4vLyBVc2VkIHRvIGNvbnN0cnVjdCBhIG1lc2gvVkJPIGZvciByZW5kZXJpbmdcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVydGV4RGF0YSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKHZlcnRleF9sYXlvdXQsIHsgcHJlYWxsb2MgfSA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gdmVydGV4X2xheW91dDtcclxuICAgICAgICB0aGlzLmJ1ZmZlcl9zaXplID0gcHJlYWxsb2MgfHwgNTAwOyAvLyAjIG9mIHZlcnRpY2VzIHRvIGFsbG9jYXRlXHJcbiAgICAgICAgdGhpcy5idWZmZXJfb2Zmc2V0ID0gMDsgICAgICAgICAgICAgLy8gYnl0ZSBvZmZzZXQgaW50byBjdXJyZW50bHkgYWxsb2NhdGVkIGJ1ZmZlclxyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMudmVydGV4X2xheW91dC5zdHJpZGUgKiB0aGlzLmJ1ZmZlcl9zaXplKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBjb21wb25lbnQgb2YgdGhpcy52ZXJ0ZXhfbGF5b3V0LmNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goWy4uLmNvbXBvbmVudF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZlcnRleF9jb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5yZWFsbG9jX2NvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnNldEJ1ZmZlclZpZXdzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gKFJlLSlhbGxvY2F0ZSB0eXBlZCB2aWV3cyBpbnRvIHRoZSBtYWluIGJ1ZmZlciAtIG9ubHkgY3JlYXRlIHRoZSB0eXBlcyB3ZSBuZWVkIGZvciB0aGlzIGxheW91dFxyXG4gICAgc2V0QnVmZmVyVmlld3MgKCkge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyX3ZpZXdzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgYXR0cmliIG9mIHRoaXMudmVydGV4X2xheW91dC5hdHRyaWJzKSB7XHJcbiAgICAgICAgICAgIC8vIE5lZWQgdmlldyBmb3IgdGhpcyB0eXBlP1xyXG4gICAgICAgICAgICBpZiAodGhpcy5idWZmZXJfdmlld3NbYXR0cmliLnR5cGVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJheV90eXBlID0gYXJyYXlfdHlwZXNbYXR0cmliLnR5cGVdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJfdmlld3NbYXR0cmliLnR5cGVdID0gbmV3IGFycmF5X3R5cGUodGhpcy5idWZmZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50IGJ1ZmZlciBwb2ludGVyc1xyXG4gICAgICAgIGZvciAodmFyIGNvbXBvbmVudCBvZiB0aGlzLmNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50WzFdID0gdGhpcy5idWZmZXJfdmlld3NbY29tcG9uZW50WzBdXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgYWxsb2NhdGVkIGJ1ZmZlciBzaXplLCBleHBhbmQvcmVhbGxvYyBidWZmZXIgaWYgbmVlZGVkXHJcbiAgICBjaGVja0J1ZmZlclNpemUgKCkge1xyXG4gICAgICAgIGlmICgodGhpcy5idWZmZXJfb2Zmc2V0ICsgdGhpcy52ZXJ0ZXhfbGF5b3V0LnN0cmlkZSkgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX3NpemUgPSBNYXRoLmZsb29yKHRoaXMuYnVmZmVyX3NpemUgKiAxLjUpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcl9zaXplIC09IHRoaXMuYnVmZmVyX3NpemUgJSA0O1xyXG4gICAgICAgICAgICB2YXIgbmV3X2Jsb2NrID0gbmV3IEFycmF5QnVmZmVyKHRoaXMudmVydGV4X2xheW91dC5zdHJpZGUgKiB0aGlzLmJ1ZmZlcl9zaXplKTtcclxuICAgICAgICAgICAgdmFyIG5ld192aWV3ID0gbmV3IFVpbnQ4QXJyYXkobmV3X2Jsb2NrKTtcclxuICAgICAgICAgICAgbmV3X3ZpZXcuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSk7IC8vIGNvcHkgZXhpc3RpbmcgZGF0YSB0byBuZXcgYnVmZmVyXHJcblxyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld19ibG9jaztcclxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXJWaWV3cygpO1xyXG4gICAgICAgICAgICB0aGlzLnJlYWxsb2NfY291bnQrKztcclxuICAgICAgICAgICAgLy8gbG9nLmluZm8oYFZlcnRleERhdGE6IGV4cGFuZGVkIHZlcnRleCBibG9jayB0byAke3RoaXMuYnVmZmVyX3NpemV9IHZlcnRpY2VzYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCBhIHZlcnRleCwgY29waWVkIGZyb20gYSBwbGFpbiBKUyBhcnJheSBvZiBlbGVtZW50cyBtYXRjaGluZyB0aGUgb3JkZXIgb2YgdGhlIHZlcnRleCBsYXlvdXQuXHJcbiAgICAvLyBOb3RlOiB1c2VzIHByZS1jYWxjdWxhdGVkIGluZm8gYWJvdXQgZWFjaCBhdHRyaWJ1dGUsIGluY2x1ZGluZyBwb2ludGVyIHRvIGFwcHJvcHJpYXRlIHR5cGVkIGFycmF5XHJcbiAgICAvLyB2aWV3IGFuZCBvZmZzZXQgaW50byBpdC4gVGhpcyB3YXMgdGhlIGZhc3Rlc3QgbWV0aG9kIHByb2ZpbGVkIHNvIGZhciBmb3IgZmlsbGluZyBhIG1peGVkLXR5cGVcclxuICAgIC8vIHZlcnRleCBsYXlvdXQgKHRob3VnaCBzdGlsbCBzbG93ZXIgdGhhbiB0aGUgcHJldmlvdXMgbWV0aG9kIHRoYXQgb25seSBzdXBwb3J0ZWQgRmxvYXQzMkFycmF5IGF0dHJpYnV0ZXMpLlxyXG4gICAgYWRkVmVydGV4ICh2ZXJ0ZXgpIHtcclxuICAgICAgICB0aGlzLmNoZWNrQnVmZmVyU2l6ZSgpO1xyXG4gICAgICAgIHZhciBpPTA7XHJcblxyXG4gICAgICAgIHZhciBjbGVuID0gdGhpcy5jb21wb25lbnRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBjPTA7IGMgPCBjbGVuOyBjKyspIHtcclxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tjXTtcclxuICAgICAgICAgICAgY29tcG9uZW50WzFdWyh0aGlzLmJ1ZmZlcl9vZmZzZXQgPj4gY29tcG9uZW50WzJdKSArIGNvbXBvbmVudFszXV0gPSB2ZXJ0ZXhbaSsrXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYnVmZmVyX29mZnNldCArPSB0aGlzLnZlcnRleF9sYXlvdXQuc3RyaWRlO1xyXG4gICAgICAgIHRoaXMudmVydGV4X2NvdW50Kys7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmluYWxpemUgdmVydGV4IGJ1ZmZlciBmb3IgdXNlIGluIGNvbnN0cnVjdGluZyBhIG1lc2hcclxuICAgIGVuZCAoKSB7XHJcbiAgICAgICAgLy8gQ2xpcCB0aGUgYWxsb2NhdGVkIGJsb2NrIHRvIGZyZWUgdW51c2VkIG1lbW9yeVxyXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcl9vZmZzZXQgPCB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdfYmxvY2sgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5idWZmZXJfb2Zmc2V0KTtcclxuICAgICAgICAgICAgdmFyIG5ld192aWV3ID0gbmV3IFVpbnQ4QXJyYXkobmV3X2Jsb2NrKTtcclxuICAgICAgICAgICAgbmV3X3ZpZXcuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLCAwLCB0aGlzLmJ1ZmZlcl9vZmZzZXQpKTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdfYmxvY2s7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyX3ZpZXdzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nKCd0cmFjZScsIGBWZXJ0ZXhEYXRhOiAke3RoaXMuYnVmZmVyX3NpemV9IHZlcnRpY2VzIHRvdGFsLCByZWFsbG9jIGNvdW50ICR7dGhpcy5yZWFsbG9jX2NvdW50fWApO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCIvKiBnbG9iYWwgVmVydGV4TGF5b3V0ICovXHJcblxyXG5pbXBvcnQgZ2wgZnJvbSAnLi9jb25zdGFudHMnOyAvLyB3ZWIgd29ya2VycyBkb24ndCBoYXZlIGFjY2VzcyB0byBHTCBjb250ZXh0LCBzbyBpbXBvcnQgYWxsIEdMIGNvbnN0YW50c1xyXG5pbXBvcnQgVmVydGV4RGF0YSBmcm9tICcuL3ZlcnRleF9kYXRhJztcclxuXHJcbi8vIERlc2NyaWJlcyBhIHZlcnRleCBsYXlvdXQgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIG1hbnkgZGlmZmVyZW50IEdMIHByb2dyYW1zLlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0ZXhMYXlvdXQge1xyXG4gICAgLy8gQXR0cmlicyBhcmUgYW4gYXJyYXksIGluIGxheW91dCBvcmRlciwgb2Y6IG5hbWUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWRcclxuICAgIC8vIGV4OiB7IG5hbWU6ICdwb3NpdGlvbicsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9XHJcbiAgICBjb25zdHJ1Y3RvciAoYXR0cmlicykge1xyXG4gICAgICAgIHRoaXMuYXR0cmlicyA9IGF0dHJpYnM7IC8vIGRpY3Rpb25hcnkgb2YgYXR0cmlidXRlcywgc3BlY2lmaWVkIGFzIHN0YW5kYXJkIEdMIGF0dHJpYiBvcHRpb25zXHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW107ICAgLy8gbGlzdCBvZiB0eXBlIGFuZCBvZmZzZXQgaW5mbyBhYm91dCBlYWNoIGF0dHJpYnV0ZSBjb21wb25lbnRcclxuICAgICAgICB0aGlzLmluZGV4ID0ge307ICAgICAgICAvLyBsaW5lYXIgYnVmZmVyIGluZGV4IG9mIGVhY2ggYXR0cmlidXRlIGNvbXBvbmVudCwgZS5nLiB0aGlzLmluZGV4LnBvc2l0aW9uLnhcclxuXHJcbiAgICAgICAgLy8gQ2FsYyB2ZXJ0ZXggc3RyaWRlXHJcbiAgICAgICAgdGhpcy5zdHJpZGUgPSAwO1xyXG5cclxuICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGF0dHJpYiBvZiB0aGlzLmF0dHJpYnMpIHtcclxuICAgICAgICAgICAgYXR0cmliLm9mZnNldCA9IHRoaXMuc3RyaWRlO1xyXG4gICAgICAgICAgICBhdHRyaWIuYnl0ZV9zaXplID0gYXR0cmliLnNpemU7XHJcbiAgICAgICAgICAgIHZhciBzaGlmdCA9IDA7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGF0dHJpYi50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGdsLkZMT0FUOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBnbC5JTlQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX0lOVDpcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWIuYnl0ZV9zaXplICo9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBnbC5TSE9SVDpcclxuICAgICAgICAgICAgICAgIGNhc2UgZ2wuVU5TSUdORURfU0hPUlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmliLmJ5dGVfc2l6ZSAqPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRm9yY2UgNC1ieXRlIGFsaWdubWVudCBvbiBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlICs9IGF0dHJpYi5ieXRlX3NpemU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmlkZSAmIDMpIHsgLy8gcGFkIHRvIG11bHRpcGxlIG9mIDQgYnl0ZXNcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RyaWRlICs9IDQgLSAodGhpcy5zdHJpZGUgJiAzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIGluZm8gdG8gbGlzdCBvZiBhdHRyaWJ1dGUgY29tcG9uZW50c1xyXG4gICAgICAgICAgICAvLyBVc2VkIHRvIGJ1aWxkIHRoZSB2ZXJ0ZXggZGF0YSwgcHJvdmlkZXMgcG9pbnRlcnMgYW5kIG9mZnNldHMgaW50byBlYWNoIHR5cGVkIGFycmF5IHZpZXdcclxuICAgICAgICAgICAgLy8gRWFjaCBjb21wb25lbnQgaXMgYW4gYXJyYXkgb2Y6XHJcbiAgICAgICAgICAgIC8vIFtHTCBhdHRyaWIgdHlwZSwgcG9pbnRlciB0byB0eXBlZCBhcnJheSB2aWV3LCBiaXRzIHRvIHNoaWZ0IHJpZ2h0IHRvIGRldGVybWluZSBidWZmZXIgb2Zmc2V0LCBhZGRpdGlvbmFsIGJ1ZmZlciBvZmZzZXQgZm9yIHRoZSBjb21wb25lbnRdXHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRfdHlwZWQgPSBhdHRyaWIub2Zmc2V0ID4+IHNoaWZ0O1xyXG4gICAgICAgICAgICBpZiAoYXR0cmliLnNpemUgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhPTA7IGEgPCBhdHRyaWIuc2l6ZTsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goW2F0dHJpYi50eXBlLCBudWxsLCBzaGlmdCwgb2Zmc2V0X3R5cGVkKytdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKFthdHRyaWIudHlwZSwgbnVsbCwgc2hpZnQsIG9mZnNldF90eXBlZF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQcm92aWRlIGFuIGluZGV4IGludG8gdGhlIHZlcnRleCBkYXRhIGJ1ZmZlciBmb3IgZWFjaCBhdHRyaWJ1dGUgY29tcG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhbYXR0cmliLm5hbWVdID0gY291bnQ7XHJcbiAgICAgICAgICAgIGNvdW50ICs9IGF0dHJpYi5zaXplO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXR1cCBhIHZlcnRleCBsYXlvdXQgZm9yIGEgc3BlY2lmaWMgR0wgcHJvZ3JhbVxyXG4gICAgLy8gQXNzdW1lcyB0aGF0IHRoZSBkZXNpcmVkIHZlcnRleCBidWZmZXIgKFZCTykgaXMgYWxyZWFkeSBib3VuZFxyXG4gICAgLy8gSWYgYSBnaXZlbiBwcm9ncmFtIGRvZXNuJ3QgaW5jbHVkZSBhbGwgYXR0cmlidXRlcywgaXQgY2FuIHN0aWxsIHVzZSB0aGUgdmVydGV4IGxheW91dFxyXG4gICAgLy8gdG8gcmVhZCB0aG9zZSBhdHRyaWJzIHRoYXQgaXQgZG9lcyByZWNvZ25pemUsIHVzaW5nIHRoZSBhdHRyaWIgb2Zmc2V0cyB0byBza2lwIG90aGVycy5cclxuICAgIGVuYWJsZSAoZ2wsIHByb2dyYW0pXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIGF0dHJpYiwgbG9jYXRpb247XHJcblxyXG4gICAgICAgIC8vIEVuYWJsZSBhbGwgYXR0cmlidXRlcyBmb3IgdGhpcyBsYXlvdXRcclxuICAgICAgICBmb3IgKHZhciBhPTA7IGEgPCB0aGlzLmF0dHJpYnMubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgYXR0cmliID0gdGhpcy5hdHRyaWJzW2FdO1xyXG4gICAgICAgICAgICBsb2NhdGlvbiA9IHByb2dyYW0uYXR0cmlidXRlKGF0dHJpYi5uYW1lKS5sb2NhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIGF0dHJpYi5zaXplLCBhdHRyaWIudHlwZSwgYXR0cmliLm5vcm1hbGl6ZWQsIHRoaXMuc3RyaWRlLCBhdHRyaWIub2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIFZlcnRleExheW91dC5lbmFibGVkX2F0dHJpYnNbbG9jYXRpb25dID0gcHJvZ3JhbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGlzYWJsZSBhbnkgcHJldmlvdXNseSBib3VuZCBhdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGZvciB0aGlzIGxheW91dFxyXG4gICAgICAgIGZvciAobG9jYXRpb24gaW4gVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlicykge1xyXG4gICAgICAgICAgICB0aGlzLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGUoZ2wsIGxvY2F0aW9uLCBwcm9ncmFtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzYWJsZSBhbiBhdHRyaWJ1dGUgaWYgaXQgd2FzIG5vdCBlbmFibGVkIGZvciB0aGUgc3BlY2lmaWVkIHByb2dyYW1cclxuICAgIC8vIE5PVEU6IHRoaXMgd2FzIG1vdmVkIG91dCBvZiB0aGUgaW5uZXIgbG9vcCBpbiBlbmFibGUoKSB0byBhc3Npc3Qgdy9WTSBvcHRpbWl6YXRpb25cclxuICAgIGRpc2FibGVVbnVzZWRBdHRyaWJ1dGUgKGdsLCBsb2NhdGlvbiwgcHJvZ3JhbSkge1xyXG4gICAgICAgIGlmIChWZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzW2xvY2F0aW9uXSAhPT0gcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xyXG4gICAgICAgICAgICBkZWxldGUgVmVydGV4TGF5b3V0LmVuYWJsZWRfYXR0cmlic1tsb2NhdGlvbl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVZlcnRleERhdGEgKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVydGV4RGF0YSh0aGlzKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbi8vIFRyYWNrIGN1cnJlbnRseSBlbmFibGVkIGF0dHJpYnMsIGJ5IHRoZSBwcm9ncmFtIHRoZXkgYXJlIGJvdW5kIHRvXHJcbi8vIFN0YXRpYyBjbGFzcyBwcm9wZXJ0eSB0byByZWZsZWN0IGdsb2JhbCBHTCBzdGF0ZVxyXG5WZXJ0ZXhMYXlvdXQuZW5hYmxlZF9hdHRyaWJzID0ge307XHJcbiIsImltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IFNjZW5lIGZyb20gJy4vc2NlbmUnO1xyXG5cclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcblxyXG4vLyBFeHBvcnRzIG11c3QgYXBwZWFyIG91dHNpZGUgYSBmdW5jdGlvbiwgYnV0IHdpbGwgb25seSBiZSBkZWZpbmVkIGluIG1haW4gdGhyZWFkIChiZWxvdylcclxuZXhwb3J0IHZhciBMZWFmbGV0TGF5ZXI7XHJcbmV4cG9ydCBmdW5jdGlvbiBsZWFmbGV0TGF5ZXIob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBMZWFmbGV0TGF5ZXIob3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIExlYWZsZXQgbGF5ZXIgZnVuY3Rpb25hbGl0eSBpcyBvbmx5IGRlZmluZWQgaW4gbWFpbiB0aHJlYWRcclxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xyXG5cclxuICAgIC8vIERldGVybWluZSBpZiB3ZSBhcmUgZXh0ZW5kaW5nIHRoZSBsZWFmbGV0IDAuNy54IFRpbGVMYXllciBjbGFzcywgb3IgdGhlIG5ld2VyXHJcbiAgICAvLyBsZWFmbGV0IDEueCBHcmlkTGF5ZXIgY2xhc3MuXHJcbiAgICBsZXQgbGF5ZXJCYXNlQ2xhc3MgPSBMLkdyaWRMYXllciA/IEwuR3JpZExheWVyIDogTC5UaWxlTGF5ZXI7XHJcbiAgICBsZXQgbGVhZmxldFZlcnNpb24gPSBsYXllckJhc2VDbGFzcyA9PT0gTC5HcmlkTGF5ZXIgPyAnMS54JyA6ICcwLjcueCc7XHJcbiAgICBsZXQgbGF5ZXJDbGFzc0NvbmZpZyA9IHt9O1xyXG5cclxuICAgIC8vIElmIGV4dGVuZGluZyBsZWFmbGV0IDAuNy54IFRpbGVMYXllciwgbWFrZSBhZGQvcmVtb3ZlIHRpbGUgbm8gb3BzXHJcbiAgICBpZiAobGF5ZXJCYXNlQ2xhc3MgPT09IEwuVGlsZUxheWVyKSB7XHJcbiAgICAgICAgbGF5ZXJDbGFzc0NvbmZpZy5fYWRkVGlsZSA9IGZ1bmN0aW9uKCl7fTtcclxuICAgICAgICBsYXllckNsYXNzQ29uZmlnLl9yZW1vdmVUaWxlID0gZnVuY3Rpb24oKXt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmluZSBjdXN0b20gbGF5ZXIgbWV0aG9kc1xyXG4gICAgT2JqZWN0LmFzc2lnbihsYXllckNsYXNzQ29uZmlnLCB7XHJcblxyXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8vIERlZmF1bHRzXHJcbiAgICAgICAgICAgIG9wdGlvbnMuc2hvd0RlYnVnID0gKCFvcHRpb25zLnNob3dEZWJ1ZyA/IGZhbHNlIDogdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2NlbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5ob29rcyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBGb3JjZSBsZWFmbGV0IHpvb20gYW5pbWF0aW9ucyBvZmZcclxuICAgICAgICAgICAgdGhpcy5fem9vbUFuaW1hdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY3JlYXRlU2NlbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZSA9IFNjZW5lLmNyZWF0ZShcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY2VuZSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBudW1Xb3JrZXJzOiB0aGlzLm9wdGlvbnMubnVtV29ya2VycyxcclxuICAgICAgICAgICAgICAgICAgICBwcmVVcGRhdGU6IHRoaXMub3B0aW9ucy5wcmVVcGRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdFVwZGF0ZTogdGhpcy5vcHRpb25zLnBvc3RVcGRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludW91c1pvb206IChMZWFmbGV0TGF5ZXIubGVhZmxldFZlcnNpb24gPT09ICcxLngnKSxcclxuICAgICAgICAgICAgICAgICAgICBoaWdoRGVuc2l0eURpc3BsYXk6IHRoaXMub3B0aW9ucy5oaWdoRGVuc2l0eURpc3BsYXksXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nTGV2ZWw6IHRoaXMub3B0aW9ucy5sb2dMZXZlbCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZHZhbmNlZCBvcHRpb24sIGFwcCB3aWxsIGhhdmUgdG8gbWFudWFsbHkgY2FsbGVkIHNjZW5lLnVwZGF0ZSgpIHBlciBmcmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVSZW5kZXJMb29wOiB0aGlzLm9wdGlvbnMuZGlzYWJsZVJlbmRlckxvb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWR2YW5jZWQgb3B0aW9uLCB3aWxsIHJlcXVpcmUgbGlicmFyeSB0byBiZSBzZXJ2ZWQgYXMgc2FtZSBob3N0IGFzIHBhZ2VcclxuICAgICAgICAgICAgICAgICAgICBhbGxvd0Nyb3NzRG9tYWluV29ya2VyczogdGhpcy5vcHRpb25zLmFsbG93Q3Jvc3NEb21haW5Xb3JrZXJzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBGaW5pc2ggaW5pdGlhbGl6aW5nIHNjZW5lIGFuZCBzZXR1cCBldmVudHMgd2hlbiBsYXllciBpcyBhZGRlZCB0byBtYXBcclxuICAgICAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlU2NlbmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGF5ZXJCYXNlQ2xhc3MucHJvdG90eXBlLm9uQWRkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmhvb2tzLnJlc2l6ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBtYXAuZ2V0U2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5yZXNpemVNYXAoc2l6ZS54LCBzaXplLnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBtYXAub24oJ3Jlc2l6ZScsIHRoaXMuaG9va3MucmVzaXplKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaG9va3MubW92ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91cGRhdGluZ190YW5ncmFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZpZXcgPSBtYXAuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICB2aWV3Lnpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5zY2VuZS5zZXRWaWV3KHZpZXcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmltbWVkaWF0ZVJlZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBtYXAub24oJ21vdmUnLCB0aGlzLmhvb2tzLm1vdmUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ob29rcy56b29tc3RhcnQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuc3RhcnRab29tKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGluZ190YW5ncmFtID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIG1hcC5vbignem9vbXN0YXJ0JywgdGhpcy5ob29rcy56b29tc3RhcnQpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5ob29rcy5kcmFnc3RhcnQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLnBhbm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBtYXAub24oJ2RyYWdzdGFydCcsIHRoaXMuaG9va3MuZHJhZ3N0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaG9va3MuZHJhZ2VuZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUucGFubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBtYXAub24oJ2RyYWdlbmQnLCB0aGlzLmhvb2tzLmRyYWdlbmQpO1xyXG5cclxuICAgICAgICAgICAgLy8gRm9yY2UgbGVhZmxldCB6b29tIGFuaW1hdGlvbnMgb2ZmXHJcbiAgICAgICAgICAgIG1hcC5fem9vbUFuaW1hdGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBDYW52YXMgZWxlbWVudCB3aWxsIGJlIGluc2VydGVkIGFmdGVyIG1hcCBjb250YWluZXIgKGxlYWZsZXQgdHJhbnNmb3JtcyBzaG91bGRuJ3QgYmUgYXBwbGllZCB0byB0aGUgR0wgY2FudmFzKVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHdheSB0byBkZWFsIHdpdGggdGhpcz8gcmlnaHQgbm93IEdMIG1hcCBvbmx5IHJlbmRlcnMgY29ycmVjdGx5IGFzIHRoZSBib3R0b20gbGF5ZXJcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5jb250YWluZXIgPSBtYXAuZ2V0Q29udGFpbmVyKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsIHZpZXdcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSBtYXAuZ2V0Q2VudGVyKCk7XHJcbiAgICAgICAgICAgIHZpZXcuem9vbSA9IG1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuc2V0Vmlldyh2aWV3KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byB0YW5ncmFtIGV2ZW50c1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLnN1YnNjcmliZSh7XHJcbiAgICAgICAgICAgICAgICBtb3ZlOiB0aGlzLm9uVGFuZ3JhbVZpZXdVcGRhdGUuYmluZCh0aGlzKVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSBsZWFmbGV0J3MgZXhpc3RpbmcgZXZlbnQgc3lzdGVtIGFzIHRoZSBjYWxsYmFjayBtZWNoYW5pc21cclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5pbml0KCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1NjZW5lLmluaXQoKSBzdWNjZWVkZWQnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnaW5pdCcpO1xyXG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIGxvZy5lcnJvcignU2NlbmUuaW5pdCgpIGZhaWxlZCB3aXRoIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgICAgICBsYXllckJhc2VDbGFzcy5wcm90b3R5cGUub25SZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgIG1hcC5vZmYoJ3Jlc2l6ZScsIHRoaXMuaG9va3MucmVzaXplKTtcclxuICAgICAgICAgICAgbWFwLm9mZignbW92ZScsIHRoaXMuaG9va3MubW92ZSk7XHJcbiAgICAgICAgICAgIG1hcC5vZmYoJ3pvb21zdGFydCcsIHRoaXMuaG9va3Muem9vbXN0YXJ0KTtcclxuICAgICAgICAgICAgbWFwLm9mZignZHJhZ3N0YXJ0JywgdGhpcy5ob29rcy5kcmFnc3RhcnQpO1xyXG4gICAgICAgICAgICBtYXAub2ZmKCdkcmFnZW5kJywgdGhpcy5ob29rcy5kcmFnZW5kKTtcclxuICAgICAgICAgICAgdGhpcy5ob29rcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbiAoY29vcmRzKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBjb29yZHMueCArICcvJyArIGNvb3Jkcy55ICsgJy8nICsgY29vcmRzLno7XHJcbiAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnZGF0YS10aWxlLWtleScsIGtleSk7XHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICcyNTZweCc7XHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAnMjU2cHgnO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93RGVidWcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWJ1Z19vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnRleHRDb250ZW50ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLmxlZnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS50b3AgPSAwO1xyXG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS5jb2xvciA9ICd3aGl0ZSc7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLmZvbnRTaXplID0gJzE2cHgnO1xyXG4gICAgICAgICAgICAgICAgZGVidWdfb3ZlcmxheS5zdHlsZS50ZXh0T3V0bGluZSA9ICcxcHggIzAwMDAwMCc7XHJcbiAgICAgICAgICAgICAgICBkZWJ1Z19vdmVybGF5LnN0eWxlLnBhZGRpbmcgPSAnOHB4JztcclxuXHJcbiAgICAgICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoZGVidWdfb3ZlcmxheSk7XHJcbiAgICAgICAgICAgICAgICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnc29saWQnO1xyXG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLmJvcmRlckNvbG9yID0gJ3doaXRlJztcclxuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5ib3JkZXJXaWR0aCA9ICcxcHgnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGl2O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG9uVGFuZ3JhbVZpZXdVcGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXAgfHwgdGhpcy5fdXBkYXRpbmdfdGFuZ3JhbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0VmlldyhbdGhpcy5zY2VuZS5jZW50ZXIubGF0LCB0aGlzLnNjZW5lLmNlbnRlci5sbmddLCB0aGlzLnNjZW5lLnpvb20sIHsgYW5pbWF0ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0aW5nX3RhbmdyYW0gPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNjZW5lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zY2VuZS51cGRhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHRoZSBsYXllciBjbGFzc1xyXG4gICAgTGVhZmxldExheWVyID0gbGF5ZXJCYXNlQ2xhc3MuZXh0ZW5kKGxheWVyQ2xhc3NDb25maWcpO1xyXG5cclxuICAgIC8vIFBvbHlmaWxsIHNvbWUgMS4wIG1ldGhvZHNcclxuICAgIGlmICh0eXBlb2YgTGVhZmxldExheWVyLnJlbW92ZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIExlYWZsZXRMYXllci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3JlbW92ZScpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgTGVhZmxldExheWVyLmxheWVyQmFzZUNsYXNzID0gbGF5ZXJCYXNlQ2xhc3M7XHJcbiAgICBMZWFmbGV0TGF5ZXIubGVhZmxldFZlcnNpb24gPSBsZWFmbGV0VmVyc2lvbjtcclxuXHJcbn1cclxuIiwiLypnbG9iYWwgTGlnaHQgKi9cclxuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi9nbC9zaGFkZXJfcHJvZ3JhbSc7XHJcbmltcG9ydCBzaGFkZXJTb3VyY2VzIGZyb20gJy4vZ2wvc2hhZGVyX3NvdXJjZXMnOyAvLyBidWlsdC1pbiBzaGFkZXJzXHJcbmltcG9ydCBHTFNMIGZyb20gJy4vZ2wvZ2xzbCc7XHJcbmltcG9ydCBHZW8gZnJvbSAnLi9nZW8nO1xyXG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xyXG5cclxuLy8gQWJzdHJhY3QgbGlnaHRcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlnaHQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChzY2VuZSwgY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmFtYmllbnQgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLmFtYmllbnQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW1iaWVudCA9IEdMU0wuZXhwYW5kVmVjNChjb25maWcuYW1iaWVudCB8fCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW1iaWVudCA9IFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IoY29uZmlnLmFtYmllbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5kaWZmdXNlID09IG51bGwgfHwgdHlwZW9mIGNvbmZpZy5kaWZmdXNlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLmRpZmZ1c2UgPSBHTFNMLmV4cGFuZFZlYzQoY29uZmlnLmRpZmZ1c2UgIT0gbnVsbCA/IGNvbmZpZy5kaWZmdXNlIDogMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRpZmZ1c2UgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZy5kaWZmdXNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuc3BlY3VsYXIgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnLnNwZWN1bGFyID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLnNwZWN1bGFyID0gR0xTTC5leHBhbmRWZWM0KGNvbmZpZy5zcGVjdWxhciB8fCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlY3VsYXIgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZy5zcGVjdWxhcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIGxpZ2h0IGJ5IHR5cGUgbmFtZSwgZmFjdG9yeS1zdHlsZVxyXG4gICAgLy8gJ2NvbmZpZycgbXVzdCBpbmNsdWRlICduYW1lJyBhbmQgJ3R5cGUnLCBhbG9uZyB3aXRoIGFueSBvdGhlciB0eXBlLXNwZWNpZmljIHByb3BlcnRpZXNcclxuICAgIHN0YXRpYyBjcmVhdGUgKHNjZW5lLCBjb25maWcpIHtcclxuICAgICAgICBpZiAoTGlnaHQudHlwZXNbY29uZmlnLnR5cGVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlnaHQudHlwZXNbY29uZmlnLnR5cGVdKHNjZW5lLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgbGlnaHQgZm9yIGEgc3R5bGU6IGZyYWdtZW50IGxpZ2h0aW5nLCB2ZXJ0ZXggbGlnaHRpbmcsIG9yIG5vbmVcclxuICAgIHN0YXRpYyBzZXRNb2RlIChtb2RlLCBzdHlsZSkge1xyXG4gICAgICAgIG1vZGUgPSBMaWdodC5lbmFibGVkICYmICgobW9kZSAhPSBudWxsKSA/IG1vZGUgOiAnZnJhZ21lbnQnKTsgLy8gZGVmYXVsdCB0byBmcmFnbWVudCBsaWdodGluZ1xyXG4gICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTElHSFRJTkdfRlJBR01FTlQnXSA9IChtb2RlID09PSAnZnJhZ21lbnQnKTtcclxuICAgICAgICBzdHlsZS5kZWZpbmVzWydUQU5HUkFNX0xJR0hUSU5HX1ZFUlRFWCddID0gKG1vZGUgPT09ICd2ZXJ0ZXgnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbmplY3QgYWxsIHByb3ZpZGVkIGxpZ2h0IGRlZmluaXRpb25zLCBhbmQgY2FsY3VsYXRlIGN1bXVsYXRpdmUgbGlnaHQgZnVuY3Rpb25cclxuICAgIHN0YXRpYyBpbmplY3QgKGxpZ2h0cykge1xyXG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGluamVjdGlvbnNcclxuICAgICAgICBTaGFkZXJQcm9ncmFtLnJlbW92ZUJsb2NrKExpZ2h0LmJsb2NrKTtcclxuXHJcbiAgICAgICAgLy8gSWYgbGlnaHRpbmcgaXMgZ2xvYmFsbHkgZGlzYWJsZWQsIG5vdGhpbmcgaXMgaW5qZWN0ZWQgKG1vc3RseSBmb3IgZGVidWdnaW5nIG9yIGxpdmUgZWRpdGluZylcclxuICAgICAgICBpZiAoIUxpZ2h0LmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29uc3RydWN0IGNvZGUgdG8gY2FsY3VsYXRlIGVhY2ggbGlnaHQgaW5zdGFuY2VcclxuICAgICAgICBsZXQgY2FsY3VsYXRlTGlnaHRzID0gXCJcIjtcclxuICAgICAgICBpZiAobGlnaHRzICYmIE9iamVjdC5rZXlzKGxpZ2h0cykubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBDb2xsZWN0IHVuaXF1ZXMgdHlwZXMgb2YgbGlnaHRzXHJcbiAgICAgICAgICAgIGxldCB0eXBlcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsaWdodF9uYW1lIGluIGxpZ2h0cykge1xyXG4gICAgICAgICAgICAgICAgdHlwZXNbbGlnaHRzW2xpZ2h0X25hbWVdLnR5cGVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5qZWN0IGVhY2ggdHlwZSBvZiBsaWdodFxyXG4gICAgICAgICAgICBmb3IgKGxldCB0eXBlIGluIHR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICBMaWdodC50eXBlc1t0eXBlXS5pbmplY3QoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5qZWN0IHBlci1pbnN0YW5jZSBibG9ja3MgYW5kIGNvbnN0cnVjdCB0aGUgbGlzdCBvZiBmdW5jdGlvbnMgdG8gY2FsY3VsYXRlIGVhY2ggbGlnaHRcclxuICAgICAgICAgICAgZm9yIChsZXQgbGlnaHRfbmFtZSBpbiBsaWdodHMpIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmluZSBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgbGlnaHRzW2xpZ2h0X25hbWVdLmluamVjdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY2FsY3VsYXRpb24gZnVuY3Rpb24gdG8gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUxpZ2h0cyArPSBgY2FsY3VsYXRlTGlnaHQoJHtsaWdodF9uYW1lfSwgX2V5ZVRvUG9pbnQsIF9ub3JtYWwpO1xcbmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGxpZ2h0IGlzIGRlZmluZWQsIHVzZSAxMDAlIG9tbmlkaXJlY3Rpb25hbCBkaWZmdXNlIGxpZ2h0XHJcbiAgICAgICAgICAgIGNhbGN1bGF0ZUxpZ2h0cyA9IGBcclxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcclxuICAgICAgICAgICAgICAgICAgICBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlID0gdmVjNCgxLik7XHJcbiAgICAgICAgICAgICAgICAjZW5kaWZcclxuICAgICAgICAgICAgYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdsdWUgdG9nZXRoZXIgdGhlIGZpbmFsIGxpZ2h0aW5nIGZ1bmN0aW9uIHRoYXQgc3VtcyBhbGwgdGhlIGxpZ2h0c1xyXG4gICAgICAgIGxldCBjYWxjdWxhdGVGdW5jdGlvbiA9IGBcclxuICAgICAgICAgICAgdmVjNCBjYWxjdWxhdGVMaWdodGluZyhpbiB2ZWMzIF9leWVUb1BvaW50LCBpbiB2ZWMzIF9ub3JtYWwsIGluIHZlYzQgX2NvbG9yKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG8gaW5pdGlhbCBtYXRlcmlhbCBjYWxjdWxhdGlvbnMgb3ZlciBub3JtYWwsIGVtaXNzaW9uLCBhbWJpZW50LCBkaWZmdXNlIGFuZCBzcGVjdWxhciB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZU1hdGVyaWFsKF9leWVUb1BvaW50LF9ub3JtYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVuIHJvbGwgdGhlIGxvb3Agb2YgaW5kaXZpZHVhbCBsaWd0aHMgdG8gY2FsY3VsYXRlXHJcbiAgICAgICAgICAgICAgICAke2NhbGN1bGF0ZUxpZ2h0c31cclxuXHJcbiAgICAgICAgICAgICAgICAvLyAgRmluYWwgbGlnaHQgaW50ZW5zaXR5IGNhbGN1bGF0aW9uXHJcbiAgICAgICAgICAgICAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xyXG5cclxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0VNSVNTSU9OXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBtYXRlcmlhbC5lbWlzc2lvbjtcclxuICAgICAgICAgICAgICAgICNlbmRpZlxyXG5cclxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0FNQklFTlRcclxuICAgICAgICAgICAgICAgICAgICBjb2xvciArPSBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICogX2NvbG9yICogbWF0ZXJpYWwuYW1iaWVudDtcclxuICAgICAgICAgICAgICAgICNlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgI2lmZGVmIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciArPSBsaWdodF9hY2N1bXVsYXRvcl9hbWJpZW50ICogX2NvbG9yICogbWF0ZXJpYWwuZGlmZnVzZTtcclxuICAgICAgICAgICAgICAgICAgICAjZW5kaWZcclxuICAgICAgICAgICAgICAgICNlbmRpZlxyXG5cclxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX0RJRkZVU0VcclxuICAgICAgICAgICAgICAgICAgICBjb2xvciArPSBsaWdodF9hY2N1bXVsYXRvcl9kaWZmdXNlICogX2NvbG9yICogbWF0ZXJpYWwuZGlmZnVzZTtcclxuICAgICAgICAgICAgICAgICNlbmRpZlxyXG5cclxuICAgICAgICAgICAgICAgICNpZmRlZiBUQU5HUkFNX01BVEVSSUFMX1NQRUNVTEFSXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgKz0gbGlnaHRfYWNjdW11bGF0b3Jfc3BlY3VsYXIgKiBtYXRlcmlhbC5zcGVjdWxhcjtcclxuICAgICAgICAgICAgICAgICNlbmRpZlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENsYW1wIGZpbmFsIGNvbG9yXHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNsYW1wKGNvbG9yLCAwLjAsIDEuMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgICAgICAgICB9YDtcclxuXHJcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jayhMaWdodC5ibG9jaywgY2FsY3VsYXRlRnVuY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbW1vbiBpbnN0YW5jZSBkZWZpbml0aW9uXHJcbiAgICBpbmplY3QgKCkge1xyXG4gICAgICAgIGxldCBpbnN0YW5jZSA9ICBgXHJcbiAgICAgICAgICAgIHVuaWZvcm0gJHt0aGlzLnN0cnVjdF9uYW1lfSB1XyR7dGhpcy5uYW1lfTtcclxuICAgICAgICAgICAgJHt0aGlzLnN0cnVjdF9uYW1lfSAke3RoaXMubmFtZX0gPSB1XyR7dGhpcy5uYW1lfTtcXG5gO1xyXG5cclxuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIG1ldGhvZCBjYWxsZWQgb25jZSBwZXIgZnJhbWVcclxuICAgIHVwZGF0ZSAoKSB7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsbGVkIG9uY2UgcGVyIGZyYW1lIHBlciBwcm9ncmFtIChlLmcuIGZvciBtYWluIHJlbmRlciBwYXNzLCB0aGVuIGZvciBlYWNoIGFkZGl0aW9uYWxcclxuICAgIC8vIHBhc3MgZm9yIGZlYXR1cmUgc2VsZWN0aW9uLCBldGMuKVxyXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xyXG4gICAgICAgIC8vICBUaHJlZSBjb21tb24gbGlnaHQgcHJvcGVydGllc1xyXG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1XyR7dGhpcy5uYW1lfS5hbWJpZW50YCwgdGhpcy5hbWJpZW50KTtcclxuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV8ke3RoaXMubmFtZX0uZGlmZnVzZWAsIHRoaXMuZGlmZnVzZSk7XHJcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfJHt0aGlzLm5hbWV9LnNwZWN1bGFyYCwgdGhpcy5zcGVjdWxhcik7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5MaWdodC50eXBlcyA9IHt9OyAvLyByZWZlcmVuY2VzIHRvIHN1YmNsYXNzZXMgYnkgc2hvcnQgbmFtZVxyXG5MaWdodC5ibG9jayA9ICdsaWdodGluZyc7IC8vIHNoYWRlciBibG9jayBuYW1lXHJcbkxpZ2h0LmVuYWJsZWQgPSB0cnVlOyAvLyBsaWdodGluZyBjYW4gYmUgZ2xvYmFsbHkgZW5hYmxlZC9kaXNhYmxlZFxyXG5cclxuXHJcbi8vIExpZ2h0IHN1YmNsYXNzZXNcclxuY2xhc3MgQW1iaWVudExpZ2h0IGV4dGVuZHMgTGlnaHQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNjZW5lLCBjb25maWcpIHtcclxuICAgICAgICBzdXBlcihzY2VuZSwgY29uZmlnKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnYW1iaWVudCc7XHJcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdBbWJpZW50TGlnaHQnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluamVjdCBzdHJ1Y3QgYW5kIGNhbGN1bGF0ZSBmdW5jdGlvblxyXG4gICAgc3RhdGljIGluamVjdCgpIHtcclxuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2FtYmllbnRMaWdodCddKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XHJcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnNGZ2JywgYHVfJHt0aGlzLm5hbWV9LmFtYmllbnRgLCB0aGlzLmFtYmllbnQpO1xyXG4gICAgfVxyXG5cclxufVxyXG5MaWdodC50eXBlc1snYW1iaWVudCddID0gQW1iaWVudExpZ2h0O1xyXG5cclxuY2xhc3MgRGlyZWN0aW9uYWxMaWdodCBleHRlbmRzIExpZ2h0IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzY2VuZSwgY29uZmlnKSB7XHJcbiAgICAgICAgc3VwZXIoc2NlbmUsIGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2RpcmVjdGlvbmFsJztcclxuICAgICAgICB0aGlzLnN0cnVjdF9uYW1lID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xyXG5cclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IChjb25maWcuZGlyZWN0aW9uIHx8IFswLjIsIDAuNywgLTAuNV0pLm1hcChwYXJzZUZsb2F0KTsgLy8gW3gsIHksIHpdXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5qZWN0IHN0cnVjdCBhbmQgY2FsY3VsYXRlIGZ1bmN0aW9uXHJcbiAgICBzdGF0aWMgaW5qZWN0KCkge1xyXG4gICAgICAgIFNoYWRlclByb2dyYW0uYWRkQmxvY2soTGlnaHQuYmxvY2ssIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvZGlyZWN0aW9uYWxMaWdodCddKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XHJcbiAgICAgICAgc3VwZXIuc2V0dXBQcm9ncmFtKF9wcm9ncmFtKTtcclxuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCczZnYnLCBgdV8ke3RoaXMubmFtZX0uZGlyZWN0aW9uYCwgdGhpcy5kaXJlY3Rpb24pO1xyXG4gICAgfVxyXG5cclxufVxyXG5MaWdodC50eXBlc1snZGlyZWN0aW9uYWwnXSA9IERpcmVjdGlvbmFsTGlnaHQ7XHJcblxyXG5cclxuY2xhc3MgUG9pbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAoc2NlbmUsIGNvbmZpZykge1xyXG4gICAgICAgIHN1cGVyKHNjZW5lLCBjb25maWcpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdwb2ludCc7XHJcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdQb2ludExpZ2h0JztcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGNvbmZpZy5wb3NpdGlvbiB8fCBbMCwgMCwgMF07XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbl9leWUgPSBbXTsgLy8gcG9zaXRpb24gaW4gZXllc3BhY2VcclxuICAgICAgICB0aGlzLm9yaWdpbiA9IGNvbmZpZy5vcmlnaW4gfHwgJ3dvcmxkJztcclxuICAgICAgICB0aGlzLmF0dGVudWF0aW9uID0gIWlzTmFOKHBhcnNlRmxvYXQoY29uZmlnLmF0dGVudWF0aW9uKSkgPyBwYXJzZUZsb2F0KGNvbmZpZy5hdHRlbnVhdGlvbikgOiAwO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLnJhZGl1cykge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcucmFkaXVzKSAmJiBjb25maWcucmFkaXVzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBjb25maWcucmFkaXVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSBbbnVsbCwgY29uZmlnLnJhZGl1c107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5qZWN0IHN0cnVjdCBhbmQgY2FsY3VsYXRlIGZ1bmN0aW9uXHJcbiAgICBzdGF0aWMgaW5qZWN0ICgpIHtcclxuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3BvaW50TGlnaHQnXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5qZWN0IGlzbnRhbmNlLXNwZWNpZmljIHNldHRpbmdzXHJcbiAgICBpbmplY3QoKSB7XHJcbiAgICAgICAgc3VwZXIuaW5qZWN0KCk7XHJcblxyXG4gICAgICAgIFNoYWRlclByb2dyYW0uZGVmaW5lc1snVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UJ10gPSAodGhpcy5hdHRlbnVhdGlvbiAhPT0gMCk7XHJcbiAgICAgICAgU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTJ10gPSAodGhpcy5yYWRpdXMgIT0gbnVsbCAmJiB0aGlzLnJhZGl1c1swXSAhPSBudWxsKTtcclxuICAgICAgICBTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVMnXSA9ICh0aGlzLnJhZGl1cyAhPSBudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUgKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlRXllUG9zaXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVFeWVQb3NpdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luID09PSAnd29ybGQnKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciB3b3JsZCBvcmlnaW4sIGZvcm1hdCBpczogW2xvbmdpdHVkZSwgbGF0aXR1ZGUsIG1ldGVycyAoZGVmYXVsdCkgb3IgcGl4ZWxzIHcvcHggdW5pdHNdXHJcblxyXG4gICAgICAgICAgICAvLyBNb3ZlIGxpZ2h0J3Mgd29ybGQgcG9zaXRpb24gaW50byBjYW1lcmEgc3BhY2VcclxuICAgICAgICAgICAgbGV0IFt4LCB5XSA9IEdlby5sYXRMbmdUb01ldGVycyh0aGlzLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMF0gPSB4IC0gdGhpcy5zY2VuZS5jYW1lcmEucG9zaXRpb25fbWV0ZXJzWzBdO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZVsxXSA9IHkgLSB0aGlzLnNjZW5lLmNhbWVyYS5wb3NpdGlvbl9tZXRlcnNbMV07XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZVsyXSA9IFN0eWxlUGFyc2VyLmNvbnZlcnRVbml0cyh0aGlzLnBvc2l0aW9uWzJdLCB7IHpvb206IHRoaXMuc2NlbmUuem9vbSB9KTtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMl0gPSB0aGlzLnBvc2l0aW9uX2V5ZVsyXSAtIHRoaXMuc2NlbmUuY2FtZXJhLnBvc2l0aW9uX21ldGVyc1syXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luID09PSAnZ3JvdW5kJyB8fCB0aGlzLm9yaWdpbiA9PT0gJ2NhbWVyYScpIHtcclxuICAgICAgICAgICAgLy8gRm9yIGNhbWVyYSBvciBncm91bmQgb3JpZ2luLCBmb3JtYXQgaXM6IFt4LCB5LCB6XSBpbiBtZXRlcnMgKGRlZmF1bHQpIG9yIHBpeGVscyB3L3B4IHVuaXRzXHJcblxyXG4gICAgICAgICAgICAvLyBMaWdodCBpcyBpbiBjYW1lcmEgc3BhY2UgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uX2V5ZSA9IFN0eWxlUGFyc2VyLmNvbnZlcnRVbml0cyh0aGlzLnBvc2l0aW9uLCB7IHpvb206IHRoaXMuc2NlbmUuem9vbSB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2dyb3VuZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIExlYXZlIGxpZ2h0J3MgeHkgaW4gY2FtZXJhIHNwYWNlLCBidXQgeiBuZWVkcyB0byBiZSBtb3ZlZCByZWxhdGl2ZSB0byBncm91bmQgcGxhbmVcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25fZXllWzJdID0gdGhpcy5wb3NpdGlvbl9leWVbMl0gLSB0aGlzLnNjZW5lLmNhbWVyYS5wb3NpdGlvbl9tZXRlcnNbMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dXBQcm9ncmFtIChfcHJvZ3JhbSkge1xyXG4gICAgICAgIHN1cGVyLnNldHVwUHJvZ3JhbShfcHJvZ3JhbSk7XHJcblxyXG4gICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmJywgYHVfJHt0aGlzLm5hbWV9LnBvc2l0aW9uYCxcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbl9leWVbMF0sIHRoaXMucG9zaXRpb25fZXllWzFdLCB0aGlzLnBvc2l0aW9uX2V5ZVsyXSwgMSk7XHJcblxyXG4gICAgICAgIGlmKFNoYWRlclByb2dyYW0uZGVmaW5lc1snVEFOR1JBTV9QT0lOVExJR0hUX0FUVEVOVUFUSU9OX0VYUE9ORU5UJ10pIHtcclxuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCBgdV8ke3RoaXMubmFtZX0uYXR0ZW51YXRpb25FeHBvbmVudGAsIHRoaXMuYXR0ZW51YXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoU2hhZGVyUHJvZ3JhbS5kZWZpbmVzWydUQU5HUkFNX1BPSU5UTElHSFRfQVRURU5VQVRJT05fSU5ORVJfUkFESVVTJ10pIHtcclxuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCBgdV8ke3RoaXMubmFtZX0uaW5uZXJSYWRpdXNgLFxyXG4gICAgICAgICAgICAgICAgU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHRoaXMucmFkaXVzWzBdLCB7IHpvb206IHRoaXMuc2NlbmUuem9vbSB9KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihTaGFkZXJQcm9ncmFtLmRlZmluZXNbJ1RBTkdSQU1fUE9JTlRMSUdIVF9BVFRFTlVBVElPTl9PVVRFUl9SQURJVVMnXSkge1xyXG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsIGB1XyR7dGhpcy5uYW1lfS5vdXRlclJhZGl1c2AsXHJcbiAgICAgICAgICAgICAgICBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModGhpcy5yYWRpdXNbMV0sIHsgem9vbTogdGhpcy5zY2VuZS56b29tIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuTGlnaHQudHlwZXNbJ3BvaW50J10gPSBQb2ludExpZ2h0O1xyXG5cclxuXHJcbmNsYXNzIFNwb3RMaWdodCBleHRlbmRzIFBvaW50TGlnaHQge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChzY2VuZSwgY29uZmlnKSB7XHJcbiAgICAgICAgc3VwZXIoc2NlbmUsIGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3Nwb3RsaWdodCc7XHJcbiAgICAgICAgdGhpcy5zdHJ1Y3RfbmFtZSA9ICdTcG90TGlnaHQnO1xyXG5cclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IChjb25maWcuZGlyZWN0aW9uIHx8IFswLCAwLCAtMV0pLm1hcChwYXJzZUZsb2F0KTsgLy8gW3gsIHksIHpdXHJcbiAgICAgICAgdGhpcy5leHBvbmVudCA9IGNvbmZpZy5leHBvbmVudCA/IHBhcnNlRmxvYXQoY29uZmlnLmV4cG9uZW50KSA6IDAuMjtcclxuICAgICAgICB0aGlzLmFuZ2xlID0gY29uZmlnLmFuZ2xlID8gcGFyc2VGbG9hdChjb25maWcuYW5nbGUpIDogMjA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5qZWN0IHN0cnVjdCBhbmQgY2FsY3VsYXRlIGZ1bmN0aW9uXHJcbiAgICBzdGF0aWMgaW5qZWN0ICgpIHtcclxuICAgICAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKExpZ2h0LmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3Nwb3RMaWdodCddKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXR1cFByb2dyYW0gKF9wcm9ncmFtKSB7XHJcbiAgICAgICAgc3VwZXIuc2V0dXBQcm9ncmFtKF9wcm9ncmFtKTtcclxuXHJcbiAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnM2Z2JywgYHVfJHt0aGlzLm5hbWV9LmRpcmVjdGlvbmAsIHRoaXMuZGlyZWN0aW9uKTtcclxuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsIGB1XyR7dGhpcy5uYW1lfS5zcG90Q29zQ3V0b2ZmYCwgTWF0aC5jb3ModGhpcy5hbmdsZSAqIDMuMTQxNTkgLyAxODApKTtcclxuICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsIGB1XyR7dGhpcy5uYW1lfS5zcG90RXhwb25lbnRgLCB0aGlzLmV4cG9uZW50KTtcclxuICAgIH1cclxuXHJcbn1cclxuTGlnaHQudHlwZXNbJ3Nwb3RsaWdodCddID0gU3BvdExpZ2h0O1xyXG4iLCIvKmdsb2JhbCBNYXRlcmlhbCAqL1xyXG5pbXBvcnQgc2hhZGVyU291cmNlcyBmcm9tICcuL2dsL3NoYWRlcl9zb3VyY2VzJzsgLy8gYnVpbHQtaW4gc2hhZGVyc1xyXG5pbXBvcnQgR0xTTCBmcm9tICcuL2dsL2dsc2wnO1xyXG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0ZXJpYWwge1xyXG4gICAgY29uc3RydWN0b3IgKGNvbmZpZykge1xyXG5cclxuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XHJcblxyXG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgYWxsIGhhdmUgdGhlIHNhbWUgZGVmYXVsdHMsIHNvIHRoZXkgY2FuIGJlIHNldCBpbiBidWxrXHJcbiAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBbJ2VtaXNzaW9uJywgJ2FtYmllbnQnLCAnZGlmZnVzZScsICdzcGVjdWxhciddKSB7XHJcbiAgICAgICAgICAgIGlmIChjb25maWdbcHJvcF0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1twcm9wXS50ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTogY29uZmlnW3Byb3BdLnRleHR1cmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNvbmZpZ1twcm9wXS5tYXBwaW5nIHx8ICdzcGhlcmVtYXAnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogR0xTTC5leHBhbmRWZWMzKGNvbmZpZ1twcm9wXS5zY2FsZSAhPSBudWxsID8gY29uZmlnW3Byb3BdLnNjYWxlIDogMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogR0xTTC5leHBhbmRWZWM0KGNvbmZpZ1twcm9wXS5hbW91bnQgIT0gbnVsbCA/IGNvbmZpZ1twcm9wXS5hbW91bnQgOiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uZmlnW3Byb3BdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSB7IGFtb3VudDogR0xTTC5leHBhbmRWZWM0KGNvbmZpZ1twcm9wXSkgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb25maWdbcHJvcF0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wXSA9IHsgYW1vdW50OiBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKGNvbmZpZ1twcm9wXSkgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcF0gPSBjb25maWdbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4dHJhIHNwZWN1bGFyIHByb3BzXHJcbiAgICAgICAgaWYgKHRoaXMuc3BlY3VsYXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zcGVjdWxhci5zaGluaW5lc3MgPSBjb25maWcuc2hpbmluZXNzID8gcGFyc2VGbG9hdChjb25maWcuc2hpbmluZXNzKSA6IDAuMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vcm1hbCBtYXBwaW5nXHJcbiAgICAgICAgaWYgKGNvbmZpZy5ub3JtYWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLm5vcm1hbCA9IHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmU6IGNvbmZpZy5ub3JtYWwudGV4dHVyZSxcclxuICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNvbmZpZy5ub3JtYWwubWFwcGluZyB8fCAndHJpcGxhbmFyJyxcclxuICAgICAgICAgICAgICAgIHNjYWxlOiBHTFNMLmV4cGFuZFZlYzMoY29uZmlnLm5vcm1hbC5zY2FsZSAhPSBudWxsID8gY29uZmlnLm5vcm1hbC5zY2FsZSA6IDEpLFxyXG4gICAgICAgICAgICAgICAgYW1vdW50OiBjb25maWcubm9ybWFsLmFtb3VudCAhPSBudWxsID8gY29uZmlnLm5vcm1hbC5hbW91bnQgOiAxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSBpZiBhIG1hdGVyaWFsIGNvbmZpZyBibG9jayBoYXMgc3VmZmljaWVudCBwcm9wZXJ0aWVzIHRvIGNyZWF0ZSBhIG1hdGVyaWFsXHJcbiAgICBzdGF0aWMgaXNWYWxpZCAoY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuZW1pc3Npb24gPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICBjb25maWcuYW1iaWVudCA9PSBudWxsICYmXHJcbiAgICAgICAgICAgIGNvbmZpZy5kaWZmdXNlID09IG51bGwgJiZcclxuICAgICAgICAgICAgY29uZmlnLnNwZWN1bGFyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaW5qZWN0IChzdHlsZSkge1xyXG4gICAgICAgIC8vIEZvciBlYWNoIHByb3BlcnR5LCBzZXRzIGRlZmluZXMgdG8gY29uZmlndXJlIHRleHR1cmUgbWFwcGluZywgd2l0aCBhIHBhdHRlcm4gbGlrZTpcclxuICAgICAgICAvLyAgIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRSwgVEFOR1JBTV9NQVRFUklBTF9ESUZGVVNFX1RFWFRVUkUsIFRBTkdSQU1fTUFURVJJQUxfRElGRlVTRV9URVhUVVJFX1NQSEVSRU1BUFxyXG4gICAgICAgIC8vIEFsc28gc2V0cyBmbGFncyB0byBrZWVwIHRyYWNrIG9mIGVhY2ggdW5pcXVlIG1hcHBpbmcgdHlwZSBiZWluZyB1c2VkLCBlLmcuOlxyXG4gICAgICAgIC8vICAgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFX1NQSEVSRU1BUFxyXG4gICAgICAgIC8vIEVuYWJsZXMgdGV4dHVyZSBjb29yZGluYXRlcyBpZiBuZWVkZWQgYW5kIG5vdCBhbHJlYWR5IG9uXHJcbiAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBbJ2VtaXNzaW9uJywgJ2FtYmllbnQnLCAnZGlmZnVzZScsICdzcGVjdWxhciddKSB7XHJcbiAgICAgICAgICAgIGxldCBkZWYgPSBgVEFOR1JBTV9NQVRFUklBTF8ke3Byb3AudG9VcHBlckNhc2UoKX1gO1xyXG4gICAgICAgICAgICBsZXQgdGV4ZGVmID0gZGVmICsgJ19URVhUVVJFJztcclxuICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1tkZWZdID0gKHRoaXNbcHJvcF0gIT0gbnVsbCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzW3Byb3BdICYmIHRoaXNbcHJvcF0udGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuZGVmaW5lc1t0ZXhkZWZdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbdGV4ZGVmICsgJ18nICsgdGhpc1twcm9wXS5tYXBwaW5nLnRvVXBwZXJDYXNlKCldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbYFRBTkdSQU1fTUFURVJJQUxfVEVYVFVSRV8ke3RoaXNbcHJvcF0ubWFwcGluZy50b1VwcGVyQ2FzZSgpfWBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleGNvb3JkcyA9IHN0eWxlLnRleGNvb3JkcyB8fCAodGhpc1twcm9wXS5tYXBwaW5nID09PSAndXYnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm9ybWFsIG1hcHBpbmdcclxuICAgICAgICAvLyBBcyBhbm92ZSwgc2V0cyBmbGFncyB0byBrZWVwIHRyYWNrIG9mIGVhY2ggdW5pcXVlIG1hcHBpbmcgdHlwZSBiZWluZyB1c2VkLCBlLmcuOlxyXG4gICAgICAgIC8vICAgVEFOR1JBTV9NQVRFUklBTF9URVhUVVJFX1NQSEVSRU1BUFxyXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbCAmJiB0aGlzLm5vcm1hbC50ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkUnXSA9IHRydWU7XHJcbiAgICAgICAgICAgIHN0eWxlLmRlZmluZXNbJ1RBTkdSQU1fTUFURVJJQUxfTk9STUFMX1RFWFRVUkVfJyArIHRoaXMubm9ybWFsLm1hcHBpbmcudG9VcHBlckNhc2UoKV0gPSB0cnVlO1xyXG4gICAgICAgICAgICBzdHlsZS5kZWZpbmVzW2BUQU5HUkFNX01BVEVSSUFMX1RFWFRVUkVfJHt0aGlzLm5vcm1hbC5tYXBwaW5nLnRvVXBwZXJDYXNlKCl9YF0gPSB0cnVlO1xyXG4gICAgICAgICAgICBzdHlsZS50ZXhjb29yZHMgPSBzdHlsZS50ZXhjb29yZHMgfHwgKHRoaXMubm9ybWFsLm1hcHBpbmcgPT09ICd1dicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3R5bGUucmVwbGFjZVNoYWRlckJsb2NrKE1hdGVyaWFsLmJsb2NrLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL21hdGVyaWFsJ10pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldHVwUHJvZ3JhbSAoX3Byb2dyYW0pIHtcclxuICAgICAgICAvLyBGb3IgZWFjaCBwcm9wZXJ0eSwgc2V0cyB1bmlmb3JtcyBpbiB0aGUgcGF0dGVybjpcclxuICAgICAgICAvLyB1X21hdGVyaWFsLmRpZmZ1c2UsIHVfbWF0ZXJpYWwuZGlmZnVzZVNjYWxlIHVfbWF0ZXJpYWxfZGlmZnVzZV90ZXh0dXJlXHJcbiAgICAgICAgZm9yIChsZXQgcHJvcCBvZiBbJ2VtaXNzaW9uJywgJ2FtYmllbnQnLCAnZGlmZnVzZScsICdzcGVjdWxhciddKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzW3Byb3BdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1twcm9wXS50ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Byb2dyYW0uc2V0VGV4dHVyZVVuaWZvcm0oYHVfbWF0ZXJpYWxfJHtwcm9wfV90ZXh0dXJlYCwgdGhpc1twcm9wXS50ZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCczZnYnLCBgdV9tYXRlcmlhbC4ke3Byb3B9U2NhbGVgLCB0aGlzW3Byb3BdLnNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCc0ZnYnLCBgdV9tYXRlcmlhbC4ke3Byb3B9YCwgdGhpc1twcm9wXS5hbW91bnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzW3Byb3BdLmFtb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzRmdicsIGB1X21hdGVyaWFsLiR7cHJvcH1gLCB0aGlzW3Byb3BdLmFtb3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4dHJhIHNwZWN1bGFyIHByb3BzXHJcbiAgICAgICAgaWYgKHRoaXMuc3BlY3VsYXIpIHtcclxuICAgICAgICAgICAgX3Byb2dyYW0udW5pZm9ybSgnMWYnLCAndV9tYXRlcmlhbC5zaGluaW5lc3MnLCB0aGlzLnNwZWN1bGFyLnNoaW5pbmVzcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOb3JtYWwgbWFwcGluZ1xyXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbCAmJiB0aGlzLm5vcm1hbC50ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIF9wcm9ncmFtLnNldFRleHR1cmVVbmlmb3JtKCd1X21hdGVyaWFsX25vcm1hbF90ZXh0dXJlJywgdGhpcy5ub3JtYWwudGV4dHVyZSk7XHJcbiAgICAgICAgICAgIF9wcm9ncmFtLnVuaWZvcm0oJzNmdicsICd1X21hdGVyaWFsLm5vcm1hbFNjYWxlJywgdGhpcy5ub3JtYWwuc2NhbGUpO1xyXG4gICAgICAgICAgICBfcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X21hdGVyaWFsLm5vcm1hbEFtb3VudCcsIHRoaXMubm9ybWFsLmFtb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5NYXRlcmlhbC5ibG9jayA9ICdtYXRlcmlhbCc7XHJcbiIsIi8qanNoaW50IHdvcmtlcjogdHJ1ZSovXHJcblxyXG4vLyBNb2R1bGVzIGFuZCBkZXBlbmRlbmNpZXMgdG8gZXhwb3NlIGluIHRoZSBwdWJsaWMgVGFuZ3JhbSBtb2R1bGVcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMvdXRpbHMnO1xyXG5cclxuLy8gVGhlIGxlYWZsZXQgbGF5ZXIgcGx1Z2luIGlzIGN1cnJlbnRseSB0aGUgcHJpbWFyeSBwdWJsaWMgQVBJXHJcbmltcG9ydCB7TGVhZmxldExheWVyLCBsZWFmbGV0TGF5ZXJ9IGZyb20gJy4vbGVhZmxldF9sYXllcic7XHJcblxyXG4vLyBUaGUgc2NlbmUgd29ya2VyIGlzIG9ubHkgYWN0aXZhdGVkIHdoZW4gYSB3b3JrZXIgdGhyZWFkIGlzIGluc3RhbnRpYXRlZCwgYnV0IG11c3QgYWx3YXlzIGJlIGxvYWRlZFxyXG5pbXBvcnQge1NjZW5lV29ya2VyfSBmcm9tICcuLi9zcmMvc2NlbmVfd29ya2VyJztcclxuXHJcbi8vIEFkZGl0aW9uYWwgbW9kdWxlcyBhcmUgZXhwb3NlZCBmb3IgZGVidWdnaW5nXHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgR2VvIGZyb20gJy4vZ2VvJztcclxuaW1wb3J0IERhdGFTb3VyY2UgZnJvbSAnLi9kYXRhX3NvdXJjZSc7XHJcbmltcG9ydCBHTFNMIGZyb20gJy4vZ2wvZ2xzbCc7XHJcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4vZ2wvc2hhZGVyX3Byb2dyYW0nO1xyXG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xyXG5pbXBvcnQgTWF0ZXJpYWwgZnJvbSAnLi9tYXRlcmlhbCc7XHJcbmltcG9ydCBMaWdodCBmcm9tICcuL2xpZ2h0JztcclxuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xyXG5pbXBvcnQge3J1bGVDYWNoZX0gZnJvbSAnLi9zdHlsZXMvcnVsZSc7XHJcbmltcG9ydCB7U3R5bGVNYW5hZ2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9tYW5hZ2VyJztcclxuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcclxuaW1wb3J0IEZlYXR1cmVTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nO1xyXG5cclxuaW1wb3J0IGdsTWF0cml4IGZyb20gJ2dsLW1hdHJpeCc7XHJcblxyXG4vLyBEZWZhdWx0IHRvIDY0LWJpdCBiZWNhdXNlIHdlIG5lZWQgdGhlIGV4dHJhIHByZWNpc2lvbiB3aGVuIG11bHRpcGx5aW5nIG1hdHJpY2VzIHcvbWVyY2F0b3IgcHJvamVjdGVkIHZhbHVlc1xyXG5nbE1hdHJpeC5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUoRmxvYXQ2NEFycmF5KTtcclxuXHJcbi8vIE1ha2Ugc29tZSBtb2R1bGVzIGFjY2Vzc2libGUgZm9yIGRlYnVnZ2luZ1xyXG52YXIgZGVidWcgPSB7XHJcbiAgICBsb2csXHJcbiAgICBVdGlscyxcclxuICAgIEdlbyxcclxuICAgIERhdGFTb3VyY2UsXHJcbiAgICBHTFNMLFxyXG4gICAgU2hhZGVyUHJvZ3JhbSxcclxuICAgIFRleHR1cmUsXHJcbiAgICBNYXRlcmlhbCxcclxuICAgIExpZ2h0LFxyXG4gICAgU2NlbmVXb3JrZXIsXHJcbiAgICBXb3JrZXJCcm9rZXIsXHJcbiAgICBydWxlQ2FjaGUsXHJcbiAgICBTdHlsZU1hbmFnZXIsXHJcbiAgICBTdHlsZVBhcnNlcixcclxuICAgIEZlYXR1cmVTZWxlY3Rpb25cclxufTtcclxuXHJcbi8vIFdpbmRvdyBjYW4gb25seSBiZSBzZXQgaW4gbWFpbiB0aHJlYWRcclxuaWYgKFV0aWxzLmlzTWFpblRocmVhZCkge1xyXG4gICAgLy8gTWFpbiB0aHJlYWQgb2JqZWN0cyB0aGF0IGNhbiBiZSBjYWxsZWQgZnJvbSB3b3JrZXJzXHJcbiAgICBXb3JrZXJCcm9rZXIuYWRkVGFyZ2V0KCdUZXh0dXJlJywgVGV4dHVyZSk7XHJcblxyXG4gICAgd2luZG93LlRhbmdyYW0gPSBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBMZWFmbGV0TGF5ZXIsXHJcbiAgICAgICAgbGVhZmxldExheWVyLFxyXG4gICAgICAgIGRlYnVnXHJcbiAgICB9O1xyXG5cclxufVxyXG5cclxuaWYgKFV0aWxzLmlzV29ya2VyVGhyZWFkKSB7XHJcbiAgICBzZWxmLlRhbmdyYW0gPSB7XHJcbiAgICAgICAgZGVidWdcclxuICAgIH07XHJcbn1cclxuXHJcbmlmIChVdGlscy5pc01haW5UaHJlYWQpIHtcclxuICAgIFV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZVBvbHlmaWxsKCk7XHJcbn1cclxuIiwiLypnbG9iYWwgU2NlbmUgKi9cclxuaW1wb3J0IEdlbyBmcm9tICcuL2dlbyc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xyXG5pbXBvcnQgc3Vic2NyaWJlTWl4aW4gZnJvbSAnLi91dGlscy9zdWJzY3JpYmUnO1xyXG5pbXBvcnQgQ29udGV4dCBmcm9tICcuL2dsL2NvbnRleHQnO1xyXG5pbXBvcnQgQnVpbGRlcnMgZnJvbSAnLi9zdHlsZXMvYnVpbGRlcnMnO1xyXG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuL2dsL3NoYWRlcl9wcm9ncmFtJztcclxuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcclxuaW1wb3J0IFZlcnRleEFycmF5T2JqZWN0IGZyb20gJy4vZ2wvdmFvJztcclxuaW1wb3J0IHtTdHlsZU1hbmFnZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX21hbmFnZXInO1xyXG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9wYXJzZXInO1xyXG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vY2FtZXJhJztcclxuaW1wb3J0IExpZ2h0IGZyb20gJy4vbGlnaHQnO1xyXG5pbXBvcnQgVGlsZSBmcm9tICcuL3RpbGUnO1xyXG5pbXBvcnQgRGF0YVNvdXJjZSBmcm9tICcuL2RhdGFfc291cmNlJztcclxuaW1wb3J0IEZlYXR1cmVTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nO1xyXG5cclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCBnbE1hdHJpeCBmcm9tICdnbC1tYXRyaXgnO1xyXG5sZXQgbWF0NCA9IGdsTWF0cml4Lm1hdDQ7XHJcbmxldCBtYXQzID0gZ2xNYXRyaXgubWF0MztcclxubGV0IHZlYzMgPSBnbE1hdHJpeC52ZWMzO1xyXG5cclxuLy8gTG9hZCBzY2VuZSBkZWZpbml0aW9uOiBwYXNzIGFuIG9iamVjdCBkaXJlY3RseSwgb3IgYSBVUkwgYXMgc3RyaW5nIHRvIGxvYWQgcmVtb3RlbHlcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmUge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ19zb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBzdWJzY3JpYmVNaXhpbih0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VzID0ge307XHJcblxyXG4gICAgICAgIHRoaXMudGlsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLnZpc2libGVfdGlsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLnF1ZXVlZF90aWxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubnVtX3dvcmtlcnMgPSBvcHRpb25zLm51bVdvcmtlcnMgfHwgMjtcclxuICAgICAgICB0aGlzLmNvbnRpbnVvdXNfem9vbSA9ICh0eXBlb2Ygb3B0aW9ucy5jb250aW51b3VzWm9vbSA9PT0gJ2Jvb2xlYW4nKSA/IG9wdGlvbnMuY29udGludW91c1pvb20gOiB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWxsb3dfY3Jvc3NfZG9tYWluX3dvcmtlcnMgPSAob3B0aW9ucy5hbGxvd0Nyb3NzRG9tYWluV29ya2VycyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUpO1xyXG4gICAgICAgIHRoaXMud29ya2VyX3VybCA9IG9wdGlvbnMud29ya2VyVXJsO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmRpc2FibGVWZXJ0ZXhBcnJheU9iamVjdHMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgVmVydGV4QXJyYXlPYmplY3QuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgVXRpbHMudXNlX2hpZ2hfZGVuc2l0eV9kaXNwbGF5ID0gb3B0aW9ucy5oaWdoRGVuc2l0eURpc3BsYXkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaGlnaERlbnNpdHlEaXNwbGF5IDogdHJ1ZTtcclxuICAgICAgICBVdGlscy51cGRhdGVEZXZpY2VQaXhlbFJhdGlvKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbmZpZ19zb3VyY2UgPSBjb25maWdfc291cmNlO1xyXG4gICAgICAgIHRoaXMuY29uZmlnX3NlcmlhbGl6ZWQgPSBudWxsO1xyXG5cclxuICAgICAgICB0aGlzLnN0eWxlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVfc3R5bGVzID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuYnVpbGRpbmcgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYWNrcyBjdXJyZW50IHNjZW5lIGJ1aWxkaW5nIHN0YXRlICh0aWxlcyBiZWluZyBidWlsdCwgZXRjLilcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGEgcmVkcmF3XHJcbiAgICAgICAgdGhpcy5hbmltYXRlZCA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdCByZWRyYXcgZXZlcnkgZnJhbWVcclxuICAgICAgICB0aGlzLnByZVVwZGF0ZSA9IG9wdGlvbnMucHJlVXBkYXRlOyAgICAgICAgICAgICAvLyBvcHRpb25hbCBwcmUtcmVuZGVyIGxvb3AgaG9va1xyXG4gICAgICAgIHRoaXMucG9zdFVwZGF0ZSA9IG9wdGlvbnMucG9zdFVwZGF0ZTsgICAgICAgICAgIC8vIG9wdGlvbmFsIHBvc3QtcmVuZGVyIGxvb3AgaG9va1xyXG4gICAgICAgIHRoaXMucmVuZGVyX2xvb3AgPSAhb3B0aW9ucy5kaXNhYmxlUmVuZGVyTG9vcDsgIC8vIGRpc2FibGUgcmVuZGVyIGxvb3AgLSBhcHAgd2lsbCBoYXZlIHRvIG1hbnVhbGx5IGNhbGwgU2NlbmUucmVuZGVyKCkgcGVyIGZyYW1lXHJcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5yZXNldFRpbWUoKTtcclxuXHJcbiAgICAgICAgdGhpcy56b29tID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNlbnRlciA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucHJlc2VydmVfdGlsZXNfd2l0aGluX3pvb20gPSAyO1xyXG4gICAgICAgIHRoaXMucGFubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpZ2h0cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gTW9kZWwtdmlldyBtYXRyaWNlc1xyXG4gICAgICAgIC8vIDY0LWJpdCB2ZXJzaW9ucyBhcmUgZm9yIENQVSBjYWxjdWF0aW9uc1xyXG4gICAgICAgIC8vIDMyLWJpdCB2ZXJzaW9ucyBhcmUgZG93bnNhbXBsZWQgYW5kIHNlbnQgdG8gR1BVXHJcbiAgICAgICAgdGhpcy5tb2RlbE1hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xyXG4gICAgICAgIHRoaXMubW9kZWxNYXRyaXgzMiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG4gICAgICAgIHRoaXMubW9kZWxWaWV3TWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XHJcbiAgICAgICAgdGhpcy5tb2RlbFZpZXdNYXRyaXgzMiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG4gICAgICAgIHRoaXMubm9ybWFsTWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSg5KTtcclxuICAgICAgICB0aGlzLm5vcm1hbE1hdHJpeDMyID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcclxuXHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZV9saXN0ZW5lciA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIERlYnVnIGNvbmZpZ1xyXG4gICAgICAgIHRoaXMuZGVidWcgPSB7XHJcbiAgICAgICAgICAgIHByb2ZpbGU6IHtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5X2J1aWxkOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2dMZXZlbCA9IG9wdGlvbnMubG9nTGV2ZWwgfHwgJ2luZm8nO1xyXG4gICAgICAgIGxvZy5zZXRMZXZlbCh0aGlzLmxvZ0xldmVsKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXppbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBMb2FkIHNjZW5lIGRlZmluaXRpb24gKHNvdXJjZXMsIHN0eWxlcywgZXRjLiksIHRoZW4gY3JlYXRlIHN0eWxlcyAmIHdvcmtlcnNcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRTY2VuZSgpLnRoZW4oKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlV29ya2VycygpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlQ2FudmFzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgRmVhdHVyZVNlbGVjdGlvbih0aGlzLmdsLCB0aGlzLndvcmtlcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVfbGlzdGVuZXIgPSB7IHVwZGF0ZTogKCkgPT4gdGhpcy5kaXJ0eSA9IHRydWUgfTtcclxuICAgICAgICAgICAgICAgICAgICBUZXh0dXJlLnN1YnNjcmliZSh0aGlzLnRleHR1cmVfbGlzdGVuZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMb2FkcyByZW5kZXJpbmcgc3R5bGVzIGZyb20gY29uZmlnLCBzZXRzIEdMIGNvbnRleHQgYW5kIGNvbXBpbGVzIHByb2dyYW1zXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb25maWcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXppbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9sb29wICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwUmVuZGVyTG9vcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4geyB0aHJvdyBlOyB9KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB7IHJlamVjdChlKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJMb29wID0gKCkgPT4ge307IC8vIHNldCB0byBuby1vcCBiZWNhdXNlIGEgbnVsbCBjYW4gY2F1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIHRocm93XHJcblxyXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVBbGwoKTsgLy8gY2xlYXIgYWxsIGV2ZW50IGxpc3RlbmVyc1xyXG5cclxuICAgICAgICBUZXh0dXJlLnVuc3Vic2NyaWJlKHRoaXMudGV4dHVyZV9saXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlX2xpc3RlbmVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5nbCkge1xyXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZmJvKTtcclxuICAgICAgICAgICAgdGhpcy5mYm8gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgVGV4dHVyZS5kZXN0cm95KHRoaXMuZ2wpO1xyXG4gICAgICAgICAgICBTdHlsZU1hbmFnZXIuZGVzdHJveSh0aGlzLmdsKTtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy53b3JrZXJzKSkge1xyXG4gICAgICAgICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCgod29ya2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLndvcmtlcnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNvdXJjZXMgPSB7fTtcclxuICAgICAgICB0aGlzLnRpbGVzID0ge307IC8vIFRPRE86IHByb2JhYmx5IGRlc3Ryb3kgZWFjaCB0aWxlIHNlcGFyYXRlbHkgdG9vXHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQ2FudmFzKCkge1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5jb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSAwO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleCA9IC0xO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcclxuXHJcbiAgICAgICAgdGhpcy5nbCA9IENvbnRleHQuZ2V0Q29udGV4dCh0aGlzLmNhbnZhcywgeyBhbHBoYTogZmFsc2UgLypwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlKi8gfSk7XHJcbiAgICAgICAgdGhpcy5yZXNpemVNYXAodGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsIHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCk7XHJcbiAgICAgICAgVmVydGV4QXJyYXlPYmplY3QuaW5pdCh0aGlzLmdsKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVPYmplY3RVUkwoKSB7XHJcbiAgICAgICAgcmV0dXJuICh3aW5kb3cuVVJMICYmIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKSB8fCAod2luZG93LndlYmtpdFVSTCAmJiB3aW5kb3cud2Via2l0VVJMLmNyZWF0ZU9iamVjdFVSTCk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZFdvcmtlclVybChzY2VuZSkge1xyXG4gICAgICAgIHZhciB3b3JrZXJfdXJsID0gc2NlbmUud29ya2VyX3VybCB8fCBVdGlscy5maW5kQ3VycmVudFVSTCgndGFuZ3JhbS5kZWJ1Zy5qcycsICd0YW5ncmFtLm1pbi5qcycpLFxyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RVUkwgPSBzY2VuZS5jcmVhdGVPYmplY3RVUkwoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF3b3JrZXJfdXJsKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ2FuJ3QgbG9hZCB3b3JrZXIgYmVjYXVzZSBjb3VsZG4ndCBmaW5kIGJhc2UgVVJMIHRoYXQgbGlicmFyeSB3YXMgbG9hZGVkIGZyb21cIikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY3JlYXRlT2JqZWN0VVJMICYmIHNjZW5lLmFsbG93X2Nyb3NzX2RvbWFpbl93b3JrZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IGBpbXBvcnRTY3JpcHRzKCcke3dvcmtlcl91cmx9Jyk7YDtcclxuICAgICAgICAgICAgICAgIHZhciB3b3JrZXJfbG9jYWxfdXJsID0gY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtib2R5XSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSkpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh3b3JrZXJfbG9jYWxfdXJsKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUod29ya2VyX3VybCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXZWIgd29ya2VycyBoYW5kbGUgaGVhdnkgZHV0eSB0aWxlIGNvbnN0cnVjdGlvbjogbmV0d29ya2luZywgZ2VvbWV0cnkgcHJvY2Vzc2luZywgZXRjLlxyXG4gICAgY3JlYXRlV29ya2VycygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRXb3JrZXJVcmwodGhpcykudGhlbigod29ya2VyX3VybCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlV29ya2Vycyh3b3JrZXJfdXJsKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluc3RhbnRpYXRlIHdvcmtlcnMgZnJvbSBVUkwsIGluaXQgZXZlbnQgaGFuZGxlcnNcclxuICAgIG1ha2VXb3JrZXJzKHVybCkge1xyXG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLndvcmtlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpZD0wOyBpZCA8IHRoaXMubnVtX3dvcmtlcnM7IGlkKyspIHtcclxuICAgICAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIodXJsKTtcclxuICAgICAgICAgICAgdGhpcy53b3JrZXJzW2lkXSA9IHdvcmtlcjtcclxuXHJcbiAgICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy53b3JrZXJMb2dNZXNzYWdlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBXb3JrZXJCcm9rZXIuYWRkV29ya2VyKHdvcmtlcik7XHJcblxyXG4gICAgICAgICAgICBsb2cuZGVidWcoYFNjZW5lLm1ha2VXb3JrZXJzOiBpbml0aWFsaXppbmcgd29ya2VyICR7aWR9YCk7XHJcbiAgICAgICAgICAgIGxldCBfaWQgPSBpZDtcclxuICAgICAgICAgICAgcXVldWUucHVzaChXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2Uod29ya2VyLCAnaW5pdCcsIGlkLCB0aGlzLm51bV93b3JrZXJzLCBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW8pLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAoaWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoYFNjZW5lLm1ha2VXb3JrZXJzOiBpbml0aWFsaXplZCB3b3JrZXIgJHtpZH1gKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKGBTY2VuZS5tYWtlV29ya2VyczogZmFpbGVkIHRvIGluaXRpYWxpemUgd29ya2VyICR7X2lkfTpgLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm5leHRfd29ya2VyID0gMDtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9tYXBfd29ya2VyX3NpemUgPSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSb3VuZCByb2JpbiBzZWxlY3Rpb24gb2YgbmV4dCB3b3JrZXJcclxuICAgIG5leHRXb3JrZXIoKSB7XHJcbiAgICAgICAgdmFyIHdvcmtlciA9IHRoaXMud29ya2Vyc1t0aGlzLm5leHRfd29ya2VyXTtcclxuICAgICAgICB0aGlzLm5leHRfd29ya2VyID0gKHRoaXMubmV4dF93b3JrZXIgKyAxKSAlIHRoaXMud29ya2Vycy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgICBTZXQgdGhlIG1hcCB2aWV3LCBjYW4gYmUgcGFzc2VkIGFuIG9iamVjdCB3aXRoIGxhdC9sbmcgYW5kL29yIHpvb21cclxuICAgICovXHJcbiAgICBzZXRWaWV3KHsgbG5nLCBsYXQsIHpvb20gfSA9IHt9KSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gU2V0IGNlbnRlclxyXG4gICAgICAgIGlmIChsbmcgJiYgbGF0KSB7XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8ICF0aGlzLmNlbnRlciB8fCBsbmcgIT09IHRoaXMuY2VudGVyLmxuZyB8fCBsYXQgIT09IHRoaXMuY2VudGVyLmxhdDtcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB7IGxuZywgbGF0IH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgem9vbVxyXG4gICAgICAgIGlmICh6b29tKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IHpvb20gIT09IHRoaXMuem9vbTtcclxuICAgICAgICAgICAgdGhpcy5zZXRab29tKHpvb20pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRab29tKCkge1xyXG4gICAgICAgIHRoaXMubGFzdF96b29tID0gdGhpcy56b29tO1xyXG4gICAgICAgIHRoaXMuem9vbWluZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hvb3NlIHRoZSBiYXNlIHpvb20gbGV2ZWwgdG8gdXNlIGZvciBhIGdpdmVuIGZyYWN0aW9uYWwgem9vbVxyXG4gICAgYmFzZVpvb20oem9vbSkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHpvb20pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFpvb20oem9vbSkge1xyXG4gICAgICAgIHRoaXMuem9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5iYXNlWm9vbSh6b29tKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRpbnVvdXNfem9vbSkge1xyXG4gICAgICAgICAgICB6b29tID0gYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlICE9PSB0aGlzLmJhc2Vab29tKHRoaXMubGFzdF96b29tKSkge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGlsZXMgb3V0c2lkZSBhIGdpdmVuIHJhbmdlIGFib3ZlIGFuZCBiZWxvdyBjdXJyZW50IHpvb21cclxuICAgICAgICAgICAgdmFyIGJlbG93ID0gYmFzZTtcclxuICAgICAgICAgICAgdmFyIGFib3ZlID0gYmFzZTtcclxuXHJcbiAgICAgICAgICAgIGxvZy50cmFjZShgc2NlbmUubGFzdF96b29tOiAke3RoaXMubGFzdF96b29tfWApO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoem9vbSAtIHRoaXMubGFzdF96b29tKSA8PSB0aGlzLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tKSB7XHJcbiAgICAgICAgICAgICAgICBiZWxvdyAtPSB0aGlzLnByZXNlcnZlX3RpbGVzX3dpdGhpbl96b29tO1xyXG4gICAgICAgICAgICAgICAgYWJvdmUgKz0gdGhpcy5wcmVzZXJ2ZV90aWxlc193aXRoaW5fem9vbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbG9nLnRyYWNlKGByZW1vdmluZyB0aWxlcyBvdXRzaWRlIHJhbmdlIFske2JlbG93fSwgJHthYm92ZX1dYCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZXNPdXRzaWRlWm9vbVJhbmdlKGJlbG93LCBhYm92ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGlsZXMgb3V0c2lkZSBjdXJyZW50IHpvb20gdGhhdCBhcmUgc3RpbGwgbG9hZGluZ1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGVzKHRpbGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbGUubG9hZGluZyAmJiB0aGlzLmJhc2Vab29tKHRpbGUuY29vcmRzLnopICE9PSBiYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLnRyYWNlKGByZW1vdmVkICR7dGlsZS5rZXl9ICh3YXMgbG9hZGluZywgYnV0IG91dHNpZGUgY3VycmVudCB6b29tKWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubGFzdF96b29tID0gdGhpcy56b29tO1xyXG4gICAgICAgIHRoaXMuem9vbSA9IHpvb207XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZpZXdSZWFkeSgpIHtcclxuICAgICAgICBpZiAodGhpcy5jc3Nfc2l6ZSA9PSBudWxsIHx8IHRoaXMuY2VudGVyID09IG51bGwgfHwgdGhpcy56b29tID09IG51bGwgfHwgT2JqZWN0LmtleXModGhpcy5zb3VyY2VzKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHZpZXdwb3J0IGJvdW5kcyBiYXNlZCBvbiBjdXJyZW50IGNlbnRlciBhbmQgem9vbVxyXG4gICAgdXBkYXRlQm91bmRzKCkge1xyXG4gICAgICAgIC8vIFRPRE86IGJldHRlciBjb25jZXB0IG9mIFwicmVhZGluZXNzXCIgc3RhdGU/XHJcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdSZWFkeSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWV0ZXJzX3Blcl9waXhlbCA9IEdlby5tZXRlcnNQZXJQaXhlbCh0aGlzLnpvb20pO1xyXG5cclxuICAgICAgICAvLyBTaXplIG9mIHRoZSBoYWxmLXZpZXdwb3J0IGluIG1ldGVycyBhdCBjdXJyZW50IHpvb21cclxuICAgICAgICB0aGlzLnZpZXdwb3J0X21ldGVycyA9IHtcclxuICAgICAgICAgICAgeDogdGhpcy5jc3Nfc2l6ZS53aWR0aCAqIHRoaXMubWV0ZXJzX3Blcl9waXhlbCxcclxuICAgICAgICAgICAgeTogdGhpcy5jc3Nfc2l6ZS5oZWlnaHQgKiB0aGlzLm1ldGVyc19wZXJfcGl4ZWxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDZW50ZXIgb2Ygdmlld3BvcnQgaW4gbWV0ZXJzLCBhbmQgdGlsZVxyXG4gICAgICAgIGxldCBbeCwgeV0gPSBHZW8ubGF0TG5nVG9NZXRlcnMoW3RoaXMuY2VudGVyLmxuZywgdGhpcy5jZW50ZXIubGF0XSk7XHJcbiAgICAgICAgdGhpcy5jZW50ZXJfbWV0ZXJzID0geyB4LCB5IH07XHJcblxyXG4gICAgICAgIGxldCB6ID0gdGhpcy5iYXNlWm9vbSh0aGlzLnpvb20pO1xyXG4gICAgICAgIGxldCBtYXhfem9vbSA9IHRoaXMuZmluZE1heFpvb20oKTtcclxuICAgICAgICBpZiAoeiA+IG1heF96b29tKSB7XHJcbiAgICAgICAgICAgIHogPSBtYXhfem9vbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jZW50ZXJfdGlsZSA9IEdlby50aWxlRm9yTWV0ZXJzKFt0aGlzLmNlbnRlcl9tZXRlcnMueCwgdGhpcy5jZW50ZXJfbWV0ZXJzLnldLCB6KTtcclxuXHJcbiAgICAgICAgdGhpcy5ib3VuZHNfbWV0ZXJzID0ge1xyXG4gICAgICAgICAgICBzdzoge1xyXG4gICAgICAgICAgICAgICAgeDogdGhpcy5jZW50ZXJfbWV0ZXJzLnggLSB0aGlzLnZpZXdwb3J0X21ldGVycy54IC8gMixcclxuICAgICAgICAgICAgICAgIHk6IHRoaXMuY2VudGVyX21ldGVycy55IC0gdGhpcy52aWV3cG9ydF9tZXRlcnMueSAvIDJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbmU6IHtcclxuICAgICAgICAgICAgICAgIHg6IHRoaXMuY2VudGVyX21ldGVycy54ICsgdGhpcy52aWV3cG9ydF9tZXRlcnMueCAvIDIsXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmNlbnRlcl9tZXRlcnMueSArIHRoaXMudmlld3BvcnRfbWV0ZXJzLnkgLyAyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBGaW5kIHZpc2libGUgdGlsZXMgYW5kIGxvYWQgbmV3IG9uZXNcclxuICAgICAgICB0aGlzLnZpc2libGVfdGlsZXMgPSB0aGlzLmZpbmRWaXNpYmxlVGlsZXMoKTtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy52aXNpYmxlX3RpbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFRpbGUodGhpcy52aXNpYmxlX3RpbGVzW2tleV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRpbGUgdmlzaWJsZSBmbGFnc1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLnRpbGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZXNba2V5XS51cGRhdGUodGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdmUnKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmaW5kVmlzaWJsZVRpbGVzKHsgYnVmZmVyIH0gPSB7fSkge1xyXG4gICAgICAgIGxldCB6ID0gdGhpcy5iYXNlWm9vbSh0aGlzLnpvb20pO1xyXG4gICAgICAgIGxldCBtYXhfem9vbSA9IHRoaXMuZmluZE1heFpvb20oKTtcclxuICAgICAgICBpZiAoeiA+IG1heF96b29tKSB7XHJcbiAgICAgICAgICAgIHogPSBtYXhfem9vbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzdyA9IEdlby50aWxlRm9yTWV0ZXJzKFt0aGlzLmJvdW5kc19tZXRlcnMuc3cueCwgdGhpcy5ib3VuZHNfbWV0ZXJzLnN3LnldLCB6KTtcclxuICAgICAgICBsZXQgbmUgPSBHZW8udGlsZUZvck1ldGVycyhbdGhpcy5ib3VuZHNfbWV0ZXJzLm5lLngsIHRoaXMuYm91bmRzX21ldGVycy5uZS55XSwgeik7XHJcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyIHx8IDA7XHJcblxyXG4gICAgICAgIGxldCB0aWxlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IHggPSBzdy54IC0gYnVmZmVyOyB4IDw9IG5lLnggKyBidWZmZXI7IHgrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gbmUueSAtIGJ1ZmZlcjsgeSA8PSBzdy55ICsgYnVmZmVyOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb29yZHMgPSB7IHgsIHksIHogfTtcclxuICAgICAgICAgICAgICAgIHRpbGVzW1RpbGUua2V5KGNvb3JkcyldID0gY29vcmRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aWxlcztcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVUaWxlc091dHNpZGVab29tUmFuZ2UoYmVsb3csIGFib3ZlKSB7XHJcbiAgICAgICAgYmVsb3cgPSBNYXRoLm1pbihiZWxvdywgdGhpcy5maW5kTWF4Wm9vbSgpIHx8IGJlbG93KTtcclxuICAgICAgICBhYm92ZSA9IE1hdGgubWluKGFib3ZlLCB0aGlzLmZpbmRNYXhab29tKCkgfHwgYWJvdmUpO1xyXG5cclxuICAgICAgICB0aGlzLnJlbW92ZVRpbGVzKHRpbGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGlsZS5jb29yZHMueiA8IGJlbG93IHx8IHRpbGUuY29vcmRzLnogPiBhYm92ZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nLnRyYWNlKGByZW1vdmVkICR7dGlsZS5rZXl9IChvdXRzaWRlIHJhbmdlIFske2JlbG93fSwgJHthYm92ZX1dKWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW1vdmVUaWxlcyhmaWx0ZXIpIHtcclxuICAgICAgICBsZXQgcmVtb3ZlX3RpbGVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgdCBpbiB0aGlzLnRpbGVzKSB7XHJcbiAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy50aWxlc1t0XTtcclxuICAgICAgICAgICAgaWYgKGZpbHRlcih0aWxlKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlX3RpbGVzLnB1c2godCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgcj0wOyByIDwgcmVtb3ZlX3RpbGVzLmxlbmd0aDsgcisrKSB7XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSByZW1vdmVfdGlsZXNbcl07XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXNpemVNYXAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNzc19zaXplID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcbiAgICAgICAgdGhpcy5kZXZpY2Vfc2l6ZSA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQodGhpcy5jc3Nfc2l6ZS53aWR0aCAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyksXHJcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZCh0aGlzLmNzc19zaXplLmhlaWdodCAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbylcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudmlld19hc3BlY3QgPSB0aGlzLmNzc19zaXplLndpZHRoIC8gdGhpcy5jc3Nfc2l6ZS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gdGhpcy5jc3Nfc2l6ZS53aWR0aCArICdweCc7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IHRoaXMuY3NzX3NpemUuaGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmRldmljZV9zaXplLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmRldmljZV9zaXplLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXF1ZXN0IHNjZW5lIGJlIHJlZHJhd24gYXQgbmV4dCBhbmltYXRpb24gbG9vcFxyXG4gICAgcmVxdWVzdFJlZHJhdygpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWRyYXcgc2NlbmUgaW1tZWRpYXRlbHkgLSBkb24ndCB3YWl0IGZvciBhbmltYXRpb24gbG9vcFxyXG4gICAgLy8gVXNlIHNwYXJpbmdseSwgYnV0IGZvciBjYXNlcyB3aGVyZSB5b3UgbmVlZCB0aGUgY2xvc2VzdCBwb3NzaWJsZSBzeW5jIHdpdGggb3RoZXIgVUkgZWxlbWVudHMsXHJcbiAgICAvLyBzdWNoIGFzIG90aGVyLCBub24tV2ViR0wgbWFwIGxheWVycyAoZS5nLiBMZWFmbGV0IHJhc3RlciBsYXllcnMsIG1hcmtlcnMsIGV0Yy4pXHJcbiAgICBpbW1lZGlhdGVSZWRyYXcoKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXR1cCB0aGUgcmVuZGVyIGxvb3BcclxuICAgIHNldHVwUmVuZGVyTG9vcCh7IHByZV9yZW5kZXIsIHBvc3RfcmVuZGVyIH0gPSB7fSkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyTG9vcCA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgc2NlbmVcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgdGhlIG5leHQgZnJhbWVcclxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlckxvb3ApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMucmVuZGVyTG9vcCgpOyB9LCAwKTsgLy8gZGVsYXkgc3RhcnQgYnkgb25lIHRpY2tcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkUXVldWVkVGlsZXMoKTtcclxuXHJcbiAgICAgICAgLy8gUmVuZGVyIG9uIGRlbWFuZFxyXG4gICAgICAgIHZhciB3aWxsX3JlbmRlciA9ICEodGhpcy5kaXJ0eSA9PT0gZmFsc2UgfHwgdGhpcy5pbml0aWFsaXplZCA9PT0gZmFsc2UgfHwgdGhpcy52aWV3UmVhZHkoKSA9PT0gZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBQcmUtcmVuZGVyIGxvb3AgaG9va1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVVcGRhdGUod2lsbF9yZW5kZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQmFpbCBpZiBubyBuZWVkIHRvIHJlbmRlclxyXG4gICAgICAgIGlmICghd2lsbF9yZW5kZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7IC8vIHN1YmNsYXNzZXMgY2FuIHNldCB0aGlzIGJhY2sgdG8gdHJ1ZSB3aGVuIGFuaW1hdGlvbiBpcyBuZWVkZWRcclxuXHJcbiAgICAgICAgLy8gUmVuZGVyIHRoZSBzY2VuZVxyXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XHJcblxyXG4gICAgICAgIC8vIFBvc3QtcmVuZGVyIGxvb3AgaG9va1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wb3N0VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zdFVwZGF0ZSh3aWxsX3JlbmRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWRyYXcgZXZlcnkgZnJhbWUgaWYgYW5pbWF0aW5nXHJcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0ZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZyYW1lKys7XHJcbiAgICAgICAgbG9nLnRyYWNlKCdTY2VuZS5yZW5kZXIoKScpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgICAvLyBNYXAgdHJhbnNmb3Jtc1xyXG4gICAgICAgIGlmICghdGhpcy5jZW50ZXJfbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMsIGNhbWVyYSwgbGlnaHRzXHJcbiAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlKCk7XHJcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5mb3JFYWNoKGkgPT4gdGhpcy5zdHlsZXNbaV0udXBkYXRlKCkpO1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMubGlnaHRzKS5mb3JFYWNoKGkgPT4gdGhpcy5saWdodHNbaV0udXBkYXRlKCkpO1xyXG5cclxuICAgICAgICAvLyBSZW5kZXJhYmxlIHRpbGUgbGlzdFxyXG4gICAgICAgIHRoaXMucmVuZGVyYWJsZV90aWxlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy50aWxlcykge1xyXG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMudGlsZXNbdF07XHJcbiAgICAgICAgICAgIGlmICh0aWxlLnZpc2libGUgJiYgdGlsZS5sb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyYWJsZV90aWxlcy5wdXNoKHRpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVuZGVyYWJsZV90aWxlc19jb3VudCA9IHRoaXMucmVuZGVyYWJsZV90aWxlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbmRlciBtYWluIHBhc3NcclxuICAgICAgICB0aGlzLnJlbmRlcl9jb3VudCA9IHRoaXMucmVuZGVyUGFzcygpO1xyXG5cclxuICAgICAgICAvLyBSZW5kZXIgc2VsZWN0aW9uIHBhc3MgKGlmIG5lZWRlZClcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24ucGVuZGluZ1JlcXVlc3RzKCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFubmluZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5iaW5kKCk7ICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIHRvIEZCT1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclBhc3MoXHJcbiAgICAgICAgICAgICAgICAnc2VsZWN0aW9uX3Byb2dyYW0nLCAgICAgICAgICAgICAgICAvLyByZW5kZXIgdy9hbHRlcm5hdGUgcHJvZ3JhbVxyXG4gICAgICAgICAgICAgICAgeyBhbGxvd19hbHBoYV9ibGVuZDogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlYWQoKTsgICAgICAgICAgICAgICAgICAvLyByZWFkIHJlc3VsdHMgZnJvbSBzZWxlY3Rpb24gYnVmZmVyXHJcblxyXG4gICAgICAgICAgICAvLyBSZXNldCB0byBzY3JlZW4gYnVmZmVyXHJcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyX2NvdW50ICE9PSB0aGlzLmxhc3RfcmVuZGVyX2NvdW50KSB7XHJcbiAgICAgICAgICAgIGxvZy5pbmZvKGBTY2VuZTogcmVuZGVyZWQgJHt0aGlzLnJlbmRlcl9jb3VudH0gcHJpbWl0aXZlc2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhc3RfcmVuZGVyX2NvdW50ID0gdGhpcy5yZW5kZXJfY291bnQ7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbmRlciBhbGwgYWN0aXZlIHN0eWxlcywgZ3JvdXBlZCBieSBibGVuZC9kZXB0aCB0eXBlIChvcGFxdWUsIG92ZXJsYXksIGV0Yy4pIGFuZCBieSBwcm9ncmFtIChzdHlsZSlcclxuICAgIC8vIENhbGxlZCBib3RoIGZvciBtYWluIHJlbmRlciBwYXNzLCBhbmQgZm9yIHNlY29uZGFyeSBwYXNzZXMgbGlrZSBzZWxlY3Rpb24gYnVmZmVyXHJcbiAgICByZW5kZXJQYXNzKHByb2dyYW1fa2V5ID0gJ3Byb2dyYW0nLCB7IGFsbG93X2FscGhhX2JsZW5kIH0gPSB7fSkge1xyXG4gICAgICAgIGxldCBzdHlsZXM7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDsgLy8gaG93IG1hbnkgcHJpbWl0aXZlcyB3ZXJlIHJlbmRlcmVkXHJcblxyXG4gICAgICAgIC8vIG9wdGlvbmFsbHkgZm9yY2UgYWxwaGEgb2ZmIChlLmcuIGZvciBzZWxlY3Rpb24gcGFzcylcclxuICAgICAgICBhbGxvd19hbHBoYV9ibGVuZCA9IChhbGxvd19hbHBoYV9ibGVuZCA9PSBudWxsKSA/IHRydWUgOiBhbGxvd19hbHBoYV9ibGVuZDtcclxuXHJcbiAgICAgICAgdGhpcy5jbGVhckZyYW1lKHsgY2xlYXJfY29sb3I6IHRydWUsIGNsZWFyX2RlcHRoOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICAvLyBPcGFxdWUgc3R5bGVzOiBkZXB0aCB0ZXN0IG9uLCBkZXB0aCB3cml0ZSBvbiwgYmxlbmRpbmcgb2ZmXHJcbiAgICAgICAgc3R5bGVzID0gT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5maWx0ZXIocyA9PiB0aGlzLnN0eWxlc1tzXS5ibGVuZCA9PT0gJ29wYXF1ZScpO1xyXG4gICAgICAgIHRoaXMuc2V0UmVuZGVyU3RhdGUoeyBkZXB0aF90ZXN0OiB0cnVlLCBkZXB0aF93cml0ZTogdHJ1ZSwgYWxwaGFfYmxlbmQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIGNvdW50ICs9IHRoaXMucmVuZGVyU3R5bGVzKHN0eWxlcywgcHJvZ3JhbV9rZXkpO1xyXG5cclxuICAgICAgICAvLyBUcmFuc3BhcmVudCBzdHlsZXM6IGRlcHRoIHRlc3Qgb2ZmLCBkZXB0aCB3cml0ZSBvbiwgY3VzdG9tIGJsZW5kaW5nXHJcbiAgICAgICAgc3R5bGVzID0gT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5maWx0ZXIocyA9PiB0aGlzLnN0eWxlc1tzXS5ibGVuZCA9PT0gJ2FkZCcpO1xyXG4gICAgICAgIHRoaXMuc2V0UmVuZGVyU3RhdGUoeyBkZXB0aF90ZXN0OiB0cnVlLCBkZXB0aF93cml0ZTogZmFsc2UsIGFscGhhX2JsZW5kOiAoYWxsb3dfYWxwaGFfYmxlbmQgJiYgJ2FkZCcpIH0pO1xyXG4gICAgICAgIGNvdW50ICs9IHRoaXMucmVuZGVyU3R5bGVzKHN0eWxlcywgcHJvZ3JhbV9rZXkpO1xyXG5cclxuICAgICAgICBzdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMpLmZpbHRlcihzID0+IHRoaXMuc3R5bGVzW3NdLmJsZW5kID09PSAnbXVsdGlwbHknKTtcclxuICAgICAgICB0aGlzLnNldFJlbmRlclN0YXRlKHsgZGVwdGhfdGVzdDogdHJ1ZSwgZGVwdGhfd3JpdGU6IGZhbHNlLCBhbHBoYV9ibGVuZDogKGFsbG93X2FscGhhX2JsZW5kICYmICdtdWx0aXBseScpIH0pO1xyXG4gICAgICAgIGNvdW50ICs9IHRoaXMucmVuZGVyU3R5bGVzKHN0eWxlcywgcHJvZ3JhbV9rZXkpO1xyXG5cclxuICAgICAgICAvLyBPdmVybGF5IHN0eWxlczogZGVwdGggdGVzdCBvZmYsIGRlcHRoIHdyaXRlIG9mZiwgYmxlbmRpbmcgb25cclxuICAgICAgICBzdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLnN0eWxlcykuZmlsdGVyKHMgPT4gdGhpcy5zdHlsZXNbc10uYmxlbmQgPT09ICdvdmVybGF5Jyk7XHJcbiAgICAgICAgdGhpcy5zZXRSZW5kZXJTdGF0ZSh7IGRlcHRoX3Rlc3Q6IGZhbHNlLCBkZXB0aF93cml0ZTogZmFsc2UsIGFscGhhX2JsZW5kOiBhbGxvd19hbHBoYV9ibGVuZCB9KTtcclxuICAgICAgICBjb3VudCArPSB0aGlzLnJlbmRlclN0eWxlcyhzdHlsZXMsIHByb2dyYW1fa2V5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlclN0eWxlcyhzdHlsZXMsIHByb2dyYW1fa2V5KSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBzdHlsZSBvZiBzdHlsZXMpIHtcclxuICAgICAgICAgICAgbGV0IHByb2dyYW0gPSB0aGlzLnN0eWxlc1tzdHlsZV1bcHJvZ3JhbV9rZXldO1xyXG4gICAgICAgICAgICBpZiAoIXByb2dyYW0gfHwgIXByb2dyYW0uY29tcGlsZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvdW50ICs9IHRoaXMucmVuZGVyU3R5bGUoc3R5bGUsIHByb2dyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyU3R5bGUoc3R5bGUsIHByb2dyYW0pIHtcclxuICAgICAgICB2YXIgZmlyc3RfZm9yX3N0eWxlID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcmVuZGVyX2NvdW50ID0gMDtcclxuXHJcbiAgICAgICAgLy8gUmVuZGVyIHRpbGUgR0wgZ2VvbWV0cmllc1xyXG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5yZW5kZXJhYmxlX3RpbGVzKSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5yZW5kZXJhYmxlX3RpbGVzW3RdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRpbGUubWVzaGVzW3N0eWxlXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXR1cCBzdHlsZSBpZiBlbmNvdW50ZXJpbmcgZm9yIGZpcnN0IHRpbWUgdGhpcyBmcmFtZVxyXG4gICAgICAgICAgICAgICAgLy8gKGxhenkgaW5pdCwgbm90IGFsbCBzdHlsZXMgd2lsbCBiZSB1c2VkIGluIGFsbCBzY3JlZW4gdmlld3M7IHNvbWUgc3R5bGVzIG1pZ2h0IGJlIGRlZmluZWQgYnV0IG5ldmVyIHVzZWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RfZm9yX3N0eWxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfZm9yX3N0eWxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0udXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbc3R5bGVdLnNldHVwKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRvbid0IHNldCB1bmlmb3JtcyB3aGVuIHRoZXkgaGF2ZW4ndCBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcyZicsICd1X3Jlc29sdXRpb24nLCB0aGlzLmRldmljZV9zaXplLndpZHRoLCB0aGlzLmRldmljZV9zaXplLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X3RpbWUnLCAoKCtuZXcgRGF0ZSgpKSAtIHRoaXMuc3RhcnRfdGltZSkgLyAxMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzNmJywgJ3VfbWFwX3Bvc2l0aW9uJywgdGhpcy5jZW50ZXJfbWV0ZXJzLngsIHRoaXMuY2VudGVyX21ldGVycy55LCB0aGlzLnpvb20pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IodGhpcy56b29tKSArIChNYXRoLmxvZygodGhpcy56b29tICUgMSkgKyAxKSAvIE1hdGguTE4yIC8vIHNjYWxlIGZyYWN0aW9uYWwgem9vbSBieSBsb2dcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJzFmJywgJ3VfbWV0ZXJzX3Blcl9waXhlbCcsIHRoaXMubWV0ZXJzX3Blcl9waXhlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCcxZicsICd1X2RldmljZV9waXhlbF9yYXRpbycsIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhLnNldHVwUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMubGlnaHRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlnaHRzW2ldLnNldHVwUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY2FsYyB0aGVzZSBvbmNlIHBlciB0aWxlIChjdXJyZW50bHkgYmVpbmcgbmVlZGxlc3NseSByZS1jYWxjdWxhdGVkIHBlci10aWxlLXBlci1zdHlsZSlcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaWxlIG9yaWdpblxyXG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCczZicsICd1X3RpbGVfb3JpZ2luJywgdGlsZS5taW4ueCwgdGlsZS5taW4ueSwgdGlsZS5jb29yZHMueik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTW9kZWwgbWF0cml4IC0gdHJhbnNmb3JtIHRpbGUgc3BhY2UgaW50byB3b3JsZCBzcGFjZSAobWV0ZXJzLCBhYnNvbHV0ZSBtZXJjYXRvciBwb3NpdGlvbilcclxuICAgICAgICAgICAgICAgIG1hdDQuaWRlbnRpdHkodGhpcy5tb2RlbE1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICBtYXQ0LnRyYW5zbGF0ZSh0aGlzLm1vZGVsTWF0cml4LCB0aGlzLm1vZGVsTWF0cml4LCB2ZWMzLmZyb21WYWx1ZXModGlsZS5taW4ueCwgdGlsZS5taW4ueSwgMCkpO1xyXG4gICAgICAgICAgICAgICAgbWF0NC5zY2FsZSh0aGlzLm1vZGVsTWF0cml4LCB0aGlzLm1vZGVsTWF0cml4LCB2ZWMzLmZyb21WYWx1ZXModGlsZS5zcGFuLnggLyBTY2VuZS50aWxlX3NjYWxlLCAtMSAqIHRpbGUuc3Bhbi55IC8gU2NlbmUudGlsZV9zY2FsZSwgMSkpOyAvLyBzY2FsZSB0aWxlIGxvY2FsIGNvb3JkcyB0byBtZXRlcnNcclxuICAgICAgICAgICAgICAgIG1hdDQuY29weSh0aGlzLm1vZGVsTWF0cml4MzIsIHRoaXMubW9kZWxNYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXg0ZnYnLCAndV9tb2RlbCcsIGZhbHNlLCB0aGlzLm1vZGVsTWF0cml4MzIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1vZGVsIHZpZXcgbWF0cml4IC0gdHJhbnNmb3JtIHRpbGUgc3BhY2UgaW50byB2aWV3IHNwYWNlIChtZXRlcnMsIHJlbGF0aXZlIHRvIGNhbWVyYSlcclxuICAgICAgICAgICAgICAgIG1hdDQubXVsdGlwbHkodGhpcy5tb2RlbFZpZXdNYXRyaXgzMiwgdGhpcy5jYW1lcmEudmlld01hdHJpeCwgdGhpcy5tb2RlbE1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm0oJ01hdHJpeDRmdicsICd1X21vZGVsVmlldycsIGZhbHNlLCB0aGlzLm1vZGVsVmlld01hdHJpeDMyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgbWF0cml4IC0gdHJhbnNmb3JtcyBzdXJmYWNlIG5vcm1hbHMgaW50byB2aWV3IHNwYWNlXHJcbiAgICAgICAgICAgICAgICBtYXQzLm5vcm1hbEZyb21NYXQ0KHRoaXMubm9ybWFsTWF0cml4MzIsIHRoaXMubW9kZWxWaWV3TWF0cml4MzIpO1xyXG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtKCdNYXRyaXgzZnYnLCAndV9ub3JtYWxNYXRyaXgnLCBmYWxzZSwgdGhpcy5ub3JtYWxNYXRyaXgzMik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIHRpbGVcclxuICAgICAgICAgICAgICAgIHRpbGUubWVzaGVzW3N0eWxlXS5yZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIHJlbmRlcl9jb3VudCArPSB0aWxlLm1lc2hlc1tzdHlsZV0uZ2VvbWV0cnlfY291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZW5kZXJfY291bnQ7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJGcmFtZSh7IGNsZWFyX2NvbG9yLCBjbGVhcl9kZXB0aCB9ID0ge30pIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVmYXVsdHNcclxuICAgICAgICBjbGVhcl9jb2xvciA9IChjbGVhcl9jb2xvciA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRydWVcclxuICAgICAgICBjbGVhcl9kZXB0aCA9IChjbGVhcl9kZXB0aCA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlOyAvLyBkZWZhdWx0IHRydWVcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgZnJhbWUgc3RhdGVcclxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgICBpZiAoY2xlYXJfY29sb3IpIHtcclxuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvciguLi50aGlzLmJhY2tncm91bmQuY29sb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNsZWFyX2RlcHRoKSB7XHJcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayh0cnVlKTsgLy8gYWx3YXlzIGNsZWFyIGRlcHRoIGlmIHJlcXVlc3RlZCwgZXZlbiBpZiBkZXB0aCB3cml0ZSB3aWxsIGJlIHR1cm5lZCBvZmZcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjbGVhcl9jb2xvciB8fCBjbGVhcl9kZXB0aCkge1xyXG4gICAgICAgICAgICBsZXQgbWFzayA9IChjbGVhcl9jb2xvciAmJiBnbC5DT0xPUl9CVUZGRVJfQklUKSB8IChjbGVhcl9kZXB0aCAmJiBnbC5ERVBUSF9CVUZGRVJfQklUKTtcclxuICAgICAgICAgICAgZ2wuY2xlYXIobWFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldFJlbmRlclN0YXRlKHsgZGVwdGhfdGVzdCwgZGVwdGhfd3JpdGUsIGN1bGxfZmFjZSwgYWxwaGFfYmxlbmQgfSA9IHt9KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHRzXHJcbiAgICAgICAgLy8gVE9ETzogd2hlbiB3ZSBhYnN0cmFjdCBvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgcmVuZGVyIHBhc3NlcywgdGhlc2UgY2FuIGJlIHBlci1wYXNzIGNvbmZpZyBvcHRpb25zXHJcbiAgICAgICAgZGVwdGhfdGVzdCA9IChkZXB0aF90ZXN0ID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7ICAgICAgICAgLy8gZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgZGVwdGhfd3JpdGUgPSAoZGVwdGhfd3JpdGUgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZTsgICAgICAgLy8gZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgY3VsbF9mYWNlID0gKGN1bGxfZmFjZSA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlOyAgICAgICAgICAgLy8gZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgYWxwaGFfYmxlbmQgPSAoYWxwaGFfYmxlbmQgIT0gbnVsbCkgPyBhbHBoYV9ibGVuZCA6IGZhbHNlOyAgLy8gZGVmYXVsdCBmYWxzZVxyXG5cclxuICAgICAgICAvLyBSZXNldCBmcmFtZSBzdGF0ZVxyXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XHJcblxyXG4gICAgICAgIGlmIChkZXB0aF90ZXN0KSB7XHJcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKGdsLkxFUVVBTCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2wuZGVwdGhNYXNrKGRlcHRoX3dyaXRlKTtcclxuXHJcbiAgICAgICAgaWYgKGN1bGxfZmFjZSkge1xyXG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcclxuICAgICAgICAgICAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWxwaGFfYmxlbmQpIHtcclxuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRyYWRpdGlvbmFsIGJsZW5kaW5nXHJcbiAgICAgICAgICAgIGlmIChhbHBoYV9ibGVuZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRkaXRpdmUgYmxlbmRpbmdcclxuICAgICAgICAgICAgZWxzZSBpZiAoYWxwaGFfYmxlbmQgPT09ICdhZGQnKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE11bHRpcGxpY2F0aXZlIGJsZW5kaW5nXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFscGhhX2JsZW5kID09PSAnbXVsdGlwbHknKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuWkVSTywgZ2wuU1JDX0NPTE9SKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcXVlc3QgZmVhdHVyZSBzZWxlY3Rpb24gYXQgZ2l2ZW4gcGl4ZWwuIFJ1bnMgYXN5bmMgYW5kIHJldHVybnMgcmVzdWx0cyB2aWEgYSBwcm9taXNlLlxyXG4gICAgZ2V0RmVhdHVyZUF0KHBpeGVsKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTY2VuZS5nZXRGZWF0dXJlQXQoKSBjYWxsZWQgYmVmb3JlIHNjZW5lIHdhcyBpbml0aWFsaXplZFwiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQb2ludCBzY2FsZWQgdG8gWzAuLjFdIHJhbmdlXHJcbiAgICAgICAgdmFyIHBvaW50ID0ge1xyXG4gICAgICAgICAgICB4OiBwaXhlbC54ICogVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvIC8gdGhpcy5kZXZpY2Vfc2l6ZS53aWR0aCxcclxuICAgICAgICAgICAgeTogcGl4ZWwueSAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyAvIHRoaXMuZGV2aWNlX3NpemUuaGVpZ2h0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7IC8vIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBzY2VuZSByZS1yZW5kZXJzIGZvciB0aGVzZSB0byBiZSBwcm9jZXNzZWRcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uZ2V0RmVhdHVyZUF0KHBvaW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBRdWV1ZSBhIHRpbGUgZm9yIGxvYWRcclxuICAgIGxvYWRUaWxlKGNvb3Jkcykge1xyXG4gICAgICAgIHRoaXMucXVldWVkX3RpbGVzW3RoaXMucXVldWVkX3RpbGVzLmxlbmd0aF0gPSBjb29yZHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9hZCBhbGwgcXVldWVkIHRpbGVzXHJcbiAgICBsb2FkUXVldWVkVGlsZXMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZF90aWxlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU29ydCBxdWV1ZWQgdGlsZXMgZnJvbSBjZW50ZXIgdGlsZVxyXG4gICAgICAgIHRoaXMucXVldWVkX3RpbGVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgbGV0IGFkID0gTWF0aC5hYnModGhpcy5jZW50ZXJfdGlsZS54IC0gYS54KSArIE1hdGguYWJzKHRoaXMuY2VudGVyX3RpbGUueSAtIGEueSk7XHJcbiAgICAgICAgICAgIGxldCBiZCA9IE1hdGguYWJzKHRoaXMuY2VudGVyX3RpbGUueCAtIGIueCkgKyBNYXRoLmFicyh0aGlzLmNlbnRlcl90aWxlLnkgLSBiLnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGJkID4gYWQgPyAtMSA6IChiZCA9PT0gYWQgPyAwIDogMSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucXVldWVkX3RpbGVzLmZvckVhY2goY29vcmRzID0+IHRoaXMuX2xvYWRUaWxlKGNvb3JkcykpO1xyXG4gICAgICAgIHRoaXMucXVldWVkX3RpbGVzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9hZCBhIHNpbmdsZSB0aWxlXHJcbiAgICBfbG9hZFRpbGUoY29vcmRzKSB7XHJcbiAgICAgICAgLy8gU2tpcCBpZiBub3QgYXQgY3VycmVudCBzY2VuZSB6b29tXHJcbiAgICAgICAgaWYgKGNvb3Jkcy56ICE9PSB0aGlzLmNlbnRlcl90aWxlLnopIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGtleSA9IFRpbGUua2V5KGNvb3Jkcyk7XHJcbiAgICAgICAgbGV0IHRpbGU7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc1RpbGUoa2V5KSkge1xyXG4gICAgICAgICAgICB0aWxlID0gVGlsZS5jcmVhdGUoe1xyXG4gICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHMsXHJcbiAgICAgICAgICAgICAgICBtYXhfem9vbTogdGhpcy5maW5kTWF4Wm9vbSgpLFxyXG4gICAgICAgICAgICAgICAgd29ya2VyOiB0aGlzLm5leHRXb3JrZXIoKVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVUaWxlKHRpbGUpO1xyXG4gICAgICAgICAgICB0aWxlLmxvYWQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aWxlID0gdGhpcy50aWxlc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGlsZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aWxlIG1hbmFnZXJcclxuICAgIGNhY2hlVGlsZSh0aWxlKSB7XHJcbiAgICAgICAgdGhpcy50aWxlc1t0aWxlLmtleV0gPSB0aWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGhhc1RpbGUoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZXNba2V5XSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcmdldFRpbGUoa2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMudGlsZXNba2V5XTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYnVpbGRpbmcgJiYgdGhpcy5idWlsZGluZy50aWxlcykge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5idWlsZGluZy50aWxlc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmaW5kTWF4Wm9vbSgpIHtcclxuICAgICAgICB2YXIgbWF4X3pvb20gPSB0aGlzLm1heF96b29tIHx8IEdlby5tYXhfem9vbTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnNvdXJjZXMpIHtcclxuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuc291cmNlc1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5tYXhfem9vbSA8IG1heF96b29tKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhfem9vbSA9IHNvdXJjZS5tYXhfem9vbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4X3pvb207XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogZGV0ZWN0IHdoaWNoIGVsZW1lbnRzIG5lZWQgdG8gYmUgcmVmcmVzaGVkL3JlYnVpbHQgKHN0eWxlc2hlZXQgY2hhbmdlcywgZXRjLilcclxuICAgIHJlYnVpbGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVidWlsZEdlb21ldHJ5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVidWlsZCBhbGwgdGlsZXNcclxuICAgIHJlYnVpbGRHZW9tZXRyeSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignU2NlbmUucmVidWlsZEdlb21ldHJ5OiBzY2VuZSBpcyBub3QgaW5pdGlhbGl6ZWQnKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBTa2lwIHJlYnVpbGQgaWYgYWxyZWFkeSBpbiBwcm9ncmVzc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5idWlsZGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gUXVldWUgdXAgdG8gb25lIHJlYnVpbGQgY2FsbCBhdCBhIHRpbWUsIG9ubHkgc2F2ZSBsYXN0IHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1aWxkaW5nLnF1ZXVlZCAmJiB0aGlzLmJ1aWxkaW5nLnF1ZXVlZC5yZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3RpZnkgcHJldmlvdXMgcmVxdWVzdCB0aGF0IGl0IGRpZCBub3QgY29tcGxldGVcclxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ1NjZW5lLnJlYnVpbGRHZW9tZXRyeTogcmVxdWVzdCBzdXBlcmNlZGVkIGJ5IGEgbmV3ZXIgY2FsbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucXVldWVkLnJlc29sdmUoZmFsc2UpOyAvLyBmYWxzZSBmbGFnIGluZGljYXRlcyByZWJ1aWxkIHJlcXVlc3Qgd2FzIHN1cGVyY2VkZWRcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHF1ZXVlZCByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkaW5nLnF1ZXVlZCA9IHsgcmVzb2x2ZSwgcmVqZWN0IH07XHJcbiAgICAgICAgICAgICAgICBsb2cudHJhY2UoYFNjZW5lLnJlYnVpbGRHZW9tZXRyeSgpOiBxdWV1aW5nIHJlcXVlc3RgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVHJhY2sgdGlsZSBidWlsZCBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5nID0geyByZXNvbHZlLCByZWplY3QsIHRpbGVzOiB7fSB9O1xyXG5cclxuICAgICAgICAgICAgLy8gUHJvZmlsaW5nXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnLnByb2ZpbGUuZ2VvbWV0cnlfYnVpbGQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGUoJ3JlYnVpbGRHZW9tZXRyeScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgY29uZmlnIChpbiBjYXNlIEpTIG9iamVjdHMgd2VyZSBtYW5pcHVsYXRlZCBkaXJlY3RseSlcclxuICAgICAgICAgICAgdGhpcy5zeW5jQ29uZmlnVG9Xb3JrZXIoKTtcclxuICAgICAgICAgICAgU3R5bGVNYW5hZ2VyLmNvbXBpbGUodGhpcy51cGRhdGVBY3RpdmVTdHlsZXMoKSk7IC8vIG9ubHkgcmVjb21waWxlIG5ld2x5IGFjdGl2ZSBzdHlsZXNcclxuICAgICAgICAgICAgdGhpcy5yZXNldEZlYXR1cmVTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNldFRpbWUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlYnVpbGQgdmlzaWJsZSB0aWxlcywgc29ydGVkIGZyb20gY2VudGVyXHJcbiAgICAgICAgICAgIGxldCBidWlsZCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0aWxlIG9mIFV0aWxzLnZhbHVlcyh0aGlzLnRpbGVzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbGUudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkLnB1c2godGlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGUodGlsZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFRpbGUuc29ydChidWlsZCkuZm9yRWFjaCh0aWxlID0+IHRpbGUuYnVpbGQodGhpcykpO1xyXG5cclxuICAgICAgICAgICAgLy8gRWRnZSBjYXNlOiBpZiBub3RoaW5nIGlzIGJlaW5nIHJlYnVpbHQsIGltbWVkaWF0ZWx5IHJlc29sdmUgcHJvbWlzZSBhbmQgZG9uJ3QgbG9jayBmdXJ0aGVyIHJlYnVpbGRzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWxkaW5nICYmIE9iamVjdC5rZXlzKHRoaXMuYnVpbGRpbmcudGlsZXMpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQW5vdGhlciByZWJ1aWxkIHF1ZXVlZD9cclxuICAgICAgICAgICAgICAgIHZhciBxdWV1ZWQgPSB0aGlzLmJ1aWxkaW5nLnF1ZXVlZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhgU2NlbmU6IHN0YXJ0aW5nIHF1ZXVlZCByZWJ1aWxkR2VvbWV0cnkoKSByZXF1ZXN0YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWJ1aWxkR2VvbWV0cnkoKS50aGVuKHF1ZXVlZC5yZXNvbHZlLCBxdWV1ZWQucmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBQcm9maWxpbmdcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcucHJvZmlsZS5nZW9tZXRyeV9idWlsZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZmlsZUVuZCgncmVidWlsZEdlb21ldHJ5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBtb3ZlIHRvIFRpbGUgY2xhc3NcclxuICAgIC8vIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIGEgd2ViIHdvcmtlciBjb21wbGV0ZXMgcHJvY2Vzc2luZyBmb3IgYSBzaW5nbGUgdGlsZSAoaW5pdGlhbCBsb2FkLCBvciByZWJ1aWxkKVxyXG4gICAgYnVpbGRUaWxlQ29tcGxldGVkKHsgdGlsZSwgd29ya2VyX2lkLCBzZWxlY3Rpb25fbWFwX3NpemUgfSkge1xyXG4gICAgICAgIC8vIFRyYWNrIHNlbGVjdGlvbiBtYXAgc2l6ZSAoZm9yIHN0YXRzL2RlYnVnKSAtIHVwZGF0ZSBwZXIgd29ya2VyIGFuZCBzdW0gYWNyb3NzIHdvcmtlcnNcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9tYXBfd29ya2VyX3NpemVbd29ya2VyX2lkXSA9IHNlbGVjdGlvbl9tYXBfc2l6ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbl9tYXBfc2l6ZSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgd2lkIGluIHRoaXMuc2VsZWN0aW9uX21hcF93b3JrZXJfc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9tYXBfc2l6ZSArPSB0aGlzLnNlbGVjdGlvbl9tYXBfd29ya2VyX3NpemVbd2lkXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZWQgdGhpcyB0aWxlIGR1cmluZyBsb2FkP1xyXG4gICAgICAgIGlmICh0aGlzLnRpbGVzW3RpbGUua2V5XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxvZy50cmFjZShgZGlzY2FyZGVkIHRpbGUgJHt0aWxlLmtleX0gaW4gU2NlbmUuYnVpbGRUaWxlQ29tcGxldGVkIGJlY2F1c2UgcHJldmlvdXNseSByZW1vdmVkYCk7XHJcbiAgICAgICAgICAgIFRpbGUuYWJvcnRCdWlsZCh0aWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBjYWNoZWQgPSB0aGlzLnRpbGVzW3RpbGUua2V5XTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aWxlIHdpdGggcHJvcGVydGllcyBmcm9tIHdvcmtlclxyXG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aWxlID0gY2FjaGVkLm1lcmdlKHRpbGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRpbGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRpbGUuZmluYWxpemVCdWlsZCh0aGlzLnN0eWxlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgbWFpbiB0aHJlYWQgdGlsZSBsb2FkIGVycm9yIGZvciAke3RpbGUua2V5fTogJHt0aWxlLmVycm9yfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpbGUucHJpbnREZWJ1ZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50cmFja1RpbGVTZXRMb2FkU3RvcCgpO1xyXG4gICAgICAgIHRoaXMudHJhY2tUaWxlQnVpbGRTdG9wKHRpbGUua2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcmFjayB0aWxlIGJ1aWxkIHN0YXRlXHJcbiAgICB0cmFja1RpbGVCdWlsZFN0YXJ0KGtleSkge1xyXG4gICAgICAgIGlmICghdGhpcy5idWlsZGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5nID0ge1xyXG4gICAgICAgICAgICAgICAgdGlsZXM6IHt9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnVpbGRpbmcudGlsZXNba2V5XSA9IHRydWU7XHJcbiAgICAgICAgbG9nLnRyYWNlKGB0cmFja1RpbGVCdWlsZFN0YXJ0IGZvciAke2tleX06ICR7T2JqZWN0LmtleXModGhpcy5idWlsZGluZy50aWxlcykubGVuZ3RofWApO1xyXG4gICAgfVxyXG5cclxuICAgIHRyYWNrVGlsZUJ1aWxkU3RvcChrZXkpIHtcclxuICAgICAgICAvLyBEb25lIGJ1aWxkaW5nP1xyXG4gICAgICAgIGlmICh0aGlzLmJ1aWxkaW5nKSB7XHJcbiAgICAgICAgICAgIGxvZy50cmFjZShgdHJhY2tUaWxlQnVpbGRTdG9wIGZvciAke2tleX06ICR7T2JqZWN0LmtleXModGhpcy5idWlsZGluZy50aWxlcykubGVuZ3RofWApO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5idWlsZGluZy50aWxlc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5idWlsZGluZy50aWxlcykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhgU2NlbmU6IGJ1aWxkIGdlb21ldHJ5IGZpbmlzaGVkYCk7XHJcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoYFNjZW5lOiB1cGRhdGVkIHNlbGVjdGlvbiBtYXA6ICR7dGhpcy5zZWxlY3Rpb25fbWFwX3NpemV9IGZlYXR1cmVzYCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVpbGRpbmcucmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRpbmcucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBbm90aGVyIHJlYnVpbGQgcXVldWVkP1xyXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXVlZCA9IHRoaXMuYnVpbGRpbmcucXVldWVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZGluZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKGBTY2VuZTogc3RhcnRpbmcgcXVldWVkIHJlYnVpbGRHZW9tZXRyeSgpIHJlcXVlc3RgKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYnVpbGRHZW9tZXRyeSgpLnRoZW4ocXVldWVkLnJlc29sdmUsIHF1ZXVlZC5yZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZVRpbGUoa2V5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nLnRyYWNlKGB0aWxlIHVubG9hZCBmb3IgJHtrZXl9YCk7XHJcblxyXG4gICAgICAgIHZhciB0aWxlID0gdGhpcy50aWxlc1trZXldO1xyXG5cclxuICAgICAgICBpZiAodGlsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRpbGUuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5mb3JnZXRUaWxlKHRpbGUua2V5KTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgIExvYWQgKG9yIHJlbG9hZCkgdGhlIHNjZW5lIGNvbmZpZ1xyXG4gICAgICAgQHJldHVybiB7UHJvbWlzZX1cclxuICAgICovXHJcbiAgICBsb2FkU2NlbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFV0aWxzLmxvYWRSZXNvdXJjZSh0aGlzLmNvbmZpZ19zb3VyY2UpLnRoZW4oKGNvbmZpZykgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlUHJvY2Vzc0NvbmZpZygpLnRoZW4oKCkgPT4geyB0aGlzLnRyaWdnZXIoJ2xvYWRTY2VuZScsIHRoaXMuY29uZmlnKTsgfSk7XHJcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7IHRocm93IGU7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbG9hZCBzY2VuZSBjb25maWcgYW5kIHJlYnVpbGQgdGlsZXNcclxuICAgIHJlbG9hZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRTY2VuZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlcygpO1xyXG4gICAgICAgICAgICB0aGlzLnN5bmNDb25maWdUb1dvcmtlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWJ1aWxkR2VvbWV0cnkoKTtcclxuICAgICAgICB9LCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZERhdGFTb3VyY2VzKCkge1xyXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5jb25maWcuc291cmNlcykge1xyXG4gICAgICAgICAgICBsZXQgc291cmNlID0gdGhpcy5jb25maWcuc291cmNlc1tuYW1lXTtcclxuICAgICAgICAgICAgc291cmNlLnVybCA9IFV0aWxzLmFkZEJhc2VVUkwoc291cmNlLnVybCk7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlc1tuYW1lXSA9IERhdGFTb3VyY2UuY3JlYXRlKE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZSwge25hbWV9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0U291cmNlTWF4KCkge1xyXG4gICAgICAgIGxldCBtYXhfem9vbSA9IHRoaXMuZmluZE1heFpvb20oKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnNvdXJjZXMpIHtcclxuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuc291cmNlc1tuYW1lXTtcclxuICAgICAgICAgICAgc291cmNlLm1heF96b29tID0gbWF4X3pvb207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXhfem9vbTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3JtYWxpemUgc29tZSBzZXR0aW5ncyB0aGF0IG1heSBub3QgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZSBzY2VuZSBkZWZpbml0aW9uXHJcbiAgICBwcmVQcm9jZXNzQ29uZmlnKCkge1xyXG4gICAgICAgIC8vIEFzc2lnbiBpZHMgdG8gZGF0YSBzb3VyY2VzXHJcbiAgICAgICAgbGV0IHNvdXJjZV9pZCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgc291cmNlIGluIHRoaXMuY29uZmlnLnNvdXJjZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25maWcuc291cmNlc1tzb3VyY2VdLmlkID0gc291cmNlX2lkKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBvbmx5IG9uZSBjYW1lcmEgc3BlY2lmaWVkLCBzZXQgaXQgYXMgZGVmYXVsdFxyXG4gICAgICAgIHRoaXMuY29uZmlnLmNhbWVyYXMgPSB0aGlzLmNvbmZpZy5jYW1lcmFzIHx8IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5jYW1lcmEpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25maWcuY2FtZXJhcy5kZWZhdWx0ID0gdGhpcy5jb25maWcuY2FtZXJhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY2FtZXJhX25hbWVzID0gT2JqZWN0LmtleXModGhpcy5jb25maWcuY2FtZXJhcyk7XHJcbiAgICAgICAgaWYgKGNhbWVyYV9uYW1lcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb25maWcuY2FtZXJhcy5kZWZhdWx0ID0geyBhY3RpdmU6IHRydWUgfTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9hY3RpdmVfY2FtZXJhKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGNhbWVyYSBzZXQgYXMgYWN0aXZlLCB1c2UgZmlyc3Qgb25lXHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNhbWVyYXNbY2FtZXJhX25hbWVzWzBdXS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcubGlnaHRzID0gdGhpcy5jb25maWcubGlnaHRzIHx8IHt9OyAvLyBlbnN1cmUgbGlnaHRzIG9iamVjdFxyXG4gICAgICAgIHRoaXMuY29uZmlnLnN0eWxlcyA9IHRoaXMuY29uZmlnLnN0eWxlcyB8fCB7fTsgLy8gZW5zdXJlIHN0eWxlcyBvYmplY3RcclxuXHJcbiAgICAgICAgcmV0dXJuIFN0eWxlTWFuYWdlci5wcmVsb2FkKHRoaXMuY29uZmlnLnN0eWxlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9hZCBhbGwgdGV4dHVyZXMgaW4gdGhlIHNjZW5lIGRlZmluaXRpb25cclxuICAgIGxvYWRUZXh0dXJlcygpIHtcclxuICAgICAgICB0aGlzLm5vcm1hbGl6ZVRleHR1cmVzKCk7XHJcbiAgICAgICAgcmV0dXJuIFRleHR1cmUuY3JlYXRlRnJvbU9iamVjdCh0aGlzLmdsLCB0aGlzLmNvbmZpZy50ZXh0dXJlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIHNpbmdsZSBvciBtdWx0aS10ZXh0dXJlIHN5bnRheCwgZm9yIHN0eWxlc2hlZXQgY29udmVuaWVuY2VcclxuICAgIG5vcm1hbGl6ZVRleHR1cmVzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb25maWcuc3R5bGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IFtzdHlsZV9uYW1lLCBzdHlsZV0gb2YgVXRpbHMuZW50cmllcyh0aGlzLmNvbmZpZy5zdHlsZXMpKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHN0eWxlIGhhcyBhIHNpbmdsZSAndGV4dHVyZScgb2JqZWN0LCBtb3ZlIGl0IHRvIHRoZSBnbG9iYWwgc2NlbmUgdGV4dHVyZSBzZXRcclxuICAgICAgICAgICAgLy8gYW5kIGdpdmUgaXQgYSBkZWZhdWx0IG5hbWVcclxuICAgICAgICAgICAgaWYgKHN0eWxlLnRleHR1cmUgJiYgdHlwZW9mIHN0eWxlLnRleHR1cmUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGV4dHVyZV9uYW1lID0gJ19fJyArIHN0eWxlX25hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy50ZXh0dXJlcyA9IHRoaXMuY29uZmlnLnRleHR1cmVzIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcudGV4dHVyZXNbdGV4dHVyZV9uYW1lXSA9IHN0eWxlLnRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0dXJlID0gdGV4dHVyZV9uYW1lOyAvLyBwb2ludCBzdGx5ZSB0byBsb2NhdGlvbiBvZiB0ZXh0dXJlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsbGVkIChjdXJyZW50bHkgbWFudWFsbHkpIGFmdGVyIHN0eWxlcyBhcmUgdXBkYXRlZCBpbiBzdHlsZXNoZWV0XHJcbiAgICB1cGRhdGVTdHlsZXMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkICYmICF0aGlzLmluaXRpYWxpemluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjZW5lLnVwZGF0ZVN0eWxlcygpIGNhbGxlZCBiZWZvcmUgc2NlbmUgd2FzIGluaXRpYWxpemVkJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAoUmUpYnVpbGQgc3R5bGVzIGZyb20gY29uZmlnXHJcbiAgICAgICAgU3R5bGVNYW5hZ2VyLmluaXQoKTtcclxuICAgICAgICB0aGlzLnN0eWxlcyA9IFN0eWxlTWFuYWdlci5idWlsZCh0aGlzLmNvbmZpZy5zdHlsZXMsIHRoaXMpO1xyXG5cclxuICAgICAgICAvLyBPcHRpb25hbGx5IHNldCBHTCBjb250ZXh0ICh1c2VkIHdoZW4gaW5pdGlhbGl6aW5nIG9yIHJlLWluaXRpYWxpemluZyBHTCByZXNvdXJjZXMpXHJcbiAgICAgICAgZm9yICh2YXIgc3R5bGUgb2YgVXRpbHMudmFsdWVzKHRoaXMuc3R5bGVzKSkge1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRHTCh0aGlzLmdsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZpbmQgJiBjb21waWxlIGFjdGl2ZSBzdHlsZXNcclxuICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZVN0eWxlcygpO1xyXG4gICAgICAgIFN0eWxlTWFuYWdlci5jb21waWxlKE9iamVjdC5rZXlzKHRoaXMuYWN0aXZlX3N0eWxlcykpO1xyXG5cclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVBY3RpdmVTdHlsZXMoKSB7XHJcbiAgICAgICAgLy8gTWFrZSBhIHNldCBvZiBjdXJyZW50bHkgYWN0aXZlIHN0eWxlcyAodXNlZCBpbiBhIGRyYXcgcnVsZSlcclxuICAgICAgICAvLyBOb3RlOiBkb2Vzbid0IGFjdHVhbGx5IGNoZWNrIGlmIGFueSBnZW9tZXRyeSBtYXRjaGVzIHRoZSBydWxlLCBqdXN0IHRoYXQgdGhlIHN0eWxlIGlzIHBvdGVudGlhbGx5IHJlbmRlcmFibGVcclxuICAgICAgICBsZXQgcHJldl9zdHlsZXMgPSBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZV9zdHlsZXMgfHwge30pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlX3N0eWxlcyA9IHt9O1xyXG4gICAgICAgIHZhciBhbmltYXRlZCA9IGZhbHNlOyAvLyBpcyBhbnkgYWN0aXZlIHN0eWxlIGFuaW1hdGVkP1xyXG4gICAgICAgIGZvciAodmFyIHJ1bGUgb2YgVXRpbHMucmVjdXJzZVZhbHVlcyh0aGlzLmNvbmZpZy5sYXllcnMpKSB7XHJcbiAgICAgICAgICAgIGlmIChydWxlLmRyYXcpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IFtuYW1lLCBncm91cF0gb2YgVXRpbHMuZW50cmllcyhydWxlLmRyYXcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogd2FybiBvbiBub24tb2JqZWN0IGRyYXcgZ3JvdXBcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdyb3VwID09PSAnb2JqZWN0JyAmJiBncm91cC52aXNpYmxlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVfbmFtZSA9IGdyb3VwLnN0eWxlIHx8IG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHRoaXMuc3R5bGVzW3N0eWxlX25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlX3N0eWxlc1tzdHlsZV9uYW1lXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuYW5pbWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbmltYXRlZCA9IGFuaW1hdGVkO1xyXG5cclxuICAgICAgICAvLyBDb21waWxlIG5ld2x5IGFjdGl2ZSBzdHlsZXNcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5hY3RpdmVfc3R5bGVzKS5maWx0ZXIocyA9PiBwcmV2X3N0eWxlcy5pbmRleE9mKHMpID09PSAtMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGNhbWVyYVxyXG4gICAgY3JlYXRlQ2FtZXJhKCkge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gQ2FtZXJhLmNyZWF0ZSh0aGlzLl9hY3RpdmVfY2FtZXJhLCB0aGlzLCB0aGlzLmNvbmZpZy5jYW1lcmFzW3RoaXMuX2FjdGl2ZV9jYW1lcmFdKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB0aGlzIGFuZCBtb3ZlIGFsbCBwb3NpdGlvbiBpbmZvIHRvIGNhbWVyYVxyXG4gICAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVNjZW5lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IGFjdGl2ZSBjYW1lcmEgLSBmb3IgcHVibGljIEFQSVxyXG4gICAgZ2V0QWN0aXZlQ2FtZXJhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVfY2FtZXJhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBhY3RpdmUgY2FtZXJhIGFuZCByZWNvbXBpbGUgLSBmb3IgcHVibGljIEFQSVxyXG4gICAgc2V0QWN0aXZlQ2FtZXJhKG5hbWUpIHtcclxuICAgICAgICB0aGlzLl9hY3RpdmVfY2FtZXJhID0gbmFtZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNvbmZpZygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVfY2FtZXJhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEludGVybmFsIG1hbmFnZW1lbnQgb2YgYWN0aXZlIGNhbWVyYVxyXG4gICAgZ2V0IF9hY3RpdmVfY2FtZXJhKCkge1xyXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5jb25maWcuY2FtZXJhcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuY2FtZXJhc1tuYW1lXS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldCBfYWN0aXZlX2NhbWVyYShuYW1lKSB7XHJcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLl9hY3RpdmVfY2FtZXJhO1xyXG5cclxuICAgICAgICAvLyBTZXQgbmV3IGFjdGl2ZSBjYW1lcmFcclxuICAgICAgICBpZiAodGhpcy5jb25maWcuY2FtZXJhc1tuYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYW1lcmFzW25hbWVdLmFjdGl2ZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGVhciBwcmV2aW91c2x5IGFjdGl2ZSBjYW1lcmFcclxuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gbmFtZSAmJiB0aGlzLmNvbmZpZy5jYW1lcmFzW3ByZXZdKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jb25maWcuY2FtZXJhc1twcmV2XS5hY3RpdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGxpZ2h0aW5nXHJcbiAgICBjcmVhdGVMaWdodHMoKSB7XHJcbiAgICAgICAgdGhpcy5saWdodHMgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMuY29uZmlnLmxpZ2h0cykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5saWdodHNbaV0ubmFtZSA9IGk7XHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxpZ2h0c1tpXS52aXNpYmxlID0gKHRoaXMuY29uZmlnLmxpZ2h0c1tpXS52aXNpYmxlID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5saWdodHNbaV0udmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saWdodHNbaV0gPSBMaWdodC5jcmVhdGUodGhpcywgdGhpcy5jb25maWcubGlnaHRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBMaWdodC5pbmplY3QodGhpcy5saWdodHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBiYWNrZ3JvdW5kIGNvbG9yXHJcbiAgICBzZXRCYWNrZ3JvdW5kKCkge1xyXG4gICAgICAgIGxldCBiZyA9IHRoaXMuY29uZmlnLmJhY2tncm91bmQ7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0ge307XHJcbiAgICAgICAgaWYgKGJnICYmIGJnLmNvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5jb2xvciA9IFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IoYmcuY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuYmFja2dyb3VuZC5jb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuY29sb3IgPSBbMCwgMCwgMCwgMV07IC8vIGRlZmF1bHQgYmFja2dyb3VuZCB0byBibGFja1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgc2NlbmUgY29uZmlnXHJcbiAgICB1cGRhdGVDb25maWcoKSB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVDYW1lcmEoKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUxpZ2h0cygpO1xyXG4gICAgICAgIHRoaXMubG9hZERhdGFTb3VyY2VzKCk7XHJcbiAgICAgICAgdGhpcy5zZXRTb3VyY2VNYXgoKTtcclxuICAgICAgICB0aGlzLmxvYWRUZXh0dXJlcygpO1xyXG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZCgpO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBkZXRlY3QgY2hhbmdlcyB0byBzdHlsZXM/IGFscmVhZHkgKGN1cnJlbnRseSkgbmVlZCB0byByZWNvbXBpbGUgYW55d2F5IHdoZW4gY2FtZXJhIG9yIGxpZ2h0cyBjaGFuZ2VcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlcygpO1xyXG4gICAgICAgIHRoaXMuc3luY0NvbmZpZ1RvV29ya2VyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2VyaWFsaXplIGNvbmZpZyBhbmQgc2VuZCB0byB3b3JrZXJcclxuICAgIHN5bmNDb25maWdUb1dvcmtlcigpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZ19zZXJpYWxpemVkID0gVXRpbHMuc2VyaWFsaXplV2l0aEZ1bmN0aW9ucyh0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25fbWFwX3dvcmtlcl9zaXplID0ge307XHJcbiAgICAgICAgLy8gVGVsbCB3b3JrZXJzIHdlJ3JlIGFib3V0IHRvIHJlYnVpbGQgKHNvIHRoZXkgY2FuIHVwZGF0ZSBzdHlsZXMsIGV0Yy4pXHJcbiAgICAgICAgdGhpcy53b3JrZXJzLmZvckVhY2god29ya2VyID0+IHtcclxuICAgICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ3VwZGF0ZUNvbmZpZycsIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWdfc2VyaWFsaXplZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXNldEZlYXR1cmVTZWxlY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy53b3JrZXJzLmZvckVhY2god29ya2VyID0+IFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh3b3JrZXIsICdyZXNldEZlYXR1cmVTZWxlY3Rpb24nKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzZXQgaW50ZXJuYWwgY2xvY2ssIG1vc3RseSB1c2VmdWwgZm9yIGNvbnNpc3RlbnQgZXhwZXJpZW5jZSB3aGVuIGNoYW5naW5nIHN0eWxlcy9kZWJ1Z2dpbmdcclxuICAgIHJlc2V0VGltZSgpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0X3RpbWUgPSArbmV3IERhdGUoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gU3RhdHMvZGVidWcvcHJvZmlsaW5nIG1ldGhvZHNcclxuXHJcbiAgICAvLyBQcm9maWxpbmcgbWV0aG9kcyB1c2VkIHRvIHRyYWNrIHdoZW4gc2V0cyBvZiB0aWxlcyBzdGFydC9zdG9wIGxvYWRpbmcgdG9nZXRoZXJcclxuICAgIC8vIGUuZy4gaW5pdGlhbCBwYWdlIGxvYWQgaXMgb25lIHNldCBvZiB0aWxlcywgbmV3IHNldHMgb2YgdGlsZSBsb2FkcyBhcmUgdGhlbiBpbml0aWF0ZWQgYnkgYSBtYXAgcGFuIG9yIHpvb21cclxuICAgIHRyYWNrVGlsZVNldExvYWRTdGFydCgpIHtcclxuICAgICAgICAvLyBTdGFydCB0cmFja2luZyBuZXcgdGlsZSBzZXQgaWYgbm8gb3RoZXIgdGlsZXMgYWxyZWFkeSBsb2FkaW5nXHJcbiAgICAgICAgaWYgKHRoaXMudGlsZV9zZXRfbG9hZGluZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZV9zZXRfbG9hZGluZyA9ICtuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBsb2cuaW5mbygnU2NlbmU6IHRpbGUgc2V0IGxvYWQgc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdHJhY2tUaWxlU2V0TG9hZFN0b3AoKSB7XHJcbiAgICAgICAgLy8gTm8gbW9yZSB0aWxlcyBhY3RpdmVseSBsb2FkaW5nP1xyXG4gICAgICAgIGlmICh0aGlzLnRpbGVfc2V0X2xvYWRpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgZW5kX3RpbGVfc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnRpbGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50aWxlc1t0XS5sb2FkaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kX3RpbGVfc2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlbmRfdGlsZV9zZXQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdF90aWxlX3NldF9sb2FkID0gKCtuZXcgRGF0ZSgpKSAtIHRoaXMudGlsZV9zZXRfbG9hZGluZztcclxuICAgICAgICAgICAgICAgIHRoaXMudGlsZV9zZXRfbG9hZGluZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhgU2NlbmU6IHRpbGUgc2V0IGxvYWQgZmluaXNoZWQgaW4gJHt0aGlzLmxhc3RfdGlsZV9zZXRfbG9hZH1tc2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN1bSBvZiBhIGRlYnVnIHByb3BlcnR5IGFjcm9zcyB0aWxlc1xyXG4gICAgZ2V0RGVidWdTdW0ocHJvcCwgZmlsdGVyKSB7XHJcbiAgICAgICAgdmFyIHN1bSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLnRpbGVzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbGVzW3RdLmRlYnVnW3Byb3BdICE9IG51bGwgJiYgKHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicgfHwgZmlsdGVyKHRoaXMudGlsZXNbdF0pID09PSB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IHRoaXMudGlsZXNbdF0uZGVidWdbcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBdmVyYWdlIG9mIGEgZGVidWcgcHJvcGVydHkgYWNyb3NzIHRpbGVzXHJcbiAgICBnZXREZWJ1Z0F2ZXJhZ2UocHJvcCwgZmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVidWdTdW0ocHJvcCwgZmlsdGVyKSAvIE9iamVjdC5rZXlzKHRoaXMudGlsZXMpLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMb2cgbWVzc2FnZXMgcGFzcyB0aHJvdWdoIGZyb20gd2ViIHdvcmtlcnNcclxuICAgIHdvcmtlckxvZ01lc3NhZ2UoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlICE9PSAnbG9nJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgeyB3b3JrZXJfaWQsIGxldmVsLCBtc2cgfSA9IGV2ZW50LmRhdGE7XHJcblxyXG4gICAgICAgIGlmIChsb2dbbGV2ZWxdKSB7XHJcbiAgICAgICAgICAgIGxvZ1tsZXZlbF0oYHdvcmtlciAke3dvcmtlcl9pZH06YCwgIC4uLm1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2cuZXJyb3IoYFNjZW5lLndvcmtlckxvZ01lc3NhZ2U6IHVucmVjb2duaXplZCBsb2cgbGV2ZWwgJHtsZXZlbH1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvZmlsZSBoZWxwZXJzLCBpc3N1ZXMgYSBwcm9maWxlIG9uIG1haW4gdGhyZWFkICYgYWxsIHdvcmtlcnNcclxuICAgIF9wcm9maWxlKG5hbWUpIHtcclxuICAgICAgICBjb25zb2xlLnByb2ZpbGUoYG1haW4gdGhyZWFkOiAke25hbWV9YCk7XHJcbiAgICAgICAgdGhpcy53b3JrZXJzLmZvckVhY2godyA9PiBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UodywgJ3Byb2ZpbGUnLCBuYW1lKSk7XHJcbiAgICB9XHJcblxyXG4gICAgX3Byb2ZpbGVFbmQobmFtZSkge1xyXG4gICAgICAgIGNvbnNvbGUucHJvZmlsZUVuZChgbWFpbiB0aHJlYWQ6ICR7bmFtZX1gKTtcclxuICAgICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCh3ID0+IFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh3LCAncHJvZmlsZUVuZCcsIG5hbWUpKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbi8vIFN0YXRpYyBtZXRob2RzL3N0YXRlXHJcblxyXG5TY2VuZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29uZmlnLCBvcHRpb25zID0ge30pIHtcclxuICAgIHJldHVybiBuZXcgU2NlbmUoY29uZmlnLCBvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG5TY2VuZS50aWxlX3NjYWxlID0gNDA5NjsgLy8gY29vcmRpbmF0ZXMgYXJlIGxvY2FsbHkgc2NhbGVkIHRvIHRoZSByYW5nZSBbMCwgdGlsZV9zY2FsZV1cclxuR2VvLnNldFRpbGVTY2FsZShTY2VuZS50aWxlX3NjYWxlKTtcclxuQnVpbGRlcnMuc2V0VGlsZVNjYWxlKFNjZW5lLnRpbGVfc2NhbGUpO1xyXG5TaGFkZXJQcm9ncmFtLmRlZmluZXMuVElMRV9TQ0FMRSA9IFNjZW5lLnRpbGVfc2NhbGU7XHJcblxyXG4iLCIvKmpzaGludCB3b3JrZXI6IHRydWUqL1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscy91dGlscyc7XHJcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcbmltcG9ydCBTY2VuZSAgZnJvbSAnLi9zY2VuZSc7XHJcbmltcG9ydCBUaWxlIGZyb20gJy4vdGlsZSc7XHJcbmltcG9ydCBEYXRhU291cmNlIGZyb20gJy4vZGF0YV9zb3VyY2UuanMnO1xyXG5pbXBvcnQgRmVhdHVyZVNlbGVjdGlvbiBmcm9tICcuL3NlbGVjdGlvbic7XHJcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4vc3R5bGVzL3N0eWxlX3BhcnNlcic7XHJcbmltcG9ydCB7U3R5bGVNYW5hZ2VyfSBmcm9tICcuL3N0eWxlcy9zdHlsZV9tYW5hZ2VyJztcclxuaW1wb3J0IHtwYXJzZVJ1bGVzfSBmcm9tICcuL3N0eWxlcy9ydWxlJztcclxuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4vc3R5bGVzL2J1aWxkZXJzJztcclxuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9nbC90ZXh0dXJlJztcclxuXHJcbmV4cG9ydCB2YXIgU2NlbmVXb3JrZXIgPSB7XHJcbiAgICBzb3VyY2VzOiB7XHJcbiAgICAgICAgdGlsZXM6IHt9LFxyXG4gICAgICAgIG9iamVjdHM6IHt9XHJcbiAgICB9LFxyXG4gICAgc3R5bGVzOiB7fSxcclxuICAgIHJ1bGVzOiB7fSxcclxuICAgIGxheWVyczoge30sXHJcbiAgICB0aWxlczoge30sXHJcbiAgICBvYmplY3RzOiB7fSxcclxuICAgIGNvbmZpZzoge31cclxufTtcclxuXHJcbi8vIFdvcmtlciBmdW5jdGlvbmFsaXR5IHdpbGwgb25seSBiZSBkZWZpbmVkIGluIHdvcmtlciB0aHJlYWRcclxuXHJcbmlmIChVdGlscy5pc1dvcmtlclRocmVhZCkge1xyXG5cclxuICAgIFNjZW5lV29ya2VyLndvcmtlciA9IHNlbGY7XHJcblxyXG4gICAgLy8gVE9ETzogc3luYyByZW5kZXIgc3R5bGUgc3RhdGUgYmV0d2VlbiBtYWluIHRocmVhZCBhbmQgd29ya2VyXHJcbiAgICBCdWlsZGVycy5zZXRUaWxlU2NhbGUoU2NlbmUudGlsZV9zY2FsZSk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB3b3JrZXJcclxuICAgIFNjZW5lV29ya2VyLndvcmtlci5pbml0ID0gZnVuY3Rpb24gKHdvcmtlcl9pZCwgbnVtX3dvcmtlcnMsIGRldmljZV9waXhlbF9yYXRpbykge1xyXG4gICAgICAgIHNlbGYuX3dvcmtlcl9pZCA9IHdvcmtlcl9pZDtcclxuICAgICAgICBTY2VuZVdvcmtlci5udW1fd29ya2VycyA9IG51bV93b3JrZXJzO1xyXG4gICAgICAgIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyA9IGRldmljZV9waXhlbF9yYXRpbztcclxuICAgICAgICBGZWF0dXJlU2VsZWN0aW9uLnNldFByZWZpeChzZWxmLl93b3JrZXJfaWQpO1xyXG4gICAgICAgIHJldHVybiB3b3JrZXJfaWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN0YXJ0cyBhIGNvbmZpZyByZWZyZXNoXHJcbiAgICBTY2VuZVdvcmtlci53b3JrZXIudXBkYXRlQ29uZmlnID0gZnVuY3Rpb24gKHsgY29uZmlnIH0pIHtcclxuICAgICAgICBTY2VuZVdvcmtlci5jb25maWcgPSBudWxsO1xyXG4gICAgICAgIFNjZW5lV29ya2VyLnN0eWxlcyA9IG51bGw7XHJcbiAgICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShjb25maWcpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGNvbmZpZy5zb3VyY2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBEYXRhU291cmNlLmNyZWF0ZShPYmplY3QuYXNzaWduKGNvbmZpZy5zb3VyY2VzW25hbWVdLCB7bmFtZX0pKTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS50aWxlZCkge1xyXG4gICAgICAgICAgICAgICAgU2NlbmVXb3JrZXIuc291cmNlcy50aWxlc1tuYW1lXSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIERpc3RyaWJ1dGUgb2JqZWN0IHNvdXJjZXMgYWNyb3NzIHdvcmtlcnNcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaWQgJSBTY2VuZVdvcmtlci5udW1fd29ya2VycyA9PT0gc2VsZi5fd29ya2VyX2lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9hZCBzb3VyY2UgaWYgbm90IGNhY2hlZFxyXG4gICAgICAgICAgICAgICAgICAgIFNjZW5lV29ya2VyLnNvdXJjZXMub2JqZWN0c1tuYW1lXSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVNjZW5lV29ya2VyLm9iamVjdHNbc291cmNlLm5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNjZW5lV29ya2VyLm9iamVjdHNbc291cmNlLm5hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5sb2FkKFNjZW5lV29ya2VyLm9iamVjdHNbc291cmNlLm5hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERhdGEgYmxvY2sgZnVuY3Rpb25zIGFyZSBub3QgbWFjcm8nZWQgYW5kIHdyYXBwZWQgbGlrZSB0aGUgcmVzdCBvZiB0aGUgc3R5bGUgZnVuY3Rpb25zIGFyZVxyXG4gICAgICAgIC8vIFRPRE86IHByb2JhYmx5IHdhbnQgYSBjbGVhbmVyIHdheSB0byBleGNsdWRlIHRoZXNlXHJcbiAgICAgICAgZm9yICh2YXIgbGF5ZXIgaW4gY29uZmlnLmxheWVycykge1xyXG4gICAgICAgICAgICBjb25maWcubGF5ZXJzW2xheWVyXS5kYXRhID0gVXRpbHMuc3RyaW5nc1RvRnVuY3Rpb25zKGNvbmZpZy5sYXllcnNbbGF5ZXJdLmRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXhwYW5kIHN0eWxlc1xyXG4gICAgICAgIFNjZW5lV29ya2VyLmNvbmZpZyA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyhTdHlsZVBhcnNlci5leHBhbmRNYWNyb3MoY29uZmlnKSwgU3R5bGVQYXJzZXIud3JhcEZ1bmN0aW9uKTtcclxuICAgICAgICBTY2VuZVdvcmtlci5zdHlsZXMgPSBTdHlsZU1hbmFnZXIuYnVpbGQoU2NlbmVXb3JrZXIuY29uZmlnLnN0eWxlcyk7XHJcblxyXG4gICAgICAgIC8vIFBhcnNlIGVhY2ggdG9wLWxldmVsIGxheWVyIGFzIGEgc2VwYXJhdGUgcnVsZSB0cmVlXHJcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIG1vcmUgZ3JhY2VmdWwgd2F5IHRvIGluY29ycG9yYXRlIHRoaXNcclxuXHJcbiAgICAgICAgU2NlbmVXb3JrZXIucnVsZXMgPSAgcGFyc2VSdWxlcyhTY2VuZVdvcmtlci5jb25maWcubGF5ZXJzKTtcclxuXHJcbiAgICAgICAgLy8gU3luYyB0ZXR4dXJlIGluZm8gZnJvbSBtYWluIHRocmVhZFxyXG4gICAgICAgIFNjZW5lV29ya2VyLnN5bmNpbmdfdGV4dHVyZXMgPSBTY2VuZVdvcmtlci5zeW5jVGV4dHVyZXMoKTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHByb21pc2UgZm9yIHdoZW4gY29uZmlnIHJlZnJlc2ggZmluaXNoZXNcclxuICAgICAgICBTY2VuZVdvcmtlci5jb25maWd1cmluZyA9IFNjZW5lV29ya2VyLnN5bmNpbmdfdGV4dHVyZXMudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIFV0aWxzLmxvZygnZGVidWcnLCBgdXBkYXRlZCBjb25maWdgKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aGVuIGNvbmZpZyByZWZyZXNoIGlzIGZpbmlzaGVkXHJcbiAgICBTY2VuZVdvcmtlci5hd2FpdENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFNjZW5lV29ya2VyLmNvbmZpZ3VyaW5nO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTbGljZSBhIHN1YnNldCBvZiBrZXlzIG91dCBvZiBhIHRpbGVcclxuICAgIC8vIEluY2x1ZGVzIGEgbWluaW11bSBzZXQgb2YgcHJlLWRlZmluZWQga2V5cyBmb3IgbG9hZCBzdGF0ZSwgZGVidWcuIGV0Yy5cclxuICAgIC8vIFdlIHVzZSB0aGlzIHRvIHNlbmQgYSBzdWJzZXQgb2YgdGhlIHRpbGUgYmFjayB0byB0aGUgbWFpbiB0aHJlYWQsIHRvIG1pbmltaXplIHVubmVjZXNzYXJ5IGRhdGEgdHJhbnNmZXJcclxuICAgIC8vIChlLmcuIHZlcnkgbGFyZ2UgaXRlbXMgbGlrZSBmZWF0dXJlIGdlb21ldHJ5IGFyZSBub3QgbmVlZGVkIG9uIHRoZSBtYWluIHRocmVhZClcclxuICAgIFNjZW5lV29ya2VyLnNsaWNlVGlsZSA9IGZ1bmN0aW9uICh0aWxlLCBrZXlzKSB7XHJcbiAgICAgICAga2V5cyA9IGtleXMgfHwge307XHJcbiAgICAgICAga2V5cy5rZXkgPSB0cnVlO1xyXG4gICAgICAgIGtleXMubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAga2V5cy5sb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgIGtleXMub3JkZXIgPSB0cnVlO1xyXG4gICAgICAgIGtleXMuZXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIGtleXMuZGVidWcgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBCdWlsZCB0aGUgdGlsZSBzdWJzZXRcclxuICAgICAgICB2YXIgdGlsZV9zdWJzZXQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBrIGluIGtleXMpIHtcclxuICAgICAgICAgICAgdGlsZV9zdWJzZXRba10gPSB0aWxlW2tdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRpbGVfc3Vic2V0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBCdWlsZCBhIHRpbGU6IGxvYWQgZnJvbSB0aWxlIHNvdXJjZSBpZiBidWlsZGluZyBmb3IgZmlyc3QgdGltZSwgb3RoZXJ3aXNlIHJlYnVpbGQgd2l0aCBleGlzdGluZyBkYXRhXHJcbiAgICBTY2VuZVdvcmtlci53b3JrZXIuYnVpbGRUaWxlID0gZnVuY3Rpb24gKHsgdGlsZSB9KSB7XHJcbiAgICAgICAgLy8gVGlsZSBjYWNoZWQ/XHJcbiAgICAgICAgaWYgKFNjZW5lV29ya2VyLnRpbGVzW3RpbGUua2V5XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIEFscmVhZHkgbG9hZGluZz9cclxuICAgICAgICAgICAgaWYgKFNjZW5lV29ya2VyLnRpbGVzW3RpbGUua2V5XS5sb2FkaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aWxlIGNhY2hlXHJcbiAgICAgICAgdGlsZSA9IFNjZW5lV29ya2VyLnRpbGVzW3RpbGUua2V5XSA9IE9iamVjdC5hc3NpZ24oU2NlbmVXb3JrZXIudGlsZXNbdGlsZS5rZXldIHx8IHt9LCB0aWxlKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGNvbmZpZyAoc3R5bGVzLCBldGMuKSwgdGhlbiBidWlsZCB0aWxlXHJcbiAgICAgICAgcmV0dXJuIFNjZW5lV29ya2VyLmF3YWl0Q29uZmlndXJhdGlvbigpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCB0aW1lIGJ1aWxkaW5nIHRoZSB0aWxlXHJcbiAgICAgICAgICAgIGlmICh0aWxlLmxvYWRlZCAhPT0gdHJ1ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5sb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlLmVycm9yID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoT2JqZWN0LmtleXMoU2NlbmVXb3JrZXIuc291cmNlcy50aWxlcykubWFwKHggPT4gU2NlbmVXb3JrZXIuc291cmNlcy50aWxlc1t4XS5sb2FkKHRpbGUpKSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFueSBlcnJvcnM/IFdhcm4gYW5kIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlID0gT2JqZWN0LmtleXModGlsZS5zb3VyY2VzKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcChzID0+IHRpbGUuc291cmNlc1tzXS5lcnJvciAmJiBgW3NvdXJjZSAnJHtzfSc6ICR7dGlsZS5zb3VyY2VzW3NdLmVycm9yfV1gKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcih4ID0+IHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3dhcm4nLCBgdGlsZSBsb2FkIGVycm9yKHMpIGZvciAke3RpbGUua2V5fTogJHtlLmpvaW4oJywgJyl9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aWxlLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRpbGUuYnVpbGRHZW9tZXRyeSh0aWxlLCBTY2VuZVdvcmtlci5jb25maWcubGF5ZXJzLCBTY2VuZVdvcmtlci5ydWxlcywgU2NlbmVXb3JrZXIuc3R5bGVzKS50aGVuKGtleXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZTogU2NlbmVXb3JrZXIuc2xpY2VUaWxlKHRpbGUsIGtleXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcl9pZDogc2VsZi5fd29ya2VyX2lkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl9tYXBfc2l6ZTogRmVhdHVyZVNlbGVjdGlvbi5nZXRNYXBTaXplKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZS5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUubG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGUuZXJyb3IgPSBlcnJvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ2Vycm9yJywgYHRpbGUgbG9hZCBlcnJvciBmb3IgJHt0aWxlLmtleX06ICR7ZXJyb3Iuc3RhY2t9YCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGU6IFNjZW5lV29ya2VyLnNsaWNlVGlsZSh0aWxlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcl9pZDogc2VsZi5fd29ya2VyX2lkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX21hcF9zaXplOiBGZWF0dXJlU2VsZWN0aW9uLmdldE1hcFNpemUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRpbGUgYWxyZWFkeSBsb2FkZWQsIGp1c3QgcmVidWlsZFxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCBgdXNlZCB3b3JrZXIgY2FjaGUgZm9yIHRpbGUgJHt0aWxlLmtleX1gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBnZW9tZXRyeVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRpbGUuYnVpbGRHZW9tZXRyeSh0aWxlLCBTY2VuZVdvcmtlci5jb25maWcubGF5ZXJzLCBTY2VuZVdvcmtlci5ydWxlcywgU2NlbmVXb3JrZXIuc3R5bGVzKS50aGVuKGtleXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGU6IFNjZW5lV29ya2VyLnNsaWNlVGlsZSh0aWxlLCBrZXlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyX2lkOiBzZWxmLl93b3JrZXJfaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl9tYXBfc2l6ZTogRmVhdHVyZVNlbGVjdGlvbi5nZXRNYXBTaXplKClcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRpbGVcclxuICAgIFNjZW5lV29ya2VyLndvcmtlci5yZW1vdmVUaWxlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciB0aWxlID0gU2NlbmVXb3JrZXIudGlsZXNba2V5XTtcclxuXHJcbiAgICAgICAgaWYgKHRpbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBDYW5jZWwgaWYgbG9hZGluZ1xyXG4gICAgICAgICAgICBpZiAodGlsZS5sb2FkaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYGNhbmNlbCB0aWxlIGxvYWQgZm9yICR7a2V5fWApO1xyXG4gICAgICAgICAgICAgICAgdGlsZS5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFRpbGUuY2FuY2VsKHRpbGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gY2FjaGVcclxuICAgICAgICAgICAgRmVhdHVyZVNlbGVjdGlvbi5jbGVhclRpbGUoa2V5KTtcclxuICAgICAgICAgICAgZGVsZXRlIFNjZW5lV29ya2VyLnRpbGVzW2tleV07XHJcbiAgICAgICAgICAgIFV0aWxzLmxvZygndHJhY2UnLCBgcmVtb3ZlIHRpbGUgZnJvbSBjYWNoZSBmb3IgJHtrZXl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBHZXQgYSBmZWF0dXJlIGZyb20gdGhlIHNlbGVjdGlvbiBtYXBcclxuICAgIFNjZW5lV29ya2VyLndvcmtlci5nZXRGZWF0dXJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHsgaWQsIGtleSB9ID0ge30pIHtcclxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gRmVhdHVyZVNlbGVjdGlvbi5tYXBba2V5XTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICBmZWF0dXJlOiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mZWF0dXJlKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJlc2V0cyB0aGUgZmVhdHVyZSBzZWxlY3Rpb24gc3RhdGVcclxuICAgIFNjZW5lV29ya2VyLndvcmtlci5yZXNldEZlYXR1cmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgRmVhdHVyZVNlbGVjdGlvbi5yZXNldCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUZXh0dXJlIGluZm8gbmVlZHMgdG8gYmUgc3luY2VkIGZyb20gbWFpbiB0aHJlYWRcclxuICAgIFNjZW5lV29ya2VyLnN5bmNUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBXZSdyZSBvbmx5IHN5bmNpbmcgdGhlIHRleHR1cmVzIHRoYXQgaGF2ZSBzcHJpdGVzIGRlZmluZWQsIHNpbmNlIHRoZXNlIGFyZSAoY3VycmVudGx5KSB0aGUgb25seSBvbmVzIHdlXHJcbiAgICAgICAgLy8gbmVlZCBpbmZvIGFib3V0IGZvciBnZW9tZXRyeSBjb25zdHJ1Y3Rpb24gKGUuZy4gd2lkdGgvaGVpZ2h0LCB3aGljaCB3ZSBvbmx5IGtub3cgYWZ0ZXIgdGhlIHRleHR1cmUgbG9hZHMpXHJcbiAgICAgICAgbGV0IHRleHR1cmVzID0gW107XHJcbiAgICAgICAgaWYgKFNjZW5lV29ya2VyLmNvbmZpZy50ZXh0dXJlcykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBbdGV4bmFtZSwgdGV4dHVyZV0gb2YgVXRpbHMuZW50cmllcyhTY2VuZVdvcmtlci5jb25maWcudGV4dHVyZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZS5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXMucHVzaCh0ZXhuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgVXRpbHMubG9nKCd0cmFjZScsICdzeW5jIHRleHR1cmVzIHRvIHdvcmtlcjonLCB0ZXh0dXJlcyk7XHJcbiAgICAgICAgaWYgKHRleHR1cmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRleHR1cmUuc3luY1RleHR1cmVzVG9Xb3JrZXIodGV4dHVyZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFByb2ZpbGluZyBoZWxwZXJzXHJcbiAgICBTY2VuZVdvcmtlci53b3JrZXIucHJvZmlsZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgY29uc29sZS5wcm9maWxlKGB3b3JrZXIgJHtzZWxmLl93b3JrZXJfaWR9OiAke25hbWV9YCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNjZW5lV29ya2VyLndvcmtlci5wcm9maWxlRW5kID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBjb25zb2xlLnByb2ZpbGVFbmQoYHdvcmtlciAke3NlbGYuX3dvcmtlcl9pZH06ICR7bmFtZX1gKTtcclxuICAgIH07XHJcblxyXG59XHJcbiIsImltcG9ydCBUZXh0dXJlIGZyb20gJy4vZ2wvdGV4dHVyZSc7XHJcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi91dGlscy93b3JrZXJfYnJva2VyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZlYXR1cmVTZWxlY3Rpb24ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGdsLCB3b3JrZXJzKSB7XHJcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMud29ya2VycyA9IHdvcmtlcnM7IC8vIHBvb2wgb2Ygd29ya2VycyB0byByZXF1ZXN0IGZlYXR1cmUgbG9vay11cHMgZnJvbSwga2V5ZWQgYnkgaWRcclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIC8vIFNlbGVjdGlvbiBzdGF0ZSB0cmFja2luZ1xyXG4gICAgICAgIHRoaXMucmVxdWVzdHMgPSB7fTsgLy8gcGVuZGluZyBzZWxlY3Rpb24gcmVxdWVzdHNcclxuICAgICAgICB0aGlzLmZlYXR1cmUgPSBudWxsOyAvLyBjdXJyZW50bHkgc2VsZWN0ZWQgZmVhdHVyZVxyXG4gICAgICAgIHRoaXMucmVhZF9kZWxheSA9IDU7IC8vIGRlbGF5IHRpbWUgZnJvbSBzZWxlY3Rpb24gcmVuZGVyIHRvIGZyYW1lYnVmZmVyIHNhbXBsZSwgdG8gYXZvaWQgQ1BVL0dQVSBzeW5jIGxvY2tcclxuICAgICAgICB0aGlzLnJlYWRfZGVsYXlfdGltZXIgPSBudWxsOyAvLyBjdXJyZW50IHRpbWVyIChzZXRUaW1lb3V0KSBmb3IgZGVsYXllZCBzZWxlY3Rpb24gcmVhZHNcclxuXHJcbiAgICAgICAgdGhpcy5waXhlbCA9IG5ldyBVaW50OEFycmF5KDQpO1xyXG4gICAgICAgIHRoaXMucGl4ZWwzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5waXhlbC5idWZmZXIpO1xyXG5cclxuICAgICAgICAvLyBGcmFtZSBidWZmZXIgZm9yIHNlbGVjdGlvblxyXG4gICAgICAgIC8vIFRPRE86IGluaXRpYXRlIGxhemlseSBpbiBjYXNlIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55IHNlbGVjdGlvblxyXG4gICAgICAgIHRoaXMuZmJvID0gdGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZmJvKTtcclxuICAgICAgICB0aGlzLmZib19zaXplID0geyB3aWR0aDogMjU2LCBoZWlnaHQ6IDI1NiB9OyAvLyBUT0RPOiBtYWtlIGNvbmZpZ3VyYWJsZSAvIGFkYXB0aXZlIGJhc2VkIG9uIGNhbnZhcyBzaXplXHJcbiAgICAgICAgdGhpcy5mYm9fc2l6ZS5hc3BlY3QgPSB0aGlzLmZib19zaXplLndpZHRoIC8gdGhpcy5mYm9fc2l6ZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIFRleHR1cmUgZm9yIHRoZSBGQk8gY29sb3IgYXR0YWNobWVudFxyXG4gICAgICAgIHZhciBmYm9fdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuZ2wsICdzZWxlY3Rpb25fZmJvJyk7XHJcbiAgICAgICAgZmJvX3RleHR1cmUuc2V0RGF0YSh0aGlzLmZib19zaXplLndpZHRoLCB0aGlzLmZib19zaXplLmhlaWdodCwgbnVsbCwgeyBmaWx0ZXJpbmc6ICduZWFyZXN0JyB9KTtcclxuICAgICAgICB0aGlzLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRoaXMuZ2wuVEVYVFVSRV8yRCwgZmJvX3RleHR1cmUudGV4dHVyZSwgMCk7XHJcblxyXG4gICAgICAgIC8vIFJlbmRlcmJ1ZmZlciBmb3IgdGhlIEZCTyBkZXB0aCBhdHRhY2htZW50XHJcbiAgICAgICAgdmFyIGZib19kZXB0aF9yYiA9IHRoaXMuZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBmYm9fZGVwdGhfcmIpO1xyXG4gICAgICAgIHRoaXMuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5nbC5ERVBUSF9DT01QT05FTlQxNiwgdGhpcy5mYm9fc2l6ZS53aWR0aCwgdGhpcy5mYm9fc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5nbC5ERVBUSF9BVFRBQ0hNRU5ULCB0aGlzLmdsLlJFTkRFUkJVRkZFUiwgZmJvX2RlcHRoX3JiKTtcclxuXHJcbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgYmluZCgpIHtcclxuICAgICAgICAvLyBTd2l0Y2ggdG8gRkJPXHJcbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5mYm8pO1xyXG4gICAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5mYm9fc2l6ZS53aWR0aCwgdGhpcy5mYm9fc2l6ZS5oZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcXVlc3QgZmVhdHVyZSBzZWxlY3Rpb25cclxuICAgIC8vIFJ1bnMgYXN5bmNocm9ub3VzbHksIHNjaGVkdWxlcyBzZWxlY3Rpb24gYnVmZmVyIHRvIGJlIHVwZGF0ZWRcclxuICAgIGdldEZlYXR1cmVBdChwb2ludCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFF1ZXVlIHJlcXVlc3RzIGZvciBmZWF0dXJlIHNlbGVjdGlvbiwgYW5kIHRoZXkgd2lsbCBiZSBwaWNrZWQgdXAgYnkgdGhlIHJlbmRlciBsb29wXHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWQgPSAodGhpcy5zZWxlY3Rpb25fcmVxdWVzdF9pZCArIDEpIHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHNbdGhpcy5zZWxlY3Rpb25fcmVxdWVzdF9pZF0gPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAncG9pbnQnLFxyXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuc2VsZWN0aW9uX3JlcXVlc3RfaWQsXHJcbiAgICAgICAgICAgICAgICBwb2ludCxcclxuICAgICAgICAgICAgICAgIHJlc29sdmVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbnkgcGVuZGluZyBzZWxlY3Rpb24gcmVxdWVzdHNcclxuICAgIHBlbmRpbmdSZXF1ZXN0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0cztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWFkIHBlbmRpbmcgcmVzdWx0cyBmcm9tIHRoZSBzZWxlY3Rpb24gYnVmZmVyLiBDYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nIHRvIHNlbGVjdGlvbiBidWZmZXIuXHJcbiAgICByZWFkKCkge1xyXG4gICAgICAgIC8vIERlbGF5IHJlYWRpbmcgdGhlIHBpeGVsIHJlc3VsdCBmcm9tIHRoZSBzZWxlY3Rpb24gYnVmZmVyIHRvIGF2b2lkIENQVS9HUFUgc3luYyBsb2NrLlxyXG4gICAgICAgIC8vIENhbGxpbmcgcmVhZFBpeGVscyBzeW5jaHJvbm91c2x5IGNhdXNlZCBhIG1hc3NpdmUgcGVyZm9ybWFuY2UgaGl0LCBwcmVzdW1hYmx5IHNpbmNlIGl0XHJcbiAgICAgICAgLy8gZm9yY2VkIHRoaXMgZnVuY3Rpb24gdG8gd2FpdCBmb3IgdGhlIEdQVSB0byBmaW5pc2ggcmVuZGVyaW5nIGFuZCByZXRyaWV2ZSB0aGUgdGV4dHVyZSBjb250ZW50cy5cclxuICAgICAgICBpZiAodGhpcy5yZWFkX2RlbGF5X3RpbWVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZF9kZWxheV90aW1lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVhZF9kZWxheV90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG5cclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZibyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciByIGluIHRoaXMucmVxdWVzdHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0c1tyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlcXVlc3Qgd2FzIGFscmVhZHkgc2VudCB0byB0aGUgd29ya2VyLCB3ZSdyZSBqdXN0IGF3YWl0aW5nIGl0cyByZXBseVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc2VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgc2VsZWN0aW9uIHR5cGVzLCBzdWNoIGFzIGZlYXR1cmVzIHdpdGhpbiBhIGJveFxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudHlwZSAhPT0gJ3BvaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHNlbGVjdGlvbiBtYXAgYWdhaW5zdCBGQk9cclxuICAgICAgICAgICAgICAgIGdsLnJlYWRQaXhlbHMoXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihyZXF1ZXN0LnBvaW50LnggKiB0aGlzLmZib19zaXplLndpZHRoKSxcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKCgxIC0gcmVxdWVzdC5wb2ludC55KSAqIHRoaXMuZmJvX3NpemUuaGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgICAgICAxLCAxLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnBpeGVsKTtcclxuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlX2tleSA9ICh0aGlzLnBpeGVsWzBdICsgKHRoaXMucGl4ZWxbMV0gPDwgOCkgKyAodGhpcy5waXhlbFsyXSA8PCAxNikgKyAodGhpcy5waXhlbFszXSA8PCAyNCkpID4+PiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGZlYXR1cmUgZm91bmQsIGFzayBhcHByb3ByaWF0ZSB3ZWIgd29ya2VyIHRvIGxvb2t1cCBmZWF0dXJlXHJcbiAgICAgICAgICAgICAgICB2YXIgd29ya2VyX2lkID0gdGhpcy5waXhlbFszXTtcclxuICAgICAgICAgICAgICAgIGlmICh3b3JrZXJfaWQgIT09IDI1NSkgeyAvLyAyNTUgaW5kaWNhdGVzIGFuIGVtcHR5IHNlbGVjdGlvbiBidWZmZXIgcGl4ZWxcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53b3JrZXJzW3dvcmtlcl9pZF0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndvcmtlcnNbd29ya2VyX2lkXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdnZXRGZWF0dXJlU2VsZWN0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQ6IHJlcXVlc3QuaWQsIGtleTogZmVhdHVyZV9rZXkgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4obWVzc2FnZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaFJlYWQobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIE5vIGZlYXR1cmUgZm91bmQsIGJ1dCBzdGlsbCBuZWVkIHRvIHJlc29sdmUgcHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hSZWFkKHsgaWQ6IHJlcXVlc3QuaWQsIGZlYXR1cmU6IG51bGwgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuXHJcbiAgICAgICAgfSwgdGhpcy5yZWFkX2RlbGF5KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxsZWQgb24gbWFpbiB0aHJlYWQgd2hlbiBhIHdlYiB3b3JrZXIgZmluZHMgYSBmZWF0dXJlIGluIHRoZSBzZWxlY3Rpb24gYnVmZmVyXHJcbiAgICBmaW5pc2hSZWFkIChtZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzW21lc3NhZ2UuaWRdO1xyXG4gICAgICAgIGlmICghcmVxdWVzdCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlU2VsZWN0aW9uLmZpbmlzaFJlYWQoKSBjYWxsZWQgd2l0aG91dCBhbnkgbWVzc2FnZVwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlID0gbWVzc2FnZS5mZWF0dXJlO1xyXG4gICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKChmZWF0dXJlICE9IG51bGwgJiYgdGhpcy5mZWF0dXJlID09IG51bGwpIHx8XHJcbiAgICAgICAgICAgIChmZWF0dXJlID09IG51bGwgJiYgdGhpcy5mZWF0dXJlICE9IG51bGwpIHx8XHJcbiAgICAgICAgICAgIChmZWF0dXJlICE9IG51bGwgJiYgdGhpcy5mZWF0dXJlICE9IG51bGwgJiYgZmVhdHVyZS5pZCAhPT0gdGhpcy5mZWF0dXJlLmlkKSkge1xyXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZmVhdHVyZSA9IGZlYXR1cmU7IC8vIHN0b3JlIHRoZSBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIGZlYXR1cmVcclxuXHJcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcmVxdWVzdFxyXG4gICAgICAgIHJlcXVlc3QucmVzb2x2ZSh7IGZlYXR1cmUsIGNoYW5nZWQsIHJlcXVlc3QgfSk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbbWVzc2FnZS5pZF07IC8vIGRvbmUgcHJvY2Vzc2luZyB0aGlzIHJlcXVlc3RcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gU2VsZWN0aW9uIG1hcCBnZW5lcmF0aW9uXHJcbiAgICAvLyBFYWNoIHdvcmtlciB3aWxsIGNyZWF0ZSBpdHMgb3duIGluZGVwZW5kZW50LCAnbG9jYWwnIHNlbGVjdGlvbiBtYXBcclxuXHJcbiAgICAvLyBDcmVhdGUgYSB1bmlxdWUgMzItYml0IGNvbG9yIHRvIGlkZW50aWZ5IGEgZmVhdHVyZVxyXG4gICAgLy8gV29ya2VycyBpbmRlcGVuZGVudGx5IGNyZWF0ZS9tb2RpZnkgc2VsZWN0aW9uIGNvbG9ycyBpbiB0aGVpciBvd24gdGhyZWFkcywgYnV0IHdlIGFsc29cclxuICAgIC8vIG5lZWQgdGhlIG1haW4gdGhyZWFkIHRvIGtub3cgd2hlcmUgZWFjaCBmZWF0dXJlIGNvbG9yIG9yaWdpbmF0ZWQuIFRvIGFjY29tcGxpc2ggdGhpcyxcclxuICAgIC8vIHdlIHBhcnRpdGlvbiB0aGUgbWFwIGJ5IHNldHRpbmcgdGhlIDR0aCBjb21wb25lbnQgKGFscGhhIGNoYW5uZWwpIHRvIHRoZSB3b3JrZXIncyBpZC5cclxuICAgIHN0YXRpYyBtYWtlRW50cnkodGlsZSkge1xyXG4gICAgICAgIC8vIDMyLWJpdCBjb2xvciBrZXlcclxuICAgICAgICB0aGlzLm1hcF9zaXplKys7XHJcbiAgICAgICAgdmFyIGlyID0gdGhpcy5tYXBfc2l6ZSAmIDI1NTtcclxuICAgICAgICB2YXIgaWcgPSAodGhpcy5tYXBfc2l6ZSA+PiA4KSAmIDI1NTtcclxuICAgICAgICB2YXIgaWIgPSAodGhpcy5tYXBfc2l6ZSA+PiAxNikgJiAyNTU7XHJcbiAgICAgICAgdmFyIGlhID0gdGhpcy5tYXBfcHJlZml4O1xyXG4gICAgICAgIHZhciByID0gaXIgLyAyNTU7XHJcbiAgICAgICAgdmFyIGcgPSBpZyAvIDI1NTtcclxuICAgICAgICB2YXIgYiA9IGliIC8gMjU1O1xyXG4gICAgICAgIHZhciBhID0gaWEgLyAyNTU7XHJcbiAgICAgICAgdmFyIGtleSA9IChpciArIChpZyA8PCA4KSArIChpYiA8PCAxNikgKyAoaWEgPDwgMjQpKSA+Pj4gMDsgLy8gbmVlZCB1bnNpZ25lZCByaWdodCBzaGlmdCB0byBjb252ZXJ0IHRvIHBvc2l0aXZlICNcclxuXHJcbiAgICAgICAgdGhpcy5tYXBba2V5XSA9IHtcclxuICAgICAgICAgICAgY29sb3I6IFtyLCBnLCBiLCBhXSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLnRpbGVzW3RpbGUua2V5XSA9IHRoaXMudGlsZXNbdGlsZS5rZXldIHx8IFtdO1xyXG4gICAgICAgIHRoaXMudGlsZXNbdGlsZS5rZXldLnB1c2goa2V5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwW2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIG1ha2VDb2xvcihmZWF0dXJlLCB0aWxlKSB7XHJcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5tYWtlRW50cnkodGlsZSk7XHJcbiAgICAgICAgc2VsZWN0b3IuZmVhdHVyZSA9IHtcclxuICAgICAgICAgICAgaWQ6IGZlYXR1cmUuaWQsXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IGZlYXR1cmUucHJvcGVydGllcyxcclxuICAgICAgICAgICAgdGlsZTogdGlsZS5rZXlcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gc2VsZWN0b3IuY29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMubWFwID0ge307XHJcbiAgICAgICAgdGhpcy5tYXBfc2l6ZSA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNsZWFyVGlsZShrZXkpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnRpbGVzW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZXNba2V5XS5mb3JFYWNoKGsgPT4gZGVsZXRlIHRoaXMubWFwW2tdKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMudGlsZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldE1hcFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwKS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHNldFByZWZpeChwcmVmaXgpIHtcclxuICAgICAgICB0aGlzLm1hcF9wcmVmaXggPSBwcmVmaXg7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG4vLyBTdGF0aWMgcHJvcGVydGllc1xyXG5GZWF0dXJlU2VsZWN0aW9uLm1hcCA9IHt9OyAgIC8vIHRoaXMgd2lsbCBiZSB1bmlxdWUgcGVyIG1vZHVsZSBpbnN0YW5jZSAoc28gdW5pcXVlIHBlciB3b3JrZXIpXHJcbkZlYXR1cmVTZWxlY3Rpb24udGlsZXMgPSB7fTsgLy8gc2VsZWN0aW9uIGtleXMsIGJ5IHRpbGVcclxuRmVhdHVyZVNlbGVjdGlvbi5tYXBfc2l6ZSA9IDE7IC8vIHN0YXJ0IGF0IDEgc2luY2UgMSB3aWxsIGJlIGRpdmlkZWQgYnkgdGhpc1xyXG5GZWF0dXJlU2VsZWN0aW9uLm1hcF9wcmVmaXggPSAwOyAvLyBzZXQgYnkgd29ya2VyIHRvIHdvcmtlciBpZCAjXHJcbkZlYXR1cmVTZWxlY3Rpb24uZGVmYXVsdENvbG9yID0gWzAsIDAsIDAsIDFdO1xyXG4iLCIvLyBHZW9tZXRyeSBidWlsZGluZyBmdW5jdGlvbnNcclxuXHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcclxuaW1wb3J0IEdlbyBmcm9tICcuLi9nZW8nO1xyXG5cclxuaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xyXG5cclxudmFyIEJ1aWxkZXJzO1xyXG5leHBvcnQgZGVmYXVsdCBCdWlsZGVycyA9IHt9O1xyXG5cclxuQnVpbGRlcnMuZGVidWcgPSBmYWxzZTtcclxuXHJcbi8vIFJlLXNjYWxlIFVWcyBmcm9tIFswLCAxXSByYW5nZSB0byBhIHNtYWxsZXIgYXJlYSB3aXRoaW4gdGhlIGltYWdlXHJcbkJ1aWxkZXJzLnNjYWxlVGV4Y29vcmRzVG9TcHJpdGUgPSBmdW5jdGlvbiAodXYsIGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKSB7XHJcbiAgICB2YXIgYXJlYV9vcmlnaW5feSA9IHRleF9zaXplWzFdIC0gYXJlYV9vcmlnaW5bMV0gLSBhcmVhX3NpemVbMV07XHJcbiAgICB2YXIgc3V2ID0gW107XHJcbiAgICBzdXZbMF0gPSAodXZbMF0gKiBhcmVhX3NpemVbMF0gKyBhcmVhX29yaWdpblswXSkgLyB0ZXhfc2l6ZVswXTtcclxuICAgIHN1dlsxXSA9ICh1dlsxXSAqIGFyZWFfc2l6ZVsxXSArIGFyZWFfb3JpZ2luX3kpIC8gdGV4X3NpemVbMV07XHJcbiAgICByZXR1cm4gc3V2O1xyXG59O1xyXG5cclxuQnVpbGRlcnMuZ2V0VGV4Y29vcmRzRm9yU3ByaXRlID0gZnVuY3Rpb24gKGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIEJ1aWxkZXJzLnNjYWxlVGV4Y29vcmRzVG9TcHJpdGUoWzAsIDBdLCBhcmVhX29yaWdpbiwgYXJlYV9zaXplLCB0ZXhfc2l6ZSksXHJcbiAgICAgICAgQnVpbGRlcnMuc2NhbGVUZXhjb29yZHNUb1Nwcml0ZShbMSwgMV0sIGFyZWFfb3JpZ2luLCBhcmVhX3NpemUsIHRleF9zaXplKVxyXG4gICAgXTtcclxufTtcclxuXHJcbi8vIFRlc3NlbGF0ZSBhIGZsYXQgMkQgcG9seWdvblxyXG4vLyB4ICYgeSBjb29yZGluYXRlcyB3aWxsIGJlIHNldCBhcyBmaXJzdCB0d28gZWxlbWVudHMgb2YgcHJvdmlkZWQgdmVydGV4X3RlbXBsYXRlXHJcbkJ1aWxkZXJzLmJ1aWxkUG9seWdvbnMgPSBmdW5jdGlvbiAoXHJcbiAgICBwb2x5Z29ucyxcclxuICAgIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsXHJcbiAgICB7IHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZF9zY2FsZSB9KSB7XHJcblxyXG4gICAgdmFyIFtbbWluX3UsIG1pbl92XSwgW21heF91LCBtYXhfdl1dID0gdGV4Y29vcmRfc2NhbGUgfHwgW1swLCAwXSwgWzEsIDFdXTtcclxuICAgIHZhciBudW1fcG9seWdvbnMgPSBwb2x5Z29ucy5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBwPTA7IHAgPCBudW1fcG9seWdvbnM7IHArKykge1xyXG4gICAgICAgIHZhciBwb2x5Z29uID0gcG9seWdvbnNbcF07XHJcblxyXG4gICAgICAgIC8vIEZpbmQgcG9seWdvbiBleHRlbnRzIHRvIGNhbGN1bGF0ZSBVVnMsIGZpdCB0aGVtIHRvIHRoZSBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94XHJcbiAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBbbWluX3gsIG1pbl95LCBtYXhfeCwgbWF4X3ldID0gR2VvLmZpbmRCb3VuZGluZ0JveChwb2x5Z29uKTtcclxuICAgICAgICAgICAgdmFyIHNwYW5feCA9IG1heF94IC0gbWluX3g7XHJcbiAgICAgICAgICAgIHZhciBzcGFuX3kgPSBtYXhfeSAtIG1pbl95O1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVfdSA9IChtYXhfdSAtIG1pbl91KSAvIHNwYW5feDtcclxuICAgICAgICAgICAgdmFyIHNjYWxlX3YgPSAobWF4X3YgLSBtaW5fdikgLyBzcGFuX3k7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUZXNzZWxsYXRlXHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gQnVpbGRlcnMudHJpYW5ndWxhdGVQb2x5Z29uKHBvbHlnb24pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdmVydGV4IGRhdGFcclxuICAgICAgICB2YXIgbnVtX3ZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIHY9MDsgdiA8IG51bV92ZXJ0aWNlczsgdisrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1t2XTtcclxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzBdID0gdmVydGV4WzBdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbMV0gPSB2ZXJ0ZXhbMV07XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgVVZzXHJcbiAgICAgICAgICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMF0gPSAodmVydGV4WzBdIC0gbWluX3gpICogc2NhbGVfdSArIG1pbl91O1xyXG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMV0gPSAodmVydGV4WzFdIC0gbWluX3kpICogc2NhbGVfdiArIG1pbl92O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBUZXNzZWxhdGUgYW5kIGV4dHJ1ZGUgYSBmbGF0IDJEIHBvbHlnb24gaW50byBhIHNpbXBsZSAzRCBtb2RlbCB3aXRoIGZpeGVkIGhlaWdodCBhbmQgYWRkIHRvIEdMIHZlcnRleCBidWZmZXJcclxuQnVpbGRlcnMuYnVpbGRFeHRydWRlZFBvbHlnb25zID0gZnVuY3Rpb24gKFxyXG4gICAgcG9seWdvbnMsXHJcbiAgICB6LCBoZWlnaHQsIG1pbl9oZWlnaHQsXHJcbiAgICB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxyXG4gICAgbm9ybWFsX2luZGV4LFxyXG4gICAgeyB0ZXhjb29yZF9pbmRleCwgdGV4Y29vcmRfc2NhbGUgfSkge1xyXG5cclxuICAgIC8vIFRvcFxyXG4gICAgdmFyIG1pbl96ID0geiArIChtaW5faGVpZ2h0IHx8IDApO1xyXG4gICAgdmFyIG1heF96ID0geiArIGhlaWdodDtcclxuICAgIHZlcnRleF90ZW1wbGF0ZVsyXSA9IG1heF96O1xyXG4gICAgQnVpbGRlcnMuYnVpbGRQb2x5Z29ucyhwb2x5Z29ucywgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSwgeyB0ZXhjb29yZF9pbmRleCB9KTtcclxuXHJcbiAgICAvLyBXYWxsc1xyXG4gICAgLy8gRml0IFVWcyB0byB3YWxsIHF1YWRcclxuICAgIHZhciBbW21pbl91LCBtaW5fdl0sIFttYXhfdSwgbWF4X3ZdXSA9IHRleGNvb3JkX3NjYWxlIHx8IFtbMCwgMF0sIFsxLCAxXV07XHJcbiAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcclxuICAgICAgICB2YXIgdGV4Y29vcmRzID0gW1xyXG4gICAgICAgICAgICBbbWluX3UsIG1heF92XSxcclxuICAgICAgICAgICAgW21pbl91LCBtaW5fdl0sXHJcbiAgICAgICAgICAgIFttYXhfdSwgbWluX3ZdLFxyXG5cclxuICAgICAgICAgICAgW21heF91LCBtaW5fdl0sXHJcbiAgICAgICAgICAgIFttYXhfdSwgbWF4X3ZdLFxyXG4gICAgICAgICAgICBbbWluX3UsIG1heF92XVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG51bV9wb2x5Z29ucyA9IHBvbHlnb25zLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHA9MDsgcCA8IG51bV9wb2x5Z29uczsgcCsrKSB7XHJcbiAgICAgICAgdmFyIHBvbHlnb24gPSBwb2x5Z29uc1twXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcT0wOyBxIDwgcG9seWdvbi5sZW5ndGg7IHErKykge1xyXG4gICAgICAgICAgICB2YXIgY29udG91ciA9IHBvbHlnb25bcV07XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciB3PTA7IHcgPCBjb250b3VyLmxlbmd0aCAtIDE7IHcrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gVHdvIHRyaWFuZ2xlcyBmb3IgdGhlIHF1YWQgZm9ybWVkIGJ5IGVhY2ggdmVydGV4IHBhaXIsIGdvaW5nIGZyb20gYm90dG9tIHRvIHRvcCBoZWlnaHRcclxuICAgICAgICAgICAgICAgIHZhciB3YWxsX3ZlcnRpY2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWFuZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbdysxXVswXSwgY29udG91clt3KzFdWzFdLCBtYXhfel0sXHJcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbdysxXVswXSwgY29udG91clt3KzFdWzFdLCBtaW5fel0sXHJcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbd11bMF0sIGNvbnRvdXJbd11bMV0sIG1pbl96XSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbmdsZVxyXG4gICAgICAgICAgICAgICAgICAgIFtjb250b3VyW3ddWzBdLCBjb250b3VyW3ddWzFdLCBtaW5fel0sXHJcbiAgICAgICAgICAgICAgICAgICAgW2NvbnRvdXJbd11bMF0sIGNvbnRvdXJbd11bMV0sIG1heF96XSxcclxuICAgICAgICAgICAgICAgICAgICBbY29udG91clt3KzFdWzBdLCBjb250b3VyW3crMV1bMV0sIG1heF96XVxyXG4gICAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxjIHRoZSBub3JtYWwgb2YgdGhlIHdhbGwgZnJvbSB1cCB2ZWN0b3IgYW5kIG9uZSBzZWdtZW50IG9mIHRoZSB3YWxsIHRyaWFuZ2xlc1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IFZlY3Rvci5jcm9zcyhcclxuICAgICAgICAgICAgICAgICAgICBbMCwgMCwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yLm5vcm1hbGl6ZShbY29udG91clt3KzFdWzBdIC0gY29udG91clt3XVswXSwgY29udG91clt3KzFdWzFdIC0gY29udG91clt3XVsxXSwgMF0pXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB2ZXJ0ZXggdGVtcGxhdGUgd2l0aCBjdXJyZW50IHN1cmZhY2Ugbm9ybWFsXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbbm9ybWFsX2luZGV4ICsgMF0gPSBub3JtYWxbMF07XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbbm9ybWFsX2luZGV4ICsgMV0gPSBub3JtYWxbMV07XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbbm9ybWFsX2luZGV4ICsgMl0gPSBub3JtYWxbMl07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd3Y9MDsgd3YgPCB3YWxsX3ZlcnRpY2VzLmxlbmd0aDsgd3YrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVswXSA9IHdhbGxfdmVydGljZXNbd3ZdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVsxXSA9IHdhbGxfdmVydGljZXNbd3ZdWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVsyXSA9IHdhbGxfdmVydGljZXNbd3ZdWzJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMF0gPSB0ZXhjb29yZHNbd3ZdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAxXSA9IHRleGNvb3Jkc1t3dl1bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8vIEJ1aWxkIHRlc3NlbGxhdGVkIHRyaWFuZ2xlcyBmb3IgYSBwb2x5bGluZVxyXG5CdWlsZGVycy5idWlsZFBvbHlsaW5lcyA9IGZ1bmN0aW9uIChcclxuICAgIGxpbmVzLFxyXG4gICAgd2lkdGgsXHJcbiAgICB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxyXG4gICAge1xyXG4gICAgICAgIGNsb3NlZF9wb2x5Z29uLFxyXG4gICAgICAgIHJlbW92ZV90aWxlX2VkZ2VzLFxyXG4gICAgICAgIHRpbGVfZWRnZV90b2xlcmFuY2UsXHJcbiAgICAgICAgdGV4Y29vcmRfaW5kZXgsXHJcbiAgICAgICAgdGV4Y29vcmRfc2NhbGUsXHJcbiAgICAgICAgc2NhbGluZ19pbmRleCxcclxuICAgICAgICBqb2luLCBjYXBcclxuICAgIH0pIHtcclxuXHJcbiAgICB2YXIgY29ybmVyc09uQ2FwID0gKGNhcCA9PT0gXCJzcXVhcmVcIik/IDIgOiAoKGNhcCA9PT0gXCJyb3VuZFwiKT8gNCA6IDApOyAgLy8gQnV0dCBpcyB0aGUgaW1wbGljaXQgZGVmYXVsdFxyXG4gICAgdmFyIHRyaWFuZ2xlc09uSm9pbiA9IChqb2luID09PSBcImJldmVsXCIpPyAxIDogKChqb2luID09PSBcInJvdW5kXCIpPyA1IDogMCk7ICAvLyBNaXRlciBpcyB0aGUgaW1wbGljaXQgZGVmYXVsdFxyXG5cclxuICAgIC8vIEJ1aWxkIHZhcmlhYmxlc1xyXG4gICAgdmFyIFtbbWluX3UsIG1pbl92XSwgW21heF91LCBtYXhfdl1dID0gdGV4Y29vcmRfc2NhbGUgfHwgW1swLCAwXSwgWzEsIDFdXTtcclxuXHJcbiAgICAvLyBWYWx1ZXMgdGhhdCBhcmUgY29uc3RhbnQgZm9yIGVhY2ggbGluZSBhbmQgYXJlIHBhc3NlZCB0byBoZWxwZXIgZnVuY3Rpb25zXHJcbiAgICB2YXIgY29uc3RhbnRzID0ge1xyXG4gICAgICAgIHZlcnRleF9kYXRhLFxyXG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZSxcclxuICAgICAgICBoYWxmV2lkdGg6IHdpZHRoLzIsXHJcbiAgICAgICAgdmVydGljZXM6IFtdLFxyXG4gICAgICAgIHNjYWxpbmdfaW5kZXgsXHJcbiAgICAgICAgc2NhbGluZ1ZlY3M6IHNjYWxpbmdfaW5kZXggJiYgW10sXHJcbiAgICAgICAgdGV4Y29vcmRfaW5kZXgsXHJcbiAgICAgICAgdGV4Y29vcmRzOiB0ZXhjb29yZF9pbmRleCAmJiBbXSxcclxuICAgICAgICBtaW5fdSwgbWluX3YsIG1heF91LCBtYXhfdixcclxuICAgICAgICBuUGFpcnM6IDBcclxuICAgIH07XHJcblxyXG4gICAgZm9yICh2YXIgbG4gPSAwOyBsbiA8IGxpbmVzLmxlbmd0aDsgbG4rKykge1xyXG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbbG5dO1xyXG4gICAgICAgIHZhciBsaW5lU2l6ZSA9IGxpbmUubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBJZ25vcmUgbm9uLWxpbmVzXHJcbiAgICAgICAgaWYgKGxpbmVTaXplIDwgMikge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICBJbml0aWFsaXplIHZhcmlhYmxlc1xyXG4gICAgICAgIHZhciBjb29yZFByZXYgPSBbMCwgMF0sIC8vIFByZXZpb3VzIHBvaW50IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGNvb3JkQ3VyciA9IFswLCAwXSwgLy8gQ3VycmVudCBwb2ludCBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICBjb29yZE5leHQgPSBbMCwgMF07IC8vIE5leHQgcG9pbnQgY29vcmRpbmF0ZXNcclxuXHJcbiAgICAgICAgdmFyIG5vcm1QcmV2ID0gWzAsIDBdLCAgLy8gUmlnaHQgbm9ybWFsIHRvIHNlZ21lbnQgYmV0d2VlbiBwcmV2aW91cyBhbmQgY3VycmVudCBtX3BvaW50c1xyXG4gICAgICAgICAgICBub3JtQ3VyciA9IFswLCAwXSwgIC8vIFJpZ2h0IG5vcm1hbCBhdCBjdXJyZW50IHBvaW50LCBzY2FsZWQgZm9yIG1pdGVyIGpvaW50XHJcbiAgICAgICAgICAgIG5vcm1OZXh0ID0gWzAsIDBdOyAgLy8gUmlnaHQgbm9ybWFsIHRvIHNlZ21lbnQgYmV0d2VlbiBjdXJyZW50IGFuZCBuZXh0IG1fcG9pbnRzXHJcblxyXG4gICAgICAgIHZhciBpc1ByZXYgPSBmYWxzZSxcclxuICAgICAgICAgICAgaXNOZXh0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHZlcnRpY2VzIHRvIGJ1ZmZlciBhY29yZGluZyB0aGVpciBpbmRleFxyXG4gICAgICAgIGluZGV4UGFpcnMoY29uc3RhbnRzKTtcclxuXHJcbiAgICAgICAgLy8gRG8gdGhpcyB3aXRoIHRoZSByZXN0IChleGNlcHQgdGhlIGxhc3Qgb25lKVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZVNpemUgOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgbmV4dCBvbmU/XHJcbiAgICAgICAgICAgIGlzTmV4dCA9IGkrMSA8IGxpbmVTaXplO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzUHJldikge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwcmV2aXVzIG9uZSwgY29weSB0aGUgY3VycmVudCAocHJldmlvdXMpIHZhbHVlcyBvbiAqUHJldlxyXG4gICAgICAgICAgICAgICAgY29vcmRQcmV2ID0gY29vcmRDdXJyO1xyXG4gICAgICAgICAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKGNvb3JkUHJldiwgbGluZVtpXSkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDAgJiYgY2xvc2VkX3BvbHlnb24gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGlzIHRoZSBmaXJzdCBwb2ludCBhbmQgaXMgYSBjbG9zZSBwb2x5Z29uXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5lZWRUb0Nsb3NlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVfdGlsZV9lZGdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKEJ1aWxkZXJzLmlzT25UaWxlRWRnZShsaW5lW2ldLCBsaW5lW2xpbmVTaXplLTJdLCB7IHRpbGVfZWRnZV90b2xlcmFuY2UgfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZFRvQ2xvc2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5lZWRUb0Nsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRQcmV2ID0gbGluZVtsaW5lU2l6ZS0yXTtcclxuICAgICAgICAgICAgICAgICAgICBub3JtUHJldiA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnBlcnAoY29vcmRQcmV2LCBsaW5lW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNQcmV2ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXNzaWduIGN1cnJlbnQgY29vcmRpbmF0ZVxyXG4gICAgICAgICAgICBjb29yZEN1cnIgPSBsaW5lW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xyXG4gICAgICAgICAgICAgICAgY29vcmROZXh0ID0gbGluZVtpKzFdO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsb3NlZF9wb2x5Z29uID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyB0aGUgbGFzdCBwb2ludCBhIGNsb3NlIHBvbHlnb25cclxuICAgICAgICAgICAgICAgIGNvb3JkTmV4dCA9IGxpbmVbMV07XHJcbiAgICAgICAgICAgICAgICBpc05leHQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNOZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyBub3QgdGhlIGxhc3Qgb25lIGdldCBuZXh0IGNvb3JkaW5hdGVzIGFuZCBjYWxjdWxhdGUgdGhlIHJpZ2h0IG5vcm1hbFxyXG5cclxuICAgICAgICAgICAgICAgIG5vcm1OZXh0ID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZEN1cnIsIGNvb3JkTmV4dCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZV90aWxlX2VkZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJ1aWxkZXJzLmlzT25UaWxlRWRnZShjb29yZEN1cnIsIGNvb3JkTmV4dCwgeyB0aWxlX2VkZ2VfdG9sZXJhbmNlIH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZFByZXYsIGNvb3JkQ3VycikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRWZXJ0ZXhQYWlyKGNvb3JkQ3Vyciwgbm9ybUN1cnIsIGkvbGluZVNpemUsIGNvbnN0YW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMublBhaXJzKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHZlcnRpY2VzIHRvIGJ1ZmZlciBhY29yZGluZyB0aGVpciBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhQYWlycyhjb25zdGFudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJldiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vICBDb21wdXRlIGN1cnJlbnQgbm9ybWFsXHJcbiAgICAgICAgICAgIGlmIChpc1ByZXYpIHtcclxuICAgICAgICAgICAgICAgIC8vICBJZiB0aGVyZSBpcyBhIFBSRVZJVVMgLi4uXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGFuZCBhIE5FWFQgT05FLCBjb21wdXRlIHByZXZpdXMgYW5kIG5leHQgbm9ybWFscyAoc2NhbGVkIGJ5IHRoZSBhbmdsZSB3aXRoIHRoZSBsYXN0IHByZXYpXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5hZGQobm9ybVByZXYsIG5vcm1OZXh0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gMiAvICgxICsgTWF0aC5hYnMoVmVjdG9yLmRvdChub3JtUHJldiwgbm9ybUN1cnIpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybUN1cnIgPSBWZWN0b3IubXVsdChub3JtQ3VycixzY2FsZSpzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgdGhlcmUgaXMgTk9UIGEgTkVYVCBPTkUsIGNvcHkgdGhlIHByZXZpdXMgbmV4dCBvbmUgKHdoaWNoIGlzIHRoZSBjdXJyZW50IG9uZSlcclxuICAgICAgICAgICAgICAgICAgICBub3JtQ3VyciA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnBlcnAoY29vcmRQcmV2LCBjb29yZEN1cnIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGlzIE5PVCBhIFBSRVZJVVMgLi4uXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uIGFuZCBhIE5FWFQgT05FLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1OZXh0ID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3IucGVycChjb29yZEN1cnIsIGNvb3JkTmV4dCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1DdXJyID0gbm9ybU5leHQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLiBhbmQgTk9UIGEgTkVYVCBPTkUsIG5vdGhpbmcgdG8gZG8gKHdpdGhvdXQgcHJldiBvciBuZXh0IG9uZSB0aGlzIGlzIGp1c3QgYSBwb2ludClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlzUHJldiB8fCBpc05leHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGlzIHRoZSBCRUdJTklORyBvZiBhIExJTkVcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmICFpc1ByZXYgJiYgIWNsb3NlZF9wb2x5Z29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2FwKGNvb3JkQ3Vyciwgbm9ybUN1cnIsIGNvcm5lcnNPbkNhcCwgdHJ1ZSwgY29uc3RhbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyBhIEpPSU5cclxuICAgICAgICAgICAgICAgIGlmKHRyaWFuZ2xlc09uSm9pbiAhPT0gMCAmJiBpc1ByZXYgJiYgaXNOZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkSm9pbihbY29vcmRQcmV2LCBjb29yZEN1cnIsIGNvb3JkTmV4dF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbm9ybVByZXYsbm9ybUN1cnIsIG5vcm1OZXh0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkvbGluZVNpemUsIHRyaWFuZ2xlc09uSm9pbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFZlcnRleFBhaXIoY29vcmRDdXJyLCBub3JtQ3VyciwgaS8obGluZVNpemUtMSksIGNvbnN0YW50cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLm5QYWlycysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlzUHJldiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCB2ZXJ0aWNlcyB0byBidWZmZXIgYWNvcmRpbmcgdGhlaXIgaW5kZXhcclxuICAgICAgICBpbmRleFBhaXJzKGNvbnN0YW50cyk7XHJcblxyXG4gICAgICAgICAvLyBJZiBpcyB0aGUgRU5EIE9GIGEgTElORVxyXG4gICAgICAgIGlmKCFjbG9zZWRfcG9seWdvbikge1xyXG4gICAgICAgICAgICBhZGRDYXAoY29vcmRDdXJyLCBub3JtQ3VyciwgY29ybmVyc09uQ2FwICwgZmFsc2UsIGNvbnN0YW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gQWRkIHRvIGVxdWlkaXN0YW50IHBhaXJzIG9mIHZlcnRpY2VzIChpbnRlcm5hbCBtZXRob2QgZm9yIHBvbHlsaW5lIGJ1aWxkZXIpXHJcbmZ1bmN0aW9uIGFkZFZlcnRleChjb29yZCwgbm9ybWFsLCB1diwgeyBoYWxmV2lkdGgsIHZlcnRpY2VzLCBzY2FsaW5nVmVjcywgdGV4Y29vcmRzIH0pIHtcclxuICAgIGlmIChzY2FsaW5nVmVjcykge1xyXG4gICAgICAgIC8vICBhLiBJZiBzY2FsaW5nIGlzIG9uIGFkZCB0aGUgdmVydGV4ICh0aGUgY3VyckNvb3JkKSBhbmQgdGhlIHNjYWxpbmcgVmVjcyAobm9ybWFscyBwb2ludGluZyB3aGVyZSB0byBleHRydWRlIHRoZSB2ZXJ0ZXhlcylcclxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKGNvb3JkKTtcclxuICAgICAgICBzY2FsaW5nVmVjcy5wdXNoKG5vcm1hbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vICBiLiBBZGQgdGhlIGV4dHJ1ZGVkIHZlcnRleGVzXHJcbiAgICAgICAgdmVydGljZXMucHVzaChbY29vcmRbMF0gKyBub3JtYWxbMF0gKiBoYWxmV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgY29vcmRbMV0gKyBub3JtYWxbMV0gKiBoYWxmV2lkdGhdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjKSBBZGQgdXYncyBpZiB0aGV5IGFyZSBlbmFibGVcclxuICAgIGlmICh0ZXhjb29yZHMpIHtcclxuICAgICAgICB0ZXhjb29yZHMucHVzaCh1dik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vICBBZGQgdG8gZXF1aWRpc3RhbnQgcGFpcnMgb2YgdmVydGljZXMgKGludGVybmFsIG1ldGhvZCBmb3IgcG9seWxpbmUgYnVpbGRlcilcclxuZnVuY3Rpb24gYWRkVmVydGV4UGFpciAoY29vcmQsIG5vcm1hbCwgdl9wY3QsIGNvbnN0YW50cykge1xyXG4gICAgYWRkVmVydGV4KGNvb3JkLCBub3JtYWwsIFtjb25zdGFudHMubWF4X3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdLCBjb25zdGFudHMpO1xyXG4gICAgYWRkVmVydGV4KGNvb3JkLCBWZWN0b3IubmVnKG5vcm1hbCksIFtjb25zdGFudHMubWluX3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdLCBjb25zdGFudHMpO1xyXG59XHJcblxyXG4vLyAgVGVzc2FsYXRlIGEgRkFOIGdlb21ldHJ5IGJldHdlZW4gcG9pbnRzIEEgICAgICAgQlxyXG4vLyAgdXNpbmcgdGhlaXIgbm9ybWFscyBmcm9tIGEgY2VudGVyICAgICAgICBcXCAuIC4gL1xyXG4vLyAgYW5kIGludGVycG9sYXRpbmcgdGhlaXIgVVZzICAgICAgICAgICAgICAgXFwgcCAvXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFwuL1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDXHJcbmZ1bmN0aW9uIGFkZEZhbiAoY29vcmQsIG5BLCBuQywgbkIsIHVBLCB1QywgdUIsIHNpZ25lZCwgbnVtVHJpYW5nbGVzLCBjb25zdGFudHMpIHtcclxuXHJcbiAgICBpZiAobnVtVHJpYW5nbGVzIDwgMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgcHJldml1cyB2ZXJ0aWNlcyB0byBidWZmZXIgYW5kIGNsZWFuIHRoZSBidWZmZXJzIGFuZCBpbmRleCBwYWlyc1xyXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gYWRkIG1vcmUgdHJpYW5nbGVzLlxyXG4gICAgaW5kZXhQYWlycyhjb25zdGFudHMpO1xyXG5cclxuICAgIHZhciBub3JtQ3VyciA9IFZlY3Rvci5zZXQobkEpO1xyXG4gICAgdmFyIG5vcm1QcmV2ID0gWzAsMF07XHJcblxyXG4gICAgdmFyIGFuZ2xlX2RlbHRhID0gVmVjdG9yLmRvdChuQSwgbkIpO1xyXG4gICAgaWYgKGFuZ2xlX2RlbHRhIDwgLTEpIHtcclxuICAgICAgICBhbmdsZV9kZWx0YSA9IC0xO1xyXG4gICAgfVxyXG4gICAgYW5nbGVfZGVsdGEgPSBNYXRoLmFjb3MoYW5nbGVfZGVsdGEpL251bVRyaWFuZ2xlcztcclxuXHJcbiAgICBpZiAoIXNpZ25lZCkge1xyXG4gICAgICAgIGFuZ2xlX2RlbHRhICo9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB1dkN1cnIgPSBWZWN0b3Iuc2V0KHVBKTtcclxuICAgIHZhciB1dl9kZWx0YSA9IFZlY3Rvci5kaXYoVmVjdG9yLnN1Yih1Qix1QSksIG51bVRyaWFuZ2xlcyk7XHJcblxyXG4gICAgLy8gIEFkZCB0aGUgZmlyc3QgYW5kIENFTlRFUiB2ZXJ0ZXhcclxuICAgIC8vICBUaGUgdHJpYW5nbGVzIHdpbGwgYmUgY29tcG9zZWQgb24gRkFOIHN0eWxlIGFycm91bmQgaXRcclxuICAgIGFkZFZlcnRleChjb29yZCwgbkMsIHVDLCBjb25zdGFudHMpO1xyXG5cclxuICAgIC8vICBBZGQgZmlyc3QgY29ybmVyXHJcbiAgICBhZGRWZXJ0ZXgoY29vcmQsIG5vcm1DdXJyLCB1QSwgY29uc3RhbnRzKTtcclxuXHJcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJlc3Qgb2YgdGhlIGNvb3JuZXJzXHJcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRyaWFuZ2xlczsgdCsrKSB7XHJcbiAgICAgICAgbm9ybVByZXYgPSBWZWN0b3Iubm9ybWFsaXplKG5vcm1DdXJyKTtcclxuICAgICAgICBub3JtQ3VyciA9IFZlY3Rvci5yb3QoIFZlY3Rvci5ub3JtYWxpemUobm9ybUN1cnIpLCBhbmdsZV9kZWx0YSk7ICAgICAvLyAgUm90YXRlIHRoZSBleHRydXNpb24gbm9ybWFsXHJcblxyXG4gICAgICAgIGlmIChudW1UcmlhbmdsZXMgPT09IDQgJiYgKHQgPT09IDAgfHwgdCA9PT0gbnVtVHJpYW5nbGVzIC0gMikpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlID0gMiAvICgxICsgTWF0aC5hYnMoVmVjdG9yLmRvdChub3JtUHJldiwgbm9ybUN1cnIpKSk7XHJcbiAgICAgICAgICAgIG5vcm1DdXJyID0gVmVjdG9yLm11bHQobm9ybUN1cnIsIHNjYWxlKnNjYWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHV2Q3VyciA9IFZlY3Rvci5hZGQodXZDdXJyLHV2X2RlbHRhKTtcclxuXHJcbiAgICAgICAgYWRkVmVydGV4KGNvb3JkLCBub3JtQ3VyciwgdXZDdXJyLCBjb25zdGFudHMpOyAgICAgIC8vICBBZGQgY29tcHV0ZWQgY29ybmVyXHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UcmlhbmdsZXM7IGkrKykge1xyXG4gICAgICAgIGlmIChzaWduZWQpIHtcclxuICAgICAgICAgICAgYWRkSW5kZXgoaSsyLCBjb25zdGFudHMpO1xyXG4gICAgICAgICAgICBhZGRJbmRleCgwLCBjb25zdGFudHMpO1xyXG4gICAgICAgICAgICBhZGRJbmRleChpKzEsIGNvbnN0YW50cyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYWRkSW5kZXgoaSsxLCBjb25zdGFudHMpO1xyXG4gICAgICAgICAgICBhZGRJbmRleCgwLCBjb25zdGFudHMpO1xyXG4gICAgICAgICAgICBhZGRJbmRleChpKzIsIGNvbnN0YW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENsZWFuIHRoZSBidWZmZXJcclxuICAgIGNvbnN0YW50cy52ZXJ0aWNlcyA9IFtdO1xyXG4gICAgaWYgKGNvbnN0YW50cy5zY2FsaW5nVmVjcykge1xyXG4gICAgICAgIGNvbnN0YW50cy5zY2FsaW5nVmVjcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbnN0YW50cy50ZXhjb29yZHMpIHtcclxuICAgICAgICBjb25zdGFudHMudGV4Y29vcmRzID0gW107XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vICBBZGQgc3BlY2NpYWxzIGpvaW5zIChub3QgbWl0ZXIpIHRpcGVzIHRoYXQgcmVxdWlyZSBGQU4gdGVzc2FsYXRpb25zXHJcbi8vICBVc2luZyB0aGlzICggaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vQXJ0aWNsZXMvMjI2NTY5L0RyYXdpbmctcG9seWxpbmVzLWJ5LXRlc3NlbGxhdGlvbiApIGFzIHJlZmVyZW5jZVxyXG5mdW5jdGlvbiBhZGRKb2luIChjb29yZHMsIG5vcm1hbHMsIHZfcGN0LCBuVHJpYW5nbGVzLCBjb25zdGFudHMpIHtcclxuXHJcbiAgICB2YXIgVCA9IFtWZWN0b3Iuc2V0KG5vcm1hbHNbMF0pLCBWZWN0b3Iuc2V0KG5vcm1hbHNbMV0pLCBWZWN0b3Iuc2V0KG5vcm1hbHNbMl0pXTtcclxuICAgIHZhciBzaWduZWQgPSBWZWN0b3Iuc2lnbmVkX2FyZWEoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSkgPiAwO1xyXG5cclxuICAgIHZhciBuQSA9IFRbMF0sICAgICAgICAgICAgICAvLyBub3JtYWwgdG8gcG9pbnQgQSAoYVQpXHJcbiAgICAgICAgbkMgPSBWZWN0b3IubmVnKFRbMV0pLCAgLy8gbm9ybWFsIHRvIGNlbnRlciAoLXZQKVxyXG4gICAgICAgIG5CID0gVFsyXTsgICAgICAgICAgICAgIC8vIG5vcm1hbCB0byBwb2ludCBCIChiVClcclxuXHJcbiAgICB2YXIgdUEgPSBbY29uc3RhbnRzLm1heF91LCAoMS12X3BjdCkqY29uc3RhbnRzLm1pbl92ICsgdl9wY3QqY29uc3RhbnRzLm1heF92XSxcclxuICAgICAgICB1QyA9IFtjb25zdGFudHMubWluX3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdLFxyXG4gICAgICAgIHVCID0gW2NvbnN0YW50cy5tYXhfdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XHJcblxyXG4gICAgaWYgKHNpZ25lZCkge1xyXG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5BLCB1QSwgY29uc3RhbnRzKTtcclxuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQywgdUMsIGNvbnN0YW50cyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5BID0gVmVjdG9yLm5lZyhUWzBdKTtcclxuICAgICAgICBuQyA9IFRbMV07XHJcbiAgICAgICAgbkIgPSBWZWN0b3IubmVnKFRbMl0pO1xyXG4gICAgICAgIHVBID0gW2NvbnN0YW50cy5taW5fdSwgKDEtdl9wY3QpKmNvbnN0YW50cy5taW5fdiArIHZfcGN0KmNvbnN0YW50cy5tYXhfdl07XHJcbiAgICAgICAgdUMgPSBbY29uc3RhbnRzLm1heF91LCAoMS12X3BjdCkqY29uc3RhbnRzLm1pbl92ICsgdl9wY3QqY29uc3RhbnRzLm1heF92XTtcclxuICAgICAgICB1QiA9IFtjb25zdGFudHMubWluX3UsICgxLXZfcGN0KSpjb25zdGFudHMubWluX3YgKyB2X3BjdCpjb25zdGFudHMubWF4X3ZdO1xyXG4gICAgICAgIGFkZFZlcnRleChjb29yZHNbMV0sIG5DLCB1QywgY29uc3RhbnRzKTtcclxuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQSwgdUEsIGNvbnN0YW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRmFuKGNvb3Jkc1sxXSwgbkEsIG5DLCBuQiwgdUEsIHVDLCB1Qiwgc2lnbmVkLCBuVHJpYW5nbGVzLCBjb25zdGFudHMpO1xyXG5cclxuICAgIGlmIChzaWduZWQpIHtcclxuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQiwgdUIsIGNvbnN0YW50cyk7XHJcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkMsIHVDLCBjb25zdGFudHMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBhZGRWZXJ0ZXgoY29vcmRzWzFdLCBuQywgdUMsIGNvbnN0YW50cyk7XHJcbiAgICAgICAgYWRkVmVydGV4KGNvb3Jkc1sxXSwgbkIsIHVCLCBjb25zdGFudHMpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyAgRnVuY3Rpb24gdG8gYWRkIHRoZSB2ZXJ0ZXggbmVlZCBmb3IgbGluZSBjYXBzLFxyXG4vLyAgYmVjYXVzZSByZS11c2UgdGhlIGJ1ZmZlcnMgbmVlZHMgdG8gYmUgYXQgdGhlIGVuZFxyXG5mdW5jdGlvbiBhZGRDYXAgKGNvb3JkLCBub3JtYWwsIG51bUNvcm5lcnMsIGlzQmVnaW5uaW5nLCBjb25zdGFudHMpIHtcclxuXHJcbiAgICBpZiAobnVtQ29ybmVycyA8IDEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVVZzXHJcbiAgICB2YXIgdXZBID0gW2NvbnN0YW50cy5taW5fdSxjb25zdGFudHMubWluX3ZdLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlZ2luaW5nIGFuZ2xlIFVWc1xyXG4gICAgICAgIHV2QyA9IFtjb25zdGFudHMubWluX3UrKGNvbnN0YW50cy5tYXhfdS1jb25zdGFudHMubWluX3UpLzIsIGNvbnN0YW50cy5taW5fdl0sICAgLy8gY2VudGVyIHBvaW50IFVWc1xyXG4gICAgICAgIHV2QiA9IFtjb25zdGFudHMubWF4X3UsY29uc3RhbnRzLm1pbl92XTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmRpbmcgYW5nbGUgVVZzXHJcblxyXG4gICAgaWYgKCFpc0JlZ2lubmluZykge1xyXG4gICAgICAgIHV2QSA9IFtjb25zdGFudHMubWluX3UsY29uc3RhbnRzLm1heF92XSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWdpbmluZyBhbmdsZSBVVnNcclxuICAgICAgICB1dkMgPSBbY29uc3RhbnRzLm1pbl91Kyhjb25zdGFudHMubWF4X3UtY29uc3RhbnRzLm1pbl91KS8yLCBjb25zdGFudHMubWF4X3ZdLCAgIC8vIGNlbnRlciBwb2ludCBVVnNcclxuICAgICAgICB1dkIgPSBbY29uc3RhbnRzLm1heF91LGNvbnN0YW50cy5tYXhfdl07XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRmFuKCBjb29yZCxcclxuICAgICAgICAgICAgVmVjdG9yLm5lZyhub3JtYWwpLCBbMCwgMF0sIG5vcm1hbCxcclxuICAgICAgICAgICAgdXZBLCB1dkMsIHV2QixcclxuICAgICAgICAgICAgaXNCZWdpbm5pbmcsIG51bUNvcm5lcnMqMiwgY29uc3RhbnRzKTtcclxufVxyXG5cclxuLy8gQWRkIGEgdmVydGV4IGJhc2VkIG9uIHRoZSBpbmRleCBwb3NpdGlvbiBpbnRvIHRoZSBWQk8gKGludGVybmFsIG1ldGhvZCBmb3IgcG9seWxpbmUgYnVpbGRlcilcclxuZnVuY3Rpb24gYWRkSW5kZXggKGluZGV4LCB7IHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsIGhhbGZXaWR0aCwgdmVydGljZXMsIHNjYWxpbmdfaW5kZXgsIHNjYWxpbmdWZWNzLCB0ZXhjb29yZF9pbmRleCwgdGV4Y29vcmRzIH0pIHtcclxuICAgIC8vIFByZXZlbnQgYWNjZXNzIHRvIHVuZGVmaW5lZCB2ZXJ0aWNlc1xyXG4gICAgaWYgKGluZGV4ID49IHZlcnRpY2VzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgdmVydGV4IHBvc2l0aW9uXHJcbiAgICB2ZXJ0ZXhfdGVtcGxhdGVbMF0gPSB2ZXJ0aWNlc1tpbmRleF1bMF07XHJcbiAgICB2ZXJ0ZXhfdGVtcGxhdGVbMV0gPSB2ZXJ0aWNlc1tpbmRleF1bMV07XHJcblxyXG4gICAgLy8gc2V0IFVWc1xyXG4gICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XHJcbiAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMF0gPSB0ZXhjb29yZHNbaW5kZXhdWzBdO1xyXG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZVt0ZXhjb29yZF9pbmRleCArIDFdID0gdGV4Y29vcmRzW2luZGV4XVsxXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgU2NhbGluZyB2ZXJ0ZXggKFgsIFkgbm9ybWFsIGRpcmVjdGlvbiArIFogaGFsdHdpZHRoIGFzIGF0dHJpYnV0ZSlcclxuICAgIGlmIChzY2FsaW5nX2luZGV4KSB7XHJcbiAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAwXSA9IHNjYWxpbmdWZWNzW2luZGV4XVswXTtcclxuICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDFdID0gc2NhbGluZ1ZlY3NbaW5kZXhdWzFdO1xyXG4gICAgICAgIHZlcnRleF90ZW1wbGF0ZVtzY2FsaW5nX2luZGV4ICsgMl0gPSBoYWxmV2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gIEFkZCB2ZXJ0ZXggdG8gVkJPXHJcbiAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcclxufVxyXG5cclxuLy8gQWRkIHRoZSBpbmRleCB2ZXJ0ZXggdG8gdGhlIFZCTyBhbmQgY2xlYW4gdGhlIGJ1ZmZlcnNcclxuZnVuY3Rpb24gaW5kZXhQYWlycyAoY29uc3RhbnRzKSB7XHJcbiAgICAvLyBBZGQgdmVydGljZXMgdG8gYnVmZmVyIGFjb3JkaW5nIHRoZWlyIGluZGV4XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0YW50cy5uUGFpcnM7IGkrKykge1xyXG4gICAgICAgIGFkZEluZGV4KDIqaSsyLCBjb25zdGFudHMpO1xyXG4gICAgICAgIGFkZEluZGV4KDIqaSsxLCBjb25zdGFudHMpO1xyXG4gICAgICAgIGFkZEluZGV4KDIqaSswLCBjb25zdGFudHMpO1xyXG5cclxuICAgICAgICBhZGRJbmRleCgyKmkrMiwgY29uc3RhbnRzKTtcclxuICAgICAgICBhZGRJbmRleCgyKmkrMywgY29uc3RhbnRzKTtcclxuICAgICAgICBhZGRJbmRleCgyKmkrMSwgY29uc3RhbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdGFudHMublBhaXJzID0gMDtcclxuXHJcbiAgICAvLyBDbGVhbiB0aGUgYnVmZmVyXHJcbiAgICBjb25zdGFudHMudmVydGljZXMgPSBbXTtcclxuICAgIGlmIChjb25zdGFudHMuc2NhbGluZ1ZlY3MpIHtcclxuICAgICAgICBjb25zdGFudHMuc2NhbGluZ1ZlY3MgPSBbXTtcclxuICAgIH1cclxuICAgIGlmIChjb25zdGFudHMudGV4Y29vcmRzKSB7XHJcbiAgICAgICAgY29uc3RhbnRzLnRleGNvb3JkcyA9IFtdO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBCdWlsZCBhIHF1YWQgY2VudGVyZWQgb24gYSBwb2ludFxyXG5CdWlsZGVycy5idWlsZFF1YWRzRm9yUG9pbnRzID0gZnVuY3Rpb24gKFxyXG4gICAgcG9pbnRzLCB3aWR0aCwgaGVpZ2h0LFxyXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcclxuICAgIHsgdGV4Y29vcmRfaW5kZXgsIHRleGNvb3JkX3NjYWxlIH0pIHtcclxuXHJcbiAgICBpZiAodGV4Y29vcmRfaW5kZXgpIHtcclxuICAgICAgICB2YXIgW1ttaW5fdSwgbWluX3ZdLCBbbWF4X3UsIG1heF92XV0gPSB0ZXhjb29yZF9zY2FsZSB8fCBbWzAsIDBdLCBbMSwgMV1dO1xyXG4gICAgICAgIHZhciB0ZXhjb29yZHMgPSBbXHJcbiAgICAgICAgICAgIFttaW5fdSwgbWluX3ZdLFxyXG4gICAgICAgICAgICBbbWF4X3UsIG1pbl92XSxcclxuICAgICAgICAgICAgW21heF91LCBtYXhfdl0sXHJcblxyXG4gICAgICAgICAgICBbbWluX3UsIG1pbl92XSxcclxuICAgICAgICAgICAgW21heF91LCBtYXhfdl0sXHJcbiAgICAgICAgICAgIFttaW5fdSwgbWF4X3ZdXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbnVtX3BvaW50cyA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBwPTA7IHAgPCBudW1fcG9pbnRzOyBwKyspIHtcclxuICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbcF07XHJcblxyXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbXHJcbiAgICAgICAgICAgIFtwb2ludFswXSAtIHdpZHRoLzIsIHBvaW50WzFdIC0gaGVpZ2h0LzJdLFxyXG4gICAgICAgICAgICBbcG9pbnRbMF0gKyB3aWR0aC8yLCBwb2ludFsxXSAtIGhlaWdodC8yXSxcclxuICAgICAgICAgICAgW3BvaW50WzBdICsgd2lkdGgvMiwgcG9pbnRbMV0gKyBoZWlnaHQvMl0sXHJcblxyXG4gICAgICAgICAgICBbcG9pbnRbMF0gLSB3aWR0aC8yLCBwb2ludFsxXSAtIGhlaWdodC8yXSxcclxuICAgICAgICAgICAgW3BvaW50WzBdICsgd2lkdGgvMiwgcG9pbnRbMV0gKyBoZWlnaHQvMl0sXHJcbiAgICAgICAgICAgIFtwb2ludFswXSAtIHdpZHRoLzIsIHBvaW50WzFdICsgaGVpZ2h0LzJdXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcG9zPTA7IHBvcyA8IDY7IHBvcysrKSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0ZXhjb29yZHNcclxuICAgICAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9IHRleGNvb3Jkc1twb3NdWzBdO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMV0gPSB0ZXhjb29yZHNbcG9zXVsxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzBdID0gcG9zaXRpb25zW3Bvc11bMF07XHJcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVsxXSA9IHBvc2l0aW9uc1twb3NdWzFdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBCdWlsZCBhIGJpbGxib2FyZCBzcHJpdGUgcXVhZCBjZW50ZXJlZCBvbiBhIHBvaW50LiBTcHJpdGVzIGFyZSBpbnRlbmRlZCB0byBiZSBkcmF3biBpbiBzY3JlZW5zcGFjZSwgYW5kIGhhdmVcclxuLy8gcHJvcGVydGllcyBmb3Igd2lkdGgsIGhlaWdodCwgYW5nbGUsIGFuZCBhIHNjYWxlIGZhY3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIGludGVycG9sYXRlIHRoZSBzY3JlZW5zcGFjZSBzaXplXHJcbi8vIG9mIGEgc3ByaXRlIGJldHdlZW4gdHdvIHpvb20gbGV2ZWxzLlxyXG5CdWlsZGVycy5idWlsZFNwcml0ZVF1YWRzRm9yUG9pbnRzID0gZnVuY3Rpb24gKFxyXG4gICAgcG9pbnRzLFxyXG4gICAgd2lkdGgsIGhlaWdodCwgYW5nbGUsIHNjYWxlLFxyXG4gICAgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSxcclxuICAgIHNjYWxpbmdfaW5kZXgsXHJcbiAgICB7IHRleGNvb3JkX2luZGV4LCB0ZXhjb29yZF9zY2FsZSB9KSB7XHJcblxyXG4gICAgbGV0IHcyID0gd2lkdGggLyAyO1xyXG4gICAgbGV0IGgyID0gaGVpZ2h0IC8gMjtcclxuICAgIGxldCBzY2FsaW5nID0gW1xyXG4gICAgICAgIFstdzIsIC1oMl0sXHJcbiAgICAgICAgW3cyLCAtaDJdLFxyXG4gICAgICAgIFt3MiwgaDJdLFxyXG5cclxuICAgICAgICBbLXcyLCAtaDJdLFxyXG4gICAgICAgIFt3MiwgaDJdLFxyXG4gICAgICAgIFstdzIsIGgyXVxyXG4gICAgXTtcclxuXHJcbiAgICBsZXQgW1ttaW5fdSwgbWluX3ZdLCBbbWF4X3UsIG1heF92XV0gPSB0ZXhjb29yZF9zY2FsZSB8fCBbWzAsIDBdLCBbMSwgMV1dO1xyXG4gICAgbGV0IHRleGNvb3JkcztcclxuICAgIGlmICh0ZXhjb29yZF9pbmRleCkge1xyXG4gICAgICAgIHRleGNvb3JkcyA9IFtcclxuICAgICAgICAgICAgW21pbl91LCBtaW5fdl0sXHJcbiAgICAgICAgICAgIFttYXhfdSwgbWluX3ZdLFxyXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcclxuXHJcbiAgICAgICAgICAgIFttaW5fdSwgbWluX3ZdLFxyXG4gICAgICAgICAgICBbbWF4X3UsIG1heF92XSxcclxuICAgICAgICAgICAgW21pbl91LCBtYXhfdl1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBudW1fcG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcclxuICAgIGZvciAobGV0IHA9MDsgcCA8IG51bV9wb2ludHM7IHArKykge1xyXG4gICAgICAgIGxldCBwb2ludCA9IHBvaW50c1twXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgcG9zPTA7IHBvcyA8IDY7IHBvcysrKSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0ZXhjb29yZHNcclxuICAgICAgICAgICAgaWYgKHRleGNvb3JkX2luZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbdGV4Y29vcmRfaW5kZXggKyAwXSA9IHRleGNvb3Jkc1twb3NdWzBdO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3RleGNvb3JkX2luZGV4ICsgMV0gPSB0ZXhjb29yZHNbcG9zXVsxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlWzBdID0gcG9pbnRbMF07XHJcbiAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZVsxXSA9IHBvaW50WzFdO1xyXG5cclxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAwXSA9IHNjYWxpbmdbcG9zXVswXTtcclxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAxXSA9IHNjYWxpbmdbcG9zXVsxXTtcclxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlW3NjYWxpbmdfaW5kZXggKyAyXSA9IGFuZ2xlO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhfdGVtcGxhdGVbc2NhbGluZ19pbmRleCArIDNdID0gc2NhbGU7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YS5hZGRWZXJ0ZXgodmVydGV4X3RlbXBsYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyogVXRpbGl0eSBmdW5jdGlvbnMgKi9cclxuXHJcbi8vIFRyaWFuZ3VsYXRpb24gdXNpbmcgZWFyY3V0XHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0XHJcbkJ1aWxkZXJzLnRyaWFuZ3VsYXRlUG9seWdvbiA9IGZ1bmN0aW9uIChjb250b3Vycylcclxue1xyXG4gICAgcmV0dXJuIGVhcmN1dChjb250b3Vycyk7XHJcbn07XHJcblxyXG4vLyBUZXN0cyBpZiBhIGxpbmUgc2VnbWVudCAoZnJvbSBwb2ludCBBIHRvIEIpIGlzIG5lYXJseSBjb2luY2lkZW50IHdpdGggdGhlIGVkZ2Ugb2YgYSB0aWxlXHJcbkJ1aWxkZXJzLmlzT25UaWxlRWRnZSA9IGZ1bmN0aW9uIChwYSwgcGIsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIHZhciB0b2xlcmFuY2VfZnVuY3Rpb24gPSBvcHRpb25zLnRvbGVyYW5jZV9mdW5jdGlvbiB8fCBCdWlsZGVycy52YWx1ZXNXaXRoaW5Ub2xlcmFuY2U7XHJcbiAgICB2YXIgdG9sZXJhbmNlID0gb3B0aW9ucy50b2xlcmFuY2UgfHwgMzsgLy8gdHdlYWsgdGhpcyBhZGp1c3QgaWYgY2F0Y2hpbmcgdG9vIGZldy9tYW55IGxpbmUgc2VnbWVudHMgbmVhciB0aWxlIGVkZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogbWFrZSB0b2xlcmFuY2UgY29uZmlndXJhYmxlIGJ5IHNvdXJjZSBpZiBuZWNlc3NhcnlcclxuICAgIHZhciB0aWxlX21pbiA9IEJ1aWxkZXJzLnRpbGVfYm91bmRzWzBdO1xyXG4gICAgdmFyIHRpbGVfbWF4ID0gQnVpbGRlcnMudGlsZV9ib3VuZHNbMV07XHJcbiAgICB2YXIgZWRnZSA9IG51bGw7XHJcblxyXG4gICAgaWYgKHRvbGVyYW5jZV9mdW5jdGlvbihwYVswXSwgdGlsZV9taW4ueCwgdG9sZXJhbmNlKSAmJiB0b2xlcmFuY2VfZnVuY3Rpb24ocGJbMF0sIHRpbGVfbWluLngsIHRvbGVyYW5jZSkpIHtcclxuICAgICAgICBlZGdlID0gJ2xlZnQnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodG9sZXJhbmNlX2Z1bmN0aW9uKHBhWzBdLCB0aWxlX21heC54LCB0b2xlcmFuY2UpICYmIHRvbGVyYW5jZV9mdW5jdGlvbihwYlswXSwgdGlsZV9tYXgueCwgdG9sZXJhbmNlKSkge1xyXG4gICAgICAgIGVkZ2UgPSAncmlnaHQnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodG9sZXJhbmNlX2Z1bmN0aW9uKHBhWzFdLCB0aWxlX21pbi55LCB0b2xlcmFuY2UpICYmIHRvbGVyYW5jZV9mdW5jdGlvbihwYlsxXSwgdGlsZV9taW4ueSwgdG9sZXJhbmNlKSkge1xyXG4gICAgICAgIGVkZ2UgPSAndG9wJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRvbGVyYW5jZV9mdW5jdGlvbihwYVsxXSwgdGlsZV9tYXgueSwgdG9sZXJhbmNlKSAmJiB0b2xlcmFuY2VfZnVuY3Rpb24ocGJbMV0sIHRpbGVfbWF4LnksIHRvbGVyYW5jZSkpIHtcclxuICAgICAgICBlZGdlID0gJ2JvdHRvbSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWRnZTtcclxufTtcclxuXHJcbkJ1aWxkZXJzLnNldFRpbGVTY2FsZSA9IGZ1bmN0aW9uIChzY2FsZSkge1xyXG4gICAgQnVpbGRlcnMudGlsZV9ib3VuZHMgPSBbXHJcbiAgICAgICAgeyB4OiAwLCB5OiAwfSxcclxuICAgICAgICB7IHg6IHNjYWxlLCB5OiAtc2NhbGUgfSAvLyBUT0RPOiBjb3JyZWN0IGZvciBmbGlwcGVkIHktYXhpcz9cclxuICAgIF07XHJcbn07XHJcblxyXG5CdWlsZGVycy52YWx1ZXNXaXRoaW5Ub2xlcmFuY2UgPSBmdW5jdGlvbiAoYSwgYiwgdG9sZXJhbmNlKSB7XHJcbiAgICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgMTtcclxuICAgIHJldHVybiAoTWF0aC5hYnMoYSAtIGIpIDwgdG9sZXJhbmNlKTtcclxufTtcclxuXHJcbi8vIEJ1aWxkIGEgemlnemFnIGxpbmUgcGF0dGVybiBmb3IgdGVzdGluZyBqb2lucyBhbmQgY2Fwc1xyXG5CdWlsZGVycy5idWlsZFppZ3phZ0xpbmVUZXN0UGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtaW4gPSB7IHg6IDAsIHk6IDB9OyAvLyAgdGlsZS5taW47XHJcbiAgICB2YXIgbWF4ID0geyB4OiA0MDk2LCB5OiA0MDk2IH07IC8vIHRpbGUubWF4O1xyXG5cclxuICAgIHZhciBnID0ge1xyXG4gICAgICAgIGlkOiAxMjMsXHJcbiAgICAgICAgZ2VvbWV0cnk6IHtcclxuICAgICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxyXG4gICAgICAgICAgICBjb29yZGluYXRlczogW1xyXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC43NSArIG1heC54ICogMC4yNSwgbWluLnkgKiAwLjc1ICsgbWF4LnkgKiAwLjI1XSxcclxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuNzUgKyBtYXgueCAqIDAuMjUsIG1pbi55ICogMC41ICsgbWF4LnkgKiAwLjVdLFxyXG4gICAgICAgICAgICAgICAgW21pbi54ICogMC4yNSArIG1heC54ICogMC43NSwgbWluLnkgKiAwLjc1ICsgbWF4LnkgKiAwLjI1XSxcclxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuMjUgKyBtYXgueCAqIDAuNzUsIG1pbi55ICogMC4yNSArIG1heC55ICogMC43NV0sXHJcbiAgICAgICAgICAgICAgICBbbWluLnggKiAwLjQgKyBtYXgueCAqIDAuNiwgbWluLnkgKiAwLjUgKyBtYXgueSAqIDAuNV0sXHJcbiAgICAgICAgICAgICAgICBbbWluLnggKiAwLjUgKyBtYXgueCAqIDAuNSwgbWluLnkgKiAwLjI1ICsgbWF4LnkgKiAwLjc1XSxcclxuICAgICAgICAgICAgICAgIFttaW4ueCAqIDAuNzUgKyBtYXgueCAqIDAuMjUsIG1pbi55ICogMC4yNSArIG1heC55ICogMC43NV0sXHJcbiAgICAgICAgICAgICAgICBbbWluLnggKiAwLjc1ICsgbWF4LnggKiAwLjI1LCBtaW4ueSAqIDAuNCArIG1heC55ICogMC42XVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgIGtpbmQ6ICdkZWJ1ZydcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGc7XHJcbn07XHJcbiIsIi8vIExpbmUgcmVuZGVyaW5nIHN0eWxlXHJcblxyXG5pbXBvcnQge1N0eWxlfSBmcm9tICcuLi9zdHlsZSc7XHJcbmltcG9ydCB7U3R5bGVQYXJzZXJ9IGZyb20gJy4uL3N0eWxlX3BhcnNlcic7XHJcbmltcG9ydCBnbCBmcm9tICcuLi8uLi9nbC9jb25zdGFudHMnOyAvLyB3ZWIgd29ya2VycyBkb24ndCBoYXZlIGFjY2VzcyB0byBHTCBjb250ZXh0LCBzbyBpbXBvcnQgYWxsIEdMIGNvbnN0YW50c1xyXG5pbXBvcnQgVmVydGV4TGF5b3V0IGZyb20gJy4uLy4uL2dsL3ZlcnRleF9sYXlvdXQnO1xyXG5pbXBvcnQgQnVpbGRlcnMgZnJvbSAnLi4vYnVpbGRlcnMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xyXG5cclxuZXhwb3J0IHZhciBMaW5lcyA9IE9iamVjdC5jcmVhdGUoU3R5bGUpO1xyXG5cclxuT2JqZWN0LmFzc2lnbihMaW5lcywge1xyXG4gICAgbmFtZTogJ2xpbmVzJyxcclxuICAgIGJ1aWx0X2luOiB0cnVlLFxyXG4gICAgdmVydGV4X3NoYWRlcl9rZXk6ICdzdHlsZXMvcG9seWdvbnMvcG9seWdvbnNfdmVydGV4JywgLy8gcmUtdXNlIHBvbHlnb24gc2hhZGVyc1xyXG4gICAgZnJhZ21lbnRfc2hhZGVyX2tleTogJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc19mcmFnbWVudCcsXHJcbiAgICBzZWxlY3Rpb246IHRydWUsXHJcblxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICBTdHlsZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgd29ybGQgY29vcmRzIHRvIHdyYXAgZXZlcnkgMTAwLDAwMCBtZXRlcnMsIGNhbiB0dXJuIG9mZiBieSBzZXR0aW5nIHRoaXMgdG8gJ2ZhbHNlJ1xyXG4gICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1dPUkxEX1BPU0lUSU9OX1dSQVAgPSAxMDAwMDA7XHJcblxyXG4gICAgICAgIC8vIEJhc2ljIGF0dHJpYnV0ZXMsIG90aGVycyBjYW4gYmUgYWRkZWQgKHNlZSB0ZXh0dXJlIFVWcyBiZWxvdylcclxuICAgICAgICB2YXIgYXR0cmlicyA9IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYV9wb3NpdGlvbicsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2V4dHJ1ZGUnLCBzaXplOiAzLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYV9zY2FsZScsIHNpemU6IDIsIHR5cGU6IGdsLlNIT1JULCBub3JtYWxpemVkOiB0cnVlIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfY29sb3InLCBzaXplOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemVkOiB0cnVlIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2Ffc2VsZWN0aW9uX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2xheWVyJywgc2l6ZTogMSwgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH1cclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvLyBUZWxsIHRoZSBzaGFkZXIgd2Ugd2FudCBhbiBvcmRlciBhdHRyaWJ1dGUsIGFuZCB0byBleHRydWRlIGxpbmVzXHJcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fT1JERVJfQVRUUklCVVRFID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9FWFRSVURFX0xJTkVTID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gT3B0aW9uYWwgdGV4dHVyZSBVVnNcclxuICAgICAgICBpZiAodGhpcy50ZXhjb29yZHMpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fVEVYVFVSRV9DT09SRFMgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHZlcnRleCBhdHRyaWJ1dGUgZm9yIFVWcyBvbmx5IHdoZW4gbmVlZGVkXHJcbiAgICAgICAgICAgIGF0dHJpYnMucHVzaCh7IG5hbWU6ICdhX3RleGNvb3JkJywgc2l6ZTogMiwgdHlwZTogZ2wuRkxPQVQsIG5vcm1hbGl6ZWQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhfbGF5b3V0ID0gbmV3IFZlcnRleExheW91dChhdHRyaWJzKTtcclxuICAgIH0sXHJcblxyXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZmVhdHVyZV9zdHlsZTtcclxuXHJcbiAgICAgICAgc3R5bGUuY29sb3IgPSBydWxlX3N0eWxlLmNvbG9yICYmIFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IocnVsZV9zdHlsZS5jb2xvciwgY29udGV4dCk7XHJcbiAgICAgICAgc3R5bGUud2lkdGggPSBydWxlX3N0eWxlLndpZHRoICYmIFN0eWxlUGFyc2VyLnBhcnNlRGlzdGFuY2UocnVsZV9zdHlsZS53aWR0aCwgY29udGV4dCk7XHJcblxyXG4gICAgICAgIC8vIFNtb290aGx5IGludGVycG9sYXRlIGxpbmUgd2lkdGggYmV0d2VlbiB6b29tczogZ2V0IHNjYWxlIGZhY3RvcnMgdG8gcHJldmlvdXMgYW5kIG5leHQgem9vbXNcclxuICAgICAgICAvLyBBZGp1c3QgYnkgZmFjdG9yIG9mIDIgYmVjYXVzZSB0aWxlIHVuaXRzIGFyZSB6b29tLWRlcGVuZGVudCAoYSBnaXZlbiB2YWx1ZSBpcyB0d2ljZSBhc1xyXG4gICAgICAgIC8vIGJpZyBpbiB3b3JsZCBzcGFjZSBhdCB0aGUgbmV4dCB6b29tIHRoYW4gYXQgdGhlIHByZXZpb3VzKVxyXG4gICAgICAgIGNvbnRleHQuem9vbS0tO1xyXG4gICAgICAgIHN0eWxlLnByZXZfd2lkdGggPSBTdHlsZVBhcnNlci5wYXJzZURpc3RhbmNlKHJ1bGVfc3R5bGUud2lkdGgsIGNvbnRleHQpIC8gMjtcclxuICAgICAgICBzdHlsZS5wcmV2X3dpZHRoID0gVXRpbHMuc2NhbGVJbnQxNihzdHlsZS5wcmV2X3dpZHRoIC8gc3R5bGUud2lkdGgsIDI1Nik7XHJcbiAgICAgICAgY29udGV4dC56b29tICs9IDI7XHJcbiAgICAgICAgc3R5bGUubmV4dF93aWR0aCA9IFN0eWxlUGFyc2VyLnBhcnNlRGlzdGFuY2UocnVsZV9zdHlsZS53aWR0aCwgY29udGV4dCkgKiAyO1xyXG4gICAgICAgIHN0eWxlLm5leHRfd2lkdGggPSBVdGlscy5zY2FsZUludDE2KHN0eWxlLm5leHRfd2lkdGggLyBzdHlsZS53aWR0aCwgMjU2KTtcclxuICAgICAgICBjb250ZXh0Lnpvb20tLTtcclxuXHJcbiAgICAgICAgLy8gaGVpZ2h0IGRlZmF1bHRzIHRvIGZlYXR1cmUgaGVpZ2h0LCBidXQgZXh0cnVkZSBzdHlsZSBjYW4gZHluYW1pY2FsbHkgYWRqdXN0IGhlaWdodCBieSByZXR1cm5pbmcgYSBudW1iZXIgb3IgYXJyYXkgKGluc3RlYWQgb2YgYSBib29sZWFuKVxyXG4gICAgICAgIHN0eWxlLnogPSAocnVsZV9zdHlsZS56ICYmIFN0eWxlUGFyc2VyLnBhcnNlRGlzdGFuY2UocnVsZV9zdHlsZS56IHx8IDAsIGNvbnRleHQpKSB8fCBTdHlsZVBhcnNlci5kZWZhdWx0cy56O1xyXG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGZlYXR1cmUucHJvcGVydGllcy5oZWlnaHQgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuaGVpZ2h0O1xyXG4gICAgICAgIHN0eWxlLmV4dHJ1ZGUgPSBydWxlX3N0eWxlLmV4dHJ1ZGU7XHJcbiAgICAgICAgaWYgKHN0eWxlLmV4dHJ1ZGUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5leHRydWRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5leHRydWRlID0gc3R5bGUuZXh0cnVkZShjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5leHRydWRlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3R5bGUuZXh0cnVkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN0eWxlLmV4dHJ1ZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5leHRydWRlWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSYWlzZSBsaW5lIGhlaWdodCBpZiBleHRydWRlZFxyXG4gICAgICAgIGlmIChzdHlsZS5leHRydWRlICYmIHN0eWxlLmhlaWdodCkge1xyXG4gICAgICAgICAgICBzdHlsZS56ICs9IHN0eWxlLmhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0eWxlLmNhcCA9IHJ1bGVfc3R5bGUuY2FwO1xyXG4gICAgICAgIHN0eWxlLmpvaW4gPSBydWxlX3N0eWxlLmpvaW47XHJcbiAgICAgICAgc3R5bGUudGlsZV9lZGdlcyA9IHJ1bGVfc3R5bGUudGlsZV9lZGdlcztcclxuXHJcbiAgICAgICAgc3R5bGUub3V0bGluZSA9IHN0eWxlLm91dGxpbmUgfHwge307XHJcbiAgICAgICAgaWYgKHJ1bGVfc3R5bGUub3V0bGluZSkge1xyXG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLmNvbG9yID0gU3R5bGVQYXJzZXIucGFyc2VDb2xvcihydWxlX3N0eWxlLm91dGxpbmUuY29sb3IsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLndpZHRoID0gU3R5bGVQYXJzZXIucGFyc2VEaXN0YW5jZShydWxlX3N0eWxlLm91dGxpbmUud2lkdGgsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLmNhcCA9IHJ1bGVfc3R5bGUub3V0bGluZS5jYXAgfHwgcnVsZV9zdHlsZS5jYXA7XHJcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuam9pbiA9IHJ1bGVfc3R5bGUub3V0bGluZS5qb2luIHx8IHJ1bGVfc3R5bGUuam9pbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuY29sb3IgPSBudWxsO1xyXG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLndpZHRoID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHlsZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIFwidGVtcGxhdGVcIiB0aGF0IHNldHMgY29uc3RhbnQgYXR0aWJ1dGVzIGZvciBlYWNoIHZlcnRleCwgd2hpY2ggaXMgdGhlbiBtb2RpZmllZCBwZXIgdmVydGV4IG9yIHBlciBmZWF0dXJlLlxyXG4gICAgICogQSBwbGFpbiBKUyBhcnJheSBtYXRjaGluZyB0aGUgb3JkZXIgb2YgdGhlIHZlcnRleCBsYXlvdXQuXHJcbiAgICAgKi9cclxuICAgIG1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSkge1xyXG4gICAgICAgIC8vIFBsYWNlaG9sZGVyIHZhbHVlc1xyXG4gICAgICAgIHZhciBjb2xvciA9IHN0eWxlLmNvbG9yIHx8IFswLCAwLCAwLCAxXTtcclxuXHJcbiAgICAgICAgLy8gQmFzaWMgYXR0cmlidXRlcywgb3RoZXJzIGNhbiBiZSBhZGRlZCAoc2VlIHRleHR1cmUgVVZzIGJlbG93KVxyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IFtcclxuICAgICAgICAgICAgLy8gcG9zaXRpb24gLSB4ICYgeSBjb29yZHMgd2lsbCBiZSBmaWxsZWQgaW4gcGVyLXZlcnRleCBiZWxvd1xyXG4gICAgICAgICAgICAwLCAwLCBzdHlsZS56IHx8IDAsXHJcbiAgICAgICAgICAgIC8vIGV4dHJ1c2lvbiB2ZWN0b3JcclxuICAgICAgICAgICAgMCwgMCwgMCxcclxuICAgICAgICAgICAgLy8gc2NhbGluZyB0byBwcmV2aW91cyBhbmQgbmV4dCB6b29tXHJcbiAgICAgICAgICAgIHN0eWxlLnByZXZfd2lkdGgsIHN0eWxlLm5leHRfd2lkdGgsXHJcbiAgICAgICAgICAgIC8vIGNvbG9yXHJcbiAgICAgICAgICAgIC8vIFRPRE86IGF1dG9tYXRlIG11bHRpcGxpY2F0aW9uIGZvciBub3JtYWxpemVkIGF0dHJpYnM/XHJcbiAgICAgICAgICAgIGNvbG9yWzBdICogMjU1LCBjb2xvclsxXSAqIDI1NSwgY29sb3JbMl0gKiAyNTUsIGNvbG9yWzNdICogMjU1LFxyXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gY29sb3JcclxuICAgICAgICAgICAgc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzBdICogMjU1LCBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMV0gKiAyNTUsIHN0eWxlLnNlbGVjdGlvbl9jb2xvclsyXSAqIDI1NSwgc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzNdICogMjU1LFxyXG4gICAgICAgICAgICAvLyBkcmF3IG9yZGVyXHJcbiAgICAgICAgICAgIHN0eWxlLm9yZGVyXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRleHR1cmUgVVZzIHRvIHRlbXBsYXRlIG9ubHkgaWYgbmVlZGVkXHJcbiAgICAgICAgaWYgKHRoaXMudGV4Y29vcmRzKSB7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlLnB1c2goMCwgMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBidWlsZExpbmVzKGxpbmVzLCBzdHlsZSwgdmVydGV4X2RhdGEsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhfdGVtcGxhdGUgPSB0aGlzLm1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSk7XHJcblxyXG4gICAgICAgIC8vIE1haW4gbGluZVxyXG4gICAgICAgIGlmIChzdHlsZS5jb2xvciAmJiBzdHlsZS53aWR0aCkge1xyXG4gICAgICAgICAgICBCdWlsZGVycy5idWlsZFBvbHlsaW5lcyhcclxuICAgICAgICAgICAgICAgIGxpbmVzLFxyXG4gICAgICAgICAgICAgICAgc3R5bGUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YSxcclxuICAgICAgICAgICAgICAgIHZlcnRleF90ZW1wbGF0ZSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXA6IHN0eWxlLmNhcCxcclxuICAgICAgICAgICAgICAgICAgICBqb2luOiBzdHlsZS5qb2luLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxpbmdfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX2V4dHJ1ZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleGNvb3JkX3NjYWxlOiB0aGlzLnRleGNvb3JkX3NjYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlZF9wb2x5Z29uOiBvcHRpb25zLmNsb3NlZF9wb2x5Z29uLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZV90aWxlX2VkZ2VzOiAhc3R5bGUudGlsZV9lZGdlcyAmJiBvcHRpb25zLnJlbW92ZV90aWxlX2VkZ2VzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdXRsaW5lXHJcbiAgICAgICAgLy8gVE9ETzogZm9yIG5vdywgb3V0bGluZXMgY2FuIGJlIGRyYXduIHdpdGggbXVsdGlwbGUgZHJhdyBncm91cHMsIGJ1dCBjYW4gY29uc2lkZXIgcmVzdG9yaW5nXHJcbiAgICAgICAgLy8gc29tZSBvdXRsaW5lIGNhcGFiaWxpdGllcyBpbiB0aGUgZnV0dXJlXHJcbiAgICAgICAgLy8gaWYgKHN0eWxlLm91dGxpbmUgJiYgc3R5bGUub3V0bGluZS5jb2xvciAmJiBzdHlsZS5vdXRsaW5lLndpZHRoKSB7XHJcbiAgICAgICAgLy8gICAgIC8vIFJlcGxhY2UgY29sb3IgaW4gdmVydGV4IHRlbXBsYXRlXHJcbiAgICAgICAgLy8gICAgIHZhciBjb2xvcl9pbmRleCA9IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX2NvbG9yO1xyXG4gICAgICAgIC8vICAgICB2ZXJ0ZXhfdGVtcGxhdGVbY29sb3JfaW5kZXggKyAwXSA9IHN0eWxlLm91dGxpbmUuY29sb3JbMF0gKiAyNTU7XHJcbiAgICAgICAgLy8gICAgIHZlcnRleF90ZW1wbGF0ZVtjb2xvcl9pbmRleCArIDFdID0gc3R5bGUub3V0bGluZS5jb2xvclsxXSAqIDI1NTtcclxuICAgICAgICAvLyAgICAgdmVydGV4X3RlbXBsYXRlW2NvbG9yX2luZGV4ICsgMl0gPSBzdHlsZS5vdXRsaW5lLmNvbG9yWzJdICogMjU1O1xyXG5cclxuICAgICAgICAvLyAgICAgLy8gTGluZSBvdXRsaW5lcyBzaXQgdW5kZXJuZWF0aCBjdXJyZW50IGxheWVyIGJ1dCBhYm92ZSB0aGUgb25lIGJlbG93XHJcbiAgICAgICAgLy8gICAgIHZlcnRleF90ZW1wbGF0ZVt0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9sYXllcl0gLT0gMC41O1xyXG5cclxuICAgICAgICAvLyAgICAgQnVpbGRlcnMuYnVpbGRQb2x5bGluZXMoXHJcbiAgICAgICAgLy8gICAgICAgICBsaW5lcyxcclxuICAgICAgICAvLyAgICAgICAgIHN0eWxlLndpZHRoICsgMiAqIHN0eWxlLm91dGxpbmUud2lkdGgsXHJcbiAgICAgICAgLy8gICAgICAgICB2ZXJ0ZXhfZGF0YSxcclxuICAgICAgICAvLyAgICAgICAgIHZlcnRleF90ZW1wbGF0ZSxcclxuICAgICAgICAvLyAgICAgICAgIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICBjYXA6IHN0eWxlLm91dGxpbmUuY2FwLFxyXG4gICAgICAgIC8vICAgICAgICAgICAgIGpvaW46IHN0eWxlLm91dGxpbmUuam9pbixcclxuICAgICAgICAvLyAgICAgICAgICAgICBzY2FsaW5nX2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9leHRydWRlLFxyXG4gICAgICAgIC8vICAgICAgICAgICAgIHRleGNvb3JkX2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV90ZXhjb29yZCxcclxuICAgICAgICAvLyAgICAgICAgICAgICB0ZXhjb29yZF9zY2FsZTogdGhpcy50ZXhjb29yZF9zY2FsZSxcclxuICAgICAgICAvLyAgICAgICAgICAgICBjbG9zZWRfcG9seWdvbjogb3B0aW9ucy5jbG9zZWRfcG9seWdvbixcclxuICAgICAgICAvLyAgICAgICAgICAgICByZW1vdmVfdGlsZV9lZGdlczogIXN0eWxlLnRpbGVfZWRnZXMgJiYgb3B0aW9ucy5yZW1vdmVfdGlsZV9lZGdlc1xyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICApO1xyXG4gICAgICAgIC8vIH1cclxuICAgIH0sXHJcblxyXG4gICAgYnVpbGRQb2x5Z29ucyhwb2x5Z29ucywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XHJcbiAgICAgICAgLy8gUmVuZGVyIHBvbHlnb25zIGFzIGluZGl2aWR1YWwgbGluZXNcclxuICAgICAgICBmb3IgKGxldCBwPTA7IHAgPCBwb2x5Z29ucy5sZW5ndGg7IHArKykge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkTGluZXMocG9seWdvbnNbcF0sIHN0eWxlLCB2ZXJ0ZXhfZGF0YSwgeyBjbG9zZWRfcG9seWdvbjogdHJ1ZSwgcmVtb3ZlX3RpbGVfZWRnZXM6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcbiIsIi8vIFBvaW50IHJlbmRlcmluZyBzdHlsZVxyXG5cclxuaW1wb3J0IHtTdHlsZX0gZnJvbSAnLi4vc3R5bGUnO1xyXG5pbXBvcnQge1N0eWxlUGFyc2VyfSBmcm9tICcuLi9zdHlsZV9wYXJzZXInO1xyXG5pbXBvcnQgZ2wgZnJvbSAnLi4vLi4vZ2wvY29uc3RhbnRzJzsgLy8gd2ViIHdvcmtlcnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gR0wgY29udGV4dCwgc28gaW1wb3J0IGFsbCBHTCBjb25zdGFudHNcclxuaW1wb3J0IFZlcnRleExheW91dCBmcm9tICcuLi8uLi9nbC92ZXJ0ZXhfbGF5b3V0JztcclxuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcclxuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi4vLi4vZ2wvdGV4dHVyZSc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XHJcblxyXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuXHJcbmV4cG9ydCB2YXIgUG9pbnRzID0gT2JqZWN0LmNyZWF0ZShTdHlsZSk7XHJcblxyXG5PYmplY3QuYXNzaWduKFBvaW50cywge1xyXG4gICAgbmFtZTogJ3BvaW50cycsXHJcbiAgICBidWlsdF9pbjogdHJ1ZSxcclxuICAgIHNlbGVjdGlvbjogdHJ1ZSxcclxuICAgIGJsZW5kOiAnb3ZlcmxheScsIC8vIG92ZXJsYXlzIGRyYXduIG9uIHRvcCBvZiBhbGwgb3RoZXIgc3R5bGVzLCB3aXRoIGJsZW5kaW5nXHJcblxyXG4gICAgaW5pdChvcHRpb25zID0ge30pIHtcclxuICAgICAgICBTdHlsZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIC8vIEJhc2Ugc2hhZGVyc1xyXG4gICAgICAgIHRoaXMudmVydGV4X3NoYWRlcl9rZXkgPSAnc3R5bGVzL3BvaW50cy9wb2ludHNfdmVydGV4JztcclxuICAgICAgICB0aGlzLmZyYWdtZW50X3NoYWRlcl9rZXkgPSAnc3R5bGVzL3BvaW50cy9wb2ludHNfZnJhZ21lbnQnO1xyXG5cclxuICAgICAgICB2YXIgYXR0cmlicyA9IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYV9wb3NpdGlvbicsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3NoYXBlJywgc2l6ZTogNCwgdHlwZTogZ2wuU0hPUlQsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYV9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYV9zZWxlY3Rpb25fY29sb3InLCBzaXplOiA0LCB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLCBub3JtYWxpemVkOiB0cnVlIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2FfdGV4Y29vcmQnLCBzaXplOiAyLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSAvLyBUT0RPOiBwYWNrIGludG8gc2hvcnRzXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IHJlbmRlcmluZyBhcyBvdmVybGF5LCB3ZSBuZWVkIGEgbGF5ZXIgYXR0cmlidXRlXHJcbiAgICAgICAgaWYgKHRoaXMuYmxlbmQgIT09ICdvdmVybGF5Jykge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9PUkRFUl9BVFRSSUJVVEUgPSB0cnVlO1xyXG4gICAgICAgICAgICBhdHRyaWJzLnB1c2goeyBuYW1lOiAnYV9sYXllcicsIHNpemU6IDEsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4X2xheW91dCA9IG5ldyBWZXJ0ZXhMYXlvdXQoYXR0cmlicyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fUE9JTlRfVEVYVFVSRSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy51bmlmb3JtcyA9IHRoaXMuc2hhZGVycy51bmlmb3JtcyB8fCB7fTtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXJzLnVuaWZvcm1zLnVfdGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9wYXJzZUZlYXR1cmUgKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XHJcblxyXG4gICAgICAgIGxldCB0aWxlID0gY29udGV4dC50aWxlLmtleTtcclxuXHJcbiAgICAgICAgc3R5bGUuY29sb3IgPSAocnVsZV9zdHlsZS5jb2xvciAmJiBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKHJ1bGVfc3R5bGUuY29sb3IsIGNvbnRleHQpKSB8fCBbMSwgMSwgMSwgMV07XHJcbiAgICAgICAgc3R5bGUueiA9IChydWxlX3N0eWxlLnogJiYgU3R5bGVQYXJzZXIucGFyc2VEaXN0YW5jZShydWxlX3N0eWxlLnogfHwgMCwgY29udGV4dCkpIHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLno7XHJcblxyXG4gICAgICAgIHN0eWxlLnNwcml0ZSA9IHJ1bGVfc3R5bGUuc3ByaXRlO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuc3ByaXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnNwcml0ZSA9IHN0eWxlLnNwcml0ZShjb250ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHBvaW50IHN0eWxlIG9ubHkgc3VwcG9ydHMgc2l6ZXMgaW4gcGl4ZWwgdW5pdHMsIHNvIHVuaXQgY29udmVyc2lvbiBmbGFnIGlzIG9mZlxyXG4gICAgICAgIHN0eWxlLnNpemUgPSBydWxlX3N0eWxlLnNpemUgfHwgWzMyLCAzMl07XHJcbiAgICAgICAgc3R5bGUuc2l6ZSA9IFN0eWxlUGFyc2VyLnBhcnNlRGlzdGFuY2Uoc3R5bGUuc2l6ZSwgY29udGV4dCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBzY2FsZSBzaXplIHRvIDE2LWJpdCBzaWduZWQgaW50LCB3aXRoIGEgbWF4IGFsbG93ZWQgd2lkdGggKyBoZWlnaHQgb2YgMTI4IHBpeGVsc1xyXG4gICAgICAgIHN0eWxlLnNpemUgPSBbXHJcbiAgICAgICAgICAgIE1hdGgubWluKChzdHlsZS5zaXplWzBdIHx8IHN0eWxlLnNpemUpLCAyNTYpLFxyXG4gICAgICAgICAgICBNYXRoLm1pbigoc3R5bGUuc2l6ZVsxXSB8fCBzdHlsZS5zaXplKSwgMjU2KVxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIHN0eWxlLnNpemVbMF0gKj0gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xyXG4gICAgICAgIHN0eWxlLnNpemVbMV0gKj0gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xyXG5cclxuICAgICAgICBzdHlsZS5hbmdsZSA9IHJ1bGVfc3R5bGUuYW5nbGUgfHwgMDtcclxuICAgICAgICBpZiAodHlwZW9mIHN0eWxlLmFuZ2xlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLmFuZ2xlID0gc3R5bGUuYW5nbGUoY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmYWN0b3IgYnkgd2hpY2ggcG9pbnQgc2NhbGVzIGZyb20gY3VycmVudCB6b29tIGxldmVsIHRvIG5leHQgem9vbSBsZXZlbFxyXG4gICAgICAgIHN0eWxlLnNjYWxlID0gcnVsZV9zdHlsZS5zY2FsZSB8fCAxO1xyXG5cclxuICAgICAgICAvLyB0byBzdG9yZSBiYm94IGJ5IHRpbGVzXHJcbiAgICAgICAgc3R5bGUudGlsZSA9IHRpbGU7XHJcblxyXG4gICAgICAgIC8vIHBvbHlnb25zIHJlbmRlcmluZyBhcyBwb2ludHMgd2lsbCByZW5kZXIgZWFjaCBpbmRpdmlkdWFsIHBvbHlnb24gcG9pbnQgYnkgZGVmYXVsdCwgYnV0XHJcbiAgICAgICAgLy8gcmVuZGVyaW5nIGEgc2luZ2xlIHBvaW50IGF0IHRoZSBwb2x5Z29uJ3MgY2VudHJvaWQgY2FuIGJlIGVuYWJsZWRcclxuICAgICAgICBzdHlsZS5jZW50cm9pZCA9IHJ1bGVfc3R5bGUuY2VudHJvaWQ7XHJcblxyXG4gICAgICAgIC8vIFNldHMgdGV4Y29vcmQgc2NhbGUgaWYgbmVlZGVkIChlLmcuIGZvciBzcHJpdGUgc3ViLWFyZWEpXHJcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSAmJiBzdHlsZS5zcHJpdGUpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXhjb29yZF9zY2FsZSA9IFRleHR1cmUuZ2V0U3ByaXRlVGV4Y29vcmRzKHRoaXMudGV4dHVyZSwgc3R5bGUuc3ByaXRlKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleGNvb3JkX3NjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBsb2cud2FybihgU3R5bGU6IGluIHN0eWxlICcke3RoaXMubmFtZX0nLCBjb3VsZCBub3QgZmluZCBzcHJpdGUgJyR7c3R5bGUuc3ByaXRlfScgZm9yIHRleHR1cmUgJyR7dGhpcy50ZXh0dXJlfSdgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgXCJ0ZW1wbGF0ZVwiIHRoYXQgc2V0cyBjb25zdGFudCBhdHRpYnV0ZXMgZm9yIGVhY2ggdmVydGV4LCB3aGljaCBpcyB0aGVuIG1vZGlmaWVkIHBlciB2ZXJ0ZXggb3IgcGVyIGZlYXR1cmUuXHJcbiAgICAgKiBBIHBsYWluIEpTIGFycmF5IG1hdGNoaW5nIHRoZSBvcmRlciBvZiB0aGUgdmVydGV4IGxheW91dC5cclxuICAgICAqL1xyXG4gICAgbWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKSB7XHJcbiAgICAgICAgLy8gQmFzaWMgYXR0cmlidXRlcywgb3RoZXJzIGNhbiBiZSBhZGRlZCAoc2VlIHRleHR1cmUgVVZzIGJlbG93KVxyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IFtcclxuICAgICAgICAgICAgLy8gcG9zaXRpb24gLSAoeCwgeSkgY29vcmRzIHdpbGwgYmUgZmlsbGVkIGluIHBlci12ZXJ0ZXggYmVsb3dcclxuICAgICAgICAgICAgMCwgMCwgc3R5bGUueiB8fCAwLFxyXG4gICAgICAgICAgICAvLyBzY2FsaW5nIHZlY3RvciAtICh4LCB5KSBjb21wb25lbnRzIHBlciBwaXhlbCwgeiA9IGFuZ2xlLCB3ID0gc2NhbGluZyBmYWN0b3JcclxuICAgICAgICAgICAgMCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgLy8gY29sb3JcclxuICAgICAgICAgICAgLy8gVE9ETzogYXV0b21hdGUgbXVsdGlwbGljYXRpb24gZm9yIG5vcm1hbGl6ZWQgYXR0cmlicz9cclxuICAgICAgICAgICAgc3R5bGUuY29sb3JbMF0gKiAyNTUsIHN0eWxlLmNvbG9yWzFdICogMjU1LCBzdHlsZS5jb2xvclsyXSAqIDI1NSwgc3R5bGUuY29sb3JbM10gKiAyNTUsXHJcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBjb2xvclxyXG4gICAgICAgICAgICBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMF0gKiAyNTUsIHN0eWxlLnNlbGVjdGlvbl9jb2xvclsxXSAqIDI1NSwgc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzJdICogMjU1LCBzdHlsZS5zZWxlY3Rpb25fY29sb3JbM10gKiAyNTUsXHJcbiAgICAgICAgICAgIC8vIHRleHR1cmUgY29vcmRzXHJcbiAgICAgICAgICAgIDAsIDBcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvLyBBZGQgbGF5ZXIgYXR0cmlidXRlIGlmIG5lZWRlZFxyXG4gICAgICAgIGlmICh0aGlzLmRlZmluZXMuVEFOR1JBTV9PUkRFUl9BVFRSSUJVVEUpIHtcclxuICAgICAgICAgICAgdGVtcGxhdGUucHVzaChzdHlsZS5vcmRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGJ1aWxkUG9pbnRzIChwb2ludHMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xyXG4gICAgICAgIGlmICghc3R5bGUuc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdmVydGV4X3RlbXBsYXRlID0gdGhpcy5tYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpO1xyXG5cclxuICAgICAgICBsZXQgc2l6ZSA9IHN0eWxlLnNpemU7XHJcbiAgICAgICAgbGV0IGFuZ2xlID0gc3R5bGUuYW5nbGU7XHJcblxyXG4gICAgICAgIEJ1aWxkZXJzLmJ1aWxkU3ByaXRlUXVhZHNGb3JQb2ludHMoXHJcbiAgICAgICAgICAgIHBvaW50cyxcclxuICAgICAgICAgICAgVXRpbHMuc2NhbGVJbnQxNihzaXplWzBdLCAyNTYpLCBVdGlscy5zY2FsZUludDE2KHNpemVbMV0sIDI1NiksXHJcbiAgICAgICAgICAgIFV0aWxzLnNjYWxlSW50MTYoVXRpbHMucmFkVG9EZWcoYW5nbGUpLCAzNjApLFxyXG4gICAgICAgICAgICBVdGlscy5zY2FsZUludDE2KHN0eWxlLnNjYWxlLCAyNTYpLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YSxcclxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxyXG4gICAgICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9zaGFwZSxcclxuICAgICAgICAgICAgeyB0ZXhjb29yZF9pbmRleDogdGhpcy52ZXJ0ZXhfbGF5b3V0LmluZGV4LmFfdGV4Y29vcmQsIHRleGNvb3JkX3NjYWxlOiB0aGlzLnRleGNvb3JkX3NjYWxlIH1cclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBidWlsZFBvbHlnb25zKHBvbHlnb25zLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcclxuICAgICAgICAvLyBSZW5kZXIgcG9seWdvbnMgYXMgaW5kaXZpZHVhbCBwb2ludHMsIG9yIGNlbnRyb2lkXHJcbiAgICAgICAgaWYgKCFzdHlsZS5jZW50cm9pZCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwb2x5PTA7IHBvbHkgPCBwb2x5Z29ucy5sZW5ndGg7IHBvbHkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvbHlnb24gPSBwb2x5Z29uc1twb2x5XTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHI9MDsgciA8IHBvbHlnb24ubGVuZ3RoOyByKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUG9pbnRzKHBvbHlnb25bcl0sIHN0eWxlLCB2ZXJ0ZXhfZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBjZW50cm9pZCA9IFV0aWxzLm11bHRpQ2VudHJvaWQocG9seWdvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkUG9pbnRzKFtjZW50cm9pZF0sIHN0eWxlLCB2ZXJ0ZXhfZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBidWlsZExpbmVzKGxpbmVzLCBzdHlsZSwgdmVydGV4X2RhdGEpIHtcclxuICAgICAgICAvLyBSZW5kZXIgbGluZXMgYXMgaW5kaXZpZHVhbCBwb2ludHNcclxuICAgICAgICBmb3IgKGxldCBsbj0wOyBsbiA8IGxpbmVzLmxlbmd0aDsgbG4rKykge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkUG9pbnRzKGxpbmVzW2xuXSwgc3R5bGUsIHZlcnRleF9kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59KTtcclxuIiwiLy8gUG9seWdvbiByZW5kZXJpbmcgc3R5bGVcclxuXHJcbmltcG9ydCB7U3R5bGV9IGZyb20gJy4uL3N0eWxlJztcclxuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi4vc3R5bGVfcGFyc2VyJztcclxuaW1wb3J0IGdsIGZyb20gJy4uLy4uL2dsL2NvbnN0YW50cyc7IC8vIHdlYiB3b3JrZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIEdMIGNvbnRleHQsIHNvIGltcG9ydCBhbGwgR0wgY29uc3RhbnRzXHJcbmltcG9ydCBWZXJ0ZXhMYXlvdXQgZnJvbSAnLi4vLi4vZ2wvdmVydGV4X2xheW91dCc7XHJcbmltcG9ydCBCdWlsZGVycyBmcm9tICcuLi9idWlsZGVycyc7XHJcblxyXG5leHBvcnQgdmFyIFBvbHlnb25zID0gT2JqZWN0LmNyZWF0ZShTdHlsZSk7XHJcblxyXG5PYmplY3QuYXNzaWduKFBvbHlnb25zLCB7XHJcbiAgICBuYW1lOiAncG9seWdvbnMnLFxyXG4gICAgYnVpbHRfaW46IHRydWUsXHJcblxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICBTdHlsZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIC8vIEJhc2Ugc2hhZGVyc1xyXG4gICAgICAgIHRoaXMudmVydGV4X3NoYWRlcl9rZXkgPSAnc3R5bGVzL3BvbHlnb25zL3BvbHlnb25zX3ZlcnRleCc7XHJcbiAgICAgICAgdGhpcy5mcmFnbWVudF9zaGFkZXJfa2V5ID0gJ3N0eWxlcy9wb2x5Z29ucy9wb2x5Z29uc19mcmFnbWVudCc7XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgd29ybGQgY29vcmRzIHRvIHdyYXAgZXZlcnkgMTAwLDAwMCBtZXRlcnMsIGNhbiB0dXJuIG9mZiBieSBzZXR0aW5nIHRoaXMgdG8gJ2ZhbHNlJ1xyXG4gICAgICAgIHRoaXMuZGVmaW5lcy5UQU5HUkFNX1dPUkxEX1BPU0lUSU9OX1dSQVAgPSAxMDAwMDA7XHJcblxyXG4gICAgICAgIC8vIFR1cm4gZmVhdHVyZSBzZWxlY3Rpb24gb25cclxuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIEJhc2ljIGF0dHJpYnV0ZXMsIG90aGVycyBjYW4gYmUgYWRkZWQgKHNlZSB0ZXh0dXJlIFVWcyBiZWxvdylcclxuICAgICAgICB2YXIgYXR0cmlicyA9IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYV9wb3NpdGlvbicsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdhX25vcm1hbCcsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICAvLyB7IG5hbWU6ICdhX25vcm1hbCcsIHNpemU6IDMsIHR5cGU6IGdsLkJZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSwgLy8gYXR0cmliIGlzbid0IGEgbXVsdGlwbGUgb2YgNCFcclxuICAgICAgICAgICAgLy8geyBuYW1lOiAnYV9jb2xvcicsIHNpemU6IDMsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdhX2NvbG9yJywgc2l6ZTogNCwgdHlwZTogZ2wuVU5TSUdORURfQllURSwgbm9ybWFsaXplZDogdHJ1ZSB9LFxyXG4gICAgICAgICAgICAvLyB7IG5hbWU6ICdhX3NlbGVjdGlvbl9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdhX3NlbGVjdGlvbl9jb2xvcicsIHNpemU6IDQsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsIG5vcm1hbGl6ZWQ6IHRydWUgfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYV9sYXllcicsIHNpemU6IDEsIHR5cGU6IGdsLkZMT0FULCBub3JtYWxpemVkOiBmYWxzZSB9XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgLy8gVGVsbCB0aGUgc2hhZGVyIHdlIGhhdmUgYSBub3JtYWwgYW5kIG9yZGVyIGF0dHJpYnV0ZXNcclxuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9OT1JNQUxfQVRUUklCVVRFID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9PUkRFUl9BVFRSSUJVVEUgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBPcHRpb25hbCB0ZXh0dXJlIFVWc1xyXG4gICAgICAgIGlmICh0aGlzLnRleGNvb3Jkcykge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmluZXMuVEFOR1JBTV9URVhUVVJFX0NPT1JEUyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdmVydGV4IGF0dHJpYnV0ZSBmb3IgVVZzIG9ubHkgd2hlbiBuZWVkZWRcclxuICAgICAgICAgICAgYXR0cmlicy5wdXNoKHsgbmFtZTogJ2FfdGV4Y29vcmQnLCBzaXplOiAyLCB0eXBlOiBnbC5GTE9BVCwgbm9ybWFsaXplZDogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQgPSBuZXcgVmVydGV4TGF5b3V0KGF0dHJpYnMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5mZWF0dXJlX3N0eWxlO1xyXG5cclxuICAgICAgICBzdHlsZS5jb2xvciA9IHJ1bGVfc3R5bGUuY29sb3IgJiYgU3R5bGVQYXJzZXIucGFyc2VDb2xvcihydWxlX3N0eWxlLmNvbG9yLCBjb250ZXh0KTtcclxuICAgICAgICBzdHlsZS53aWR0aCA9IHJ1bGVfc3R5bGUud2lkdGggJiYgU3R5bGVQYXJzZXIucGFyc2VEaXN0YW5jZShydWxlX3N0eWxlLndpZHRoLCBjb250ZXh0KTtcclxuICAgICAgICBzdHlsZS56ID0gKHJ1bGVfc3R5bGUueiAmJiBTdHlsZVBhcnNlci5wYXJzZURpc3RhbmNlKHJ1bGVfc3R5bGUueiB8fCAwLCBjb250ZXh0KSkgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMuejtcclxuXHJcbiAgICAgICAgc3R5bGUuc2l6ZSA9IHJ1bGVfc3R5bGUuc2l6ZSAmJiBTdHlsZVBhcnNlci5wYXJzZURpc3RhbmNlKHJ1bGVfc3R5bGUuc2l6ZSwgY29udGV4dCk7XHJcblxyXG4gICAgICAgIC8vIGhlaWdodCBkZWZhdWx0cyB0byBmZWF0dXJlIGhlaWdodCwgYnV0IGV4dHJ1ZGUgc3R5bGUgY2FuIGR5bmFtaWNhbGx5IGFkanVzdCBoZWlnaHQgYnkgcmV0dXJuaW5nIGEgbnVtYmVyIG9yIGFycmF5IChpbnN0ZWFkIG9mIGEgYm9vbGVhbilcclxuICAgICAgICBzdHlsZS5oZWlnaHQgPSBmZWF0dXJlLnByb3BlcnRpZXMuaGVpZ2h0IHx8IFN0eWxlUGFyc2VyLmRlZmF1bHRzLmhlaWdodDtcclxuICAgICAgICBzdHlsZS5taW5faGVpZ2h0ID0gZmVhdHVyZS5wcm9wZXJ0aWVzLm1pbl9oZWlnaHQgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMubWluX2hlaWdodDtcclxuICAgICAgICBzdHlsZS5leHRydWRlID0gcnVsZV9zdHlsZS5leHRydWRlO1xyXG4gICAgICAgIGlmIChzdHlsZS5leHRydWRlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuZXh0cnVkZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuZXh0cnVkZSA9IHN0eWxlLmV4dHJ1ZGUoY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuZXh0cnVkZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IHN0eWxlLmV4dHJ1ZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzdHlsZS5leHRydWRlKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUubWluX2hlaWdodCA9IHN0eWxlLmV4dHJ1ZGVbMF07XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBzdHlsZS5leHRydWRlWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHlsZS5jYXAgPSBydWxlX3N0eWxlLmNhcDtcclxuICAgICAgICBzdHlsZS5qb2luID0gcnVsZV9zdHlsZS5qb2luO1xyXG5cclxuICAgICAgICBzdHlsZS5vdXRsaW5lID0gc3R5bGUub3V0bGluZSB8fCB7fTtcclxuICAgICAgICBpZiAocnVsZV9zdHlsZS5vdXRsaW5lKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuY29sb3IgPSBTdHlsZVBhcnNlci5wYXJzZUNvbG9yKHJ1bGVfc3R5bGUub3V0bGluZS5jb2xvciwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUud2lkdGggPSBTdHlsZVBhcnNlci5wYXJzZURpc3RhbmNlKHJ1bGVfc3R5bGUub3V0bGluZS53aWR0aCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUudGlsZV9lZGdlcyA9IHJ1bGVfc3R5bGUub3V0bGluZS50aWxlX2VkZ2VzO1xyXG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLmNhcCA9IHJ1bGVfc3R5bGUub3V0bGluZS5jYXAgfHwgcnVsZV9zdHlsZS5jYXA7XHJcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuam9pbiA9IHJ1bGVfc3R5bGUub3V0bGluZS5qb2luIHx8IHJ1bGVfc3R5bGUuam9pbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuY29sb3IgPSBudWxsO1xyXG4gICAgICAgICAgICBzdHlsZS5vdXRsaW5lLndpZHRoID0gbnVsbDtcclxuICAgICAgICAgICAgc3R5bGUub3V0bGluZS50aWxlX2VkZ2VzID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBcInRlbXBsYXRlXCIgdGhhdCBzZXRzIGNvbnN0YW50IGF0dGlidXRlcyBmb3IgZWFjaCB2ZXJ0ZXgsIHdoaWNoIGlzIHRoZW4gbW9kaWZpZWQgcGVyIHZlcnRleCBvciBwZXIgZmVhdHVyZS5cclxuICAgICAqIEEgcGxhaW4gSlMgYXJyYXkgbWF0Y2hpbmcgdGhlIG9yZGVyIG9mIHRoZSB2ZXJ0ZXggbGF5b3V0LlxyXG4gICAgICovXHJcbiAgICBtYWtlVmVydGV4VGVtcGxhdGUoc3R5bGUpIHtcclxuICAgICAgICAvLyBQbGFjZWhvbGRlciB2YWx1ZXNcclxuICAgICAgICB2YXIgY29sb3IgPSBzdHlsZS5jb2xvciB8fCBbMCwgMCwgMCwgMV07XHJcblxyXG4gICAgICAgIC8vIEJhc2ljIGF0dHJpYnV0ZXMsIG90aGVycyBjYW4gYmUgYWRkZWQgKHNlZSB0ZXh0dXJlIFVWcyBiZWxvdylcclxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBbXHJcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIC0geCAmIHkgY29vcmRzIHdpbGwgYmUgZmlsbGVkIGluIHBlci12ZXJ0ZXggYmVsb3dcclxuICAgICAgICAgICAgMCwgMCwgc3R5bGUueiB8fCAwLFxyXG4gICAgICAgICAgICAvLyBub3JtYWxcclxuICAgICAgICAgICAgMCwgMCwgMSxcclxuICAgICAgICAgICAgLy8gY29sb3JcclxuICAgICAgICAgICAgLy8gVE9ETzogYXV0b21hdGUgbXVsdGlwbGljYXRpb24gZm9yIG5vcm1hbGl6ZWQgYXR0cmlicz9cclxuICAgICAgICAgICAgY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSwgY29sb3JbM10gKiAyNTUsXHJcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBjb2xvclxyXG4gICAgICAgICAgICBzdHlsZS5zZWxlY3Rpb25fY29sb3JbMF0gKiAyNTUsIHN0eWxlLnNlbGVjdGlvbl9jb2xvclsxXSAqIDI1NSwgc3R5bGUuc2VsZWN0aW9uX2NvbG9yWzJdICogMjU1LCBzdHlsZS5zZWxlY3Rpb25fY29sb3JbM10gKiAyNTUsXHJcbiAgICAgICAgICAgIC8vIGRyYXcgb3JkZXJcclxuICAgICAgICAgICAgc3R5bGUub3JkZXJcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGV4dHVyZSBVVnMgdG8gdGVtcGxhdGUgb25seSBpZiBuZWVkZWRcclxuICAgICAgICBpZiAodGhpcy50ZXhjb29yZHMpIHtcclxuICAgICAgICAgICAgdGVtcGxhdGUucHVzaCgwLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIGJ1aWxkUG9seWdvbnMocG9seWdvbnMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhfdGVtcGxhdGUgPSB0aGlzLm1ha2VWZXJ0ZXhUZW1wbGF0ZShzdHlsZSk7XHJcblxyXG4gICAgICAgIC8vIFBvbHlnb24gZmlsbFxyXG4gICAgICAgIGlmIChzdHlsZS5jb2xvcikge1xyXG4gICAgICAgICAgICAvLyBFeHRydWRlZCBwb2x5Z29ucyAoZS5nLiAzRCBidWlsZGluZ3MpXHJcbiAgICAgICAgICAgIGlmIChzdHlsZS5leHRydWRlICYmIHN0eWxlLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgQnVpbGRlcnMuYnVpbGRFeHRydWRlZFBvbHlnb25zKFxyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnosIHN0eWxlLmhlaWdodCwgc3R5bGUubWluX2hlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX25vcm1hbCxcclxuICAgICAgICAgICAgICAgICAgICB7IHRleGNvb3JkX2luZGV4OiB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV90ZXhjb29yZCwgdGV4Y29vcmRfc2NhbGU6IHRoaXMudGV4Y29vcmRfc2NhbGUgfVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZWd1bGFyIHBvbHlnb25zXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQnVpbGRlcnMuYnVpbGRQb2x5Z29ucyhcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29ucyxcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLCB0ZXhjb29yZF9zY2FsZTogdGhpcy50ZXhjb29yZF9zY2FsZSB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSk7XHJcbiIsImltcG9ydCB7bWF0Y2h9IGZyb20gJ21hdGNoLWZlYXR1cmUnO1xyXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuXHJcbmV4cG9ydCBjb25zdCB3aGl0ZUxpc3QgPSBbJ2ZpbHRlcicsICdkcmF3JywgJ3Zpc2libGUnLCAnZGF0YScsICdwcm9wZXJ0aWVzJ107XHJcblxyXG5leHBvcnQgbGV0IHJ1bGVDYWNoZSA9IHt9O1xyXG5cclxuZnVuY3Rpb24gY2FjaGVLZXkgKHJ1bGVzKSB7XHJcbiAgICByZXR1cm4gcnVsZXMubWFwKHIgPT4gci5pZCkuam9pbignLycpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VUcmVlcyhtYXRjaGluZ1RyZWVzLCBrZXksIGNvbnRleHQpIHtcclxuICAgIHZhciBkcmF3ID0ge30sXHJcbiAgICAgICAgZHJhd3MsXHJcbiAgICAgICAgb3JkZXIgPSBbXSxcclxuICAgICAgICBvcmRlcl9kcmF3cyA9IFtdLFxyXG4gICAgICAgIHRyZWVEZXB0aCA9IDAsXHJcbiAgICAgICAgaSwgeCwgdDtcclxuXHJcbiAgICAvLyBWaXNpYmxlIGJ5IGRlZmF1bHRcclxuICAgIGRyYXcudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgLy8gRmluZCBkZWVwZXN0IHRyZWVcclxuICAgIGZvciAodCA9IDA7IHQgPCBtYXRjaGluZ1RyZWVzLmxlbmd0aDsgdCsrKSB7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nVHJlZXNbdF0ubGVuZ3RoID4gdHJlZURlcHRoKSB7XHJcbiAgICAgICAgICAgIHRyZWVEZXB0aCA9IG1hdGNoaW5nVHJlZXNbdF0ubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBObyBydWxlcyB0byBwYXJzZVxyXG4gICAgaWYgKHRyZWVEZXB0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEl0ZXJhdGUgdHJlZXMgaW4gcGFyYWxsZWxcclxuICAgIGZvciAoeCA9IDA7IHggPCB0cmVlRGVwdGg7IHgrKykge1xyXG4gICAgICAgIGRyYXdzID0gbWF0Y2hpbmdUcmVlcy5tYXAodHJlZSA9PiB0cmVlW3hdICYmIHRyZWVbeF1ba2V5XSk7XHJcbiAgICAgICAgaWYgKGRyYXdzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByb3BlcnR5LXNwZWNpZmljIGxvZ2ljXHJcbiAgICAgICAgZm9yIChpPTA7IGkgPCBkcmF3cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWRyYXdzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29sbGVjdCB1bmlxdWUgb3JkZXJzIChkb24ndCBhZGQgdGhlIG9yZGVyIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc21hZSBkcmF3IHJ1bGUpXHJcbiAgICAgICAgICAgIGlmIChkcmF3c1tpXS5vcmRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJfZHJhd3MuaW5kZXhPZihkcmF3c1tpXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChkcmF3c1tpXS5vcmRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJfZHJhd3MucHVzaChkcmF3c1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1lcmdlIHJlbWFpbmluZyBkcmF3IG9iamVjdHNcclxuICAgICAgICBtZXJnZU9iamVjdHMoZHJhdywgLi4uZHJhd3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgbm90IHZpc2libGVcclxuICAgIGlmIChkcmF3LnZpc2libGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3VtIGFsbCBvcmRlcnNcclxuICAgIGlmIChvcmRlci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gT3JkZXIgY2FuIGJlIGNhY2hlZCBpZiBpdCBpcyBhbGwgbnVtZXJpY1xyXG4gICAgICAgIGlmIChvcmRlci5sZW5ndGggPT09IDEgJiYgdHlwZW9mIG9yZGVyWzBdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBvcmRlciA9IG9yZGVyWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcmRlci5ldmVyeSh2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJykpIHtcclxuICAgICAgICAgICAgb3JkZXIgPSBjYWxjdWxhdGVPcmRlcihvcmRlciwgY29udGV4dCk7IC8vIFRPRE86IHVzZSBTdHlsZVBhcnNlci5jYWxjdWxhdGVPcmRlclxyXG4gICAgICAgIH1cclxuICAgICAgICBkcmF3Lm9yZGVyID0gb3JkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRyYXc7XHJcbn1cclxuXHJcblxyXG5jbGFzcyBSdWxlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih7bmFtZSwgcGFyZW50LCBkcmF3LCB2aXNpYmxlLCBmaWx0ZXIsIHByb3BlcnRpZXN9KSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IFJ1bGUuaWQrKztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZHJhdyA9IGRyYXc7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZSAhPT0gdW5kZWZpbmVkID8gdmlzaWJsZSA6ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC52aXNpYmxlKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQgPyBwcm9wZXJ0aWVzIDogKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAvLyBEZW5vcm1hbGl6ZSBwcm9wZXJ0aWVzIHRvIGRyYXcgZ3JvdXBzXHJcbiAgICAgICAgaWYgKHRoaXMuZHJhdykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBncm91cCBpbiB0aGlzLmRyYXcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1tncm91cF0ucHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5idWlsZEZpbHRlcigpO1xyXG4gICAgICAgIHRoaXMuYnVpbGREcmF3KCk7XHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGREcmF3KCkge1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlZERyYXcgPSBjYWxjdWxhdGVEcmF3KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkRmlsdGVyKCkge1xyXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHRoaXMuZmlsdGVyO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlciA9IG1hdGNoKHRoaXMuZmlsdGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgZHJhdzogdGhpcy5kcmF3XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblJ1bGUuaWQgPSAwO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBSdWxlTGVhZiBleHRlbmRzIFJ1bGUge1xyXG4gICAgY29uc3RydWN0b3Ioe25hbWUsIHBhcmVudCwgZHJhdywgdmlzaWJsZSwgZmlsdGVyLCBwcm9wZXJ0aWVzfSkge1xyXG4gICAgICAgIHN1cGVyKHtuYW1lLCBwYXJlbnQsIGRyYXcsIHZpc2libGUsIGZpbHRlciwgcHJvcGVydGllc30pO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFJ1bGVUcmVlIGV4dGVuZHMgUnVsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7bmFtZSwgcGFyZW50LCBkcmF3LCB2aXNpYmxlLCBydWxlcywgZmlsdGVyLCBwcm9wZXJ0aWVzfSkge1xyXG4gICAgICAgIHN1cGVyKHtuYW1lLCBwYXJlbnQsIGRyYXcsIHZpc2libGUsIGZpbHRlciwgcHJvcGVydGllc30pO1xyXG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlcyB8fCBbXTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRSdWxlKHJ1bGUpIHtcclxuICAgICAgICB0aGlzLnJ1bGVzLnB1c2gocnVsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGREcmF3R3JvdXBzKGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgcnVsZXMgID0gW107XHJcbiAgICAgICAgLy9UT0RPLCBzaG91bGQgdGhpcyBmdW5jdGlvbiB0YWtlIGEgUnVsZVRyZWVcclxuICAgICAgICBtYXRjaEZlYXR1cmUoY29udGV4dCwgW3RoaXNdLCBydWxlcyk7XHJcblxyXG4gICAgICAgIGlmIChydWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBjYWNoZV9rZXkgPSBjYWNoZUtleShydWxlcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IGV2YWx1YXRlIGVhY2ggcnVsZSBjb21iaW5hdGlvbiBvbmNlICh1bmRlZmluZWQgbWVhbnMgbm90IHlldCBldmFsdWF0ZWQsXHJcbiAgICAgICAgICAgIC8vIG51bGwgbWVhbnMgZXZhbHVhdGVkIHdpdGggbm8gZHJhdyBvYmplY3QpXHJcbiAgICAgICAgICAgIGlmIChydWxlQ2FjaGVbY2FjaGVfa2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBWaXNpYmxlP1xyXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGVzLnNvbWUoeCA9PiB4LnZpc2libGUgPT09IGZhbHNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVDYWNoZVtjYWNoZV9rZXldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgYWxsIHRoZSB1bmlxdWUgZHJhdyBibG9ja3MgZm9yIHRoaXMgcnVsZSB0cmVlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRyYXdfcnVsZXMgPSBydWxlcy5tYXAoeCA9PiB4ICYmIHguY2FsY3VsYXRlZERyYXcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkcmF3X2tleXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcnVsZSBvZiBkcmF3X3J1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXAgb2YgcnVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd19rZXlzW2tleV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgZWFjaCBkcmF3IGdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZHJhd19rZXkgaW4gZHJhd19rZXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVDYWNoZVtjYWNoZV9rZXldID0gcnVsZUNhY2hlW2NhY2hlX2tleV0gfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVDYWNoZVtjYWNoZV9rZXldW2RyYXdfa2V5XSA9IG1lcmdlVHJlZXMoZHJhd19ydWxlcywgZHJhd19rZXksIGNvbnRleHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzYXZlIHRoZSBvbmVzIHRoYXQgd2VyZW4ndCBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVsZUNhY2hlW2NhY2hlX2tleV1bZHJhd19rZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBydWxlcyBldmFsdWF0ZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZUNhY2hlW2NhY2hlX2tleV0gJiYgT2JqZWN0LmtleXMocnVsZUNhY2hlW2NhY2hlX2tleV0pLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlQ2FjaGVbY2FjaGVfa2V5XSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBydWxlQ2FjaGVbY2FjaGVfa2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1doaXRlTGlzdGVkKGtleSkge1xyXG4gICAgcmV0dXJuIHdoaXRlTGlzdC5pbmRleE9mKGtleSkgPiAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHdhbGtVcChydWxlLCBjYikge1xyXG5cclxuICAgIGlmIChydWxlLnBhcmVudCkge1xyXG4gICAgICAgIHdhbGtVcChydWxlLnBhcmVudCwgY2IpO1xyXG4gICAgfVxyXG5cclxuICAgIGNiKHJ1bGUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gd2Fsa0Rvd24ocnVsZSwgY2IpIHtcclxuXHJcbiAgICBpZiAocnVsZS5ydWxlcykge1xyXG4gICAgICAgIHJ1bGUucnVsZXMuZm9yRWFjaCgocikgPT4ge1xyXG4gICAgICAgICAgICB3YWxrRG93bihyLCBjYik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2IocnVsZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBncm91cFByb3BzKG9iaikge1xyXG4gICAgbGV0IHdoaXRlTGlzdGVkID0ge30sIG5vbldoaXRlTGlzdGVkID0ge307XHJcblxyXG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChpc1doaXRlTGlzdGVkKGtleSkpIHtcclxuICAgICAgICAgICAgd2hpdGVMaXN0ZWRba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vbldoaXRlTGlzdGVkW2tleV0gPSBvYmpba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW3doaXRlTGlzdGVkLCBub25XaGl0ZUxpc3RlZF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEcmF3KHJ1bGUpIHtcclxuXHJcbiAgICBsZXQgZHJhdyAgPSBbXTtcclxuXHJcbiAgICBpZiAocnVsZS5wYXJlbnQpIHtcclxuICAgICAgICBsZXQgY3MgPSBydWxlLnBhcmVudC5jYWxjdWxhdGVkRHJhdyB8fCBbXTtcclxuICAgICAgICBkcmF3LnB1c2goLi4uY3MpO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXcucHVzaChydWxlLmRyYXcpO1xyXG4gICAgcmV0dXJuIGRyYXc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZU9iamVjdHMobmV3T2JqLCAuLi5zb3VyY2VzKSB7XHJcblxyXG4gICAgZm9yIChsZXQgc291cmNlIG9mIHNvdXJjZXMpIHtcclxuICAgICAgICBpZiAoIXNvdXJjZSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG1lcmdlT2JqZWN0cyhuZXdPYmpba2V5XSB8fCB7fSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3T2JqO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlT3JkZXIob3JkZXJzLCBjb250ZXh0ID0gbnVsbCwgZGVmYXVsdE9yZGVyID0gMCkge1xyXG4gICAgbGV0IHN1bSA9IGRlZmF1bHRPcmRlcjtcclxuXHJcbiAgICBmb3IgKGxldCBvcmRlciBvZiBvcmRlcnMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG9yZGVyID0gb3JkZXIoY29udGV4dCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3JkZXIgPSBwYXJzZUZsb2F0KG9yZGVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghb3JkZXIgfHwgaXNOYU4ob3JkZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdW0gKz0gb3JkZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VtO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUnVsZVRyZWUobmFtZSwgcnVsZSwgcGFyZW50KSB7XHJcblxyXG4gICAgbGV0IHByb3BlcnRpZXMgPSB7bmFtZSwgcGFyZW50fTtcclxuICAgIGxldCBbd2hpdGVMaXN0ZWQsIG5vbldoaXRlTGlzdGVkXSA9IGdyb3VwUHJvcHMocnVsZSk7XHJcbiAgICBsZXQgZW1wdHkgPSBpc0VtcHR5KG5vbldoaXRlTGlzdGVkKTtcclxuICAgIGxldCBDcmVhdGU7XHJcblxyXG4gICAgaWYgKGVtcHR5ICYmIHBhcmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgQ3JlYXRlID0gUnVsZUxlYWY7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIENyZWF0ZSA9IFJ1bGVUcmVlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCByID0gbmV3IENyZWF0ZShPYmplY3QuYXNzaWduKHByb3BlcnRpZXMsIHdoaXRlTGlzdGVkKSk7XHJcblxyXG4gICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHBhcmVudC5hZGRSdWxlKHIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghZW1wdHkpIHtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbm9uV2hpdGVMaXN0ZWQpIHtcclxuICAgICAgICAgICAgbGV0IHByb3BlcnR5ID0gbm9uV2hpdGVMaXN0ZWRba2V5XTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlUnVsZVRyZWUoa2V5LCBwcm9wZXJ0eSwgcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2cud2FybignUnVsZSBwcm9wZXJ0eSBtdXN0IGJlIGFuIG9iamVjdDogJywgbmFtZSwgcnVsZSwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJ1bGVzKHJ1bGVzKSB7XHJcbiAgICBsZXQgcnVsZVRyZWVzID0ge307XHJcblxyXG4gICAgZm9yIChsZXQga2V5IGluIHJ1bGVzKSB7XHJcbiAgICAgICAgbGV0IHJ1bGUgPSBydWxlc1trZXldO1xyXG4gICAgICAgIHJ1bGVUcmVlc1trZXldID0gcGFyc2VSdWxlVHJlZShrZXksIHJ1bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBydWxlVHJlZXM7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBkb2VzTWF0Y2goZmlsdGVyLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gKCh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihjb250ZXh0KSkgfHwgKGZpbHRlciA9PSBudWxsKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXRjaEZlYXR1cmUoY29udGV4dCwgcnVsZXMsIGNvbGxlY3RlZFJ1bGVzKSB7XHJcbiAgICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xyXG4gICAgbGV0IGNoaWxkTWF0Y2hlZCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChydWxlcy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgZm9yIChsZXQgcj0wOyByIDwgcnVsZXMubGVuZ3RoOyByKyspIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHJ1bGVzW3JdO1xyXG4gICAgICAgIGNvbnRleHQucHJvcGVydGllcyA9IGN1cnJlbnQucHJvcGVydGllcztcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBSdWxlTGVhZikge1xyXG5cclxuICAgICAgICAgICAgaWYgKGRvZXNNYXRjaChjdXJyZW50LmZpbHRlciwgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGVkUnVsZXMucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBSdWxlVHJlZSkge1xyXG4gICAgICAgICAgICBpZiAoZG9lc01hdGNoKGN1cnJlbnQuZmlsdGVyLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hpbGRNYXRjaGVkID0gbWF0Y2hGZWF0dXJlKFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5ydWxlcyxcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRSdWxlc1xyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkTWF0Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZFJ1bGVzLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRleHQucHJvcGVydGllcyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1hdGNoZWQ7XHJcbn1cclxuIiwiLy8gUmVuZGVyaW5nIHN0eWxlc1xyXG5cclxuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZV9wYXJzZXInO1xyXG5pbXBvcnQgRmVhdHVyZVNlbGVjdGlvbiBmcm9tICcuLi9zZWxlY3Rpb24nO1xyXG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tICcuLi9nbC9zaGFkZXJfcHJvZ3JhbSc7XHJcbmltcG9ydCBWQk9NZXNoIGZyb20gJy4uL2dsL3Zib19tZXNoJztcclxuaW1wb3J0IE1hdGVyaWFsIGZyb20gJy4uL21hdGVyaWFsJztcclxuaW1wb3J0IExpZ2h0IGZyb20gJy4uL2xpZ2h0JztcclxuaW1wb3J0IHtNZXRob2ROb3RJbXBsZW1lbnRlZH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJztcclxuaW1wb3J0IHNoYWRlclNvdXJjZXMgZnJvbSAnLi4vZ2wvc2hhZGVyX3NvdXJjZXMnOyAvLyBidWlsdC1pbiBzaGFkZXJzXHJcblxyXG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuXHJcbi8vIEJhc2UgY2xhc3NcclxuXHJcbmV4cG9ydCB2YXIgU3R5bGUgPSB7XHJcbiAgICBpbml0ICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNCdWlsdEluKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsdF9pbiA9IGZhbHNlOyAvLyBleHBsaWNpdGx5IHNldCB0byBmYWxzZSB0byBhdm9pZCBhbnkgY29uZnVzaW9uXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmRlZmluZXMgPSAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnZGVmaW5lcycpICYmIHRoaXMuZGVmaW5lcykgfHwge307IC8vICNkZWZpbmVzIHRvIGJlIGluamVjdGVkIGludG8gdGhlIHNoYWRlcnNcclxuICAgICAgICB0aGlzLnNoYWRlcnMgPSAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnc2hhZGVycycpICYmIHRoaXMuc2hhZGVycykgfHwge307IC8vIHNoYWRlciBjdXN0b21pemF0aW9uICh1bmlmb3JtcywgZGVmaW5lcywgYmxvY2tzLCBldGMuKVxyXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24gfHwgZmFsc2U7ICAgLy8gZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgc3R5bGUgc3VwcG9ydHMgZmVhdHVyZSBzZWxlY3Rpb25cclxuICAgICAgICB0aGlzLmNvbXBpbGluZyA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgIC8vIHByb2dyYW1zIGFyZSBjdXJyZW50bHkgY29tcGlsaW5nXHJcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9ncmFtcyBhcmUgZmluaXNoZWQgY29tcGlsaW5nXHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBHTCBwcm9ncmFtIHJlZmVyZW5jZSAoZm9yIG1haW4gcmVuZGVyIHBhc3MpXHJcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25fcHJvZ3JhbSA9IG51bGw7ICAgICAgICAgICAgICAvLyBHTCBwcm9ncmFtIHJlZmVyZW5jZSBmb3IgZmVhdHVyZSBzZWxlY3Rpb24gcmVuZGVyIHBhc3NcclxuICAgICAgICB0aGlzLmZlYXR1cmVfc3R5bGUgPSB7fTsgICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlIGZvciBmZWF0dXJlIGN1cnJlbnRseSBiZWluZyBwYXJzZWQsIHNoYXJlZCB0byBsZXNzZW4gR0MvbWVtb3J5IHRocmFzaFxyXG5cclxuICAgICAgICAvLyBCbGVuZGluZ1xyXG4gICAgICAgIHRoaXMuYmxlbmQgPSB0aGlzLmJsZW5kIHx8ICdvcGFxdWUnOyAgICAgICAgLy8gZGVmYXVsdDogb3BhcXVlIHN0eWxlcyBhcmUgZHJhd24gZmlyc3QsIHdpdGhvdXQgYmxlbmRpbmdcclxuICAgICAgICB0aGlzLmRlZmluZXNbYFRBTkdSQU1fQkxFTkRfJHt0aGlzLmJsZW5kLnRvVXBwZXJDYXNlKCl9YF0gPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgc3R5bGUgZGVmaW5lcyBpdHMgb3duIG1hdGVyaWFsLCByZXBsYWNlIHRoZSBpbmhlcml0ZWQgbWF0ZXJpYWwgaW5zdGFuY2VcclxuICAgICAgICBpZiAoISh0aGlzLm1hdGVyaWFsIGluc3RhbmNlb2YgTWF0ZXJpYWwpKSB7XHJcbiAgICAgICAgICAgIGlmICghTWF0ZXJpYWwuaXNWYWxpZCh0aGlzLm1hdGVyaWFsKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbCA9IFN0eWxlUGFyc2VyLmRlZmF1bHRzLm1hdGVyaWFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwodGhpcy5tYXRlcmlhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWF0ZXJpYWwuaW5qZWN0KHRoaXMpO1xyXG5cclxuICAgICAgICAvLyBTZXQgbGlnaHRpbmcgbW9kZTogZnJhZ21lbnQsIHZlcnRleCwgb3Igbm9uZSAoc3BlY2lmaWVkIGFzICdmYWxzZScpXHJcbiAgICAgICAgTGlnaHQuc2V0TW9kZSh0aGlzLmxpZ2h0aW5nLCB0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIGRlc3Ryb3kgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0pIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbl9wcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3Byb2dyYW0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIH0sXHJcblxyXG4gICAgaXNCdWlsdEluICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYXNPd25Qcm9wZXJ0eSgnYnVpbHRfaW4nKSAmJiB0aGlzLmJ1aWx0X2luO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKioqIFN0eWxlIHBhcnNpbmcgYW5kIGdlb21ldHJ5IGNvbnN0cnVjdGlvbiAqKiovXHJcblxyXG4gICAgLy8gUmV0dXJucyBhbiBvYmplY3QgdG8gaG9sZCBmZWF0dXJlIGRhdGEgKGZvciBhIHRpbGUgb3Igb3RoZXIgb2JqZWN0KVxyXG4gICAgc3RhcnREYXRhICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YTogbnVsbCxcclxuICAgICAgICAgICAgdW5pZm9ybXM6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBGaW5hbGl6ZXMgYW4gb2JqZWN0IGhvbGRpbmcgZmVhdHVyZSBkYXRhIChmb3IgYSB0aWxlIG9yIG90aGVyIG9iamVjdClcclxuICAgIGVuZERhdGEgKHRpbGVfZGF0YSkge1xyXG4gICAgICAgIGlmICh0aWxlX2RhdGEudmVydGV4X2RhdGEpIHtcclxuICAgICAgICAgICAgLy8gT25seSBrZWVwIGZpbmFsIGJ5dGUgYnVmZmVyXHJcbiAgICAgICAgICAgIHRpbGVfZGF0YS52ZXJ0ZXhfZGF0YS5lbmQoKTtcclxuICAgICAgICAgICAgdGlsZV9kYXRhLnZlcnRleF9kYXRhID0gdGlsZV9kYXRhLnZlcnRleF9kYXRhLmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aWxlX2RhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRGZWF0dXJlIChmZWF0dXJlLCBydWxlLCBjb250ZXh0LCB0aWxlX2RhdGEpIHtcclxuICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLnBhcnNlRmVhdHVyZShmZWF0dXJlLCBydWxlLCBjb250ZXh0KTtcclxuXHJcbiAgICAgICAgLy8gU2tpcCBmZWF0dXJlP1xyXG4gICAgICAgIGlmICghc3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmlyc3QgZmVhdHVyZSBpbiB0aGlzIHJlbmRlciBzdHlsZT9cclxuICAgICAgICBpZiAoIXRpbGVfZGF0YS52ZXJ0ZXhfZGF0YSkge1xyXG4gICAgICAgICAgICB0aWxlX2RhdGEudmVydGV4X2RhdGEgPSB0aGlzLnZlcnRleF9sYXlvdXQuY3JlYXRlVmVydGV4RGF0YSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5idWlsZEdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIHN0eWxlLCB0aWxlX2RhdGEudmVydGV4X2RhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICBidWlsZEdlb21ldHJ5IChnZW9tZXRyeSwgc3R5bGUsIHZlcnRleF9kYXRhKSB7XHJcbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkUG9seWdvbnMoW2dlb21ldHJ5LmNvb3JkaW5hdGVzXSwgc3R5bGUsIHZlcnRleF9kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFBvbHlnb25zKGdlb21ldHJ5LmNvb3JkaW5hdGVzLCBzdHlsZSwgdmVydGV4X2RhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZExpbmVzKFtnZW9tZXRyeS5jb29yZGluYXRlc10sIHN0eWxlLCB2ZXJ0ZXhfZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRMaW5lcyhnZW9tZXRyeS5jb29yZGluYXRlcywgc3R5bGUsIHZlcnRleF9kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50Jykge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkUG9pbnRzKFtnZW9tZXRyeS5jb29yZGluYXRlc10sIHN0eWxlLCB2ZXJ0ZXhfZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkUG9pbnRzKGdlb21ldHJ5LmNvb3JkaW5hdGVzLCBzdHlsZSwgdmVydGV4X2RhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VGZWF0dXJlIChmZWF0dXJlLCBydWxlX3N0eWxlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5mZWF0dXJlX3N0eWxlO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG9yZGVyIGlmIGl0IHdhcyBub3QgY2FjaGVkXHJcbiAgICAgICAgICAgIHN0eWxlLm9yZGVyID0gcnVsZV9zdHlsZS5vcmRlcjtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZS5vcmRlciAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLm9yZGVyID0gU3R5bGVQYXJzZXIuY2FsY3VsYXRlT3JkZXIoc3R5bGUub3JkZXIsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGZWF0dXJlIHNlbGVjdGlvbiAob25seSBpZiBzdHlsZSBzdXBwb3J0cyBpdClcclxuICAgICAgICAgICAgdmFyIHNlbGVjdGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgc3R5bGUuaW50ZXJhY3RpdmUgPSBydWxlX3N0eWxlLmludGVyYWN0aXZlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGUuaW50ZXJhY3RpdmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlID0gc3R5bGUuaW50ZXJhY3RpdmUoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlID0gc3R5bGUuaW50ZXJhY3RpdmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGZlYXR1cmUgaXMgbWFya2VkIGFzIHNlbGVjdGFibGVcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnNlbGVjdGlvbl9jb2xvciA9IEZlYXR1cmVTZWxlY3Rpb24ubWFrZUNvbG9yKGZlYXR1cmUsIGNvbnRleHQudGlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zZWxlY3Rpb25fY29sb3IgPSBGZWF0dXJlU2VsZWN0aW9uLmRlZmF1bHRDb2xvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3ViY2xhc3MgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgc3R5bGUgPSB0aGlzLl9wYXJzZUZlYXR1cmUoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZy5lcnJvcignU3R5bGUucGFyc2VGZWF0dXJlOiBzdHlsZSBwYXJzaW5nIGVycm9yJywgZmVhdHVyZSwgc3R5bGUsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9wYXJzZUZlYXR1cmUgKGZlYXR1cmUsIHJ1bGVfc3R5bGUsIGNvbnRleHQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWQoJ19wYXJzZUZlYXR1cmUnKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQnVpbGQgZnVuY3Rpb25zIGFyZSBuby1vcHMgdW50aWwgb3ZlcnJpZGVuXHJcbiAgICBidWlsZFBvbHlnb25zICgpIHt9LFxyXG4gICAgYnVpbGRMaW5lcyAoKSB7fSxcclxuICAgIGJ1aWxkUG9pbnRzICgpIHt9LFxyXG5cclxuXHJcbiAgICAvKioqIEdMIHN0YXRlIGFuZCByZW5kZXJpbmcgKioqL1xyXG5cclxuICAgIHNldEdMIChnbCkge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgIH0sXHJcblxyXG4gICAgbWFrZU1lc2ggKHZlcnRleF9kYXRhLCB7IHVuaWZvcm1zIH0gPSB7fSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVkJPTWVzaCh0aGlzLmdsLCB2ZXJ0ZXhfZGF0YSwgdGhpcy52ZXJ0ZXhfbGF5b3V0LCB7IHVuaWZvcm1zIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb21waWxlICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZ2wpIHtcclxuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKGBzdHlsZS5jb21waWxlKCk6IHNraXBwaW5nIGZvciAke3RoaXMubmFtZX0gYmVjYXVzZSBubyBHTCBjb250ZXh0YCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY29tcGlsaW5nKSB7XHJcbiAgICAgICAgICAgIHRocm93KG5ldyBFcnJvcihgc3R5bGUuY29tcGlsZSgpOiBza2lwcGluZyBmb3IgJHt0aGlzLm5hbWV9IGJlY2F1c2Ugc3R5bGUgaXMgYWxyZWFkeSBjb21waWxpbmdgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcGlsaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIEJ1aWxkIGRlZmluZXMgJiBmb3Igc2VsZWN0aW9uIChuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3Qgc2luY2UgdGhlIGZpcnN0IGlzIHN0b3JlZCBhcyBhIHJlZmVyZW5jZSBieSB0aGUgcHJvZ3JhbSlcclxuICAgICAgICB2YXIgZGVmaW5lcyA9IHRoaXMuYnVpbGREZWZpbmVMaXN0KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25fZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmluZXMpO1xyXG4gICAgICAgICAgICBzZWxlY3Rpb25fZGVmaW5lcy5UQU5HUkFNX0ZFQVRVUkVfU0VMRUNUSU9OID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdldCBhbnkgY3VzdG9tIGNvZGUgYmxvY2tzLCB1bmlmb3JtIGRlcGVuZGVuY2llcywgZXRjLlxyXG4gICAgICAgIHZhciBibG9ja3MgPSAodGhpcy5zaGFkZXJzICYmIHRoaXMuc2hhZGVycy5ibG9ja3MpO1xyXG4gICAgICAgIHZhciB1bmlmb3JtcyA9ICh0aGlzLnNoYWRlcnMgJiYgdGhpcy5zaGFkZXJzLnVuaWZvcm1zKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHNoYWRlcnNcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2wsXHJcbiAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzW3RoaXMudmVydGV4X3NoYWRlcl9rZXldLFxyXG4gICAgICAgICAgICAgICAgc2hhZGVyU291cmNlc1t0aGlzLmZyYWdtZW50X3NoYWRlcl9rZXldLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVzLFxyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLnByb2dyYW0uY29tcGlsZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0oXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbCxcclxuICAgICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2VzW3RoaXMudmVydGV4X3NoYWRlcl9rZXldLFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYWRlclNvdXJjZXNbJ2dsL3NoYWRlcnMvc2VsZWN0aW9uX2ZyYWdtZW50J10sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5uYW1lICsgJyAoc2VsZWN0aW9uKScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVzOiBzZWxlY3Rpb25fZGVmaW5lcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbl9wcm9ncmFtLmNvbXBpbGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uX3Byb2dyYW0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGlsaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cobmV3IEVycm9yKGBzdHlsZS5jb21waWxlKCk6IHN0eWxlICR7dGhpcy5uYW1lfSBlcnJvcjpgLCBlcnJvcikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jb21waWxpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbXBpbGVkID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQWRkIGEgc2hhZGVyIGJsb2NrXHJcbiAgICBhZGRTaGFkZXJCbG9jayAoa2V5LCAuLi5ibG9ja3MpIHtcclxuICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tzID0gdGhpcy5zaGFkZXJzLmJsb2NrcyB8fCB7fTtcclxuICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tzW2tleV0gPSB0aGlzLnNoYWRlcnMuYmxvY2tzW2tleV0gfHwgW107XHJcbiAgICAgICAgdGhpcy5zaGFkZXJzLmJsb2Nrc1trZXldLnB1c2goLi4uYmxvY2tzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmVtb3ZlIGFsbCBzaGFkZXIgYmxvY2tzIGZvciBrZXlcclxuICAgIHJlbW92ZVNoYWRlckJsb2NrIChrZXkpIHtcclxuICAgICAgICBpZiAodGhpcy5zaGFkZXJzLmJsb2Nrcykge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlcnMuYmxvY2tzW2tleV0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcmVwbGFjZVNoYWRlckJsb2NrIChrZXksIC4uLmJsb2Nrcykge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlU2hhZGVyQmxvY2soa2V5KTtcclxuICAgICAgICB0aGlzLmFkZFNoYWRlckJsb2NrKGtleSwgLi4uYmxvY2tzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqIFRPRE86IGNvdWxkIHByb2JhYmx5IGNvbWJpbmUgYW5kIGdlbmVyYWxpemUgdGhpcyB3aXRoIHNpbWlsYXIgbWV0aG9kIGluIFNoYWRlclByb2dyYW1cclxuICAgICAqIChsaXN0IG9mIGRlZmluZSBvYmplY3RzIHRoYXQgaW5oZXJpdCBmcm9tIGVhY2ggb3RoZXIpXHJcbiAgICAgKi9cclxuICAgIGJ1aWxkRGVmaW5lTGlzdCAoKSB7XHJcbiAgICAgICAgLy8gQWRkIGFueSBjdXN0b20gZGVmaW5lcyB0byBidWlsdC1pbiBzdHlsZSBkZWZpbmVzXHJcbiAgICAgICAgdmFyIGRlZmluZXMgPSB7fTsgLy8gY3JlYXRlIGEgbmV3IG9iamVjdCB0byBhdm9pZCBtdXRhdGluZyBhIHByb3RvdHlwZSB2YWx1ZSB0aGF0IG1heSBiZSBzaGFyZWQgd2l0aCBvdGhlciBzdHlsZXNcclxuICAgICAgICBpZiAodGhpcy5kZWZpbmVzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZCBpbiB0aGlzLmRlZmluZXMpIHtcclxuICAgICAgICAgICAgICAgIGRlZmluZXNbZF0gPSB0aGlzLmRlZmluZXNbZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVycyAhPSBudWxsICYmIHRoaXMuc2hhZGVycy5kZWZpbmVzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZm9yIChkIGluIHRoaXMuc2hhZGVycy5kZWZpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZpbmVzW2RdID0gdGhpcy5zaGFkZXJzLmRlZmluZXNbZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZmluZXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTZXR1cCBhbnkgR0wgc3RhdGUgZm9yIHJlbmRlcmluZ1xyXG4gICAgc2V0dXAgKCkge1xyXG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybXMoKTtcclxuICAgICAgICB0aGlzLm1hdGVyaWFsLnNldHVwUHJvZ3JhbShTaGFkZXJQcm9ncmFtLmN1cnJlbnQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTZXQgc3R5bGUgdW5pZm9ybXMgb24gY3VycmVudGx5IGJvdW5kIHByb2dyYW1cclxuICAgIHNldFVuaWZvcm1zICgpIHtcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IFNoYWRlclByb2dyYW0uY3VycmVudDtcclxuICAgICAgICBpZiAoIXByb2dyYW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3Jtcyh0aGlzLnNoYWRlcnMgJiYgdGhpcy5zaGFkZXJzLnVuaWZvcm1zLCB0cnVlKTsgLy8gcmVzZXQgdGV4dHVyZSB1bml0IHRvIDBcclxuICAgIH0sXHJcblxyXG4gICAgdXBkYXRlICgpIHtcclxuICAgICAgICAvLyBTdHlsZS1zcGVjaWZpYyBhbmltYXRpb25cclxuICAgICAgICAvLyBpZiAodHlwZW9mIHRoaXMuYW5pbWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuYW5pbWF0aW9uKCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG59O1xyXG4iLCIvLyBNYW5hZ2UgcmVuZGVyaW5nIHN0eWxlc1xyXG5cclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSAnLi4vZ2wvc2hhZGVyX3Byb2dyYW0nO1xyXG5pbXBvcnQgc2hhZGVyU291cmNlcyBmcm9tICcuLi9nbC9zaGFkZXJfc291cmNlcyc7IC8vIGJ1aWx0LWluIHNoYWRlcnNcclxuXHJcbmltcG9ydCB7U3R5bGV9IGZyb20gJy4vc3R5bGUnO1xyXG5pbXBvcnQge1BvbHlnb25zfSBmcm9tICcuL3BvbHlnb25zL3BvbHlnb25zJztcclxuaW1wb3J0IHtMaW5lc30gZnJvbSAnLi9saW5lcy9saW5lcyc7XHJcbmltcG9ydCB7UG9pbnRzfSBmcm9tICcuL3BvaW50cy9wb2ludHMnO1xyXG5pbXBvcnQge1RleHRTdHlsZX0gZnJvbSAnLi90ZXh0L3RleHQnO1xyXG5cclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcblxyXG5leHBvcnQgdmFyIFN0eWxlTWFuYWdlciA9IHt9O1xyXG5leHBvcnQgdmFyIFN0eWxlcyA9IHt9O1xyXG5leHBvcnQgdmFyIEJhc2VTdHlsZXMgPSB7fTtcclxuXHJcbi8vIFNldCB0aGUgYmFzZSBvYmplY3QgdXNlZCB0byBpbnN0YW50aWF0ZSBzdHlsZXNcclxuU3R5bGVNYW5hZ2VyLmJhc2VTdHlsZSA9IFN0eWxlO1xyXG5cclxuLy8gR2xvYmFsIGNvbmZpZ3VyYXRpb24gZm9yIGFsbCBzdHlsZXNcclxuU3R5bGVNYW5hZ2VyLmluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoU3R5bGVNYW5hZ2VyLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIFNoYWRlclByb2dyYW0ucmVtb3ZlQmxvY2soJ2dsb2JhbCcpO1xyXG5cclxuICAgIC8vIExheWVyIHJlLW9yZGVyaW5nIGZ1bmN0aW9uXHJcbiAgICBTaGFkZXJQcm9ncmFtLmFkZEJsb2NrKCdnbG9iYWwnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL2xheWVyX29yZGVyJ10pO1xyXG5cclxuICAgIC8vIEZlYXR1cmUgc2VsZWN0aW9uIGdsb2JhbFxyXG4gICAgU2hhZGVyUHJvZ3JhbS5hZGRCbG9jaygnZ2xvYmFsJywgc2hhZGVyU291cmNlc1snZ2wvc2hhZGVycy9zZWxlY3Rpb25fZ2xvYmFscyddKTtcclxuXHJcbiAgICAvLyBGZWF0dXJlIHNlbGVjdGlvbiB2ZXJ0ZXggc2hhZGVyIHN1cHBvcnRcclxuICAgIFNoYWRlclByb2dyYW0ucmVwbGFjZUJsb2NrKCdmZWF0dXJlLXNlbGVjdGlvbi12ZXJ0ZXgnLCBzaGFkZXJTb3VyY2VzWydnbC9zaGFkZXJzL3NlbGVjdGlvbl92ZXJ0ZXgnXSk7XHJcblxyXG4gICAgLy8gYXNzdW1lIG1pbiAxNi1iaXQgZGVwdGggYnVmZmVyLCBpbiBwcmFjdGljZSB1c2VzIDE0LWJpdHMsIDEgZXh0cmEgYml0IHRvIGhhbmRsZSB2aXJ0dWFsIGhhbGYtbGF5ZXJzXHJcbiAgICAvLyBmb3Igb3V0bGluZXMgKGluc2VydGVkIGluIGJldHdlZW4gbGF5ZXJzKSwgYW5vdGhlciBleHRyYSBiaXQgdG8gcHJldmVudCBwcmVjaXNpb24gbG9zc1xyXG4gICAgU2hhZGVyUHJvZ3JhbS5kZWZpbmVzLlRBTkdSQU1fTEFZRVJfREVMVEEgPSAxIC8gKDEgPDwgMTQpO1xyXG5cclxuICAgIFN0eWxlTWFuYWdlci5pbml0aWFsaXplZCA9IHRydWU7XHJcbn07XHJcblxyXG4vLyBEZXN0cm95IGFsbCBzdHlsZXMgZm9yIGEgZ2l2ZW4gR0wgY29udGV4dFxyXG5TdHlsZU1hbmFnZXIuZGVzdHJveSA9IGZ1bmN0aW9uIChnbCkge1xyXG4gICAgT2JqZWN0LmtleXMoU3R5bGVzKS5mb3JFYWNoKChfbmFtZSkgPT4ge1xyXG4gICAgICAgIHZhciBzdHlsZSA9IFN0eWxlc1tfbmFtZV07XHJcbiAgICAgICAgaWYgKHN0eWxlLmdsID09PSBnbCkge1xyXG4gICAgICAgICAgICBsb2cudHJhY2UoYFN0eWxlTWFuYWdlci5kZXN0cm95OiBkZXN0cm95aW5nIHJlbmRlciBzdHlsZSAke3N0eWxlLm5hbWV9YCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXN0eWxlLmlzQnVpbHRJbigpKSB7XHJcbiAgICAgICAgICAgICAgICBTdHlsZU1hbmFnZXIucmVtb3ZlKHN0eWxlLm5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8vIFJlZ2lzdGVyIGEgc3R5bGVcclxuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHN0eWxlKSB7XHJcbiAgICBTdHlsZXNbc3R5bGUubmFtZV0gPSBzdHlsZTtcclxuICAgIEJhc2VTdHlsZXNbc3R5bGUubmFtZV0gPSBzdHlsZTtcclxufTtcclxuXHJcbi8vIFJlbW92ZSBhIHN0eWxlXHJcblN0eWxlTWFuYWdlci5yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgZGVsZXRlIFN0eWxlc1tuYW1lXTtcclxufTtcclxuXHJcbi8vIFByZWxvYWRzIG5ldHdvcmsgcmVzb3VyY2VzIGluIHRoZSBzdHlsZXNoZWV0IChzaGFkZXJzLCB0ZXh0dXJlcywgZXRjLilcclxuU3R5bGVNYW5hZ2VyLnByZWxvYWQgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XHJcbiAgICAvLyBGaXJzdCBsb2FkIHJlbW90ZSBzdHlsZXMsIHRoZW4gbG9hZCBzaGFkZXIgYmxvY2tzIGZyb20gcmVtb3RlIFVSTHNcclxuICAgIHJldHVybiBTdHlsZU1hbmFnZXIubG9hZFJlbW90ZVN0eWxlcyhzdHlsZXMpLnRoZW4oU3R5bGVNYW5hZ2VyLmxvYWRTaGFkZXJCbG9ja3MpO1xyXG59O1xyXG5cclxuLy8gTG9hZCBzdHlsZSBkZWZpbml0aW9ucyBmcm9tIGV4dGVybmFsIFVSTHNcclxuU3R5bGVNYW5hZ2VyLmxvYWRSZW1vdGVTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XHJcbiAgICAvLyBDb2xsZWN0IFVSTHMgYW5kIG1vZGVzIHRvIGltcG9ydCBmcm9tIHRoZW1cclxuICAgIC8vIFRoaXMgaXMgZG9uZSBhcyBhIHNlcGFyYXRlIHN0ZXAgYmVjdWFzZSBpdCBpcyBwb3NzaWJsZSB0byBpbXBvcnQgbXVsdGlwbGUgbW9kZXMgZnJvbSBhIHNpbmdsZVxyXG4gICAgLy8gVVJMLCBhbmQgd2Ugd2FudCB0byBhdm9pZCBkdXBsaWNhdGUgY2FsbHMgZm9yIHRoZSBzYW1lIGZpbGUuXHJcbiAgICB2YXIgdXJscyA9IHt9O1xyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcclxuICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbbmFtZV07XHJcbiAgICAgICAgaWYgKHN0eWxlLnVybCkge1xyXG4gICAgICAgICAgICBpZiAoIXVybHNbc3R5bGUudXJsXSkge1xyXG4gICAgICAgICAgICAgICAgdXJsc1tzdHlsZS51cmxdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2UgYSBsaXN0IG9mIHRoZSBzdHlsZXMgdG8gaW1wb3J0IGZvciB0aGlzIFVSTFxyXG4gICAgICAgICAgICB1cmxzW3N0eWxlLnVybF0ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRfbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgIHNvdXJjZV9uYW1lOiBzdHlsZS5uYW1lIHx8IG5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFzIGVhY2ggVVJMIGZpbmlzaGVzIGxvYWRpbmcsIHJlcGxhY2UgdGhlIHRhcmdldCBzdHlsZShzKVxyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHVybHMpLm1hcCh1cmwgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIFV0aWxzLmxvYWRSZXNvdXJjZSh1cmwpLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE1peGluIHJlbW90ZSBzdHlsZXMsIHdpdGhpbiBlYWNoIHJlbW90ZSBmaWxlXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzb3VyY2Vfc3R5bGUgaW4gZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFN0eWxlTWFuYWdlci5taXgoZGF0YVtzb3VyY2Vfc3R5bGVdLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgcmVtb3RlIHN0eWxlcyB0byBsb2NhbCBzdHlsZXNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHRhcmdldCBvZiB1cmxzW3VybF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhW3RhcmdldC5zb3VyY2VfbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzW3RhcmdldC50YXJnZXRfbmFtZV0gPSBkYXRhW3RhcmdldC5zb3VyY2VfbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3R5bGVzW3RhcmdldC50YXJnZXRfbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBTdHlsZU1hbmFnZXIucHJlbG9hZDogZXJyb3IgaW1wb3J0aW5nIHN0eWxlICR7dGFyZ2V0LnRhcmdldF9uYW1lfSwgY291bGQgbm90IGZpbmQgc291cmNlIHN0eWxlICR7dGFyZ2V0LnNvdXJjZV9uYW1lfSBpbiAke3VybH1gKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKGBTdHlsZU1hbmFnZXIucHJlbG9hZDogZXJyb3IgaW1wb3J0aW5nIHN0eWxlKHMpICR7SlNPTi5zdHJpbmdpZnkodXJsc1t1cmxdKX0gZnJvbSAke3VybH1gLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSkpLnRoZW4oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN0eWxlcykpO1xyXG59O1xyXG5cclxuLy8gUHJlbG9hZCBzaGFkZXIgYmxvY2tzIGZyb20gZXh0ZXJuYWwgVVJMc1xyXG5TdHlsZU1hbmFnZXIubG9hZFNoYWRlckJsb2NrcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcclxuICAgIHZhciBxdWV1ZSA9IFtdO1xyXG4gICAgZm9yICh2YXIgc3R5bGUgb2YgVXRpbHMudmFsdWVzKHN0eWxlcykpIHtcclxuICAgICAgICBpZiAoc3R5bGUuc2hhZGVycyAmJiBzdHlsZS5zaGFkZXJzLmJsb2Nrcykge1xyXG4gICAgICAgICAgICBsZXQgX2Jsb2NrcyA9IHN0eWxlLnNoYWRlcnMuYmxvY2tzO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgYmxvY2tdIG9mIFV0aWxzLmVudHJpZXMoc3R5bGUuc2hhZGVycy5ibG9ja3MpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgX2tleSA9IGtleTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcnJheSBvZiBibG9ja3NcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2NrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGI9MDsgYiA8IGJsb2NrLmxlbmd0aDsgYisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYmxvY2tbYl0gPT09ICdvYmplY3QnICYmIGJsb2NrW2JdLnVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9pbmRleCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFV0aWxzLmlvKFV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsKGJsb2NrW2JdLnVybCkpLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmxvY2tzW19rZXldW19pbmRleF0gPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKGBTdHlsZU1hbmFnZXIubG9hZFNoYWRlckJsb2NrczogZXJyb3IgbG9hZGluZyBzaGFkZXIgYmxvY2tgLCBfYmxvY2tzLCBfa2V5LCBfaW5kZXgsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNpbmdsZSBibG9ja1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJsb2NrID09PSAnb2JqZWN0JyAmJiBibG9jay51cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKFV0aWxzLmlvKFV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsKGJsb2NrLnVybCkpLnRoZW4oKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Jsb2Nrc1tfa2V5XSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGVNYW5hZ2VyLmxvYWRTaGFkZXJCbG9ja3M6IGVycm9yIGxvYWRpbmcgc2hhZGVyIGJsb2NrYCwgX2Jsb2NrcywgX2tleSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLmFsbChxdWV1ZSkudGhlbigoKSA9PiBQcm9taXNlLnJlc29sdmUoc3R5bGVzKSk7IC8vIFRPRE86IGFkZCBlcnJvclxyXG59O1xyXG5cclxuU3R5bGVNYW5hZ2VyLm1peCA9IGZ1bmN0aW9uIChzdHlsZSwgc3R5bGVzKSB7XHJcbiAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGhhdmUgYWxyZWFkeSBhcHBsaWVkIG1peGlucyB0byB0aGlzIHN0eWxlXHJcbiAgICBpZiAoc3R5bGUubWl4ZWQpIHtcclxuICAgICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWl4aW4gc291cmNlcywgaW4gb3JkZXJcclxuICAgIGxldCBzb3VyY2VzID0gW107XHJcbiAgICBpZiAoc3R5bGUubWl4KSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUubWl4KSkge1xyXG4gICAgICAgICAgICBzb3VyY2VzLnB1c2goLi4uc3R5bGUubWl4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNvdXJjZXMucHVzaChzdHlsZS5taXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzb3VyY2VzID0gc291cmNlcy5tYXAoeCA9PiBzdHlsZXNbeF0pLmZpbHRlcih4ID0+IHgpO1xyXG4gICAgfVxyXG4gICAgc291cmNlcy5wdXNoKHN0eWxlKTtcclxuXHJcbiAgICAvLyBGbGFncyAtIE9SJ2QsIHRydWUgaWYgYW55IHN0eWxlIGhhcyBpdCBzZXRcclxuICAgIHN0eWxlLmFuaW1hdGVkID0gc291cmNlcy5zb21lKHggPT4geCAmJiB4LmFuaW1hdGVkKTtcclxuICAgIHN0eWxlLnRleGNvb3JkcyA9IHNvdXJjZXMuc29tZSh4ID0+IHggJiYgeC50ZXhjb29yZHMpO1xyXG5cclxuICAgIC8vIE92ZXJ3cml0ZXMgLSBsYXN0IGRlZmluaXRpb24gd2luc1xyXG4gICAgc3R5bGUuYmFzZSA9IHNvdXJjZXMubWFwKHggPT4geC5iYXNlKS5maWx0ZXIoeCA9PiB4KS5wb3AoKTtcclxuICAgIHN0eWxlLnRleHR1cmUgPSBzb3VyY2VzLm1hcCh4ID0+IHgudGV4dHVyZSkuZmlsdGVyKHggPT4geCkucG9wKCk7XHJcblxyXG4gICAgLy8gTWVyZ2VzIC0gcHJvcGVydHktc3BlY2lmaWMgcnVsZXMgZm9yIG1lcmdpbmcgdmFsdWVzXHJcbiAgICBzdHlsZS5kZWZpbmVzID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc291cmNlcy5tYXAoeCA9PiB4LmRlZmluZXMpLmZpbHRlcih4ID0+IHgpKTtcclxuICAgIHN0eWxlLm1hdGVyaWFsID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc291cmNlcy5tYXAoeCA9PiB4Lm1hdGVyaWFsKS5maWx0ZXIoeCA9PiB4KSk7XHJcblxyXG4gICAgbGV0IG1lcmdlID0gc291cmNlcy5tYXAoeCA9PiB4LnNoYWRlcnMpLmZpbHRlcih4ID0+IHgpO1xyXG4gICAgbGV0IHNoYWRlcnMgPSB7fTtcclxuICAgIHNoYWRlcnMuZGVmaW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLm1lcmdlLm1hcCh4ID0+IHguZGVmaW5lcykuZmlsdGVyKHggPT4geCkpO1xyXG4gICAgc2hhZGVycy51bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLm1lcmdlLm1hcCh4ID0+IHgudW5pZm9ybXMpLmZpbHRlcih4ID0+IHgpKTtcclxuXHJcbiAgICBtZXJnZS5tYXAoeCA9PiB4LmJsb2NrcykuZmlsdGVyKHggPT4geCkuZm9yRWFjaChibG9ja3MgPT4ge1xyXG4gICAgICAgIHNoYWRlcnMuYmxvY2tzID0gc2hhZGVycy5ibG9ja3MgfHwge307XHJcblxyXG4gICAgICAgIGZvciAobGV0IFt0LCBibG9ja10gb2YgVXRpbHMuZW50cmllcyhibG9ja3MpKSB7XHJcbiAgICAgICAgICAgIHNoYWRlcnMuYmxvY2tzW3RdID0gc2hhZGVycy5ibG9ja3NbdF0gfHwgW107XHJcblxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShibG9jaykpIHtcclxuICAgICAgICAgICAgICAgIHNoYWRlcnMuYmxvY2tzW3RdLnB1c2goLi4uYmxvY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2hhZGVycy5ibG9ja3NbdF0ucHVzaChibG9jayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBzdHlsZS5zaGFkZXJzID0gc2hhZGVycztcclxuICAgIHN0eWxlLm1peGVkID0gdHJ1ZTsgLy8gdHJhY2sgdGhhdCB3ZSBhbHJlYWR5IGFwcGxpZWQgbWl4aW5zIChhdm9pZCBkdXBlIHdvcmsgbGF0ZXIpXHJcblxyXG4gICAgcmV0dXJuIHN0eWxlO1xyXG59O1xyXG5cclxuLy8gQ3JlYXRlIGEgbmV3IHN0eWxlXHJcbi8vIG5hbWU6IG5hbWUgb2YgbmV3IHN0eWxlXHJcbi8vIGNvbmZpZzogcHJvcGVydGllcyBvZiBuZXcgc3R5bGVcclxuLy8gc3R5bGVzOiB3b3JraW5nIHNldCBvZiBzdHlsZXMgYmVpbmcgYnVpbHQgKHVzZWQgZm9yIG1peGluZyBpbiBleGlzdGluZyBzdHlsZXMpXHJcblN0eWxlTWFuYWdlci5jcmVhdGUgPSBmdW5jdGlvbiAobmFtZSwgY29uZmlnLCBzdHlsZXMgPSB7fSkge1xyXG4gICAgbGV0IHN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTsgLy8gc2hhbGxvdyBjb3B5XHJcbiAgICBzdHlsZS5uYW1lID0gbmFtZTtcclxuXHJcbiAgICAvLyBTdHlsZSBtaXhpbnNcclxuICAgIFN0eWxlTWFuYWdlci5taXgoc3R5bGUsIHN0eWxlcyk7XHJcblxyXG4gICAgLy8gSGFzIGJhc2Ugc3R5bGU/XHJcbiAgICAvLyBPbmx5IHJlbmRlcmFibGUgKGluc3RhbnRpYXRlZCkgc3R5bGVzIHNob3VsZCBiZSBpbmNsdWRlZCBmb3IgcnVuLXRpbWUgdXNlXHJcbiAgICAvLyBPdGhlcnMgYXJlIGludGVybWVkaWFyeS9hYnN0cmFjdCwgdXNlZCBkdXJpbmcgc3R5bGUgY29tcG9zaXRpb24gYnV0IG5vdCBleGVjdXRpb25cclxuICAgIGlmIChzdHlsZS5iYXNlICYmIEJhc2VTdHlsZXNbc3R5bGUuYmFzZV0pIHtcclxuICAgICAgICBTdHlsZXNbbmFtZV0gPSBzdHlsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShCYXNlU3R5bGVzW3N0eWxlLmJhc2VdKSwgc3R5bGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHlsZTtcclxufTtcclxuXHJcbi8vIENhbGxlZCB0byBjcmVhdGUgYW5kIGluaXRpYWxpemUgc3R5bGVzXHJcblN0eWxlTWFuYWdlci5idWlsZCA9IGZ1bmN0aW9uIChzdHlsZXMsIHNjZW5lID0ge30pIHtcclxuICAgIC8vIFNvcnQgc3R5bGVzIGJ5IGRlcGVuZGVuY3ksIHRoZW4gYnVpbGQgdGhlbVxyXG4gICAgbGV0IHN0eWxlX2RlcHMgPSBPYmplY3Qua2V5cyhzdHlsZXMpLnNvcnQoXHJcbiAgICAgICAgKGEsIGIpID0+IFN0eWxlTWFuYWdlci5pbmhlcml0YW5jZURlcHRoKGEsIHN0eWxlcykgLSBTdHlsZU1hbmFnZXIuaW5oZXJpdGFuY2VEZXB0aChiLCBzdHlsZXMpXHJcbiAgICApO1xyXG5cclxuICAgIC8vIE9ubHkga2VlcCBidWlsdC1pbiBiYXNlIHN0eWxlc1xyXG4gICAgZm9yIChsZXQgc25hbWUgaW4gU3R5bGVzKSB7XHJcbiAgICAgICAgaWYgKCFCYXNlU3R5bGVzW3NuYW1lXSkge1xyXG4gICAgICAgICAgICBkZWxldGUgU3R5bGVzW3NuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV29ya2luZyBzZXQgb2Ygc3R5bGVzIGJlaW5nIGJ1aWx0XHJcbiAgICBsZXQgd3MgPSB7fTtcclxuICAgIGZvciAobGV0IHNuYW1lIG9mIHN0eWxlX2RlcHMpIHtcclxuICAgICAgICB3c1tzbmFtZV0gPSBTdHlsZU1hbmFnZXIuY3JlYXRlKHNuYW1lLCBzdHlsZXNbc25hbWVdLCB3cyk7XHJcbiAgICB9XHJcblxyXG4gICAgU3R5bGVNYW5hZ2VyLmluaXRTdHlsZXMoKTtcclxuICAgIHJldHVybiBTdHlsZXM7XHJcbn07XHJcblxyXG4vLyBJbml0aWFsaXplIGFsbCBzdHlsZXNcclxuU3R5bGVNYW5hZ2VyLmluaXRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBJbml0aWFsaXplIGFsbFxyXG4gICAgZm9yIChsZXQgc25hbWUgaW4gU3R5bGVzKSB7XHJcbiAgICAgICAgU3R5bGVzW3NuYW1lXS5pbml0KCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBHaXZlbiBhIHN0eWxlIGtleSBpbiBhIHNldCBvZiBzdHlsZXMgdG8gYWRkLCBjb3VudCB0aGUgbGVuZ3RoIG9mIHRoZSBpbmhlcml0YW5jZSBjaGFpblxyXG4vLyBUT0RPOiByZW1vdmUgY3VycmVudCAoU3R5bGVzKSBhbmQgZnV0dXJlIChzdHlsZXMpIGR1cGxpY2F0aW9uLCBjb25mdXNpbmdcclxuU3R5bGVNYW5hZ2VyLmluaGVyaXRhbmNlRGVwdGggPSBmdW5jdGlvbiAoa2V5LCBzdHlsZXMpIHtcclxuICAgIGxldCBwYXJlbnRzID0gMDtcclxuXHJcbiAgICB3aGlsZSh0cnVlKSB7XHJcbiAgICAgICAgbGV0IHN0eWxlID0gc3R5bGVzW2tleV07XHJcbiAgICAgICAgaWYgKCFzdHlsZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgc2NlbmUgZGVmIGVycm9yLCB0cnlpbmcgdG8gZXh0ZW5kIGEgc3R5bGUgdGhhdCBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHdhcm4vdGhyb3c/XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVwZW5kZW5jeSBjaGFpbiBlbmRzIHdoZW4gdGhpcyBzdHlsZSBpc24ndCBtaXhpbmcgaW4gYW55IG90aGVyc1xyXG4gICAgICAgIGlmICghc3R5bGUubWl4KSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVHJhdmVyc2UgbmV4dCBwYXJlbnQgc3R5bGVcclxuICAgICAgICBwYXJlbnRzKys7XHJcblxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlLm1peCkpIHtcclxuICAgICAgICAgICAgLy8gSWYgbXVsdGlwbGUgbWl4aW5zLCBmaW5kIHRoZSBkZWVwZXN0IG9uZVxyXG4gICAgICAgICAgICBwYXJlbnRzICs9IE1hdGgubWF4KC4uLnN0eWxlLm1peC5tYXAocyA9PiBTdHlsZU1hbmFnZXIuaW5oZXJpdGFuY2VEZXB0aChzLCBzdHlsZXMpKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgc2luZ2xlIG1peGluLCBjb250aW51ZSBsb29wIHVwIHRoZSB0cmVlXHJcbiAgICAgICAgICAgIGtleSA9IHN0eWxlLm1peDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyZW50cztcclxufTtcclxuXHJcbi8vIENvbXBpbGUgYWxsIHN0eWxlc1xyXG5TdHlsZU1hbmFnZXIuY29tcGlsZSA9IGZ1bmN0aW9uIChrZXlzKSB7XHJcbiAgICBrZXlzID0ga2V5cyB8fCBPYmplY3Qua2V5cyhTdHlsZXMpO1xyXG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBTdHlsZXNba2V5XS5jb21waWxlKCk7XHJcbiAgICAgICAgICAgIGxvZy50cmFjZShgU3R5bGVNYW5hZ2VyLmNvbXBpbGUoKTogY29tcGlsZWQgc3R5bGUgJHtrZXl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZy5lcnJvcihgU3R5bGVNYW5hZ2VyLmNvbXBpbGUoKTogZXJyb3IgY29tcGlsaW5nIHN0eWxlICR7a2V5fTpgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxvZy5kZWJ1ZyhgU3R5bGVNYW5hZ2VyLmNvbXBpbGUoKTogY29tcGlsZWQgYWxsIHN0eWxlc2ApO1xyXG59O1xyXG5cclxuLy8gQWRkIGJ1aWx0LWluIHJlbmRlcmluZyBzdHlsZXNcclxuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyKFBvbHlnb25zKTtcclxuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyKExpbmVzKTtcclxuU3R5bGVNYW5hZ2VyLnJlZ2lzdGVyKFBvaW50cyk7XHJcblN0eWxlTWFuYWdlci5yZWdpc3RlcihUZXh0U3R5bGUpO1xyXG4iLCJpbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgR2VvIGZyb20gJy4uL2dlbyc7XHJcblxyXG5pbXBvcnQgcGFyc2VDU1NDb2xvciBmcm9tICdjc3Njb2xvcnBhcnNlcic7XHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5cclxuZXhwb3J0IHZhciBTdHlsZVBhcnNlciA9IHt9O1xyXG5cclxuLy8gU3R5bGUgbWFjcm9zXHJcblxyXG5TdHlsZVBhcnNlci5leHBhbmRNYWNyb3MgPSBmdW5jdGlvbiBleHBhbmRNYWNyb3MgKG9iaikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBvYmopIHtcclxuICAgICAgICB2YXIgdmFsID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAvLyBMb29wIHRocm91Z2ggb2JqZWN0IHByb3BlcnRpZXNcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgb2JqW3BdID0gZXhwYW5kTWFjcm9zKHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvbnZlcnQgc3RyaW5ncyBiYWNrIGludG8gZnVuY3Rpb25zXHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBTdHlsZVBhcnNlci5tYWNyb3MpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwubWF0Y2goU3R5bGVQYXJzZXIubWFjcm9zW21dKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNoaW50IGlnbm9yZTpzdGFydCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsKCdmID0gJyArIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNoaW50IGlnbm9yZTplbmQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3BdID0gZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBleHBhbmRlZCBtYWNybyAke3ZhbH0gdG8gJHtmfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbC1iYWNrIHRvIG9yaWdpbmFsIHZhbHVlIGlmIHBhcnNpbmcgZmFpbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtwXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnRyYWNlKGBmYWlsZWQgdG8gZXhwYW5kIG1hY3JvICR7dmFsfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuLy8gTGlzdCBvZiBtYWNyb3NcclxuU3R5bGVQYXJzZXIubWFjcm9zID0gW1xyXG4gICAgJ1N0eWxlLmNvbG9yLnBzZXVkb1JhbmRvbUNvbG9yJyxcclxuICAgICdTdHlsZS5jb2xvci5yYW5kb21Db2xvcicsXHJcbiAgICAnU3R5bGUucGl4ZWxzJ1xyXG5dO1xyXG5cclxuXHJcblxyXG52YXIgU3R5bGUgPSB7fTtcclxuXHJcblN0eWxlLmNvbG9yID0ge1xyXG4gICAgLy8gcHNldWRvLXJhbmRvbSBncmF5c2NhbGUgYnkgZ2VvbWV0cnkgaWRcclxuICAgIHBzZXVkb1JhbmRvbUdyYXlzY2FsZSgpIHtcclxuICAgICAgICB2YXIgZnVuYyA9IGBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLm1heCgocGFyc2VJbnQoZmVhdHVyZS5vc21faWQsIDE2KSAlIDEwMCkgLyAxMDAsIDAuNCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbMC43ICogYywgMC43ICogYywgMC43ICogY107XHJcbiAgICAgICAgfWA7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHBzZXVkby1yYW5kb20gY29sb3IgYnkgZ2VvbWV0cnkgaWRcclxuICAgIHBzZXVkb1JhbmRvbUNvbG9yKCkge1xyXG4gICAgICAgIHZhciBmdW5jID0gYGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgMC43ICogKHBhcnNlSW50KGZlYXR1cmUub3NtX2lkLCAxNikgLyAxMDAgJSAxKSxcclxuICAgICAgICAgICAgICAgIDAuNyAqIChwYXJzZUludChmZWF0dXJlLm9zbV9pZCwgMTYpIC8gMTAwMDAgJSAxKSxcclxuICAgICAgICAgICAgICAgIDAuNyAqIChwYXJzZUludChmZWF0dXJlLm9zbV9pZCwgMTYpIC8gMTAwMDAwMCAlIDEpXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfWA7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmM7XHJcbiAgICAgICAgLy8gcmV0dXJuIGBmdW5jdGlvbigpIHsgcmV0dXJuIFswLjcgKiAocGFyc2VJbnQoZmVhdHVyZS5vc21faWQsIDE2KSAvIDEwMCAlIDEpLCAwLjcgKiAocGFyc2VJbnQoZmVhdHVyZS5vc21faWQsIDE2KSAvIDEwMDAwICUgMSksIDAuNyAqIChwYXJzZUludChmZWF0dXJlLm9zbV9pZCwgMTYpIC8gMTAwMDAwMCAlIDEpXTsgfWA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHJhbmRvbSBjb2xvclxyXG4gICAgcmFuZG9tQ29sb3IoKSB7XHJcbiAgICAgICAgdmFyIGZ1bmMgPSBgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbMC43ICogTWF0aC5yYW5kb20oKSwgMC43ICogTWF0aC5yYW5kb20oKSwgMC43ICogTWF0aC5yYW5kb20oKV07XHJcbiAgICAgICAgfWA7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmM7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gKHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBkeW5hbWljIHN0eWxlKSB0aGF0IGNvbnZlcnRzIHBpeGVscyB0byBtZXRlcnMgZm9yIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwuXHJcbi8vIFRoZSBwcm92aWRlZCBwaXhlbCB2YWx1ZSAoJ3AnKSBjYW4gaXRzZWxmIGJlIGEgZnVuY3Rpb24sIGluIHdoaWNoIGNhc2UgaXQgaXMgd3JhcHBlZCBieSB0aGlzIG9uZS5cclxuU3R5bGUucGl4ZWxzID0gZnVuY3Rpb24gKHApIHtcclxuICAgIHZhciBmO1xyXG4gICAgZiA9ICdmdW5jdGlvbigpIHsgcmV0dXJuICcgKyAodHlwZW9mIHAgPT09ICdmdW5jdGlvbicgPyAnKCcgKyAocC50b1N0cmluZygpICsgJygpKScpIDogcCkgKyAnICogJG1ldGVyc19wZXJfcGl4ZWw7IH0nO1xyXG4gICAgcmV0dXJuIGY7XHJcbn07XHJcblxyXG4vLyBXcmFwcyBzdHlsZSBmdW5jdGlvbnMgYW5kIHByb3ZpZGVzIGEgc2NvcGUgb2YgY29tbW9ubHkgYWNjZXNzaWJsZSBkYXRhOlxyXG4vLyAtIGZlYXR1cmU6IHRoZSAncHJvcGVydGllcycgb2YgdGhlIGZlYXR1cmUsIGUuZy4gYWNjZXNzZWQgYXMgJ2ZlYXR1cmUubmFtZSdcclxuLy8gLSAkem9vbTogdGhlIGN1cnJlbnQgbWFwIHpvb20gbGV2ZWxcclxuLy8gLSAkZ2VvbWV0cnk6IHRoZSB0eXBlIG9mIGdlb21ldHJ5LCAncG9pbnQnLCAnbGluZScsIG9yICdwb2x5Z29uJ1xyXG4vLyAtICRtZXRlcnNfcGVyX3BpeGVsOiBjb252ZXJzaW9uIGZvciBtZXRlcnMvcGl4ZWxzIGF0IGN1cnJlbnQgbWFwIHpvb21cclxuLy8gLSBwcm9wZXJ0aWVzOiB1c2VyLWRlZmluZWQgcHJvcGVydGllcyBvbiB0aGUgc3R5bGUtcnVsZSBvYmplY3QgaW4gdGhlIHN0eWxlc2hlZXRcclxuU3R5bGVQYXJzZXIud3JhcEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgIHZhciBmID0gYGZ1bmN0aW9uKGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gY29udGV4dC5mZWF0dXJlLnByb3BlcnRpZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgJHpvb20gPSBjb250ZXh0Lnpvb207XHJcbiAgICAgICAgICAgICAgICB2YXIgJGdlb21ldHJ5ID0gY29udGV4dC5nZW9tZXRyeTtcclxuICAgICAgICAgICAgICAgIHZhciAkbWV0ZXJzX3Blcl9waXhlbCA9IGNvbnRleHQubWV0ZXJzX3Blcl9waXhlbDtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBvbmNlIHRpbGUgZmVhdHVyZSBpZHMgYXJlIG5vcm1hbGl6ZWRcclxuICAgICAgICAgICAgICAgIGZlYXR1cmUub3NtX2lkID0gZmVhdHVyZS5vc21faWQgfHwgZmVhdHVyZS51aWQgfHwgY29udGV4dC5mZWF0dXJlLmlkO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAoJHtmdW5jfSgpKTtcclxuICAgICAgICAgICAgfWA7XHJcbiAgICByZXR1cm4gZjtcclxufTtcclxuXHJcblxyXG4vLyBTdHlsZSBwYXJzaW5nXHJcblxyXG4vLyBTdHlsZSBkZWZhdWx0c1xyXG5TdHlsZVBhcnNlci5kZWZhdWx0cyA9IHtcclxuICAgIGNvbG9yOiBbMS4wLCAwLCAwXSxcclxuICAgIHdpZHRoOiAxLFxyXG4gICAgc2l6ZTogMSxcclxuICAgIGV4dHJ1ZGU6IGZhbHNlLFxyXG4gICAgaGVpZ2h0OiAyMCxcclxuICAgIG1pbl9oZWlnaHQ6IDAsXHJcbiAgICBvcmRlcjogMCxcclxuICAgIHo6IDAsXHJcbiAgICBtYXRlcmlhbDoge1xyXG4gICAgICAgIGFtYmllbnQ6IDEsXHJcbiAgICAgICAgZGlmZnVzZTogMVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8vIEEgY29udGV4dCBvYmplY3QgdGhhdCBpcyBwYXNzZWQgdG8gc3R5bGUgcGFyc2luZyBmdW5jdGlvbnMgdG8gcHJvdmlkZSBhIHNjb3BlIG9mIGNvbW1vbmx5IHVzZWQgdmFsdWVzXHJcblN0eWxlUGFyc2VyLmdldEZlYXR1cmVQYXJzZUNvbnRleHQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgdGlsZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmZWF0dXJlLFxyXG4gICAgICAgIHRpbGUsXHJcbiAgICAgICAgem9vbTogdGlsZS5jb29yZHMueixcclxuICAgICAgICBnZW9tZXRyeTogR2VvLmdlb21ldHJ5VHlwZShmZWF0dXJlLmdlb21ldHJ5LnR5cGUpLFxyXG4gICAgICAgIG1ldGVyc19wZXJfcGl4ZWw6IEdlby5tZXRlcnNQZXJQaXhlbCh0aWxlLmNvb3Jkcy56KSxcclxuICAgICAgICB1bml0c19wZXJfbWV0ZXI6IEdlby51bml0c19wZXJfbWV0ZXJbdGlsZS5jb29yZHMuel1cclxuICAgIH07XHJcbn07XHJcblxyXG5TdHlsZVBhcnNlci5jb252ZXJ0VW5pdHMgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQsIGNvbnZlcnQgPSB0cnVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB2YXIgdW5pdHMgPSB2YWwubWF0Y2goLyhbMC05Li1dKykoW2Etel0rKS8pO1xyXG4gICAgICAgIGlmICh1bml0cyAmJiB1bml0cy5sZW5ndGggPT09IDMpIHtcclxuICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh1bml0c1sxXSk7XHJcbiAgICAgICAgICAgIHVuaXRzID0gdW5pdHNbMl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29udmVydCkge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gcGl4ZWxzXHJcbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3B4Jykge1xyXG4gICAgICAgICAgICAgICAgdmFsICo9IEdlby5tZXRlcnNQZXJQaXhlbChjb250ZXh0Lnpvb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZnJvbSBraWxvbWV0ZXJzXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHVuaXRzID09PSAna20nKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgKj0gMTAwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgIC8vIEFycmF5IG9mIGFycmF5cywgZS5nLiB6b29tLWludGVycG9sYXRlZCBzdG9wc1xyXG4gICAgICAgIGlmICh2YWwuZXZlcnkodiA9PiB7IHJldHVybiBBcnJheS5pc0FycmF5KHYpOyB9KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsLm1hcCh2ID0+IHsgcmV0dXJuIFt2WzBdLCBTdHlsZVBhcnNlci5jb252ZXJ0VW5pdHModlsxXSwgY29udGV4dCwgY29udmVydCldOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXJyYXkgb2YgdmFsdWVzXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWwubWFwKHYgPT4geyByZXR1cm4gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHYsIGNvbnRleHQsIGNvbnZlcnQpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59O1xyXG5cclxuU3R5bGVQYXJzZXIucGFyc2VEaXN0YW5jZSA9IGZ1bmN0aW9uKHZhbCwgY29udGV4dCwgY29udmVydCA9IHRydWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdmFsID0gdmFsKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgdmFsID0gU3R5bGVQYXJzZXIuY29udmVydFVuaXRzKHZhbCwgY29udGV4dCwgY29udmVydCk7XHJcbiAgICB2YWwgPSBVdGlscy5pbnRlcnBvbGF0ZShjb250ZXh0Lnpvb20sIHZhbCk7XHJcblxyXG4gICAgaWYgKGNvbnZlcnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdmFsICo9IGNvbnRleHQudW5pdHNfcGVyX21ldGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICAgICAgdmFsLmZvckVhY2goKHYsIGkpID0+IHZhbFtpXSAqPSBjb250ZXh0LnVuaXRzX3Blcl9tZXRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufTtcclxuXHJcblN0eWxlUGFyc2VyLnBhcnNlQ29sb3IgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQgPSB7fSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB2YWwgPSB2YWwoY29udGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2UgQ1NTLXN0eWxlIGNvbG9yc1xyXG4gICAgLy8gVE9ETzogY2hhbmdlIGFsbCBjb2xvcnMgdG8gdXNlIDAtMjU1IHJhbmdlIGludGVybmFsbHkgdG8gYXZvaWQgZGl2aWRpbmcgYW5kIHRoZW4gcmUtbXVsdGlwbHlpbmcgaW4gZ2VvbSBidWlsZGVyXHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB2YWwgPSBwYXJzZUNTU0NvbG9yLnBhcnNlQ1NTQ29sb3IodmFsKTtcclxuICAgICAgICBpZiAodmFsICYmIHZhbC5sZW5ndGggPT09IDQpIHtcclxuICAgICAgICAgICAgdmFsID0gdmFsLnNsaWNlKDAsIDMpLm1hcChjID0+IHsgcmV0dXJuIGMgLyAyNTU7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLmV2ZXJ5KHYgPT4geyByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTsgfSkpIHtcclxuICAgICAgICAvLyBBcnJheSBvZiB6b29tLWludGVycG9sYXRlZCBzdG9wcywgZS5nLiBbem9vbSwgY29sb3JdIHBhaXJzXHJcbiAgICAgICAgdmFsID0gdmFsLm1hcCh2ID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2WzFdID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZjID0gcGFyc2VDU1NDb2xvci5wYXJzZUNTU0NvbG9yKHZbMV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZjICYmIHZjLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZjID0gdmMuc2xpY2UoMCwgMykubWFwKGMgPT4geyByZXR1cm4gYyAvIDI1NTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ZbMF0sIHZjXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29udGV4dC56b29tKSB7XHJcbiAgICAgICAgdmFsID0gVXRpbHMuaW50ZXJwb2xhdGUoY29udGV4dC56b29tLCB2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHRzXHJcbiAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgLy8gYWxwaGFcclxuICAgICAgICBpZiAoIXZhbFszXSkge1xyXG4gICAgICAgICAgICB2YWxbM10gPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbCA9IFswLCAwLCAwLCAxXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsO1xyXG59O1xyXG5cclxuLy8gT3JkZXIgaXMgc3VtbWVkIGZyb20gdG9wIHRvIGJvdHRvbSBpbiB0aGUgc3R5bGUgaGllcmFyY2h5OlxyXG4vLyBlYWNoIGNoaWxkIG9yZGVyIHZhbHVlIGlzIGFkZGVkIHRvIHRoZSBwYXJlbnQgb3JkZXIgdmFsdWVcclxuU3R5bGVQYXJzZXIuY2FsY3VsYXRlT3JkZXIgPSBmdW5jdGlvbihvcmRlciwgY29udGV4dCkge1xyXG4gICAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG9yZGVyID0gb3JkZXIoY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9yZGVyKSkge1xyXG4gICAgICAgIG9yZGVyID0gb3JkZXIucmVkdWNlKChzdW0sIG9yZGVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9yZGVyID0gb3JkZXIgfHwgU3R5bGVQYXJzZXIuZGVmYXVsdHMub3JkZXI7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIG9yZGVyID0gb3JkZXIoY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9yZGVyID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgb3JkZXIgPSBjb250ZXh0LmZlYXR1cmUucHJvcGVydGllc1tvcmRlcl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcmRlciA9IHBhcnNlRmxvYXQob3JkZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIW9yZGVyIHx8IGlzTmFOKG9yZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3VtICsgb3JkZXI7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgb3JkZXIgPSBjb250ZXh0LmZlYXR1cmUucHJvcGVydGllc1tvcmRlcl07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBvcmRlciA9IHBhcnNlRmxvYXQob3JkZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvcmRlcjtcclxufTtcclxuIiwiLypnbG9iYWwgTGFiZWwgKi9cclxuXHJcbmltcG9ydCBib3hJbnRlcnNlY3QgZnJvbSAnYm94LWludGVyc2VjdCc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XHJcbmltcG9ydCBHZW8gZnJvbSAnLi4vLi4vZ2VvJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsIHtcclxuICAgIGNvbnN0cnVjdG9yICh0ZXh0LCBzaXplLCB7IG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlIH0pIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcclxuICAgICAgICAgICAgdGV4dCxcclxuICAgICAgICAgICAgc2l6ZSxcclxuICAgICAgICAgICAgcG9zaXRpb246IFtdLFxyXG4gICAgICAgICAgICBiYm94OiBbXSxcclxuICAgICAgICAgICAgbW92ZV9pbl90aWxlLFxyXG4gICAgICAgICAgICBrZWVwX2luX3RpbGVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IExhYmVsLmlkKys7XHJcblxyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIgfHwgMjsgLy8gVE9ETzogbWFrZSBjb25maWd1cmFibGVcclxuICAgICAgICB0aGlzLmJ1ZmZlciAqPSBHZW8udW5pdHNfcGVyX3BpeGVsO1xyXG4gICAgfVxyXG5cclxuICAgIGlzQ29tcG9zaXRlICgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgb2NjbHVkZWQgKGJib3hlcykge1xyXG4gICAgICAgIGxldCBpbnRlcnNlY3QgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKGJib3hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGJveEludGVyc2VjdChbdGhpcy5iYm94XSwgYmJveGVzLCAoaSwgaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaW50ZXJzZWN0KSB7XHJcbiAgICAgICAgICAgIGJib3hlcy5wdXNoKHRoaXMuYmJveCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIGluVGlsZUJvdW5kcyAoKSB7XHJcbiAgICAgICAgbGV0IG1pbiA9IFsgdGhpcy5iYm94WzBdLCB0aGlzLmJib3hbMV0gXTtcclxuICAgICAgICBsZXQgbWF4ID0gWyB0aGlzLmJib3hbMl0sIHRoaXMuYmJveFszXSBdO1xyXG5cclxuICAgICAgICBpZiAoIVV0aWxzLnBvaW50SW5UaWxlKG1pbikgfHwgIVV0aWxzLnBvaW50SW5UaWxlKG1heCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzY2FyZCAoYmJveGVzKSB7XHJcbiAgICAgICAgbGV0IGRpc2NhcmQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gcGVyZm9ybSBzcGVjaWZpYyBzdHlsaW5nIHJ1bGUsIHNob3VsZCB3ZSBrZWVwIHRoZSBsYWJlbCBpbiB0aWxlIGJvdW5kcz9cclxuICAgICAgICBpZiAodGhpcy5rZWVwX2luX3RpbGUpIHtcclxuICAgICAgICAgICAgbGV0IGluX3RpbGUgPSB0aGlzLmluVGlsZUJvdW5kcygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpbl90aWxlICYmIHRoaXMubW92ZV9pbl90aWxlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjYW4gd2UgbW92ZT9cclxuICAgICAgICAgICAgICAgIGRpc2NhcmQgPSB0aGlzLm1vdmVJblRpbGUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghaW5fdGlsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgZGlkbid0IHdhbnQgdG8gbW92ZSBhdCBhbGwsXHJcbiAgICAgICAgICAgICAgICAvLyBqdXN0IGRpc2NhcmQgc2luY2Ugd2UncmUgb3V0IG9mIHRpbGUgYm91bmRzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2hvdWxkIHdlIGRpc2NhcmQ/IGlmIG5vdCwganVzdCBtYWtlIG9jY2x1c2lvbiB0ZXN0XHJcbiAgICAgICAgcmV0dXJuIGRpc2NhcmQgfHwgdGhpcy5vY2NsdWRlZChiYm94ZXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5MYWJlbC5pZCA9IDA7XHJcblxyXG4iLCJpbXBvcnQgTGFiZWxQb2ludCBmcm9tICcuL2xhYmVsX3BvaW50JztcclxuaW1wb3J0IExhYmVsTGluZSBmcm9tICcuL2xhYmVsX2xpbmUnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xyXG5cclxudmFyIExhYmVsQnVpbGRlcjtcclxuZXhwb3J0IGRlZmF1bHQgTGFiZWxCdWlsZGVyID0ge307XHJcblxyXG5MYWJlbEJ1aWxkZXIubGFiZWxzRnJvbUdlb21ldHJ5ID0gZnVuY3Rpb24gKGdlb21ldHJ5LCB7IHRleHQsIHNpemUgfSwgbGFiZWxfc3R5bGUpIHtcclxuICAgIGxldCBsYWJlbHMgPSBbXTtcclxuXHJcbiAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcclxuICAgICAgICBsZXQgbGluZXMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcclxuXHJcbiAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsTGluZSh0ZXh0LCBzaXplLCBsaW5lcywgbGFiZWxfc3R5bGUubGluZXMsIHsgbW92ZV9pbl90aWxlOiB0cnVlLCBrZWVwX2luX3RpbGU6IHRydWUgfSkpO1xyXG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIk11bHRpTGluZVN0cmluZ1wiKSB7XHJcbiAgICAgICAgbGV0IGxpbmVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IGxpbmUgPSBsaW5lc1tpXTtcclxuXHJcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKG5ldyBMYWJlbExpbmUodGV4dCwgc2l6ZSwgbGluZSwgbGFiZWxfc3R5bGUubGluZXMsIHsgbW92ZV9pbl90aWxlOiB0cnVlLCBrZWVwX2luX3RpbGU6IHRydWUgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2ludFwiKSB7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gbGFiZWxfc3R5bGUucG9pbnRzLm1heF93aWR0aDtcclxuXHJcbiAgICAgICAgaWYgKHdpZHRoICYmIHNpemUudGV4dF9zaXplWzBdID4gd2lkdGgpIHtcclxuICAgICAgICAgICAgbGV0IGxpbmVfaGVpZ2h0ID0gKHNpemUucHhfbG9naWNhbF9zaXplIC8gMTAwKSAqIGxhYmVsX3N0eWxlLnBvaW50cy5saW5lX2hlaWdodDtcclxuICAgICAgICAgICAgbGluZV9oZWlnaHQgPSBVdGlscy5waXhlbFRvTWVyY2F0b3IobGluZV9oZWlnaHQpO1xyXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBMYWJlbFBvaW50LmV4cGxvZGUodGV4dCwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHNpemUsIHdpZHRoLCBsaW5lX2hlaWdodCwgeyBtb3ZlX2luX3RpbGU6IHRydWUsIGtlZXBfaW5fdGlsZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKGxhYmVsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsYWJlbHMucHVzaChuZXcgTGFiZWxQb2ludCh0ZXh0LCBnZW9tZXRyeS5jb29yZGluYXRlcywgc2l6ZSwgbnVsbCwgeyBtb3ZlX2luX3RpbGU6IHRydWUsIGtlZXBfaW5fdGlsZTogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIk11bHRpUG9pbnRcIikge1xyXG4gICAgICAgIGxldCBwb2ludHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IHBvaW50ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICBsYWJlbHMucHVzaChuZXcgTGFiZWxQb2ludCh0ZXh0LCBwb2ludCwgc2l6ZSwgbnVsbCwgeyBtb3ZlX2luX3RpbGU6IHRydWUsIGtlZXBfaW5fdGlsZTogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIlBvbHlnb25cIikge1xyXG4gICAgICAgIGxldCBjZW50cm9pZCA9IFV0aWxzLmNlbnRyb2lkKGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKTtcclxuICAgICAgICBsZXQgYXJlYSA9IFV0aWxzLnBvbHlnb25BcmVhKGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKTtcclxuXHJcbiAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQodGV4dCwgY2VudHJvaWQsIHNpemUsIGFyZWEsIHsgbW92ZV9pbl90aWxlOiB0cnVlLCBrZWVwX2luX3RpbGU6IHRydWUgfSkpO1xyXG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSBcIk11bHRpUG9seWdvblwiKSB7XHJcbiAgICAgICAgbGV0IGNlbnRyb2lkID0gVXRpbHMubXVsdGlDZW50cm9pZChnZW9tZXRyeS5jb29yZGluYXRlcyk7XHJcbiAgICAgICAgbGV0IGFyZWEgPSBVdGlscy5tdWx0aVBvbHlnb25BcmVhKGdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuXHJcbiAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQodGV4dCwgY2VudHJvaWQsIHNpemUsIGFyZWEsIHsgbW92ZV9pbl90aWxlOiB0cnVlLCBrZWVwX2luX3RpbGU6IHRydWUgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYWJlbHM7XHJcbn07XHJcblxyXG5cclxuIiwiaW1wb3J0IFZlY3RvciBmcm9tICcuLi8uLi92ZWN0b3InO1xyXG5pbXBvcnQgR2VvIGZyb20gJy4uLy4uL2dlbyc7XHJcbmltcG9ydCBMYWJlbCBmcm9tICcuL2xhYmVsJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsTGluZSBleHRlbmRzIExhYmVsIHtcclxuICAgIGNvbnN0cnVjdG9yICh0ZXh0LCBzaXplLCBsaW5lcywgc3R5bGUsIHsgbW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUgfSkge1xyXG4gICAgICAgIHN1cGVyKHRleHQsIHNpemUsIHsgbW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VnbWVudF9pbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xyXG4gICAgICAgIHRoaXMuZXhjZWVkX2hldXJpc3RpYyA9IHN0eWxlLmV4Y2VlZDtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IHN0eWxlLm9mZnNldDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIG1pZGRsZVNlZ21lbnQgKHNlZ21lbnQpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAoc2VnbWVudFswXVswXSArIHNlZ21lbnRbMV1bMF0pIC8gMixcclxuICAgICAgICAgICAgKHNlZ21lbnRbMF1bMV0gKyBzZWdtZW50WzFdWzFdKSAvIDIsXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUgKCkge1xyXG4gICAgICAgIGxldCBzZWdtZW50ID0gdGhpcy5jdXJyZW50U2VnbWVudCgpO1xyXG5cclxuICAgICAgICB0aGlzLmFuZ2xlID0gdGhpcy5jb21wdXRlQW5nbGUoKTtcclxuXHJcbiAgICAgICAgbGV0IHBlcnAgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5wZXJwKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pKTtcclxuICAgICAgICBsZXQgZG90ID0gVmVjdG9yLmRvdChwZXJwLCBbMCwgMV0pO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSBWZWN0b3IubXVsdChwZXJwLCBVdGlscy5waXhlbFRvTWVyY2F0b3IodGhpcy5vZmZzZXQgKiBNYXRoLnNpZ24oZG90KSkpO1xyXG5cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gVmVjdG9yLmFkZCh0aGlzLm1pZGRsZVNlZ21lbnQoc2VnbWVudCksIG9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5iYm94ID0gdGhpcy5jb21wdXRlQkJveCgpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vdmVOZXh0U2VnbWVudCAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VnbWVudF9pbmRleCArIDEgPj0gdGhpcy5saW5lcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2VnbWVudF9pbmRleCsrO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXB1dGVBbmdsZSAoKSB7XHJcbiAgICAgICAgbGV0IHNlZ21lbnQgPSB0aGlzLmN1cnJlbnRTZWdtZW50KCk7XHJcbiAgICAgICAgbGV0IHAwcDEgPSBWZWN0b3Iuc3ViKHNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pO1xyXG5cclxuICAgICAgICBwMHAxID0gVmVjdG9yLm5vcm1hbGl6ZShwMHAxKTtcclxuXHJcbiAgICAgICAgbGV0IFBJXzIgPSBNYXRoLlBJIC8gMjtcclxuICAgICAgICBsZXQgdGhldGEgPSBNYXRoLmF0YW4yKHAwcDFbMF0sIHAwcDFbMV0pICsgUElfMjtcclxuXHJcbiAgICAgICAgaWYgKHRoZXRhID4gUElfMiB8fCB0aGV0YSA8IC1QSV8yKSB7XHJcbiAgICAgICAgICAgIHRoZXRhICs9IE1hdGguUEk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoZXRhICU9IE1hdGguUEkgKiAyO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhldGE7XHJcbiAgICB9XHJcblxyXG4gICAgZml0VG9TZWdtZW50IChzaG91bGRfZml0ID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICghc2hvdWxkX2ZpdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzZWdtZW50ID0gdGhpcy5jdXJyZW50U2VnbWVudCgpO1xyXG4gICAgICAgIGxldCBwMHAxID0gVmVjdG9yLnN1YihzZWdtZW50WzBdLCBzZWdtZW50WzFdKTtcclxuICAgICAgICBsZXQgbGVuZ3RoID0gVmVjdG9yLmxlbmd0aChwMHAxKTtcclxuXHJcbiAgICAgICAgbGV0IGxhYmVsX2xlbmd0aCA9IFV0aWxzLnBpeGVsVG9NZXJjYXRvcih0aGlzLnNpemUudGV4dF9zaXplWzBdKTtcclxuXHJcbiAgICAgICAgaWYgKGxhYmVsX2xlbmd0aCA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBhbiBleGNlZWQgaGV1cmVzdGljIG9mIDEwMCUgd291bGQgbGV0IHRoZSBsYWJlbCBmaXQgaW4gYW55IGNhc2VzXHJcbiAgICAgICAgICAgIGxldCBleGNlZWQgPSAoMSAtIChsZW5ndGggLyBsYWJlbF9sZW5ndGgpKSAqIDEwMDtcclxuICAgICAgICAgICAgcmV0dXJuIGV4Y2VlZCA8IHRoaXMuZXhjZWVkX2hldXJpc3RpYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsYWJlbF9sZW5ndGggPCBsZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgY3VycmVudFNlZ21lbnQgKCkge1xyXG4gICAgICAgIGxldCBwMSA9IHRoaXMubGluZXNbdGhpcy5zZWdtZW50X2luZGV4XTtcclxuICAgICAgICBsZXQgcDIgPSB0aGlzLmxpbmVzW3RoaXMuc2VnbWVudF9pbmRleCArIDFdO1xyXG5cclxuICAgICAgICByZXR1cm4gWyBwMSwgcDIgXTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wdXRlQkJveCAoc2l6ZSkge1xyXG4gICAgICAgIGxldCB1cHAgPSBHZW8udW5pdHNfcGVyX3BpeGVsO1xyXG5cclxuICAgICAgICBsZXQgbWVyY193aWR0aCA9IHRoaXMuc2l6ZS50ZXh0X3NpemVbMF0gKiB1cHA7XHJcbiAgICAgICAgbGV0IG1lcmNfaGVpZ2h0ID0gdGhpcy5zaXplLnRleHRfc2l6ZVsxXSAqIHVwcDtcclxuXHJcbiAgICAgICAgbGV0IGMgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKTtcclxuICAgICAgICBsZXQgcyA9IE1hdGguc2luKHRoaXMuYW5nbGUpO1xyXG5cclxuICAgICAgICBsZXQgeCA9IG1lcmNfd2lkdGggKiBjIC0gbWVyY19oZWlnaHQgKiBzO1xyXG4gICAgICAgIGxldCB5ID0gbWVyY193aWR0aCAqIHMgKyBtZXJjX2hlaWdodCAqIGM7XHJcblxyXG4gICAgICAgIGxldCBtYXggPSBNYXRoLm1heChNYXRoLmFicyh4KSwgTWF0aC5hYnMoeSkpICogMC41ICsgdGhpcy5idWZmZXI7XHJcblxyXG4gICAgICAgIGxldCBiYm94ID0gW1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdIC0gbWF4LFxyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdIC0gbWF4LFxyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdICsgbWF4LFxyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdICsgbWF4XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJib3g7XHJcbiAgICB9XHJcblxyXG4gICAgbW92ZUluVGlsZSAoKSB7XHJcbiAgICAgICAgbGV0IGluX3RpbGUgPSBmYWxzZTtcclxuICAgICAgICBsZXQgZml0c190b19zZWdtZW50ID0gdGhpcy5maXRUb1NlZ21lbnQoKTtcclxuXHJcbiAgICAgICAgLy8gbW92ZSB0aGlzIGxhYmVsIHVudGlsIHdlIGZvdW5kIGEgbGluZSB3ZSBjYW4gZml0IGluXHJcbiAgICAgICAgd2hpbGUgKCFpbl90aWxlICYmICFmaXRzX3RvX3NlZ21lbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm1vdmVOZXh0U2VnbWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCBtb3ZlIGZ1cnRoZXIgaW4gdGhpcyBsaW5lXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW5fdGlsZSA9IHRoaXMuaW5UaWxlQm91bmRzKCk7XHJcbiAgICAgICAgICAgIGZpdHNfdG9fc2VnbWVudCA9IHRoaXMuZml0VG9TZWdtZW50KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gIWluX3RpbGUgfHzCoCFmaXRzX3RvX3NlZ21lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzY2FyZCAoYmJveGVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGluZXMgJiYgIXRoaXMuZml0VG9TZWdtZW50KCkpIHtcclxuICAgICAgICAgICAgd2hpbGUgKCF0aGlzLmZpdFRvU2VnbWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubW92ZU5leHRTZWdtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRpc2NhcmQoYmJveGVzKTtcclxuICAgIH1cclxufVxyXG5cclxuIiwiaW1wb3J0IExhYmVsIGZyb20gJy4vbGFiZWwnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMnO1xyXG5pbXBvcnQgR2VvIGZyb20gJy4uLy4uL2dlbyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbFBvaW50IGV4dGVuZHMgTGFiZWwge1xyXG4gICAgY29uc3RydWN0b3IgKHRleHQsIHBvc2l0aW9uLCBzaXplLCBhcmVhLCB7IG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlIH0pIHtcclxuICAgICAgICBzdXBlcih0ZXh0LCBzaXplLCB7IG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFyZWEgPSBhcmVhO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICB0aGlzLmJib3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZUJCb3ggKCkge1xyXG4gICAgICAgIGxldCBoYWxmX21lcmNfd2lkdGggPSBVdGlscy5waXhlbFRvTWVyY2F0b3IodGhpcy5zaXplLnRleHRfc2l6ZVswXSkgKiAwLjUgKyB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICBsZXQgaGFsZl9tZXJjX2hlaWdodCA9IFV0aWxzLnBpeGVsVG9NZXJjYXRvcih0aGlzLnNpemUudGV4dF9zaXplWzFdKSAqIDAuNSArIHRoaXMuYnVmZmVyO1xyXG5cclxuICAgICAgICBsZXQgYmJveCA9IFtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblswXSAtIGhhbGZfbWVyY193aWR0aCxcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAtIGhhbGZfbWVyY19oZWlnaHQsXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMF0gKyBoYWxmX21lcmNfd2lkdGgsXHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bMV0gKyBoYWxmX21lcmNfaGVpZ2h0XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJib3g7XHJcbiAgICB9XHJcblxyXG4gICAgbW92ZUluVGlsZSAoaW5fdGlsZSkge1xyXG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuYmJveFsyXSAtIHRoaXMuYmJveFswXTtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gLXRoaXMuYmJveFszXSAtICgtdGhpcy5iYm94WzFdKTtcclxuXHJcbiAgICAgICAgLy8gTW92ZSBwb2ludCBsYWJlbHMgdG8gdGlsZSBlZGdlcyAob25seSBpZiBtb3N0bHkgaW4gdGhpcyB0aWxlKVxyXG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uWzBdIC0gd2lkdGgvMiA8IDAgJiYgdGhpcy5wb3NpdGlvblswXSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblswXSA9IHdpZHRoLzIgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnBvc2l0aW9uWzBdICsgd2lkdGgvMiA+IEdlby50aWxlX3NjYWxlICYmIHRoaXMucG9zaXRpb25bMF0gPCBHZW8udGlsZV9zY2FsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzBdID0gR2VvLnRpbGVfc2NhbGUgLSAod2lkdGgvMiArIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvblsxXSAqPSAtMTsgLy8ganVzdCBkb2luZyB0aGlzIHNvIFkgY29vcmQgaXMgcG9zaXRpdmVcclxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvblsxXSAtIGhlaWdodC8yIDwgMCAmJiB0aGlzLnBvc2l0aW9uWzFdID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uWzFdID0gaGVpZ2h0LzIgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnBvc2l0aW9uWzFdICsgaGVpZ2h0LzIgPiBHZW8udGlsZV9zY2FsZSAmJiB0aGlzLnBvc2l0aW9uWzFdIDwgR2VvLnRpbGVfc2NhbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvblsxXSA9IEdlby50aWxlX3NjYWxlIC0gKGhlaWdodC8yICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9zaXRpb25bMV0gKj0gLTE7XHJcblxyXG4gICAgICAgIHRoaXMuYmJveCA9IHRoaXMuY29tcHV0ZUJCb3goKTtcclxuICAgICAgICByZXR1cm4gIXRoaXMuaW5UaWxlQm91bmRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGV4cGxvZGUgKHRleHQsIHBvc2l0aW9uLCBzaXplLCBtYXhfd2lkdGgsIHBhZGRpbmcsIG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlKSB7XHJcbiAgICAgICAgbGV0IHNwbGl0X3RleHQgPSB0ZXh0LnNwbGl0KCcgJyk7XHJcblxyXG4gICAgICAgIGlmIChzcGxpdF90ZXh0Lmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMYWJlbFBvaW50KHRleHQsIHBvc2l0aW9uLCBzaXplLCBudWxsLCBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGluZSA9IG5ldyBUZXh0TGluZSh0ZXh0LCBzaXplLnRleHRfc2l6ZVswXSwgc3BsaXRfdGV4dCwgc2l6ZS5zcGxpdF9zaXplKTtcclxuICAgICAgICBsZXQgbGluZXMgPSBsaW5lLmV4cGxvZGUobWF4X3dpZHRoKTtcclxuICAgICAgICBsZXQgbGFiZWxzID0gW107XHJcblxyXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMYWJlbFBvaW50KHRleHQsIHBvc2l0aW9uLCBzaXplLCBudWxsLCBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpIGluIGxpbmVzKSB7XHJcbiAgICAgICAgICAgIGxldCBsID0gbGluZXNbaV07XHJcbiAgICAgICAgICAgIGxldCBwb3MgPSBbcG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdIC0gTWF0aC5hYnMocGFkZGluZykgKiBpXTtcclxuICAgICAgICAgICAgbGFiZWxzLnB1c2gobmV3IExhYmVsUG9pbnQobC50ZXh0LCBwb3MsIHNpemUsIG51bGwsIG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IExhYmVsQ29tcG9zaXRlKHRleHQsIHBvc2l0aW9uLCBzaXplLCBsYWJlbHMsIG1vdmVfaW5fdGlsZSwga2VlcF9pbl90aWxlKTtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgTGFiZWxDb21wb3NpdGUgZXh0ZW5kcyBMYWJlbCB7XHJcbiAgICBjb25zdHJ1Y3RvciAodGV4dCwgcG9zaXRpb24sIHNpemUsIGxhYmVscywgbW92ZV9pbl90aWxlLCBrZWVwX2luX3RpbGUpIHtcclxuICAgICAgICBzdXBlcih0ZXh0LCBzaXplLCBtb3ZlX2luX3RpbGUsIGtlZXBfaW5fdGlsZSk7XHJcblxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICB0aGlzLmxhYmVscyA9IGxhYmVscztcclxuICAgICAgICB0aGlzLmJib3ggPSB0aGlzLmNvbXB1dGVCQm94KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNDb21wb3NpdGUgKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIG1vdmVJblRpbGUgKGluX3RpbGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcHV0ZUJCb3ggKCkge1xyXG4gICAgICAgIGxldCBiYm94ID0gWyBJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5IF07XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5sYWJlbHMpIHtcclxuICAgICAgICAgICAgbGV0IGIgPSB0aGlzLmxhYmVsc1tpXS5iYm94O1xyXG5cclxuICAgICAgICAgICAgYmJveFswXSA9IE1hdGgubWluKGJbMF0sIGJib3hbMF0pO1xyXG4gICAgICAgICAgICBiYm94WzFdID0gTWF0aC5taW4oYlsxXSwgYmJveFsxXSk7XHJcbiAgICAgICAgICAgIGJib3hbMl0gPSBNYXRoLm1heChiWzJdLCBiYm94WzJdKTtcclxuICAgICAgICAgICAgYmJveFszXSA9IE1hdGgubWF4KGJbM10sIGJib3hbM10pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGJib3g7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIFRleHRMaW5lIHtcclxuICAgIGNvbnN0cnVjdG9yICh0ZXh0LCBsaW5lX2xlbmd0aCwgd29yZHMsIHNpemVfaW5mbykge1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy5saW5lX2xlbmd0aCA9IGxpbmVfbGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc2l6ZV9pbmZvID0gc2l6ZV9pbmZvO1xyXG4gICAgICAgIHRoaXMud29yZHMgPSB0aGlzLnBvc2l0aW9ucyh3b3Jkcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcG9zaXRpb25zICh3b3Jkcywgc2l6ZV9pbmZvKSB7XHJcbiAgICAgICAgbGV0IHdvcmRfaW5mb3MgPSBbXTtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgICAgICBsZXQgc3BhY2Vfb2Zmc2V0ID0gdGhpcy5zaXplX2luZm9bJyAnXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBsZXQgd29yZCA9IHdvcmRzW2ldO1xyXG4gICAgICAgICAgICBsZXQgd29yZF9sZW5ndGggPSB0aGlzLnNpemVfaW5mb1t3b3JkXTtcclxuXHJcbiAgICAgICAgICAgIHdvcmRfaW5mb3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB3b3JkOiB3b3JkLFxyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IG9mZnNldCxcclxuICAgICAgICAgICAgICAgIGVuZDogb2Zmc2V0ICsgd29yZF9sZW5ndGhcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSB3b3JkX2xlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChpICE9PSB3b3Jkcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICB3b3JkX2luZm9zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmQ6ICcgJyxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydDogb2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogb2Zmc2V0ICsgc3BhY2Vfb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzcGFjZV9vZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB3b3JkX2luZm9zO1xyXG4gICAgfVxyXG5cclxuICAgIGV4cGxvZGUgKG1heF93aWR0aCwgZXhwbG9kZWRfbGluZXMgPSBbXSkge1xyXG4gICAgICAgIGlmIChtYXhfd2lkdGggPiB0aGlzLmxpbmVfbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGV4cGxvZGVkX2xpbmVzLnB1c2godGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBsb2RlZF9saW5lcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMud29yZEluZm9JbmRleChtYXhfd2lkdGgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy53b3Jkc1tpbmRleF0ud29yZCA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgIGluZGV4IC09IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5kZXggPCAxKSB7XHJcbiAgICAgICAgICAgIGV4cGxvZGVkX2xpbmVzLnB1c2godGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBsb2RlZF9saW5lcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMud29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0X2xpbmVfbGVuZ3RoID0gMCwgcHJldmlvdXNfbGluZV9sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBsZXQgbmV4dF9saW5lX3dvcmRzID0gJycsIHByZXZpb3VzX2xpbmVfd29yZHMgPSAnJztcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMud29yZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIG5leHRfbGluZV93b3JkcyArPSB0aGlzLndvcmRzW2ldLndvcmQ7XHJcbiAgICAgICAgICAgICAgICBuZXh0X2xpbmVfbGVuZ3RoICs9IHRoaXMuc2l6ZV9pbmZvW3RoaXMud29yZHNbaV0ud29yZF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4IC0gMSAmJiB0aGlzLndvcmRzW2ldICE9PSAnICcpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19saW5lX3dvcmRzICs9IHRoaXMud29yZHNbaV0ud29yZDtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19saW5lX2xlbmd0aCArPSB0aGlzLnNpemVfaW5mb1t0aGlzLndvcmRzW2ldLndvcmRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBleHBsb2RlZF9saW5lcy5wdXNoKG5ldyBUZXh0TGluZShcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c19saW5lX3dvcmRzLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX2xpbmVfbGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX2xpbmVfd29yZHMuc3BsaXQoJyAnKSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemVfaW5mb1xyXG4gICAgICAgICAgICApKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBuZXh0X2xpbmUgPSBuZXcgVGV4dExpbmUobmV4dF9saW5lX3dvcmRzLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRfbGluZV9sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dF9saW5lX3dvcmRzLnNwbGl0KCcgJyksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplX2luZm9cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0X2xpbmUuZXhwbG9kZShtYXhfd2lkdGgsIGV4cGxvZGVkX2xpbmVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cGxvZGVkX2xpbmVzLnB1c2godGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGV4cGxvZGVkX2xpbmVzO1xyXG4gICAgfVxyXG5cclxuICAgIHdvcmRJbmZvSW5kZXggKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5saW5lX2xlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53b3Jkcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGQgPSB0aGlzLndvcmRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgbGV0IGkgPSBNYXRoLmNlaWwoZCk7XHJcbiAgICAgICAgaSA9IE1hdGgubWluKE1hdGgubWF4KDAsIGkpLCB0aGlzLndvcmRzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIGxldCB3b3JkX2luZm8gPSB0aGlzLndvcmRzW2ldO1xyXG5cclxuICAgICAgICAvLyBkaWNob3RvbWljIHNlYXJjaFxyXG4gICAgICAgIHdoaWxlICh3b3JkX2luZm8uc3RhcnQgPiBwb3NpdGlvbiB8fCB3b3JkX2luZm8uZW5kIDwgcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgZCAvPSAyO1xyXG4gICAgICAgICAgICBpICs9IHdvcmRfaW5mby5lbmQgPCBwb3NpdGlvbiA/IE1hdGguY2VpbChkKSA6IC1NYXRoLmNlaWwoZCk7XHJcbiAgICAgICAgICAgIGkgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBpKSwgdGhpcy53b3Jkcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgd29yZF9pbmZvID0gdGhpcy53b3Jkc1tpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCIvLyBUZXh0IHJlbmRlcmluZyBzdHlsZVxyXG5cclxuaW1wb3J0IEJ1aWxkZXJzIGZyb20gJy4uL2J1aWxkZXJzJztcclxuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi4vc3R5bGVfcGFyc2VyJztcclxuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi4vLi4vZ2wvdGV4dHVyZSc7XHJcbmltcG9ydCBXb3JrZXJCcm9rZXIgZnJvbSAnLi4vLi4vdXRpbHMvd29ya2VyX2Jyb2tlcic7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7UG9pbnRzfSBmcm9tICcuLi9wb2ludHMvcG9pbnRzJztcclxuaW1wb3J0IExhYmVsQnVpbGRlciBmcm9tICcuL2xhYmVsX2J1aWxkZXInO1xyXG5cclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcblxyXG5leHBvcnQgbGV0IFRleHRTdHlsZSA9IE9iamVjdC5jcmVhdGUoUG9pbnRzKTtcclxuXHJcbk9iamVjdC5hc3NpZ24oVGV4dFN0eWxlLCB7XHJcbiAgICBuYW1lOiAndGV4dCcsXHJcbiAgICBzdXBlcjogUG9pbnRzLFxyXG4gICAgYnVpbHRfaW46IHRydWUsXHJcbiAgICBzZWxlY3Rpb246IGZhbHNlLFxyXG5cclxuICAgIGluaXQoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdGhpcyBvYmplY3QgdG8gYmUgY2FsbGVkIGZyb20gd29ya2VyIHRocmVhZHNcclxuICAgICAgICBpZiAoVXRpbHMuaXNNYWluVGhyZWFkKSB7XHJcbiAgICAgICAgICAgIFdvcmtlckJyb2tlci5hZGRUYXJnZXQoJ1RleHRTdHlsZScsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50ZXh0cyA9IHt9OyAvLyB1bmlxdWUgdGV4dHMsIGtleWVkIGJ5IHRpbGVcclxuICAgICAgICB0aGlzLnRleHR1cmVzID0ge307XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSB7fTtcclxuICAgICAgICB0aGlzLmJib3hlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5tYXhfcHJpb3JpdHkgPSAwO1xyXG5cclxuICAgICAgICAvLyBQb2ludCBzdHlsZSAocGFyZW50IGNsYXNzKSByZXF1aXJlcyB0ZXh0dXJpbmcgdG8gYmUgdHVybmVkIG9uXHJcbiAgICAgICAgLy8gKGxhYmVscyBhcmUgYWx3YXlzIGRyYXduIHdpdGggdGV4dHVyZXMpXHJcbiAgICAgICAgdGhpcy5kZWZpbmVzLlRBTkdSQU1fUE9JTlRfVEVYVFVSRSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIGRlZmF1bHQgZm9udCBzdHlsZVxyXG4gICAgICAgIHRoaXMuZm9udF9zdHlsZSA9IHtcclxuICAgICAgICAgICAgdHlwZWZhY2U6ICdIZWx2ZXRpY2EgMTJweCcsXHJcbiAgICAgICAgICAgIGZpbGw6ICd3aGl0ZScsXHJcbiAgICAgICAgICAgIGNhcGl0YWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGRlZmF1bHQgbGFiZWwgc3R5bGVcclxuICAgICAgICB0aGlzLmxhYmVsX3N0eWxlID0ge1xyXG4gICAgICAgICAgICBwcmlvcml0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICBhZG1pbmlzdHJhdGl2ZTogNCxcclxuICAgICAgICAgICAgICAgIG1ham9yX3JvYWQ6IDMsXHJcbiAgICAgICAgICAgICAgICBtaW5vcl9yb2FkOiAyLFxyXG4gICAgICAgICAgICAgICAgcmVzdGF1cmFudDogMSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluZXM6IHtcclxuICAgICAgICAgICAgICAgIGV4Y2VlZDogODAsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICBtYXhfd2lkdGg6IDEwMCxcclxuICAgICAgICAgICAgICAgIGxpbmVfaGVpZ2h0OiAxMDAgLy8gcGVyY2VudGFnZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLnN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnRleHRzID0ge307IC8vIHVuaXF1ZSB0ZXh0cywga2V5ZWQgYnkgdGlsZVxyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuY2FudmFzID0ge307XHJcbiAgICAgICAgdGhpcy5iYm94ZXMgPSB7fTtcclxuICAgICAgICB0aGlzLmZlYXR1cmVzID0ge307XHJcbiAgICAgICAgdGhpcy5mZWF0dXJlX2xhYmVscyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmZlYXR1cmVfc3R5bGVfa2V5ID0gbmV3IE1hcCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTZXQgZm9udCBzdHlsZSBwYXJhbXMgZm9yIGNhbnZhcyBkcmF3aW5nXHJcbiAgICBzZXRGb250ICh0aWxlLCB7IGZvbnQsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlX3dpZHRoLCBweF9zaXplLCBweF9sb2dpY2FsX3NpemUgfSkge1xyXG4gICAgICAgIHRoaXMucHhfc2l6ZSA9IHBhcnNlSW50KHB4X3NpemUpO1xyXG4gICAgICAgIHRoaXMucHhfbG9naWNhbF9zaXplID0gcGFyc2VJbnQocHhfbG9naWNhbF9zaXplKTtcclxuICAgICAgICB0aGlzLnRleHRfYnVmZmVyID0gNjsgLy8gcGl4ZWwgcGFkZGluZyBhcm91bmQgdGV4dFxyXG4gICAgICAgIGxldCBjdHggPSB0aGlzLmNhbnZhc1t0aWxlXS5jb250ZXh0O1xyXG5cclxuICAgICAgICBjdHguZm9udCA9IGZvbnQ7XHJcbiAgICAgICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBzdHJva2Vfd2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBudWxsO1xyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XHJcbiAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSAyO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIHRleHQgYmFzZWQgb24gY3VycmVudCBmb250IHN0eWxlXHJcbiAgICB0ZXh0U2l6ZSAodGV4dCwgdGlsZSwgY2FwaXRhbGl6ZWQpIHtcclxuICAgICAgICBsZXQgc3RyID0gY2FwaXRhbGl6ZWQgPyB0ZXh0LnRvVXBwZXJDYXNlKCkgOiB0ZXh0O1xyXG4gICAgICAgIGxldCBjdHggPSB0aGlzLmNhbnZhc1t0aWxlXS5jb250ZXh0O1xyXG4gICAgICAgIGxldCBzcGxpdCA9IHN0ci5zcGxpdCgnICcpO1xyXG4gICAgICAgIGxldCBweF9zaXplID0gdGhpcy5weF9zaXplO1xyXG4gICAgICAgIGxldCBweF9sb2dpY2FsX3NpemUgPSB0aGlzLnB4X2xvZ2ljYWxfc2l6ZTtcclxuICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy50ZXh0X2J1ZmZlciAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcclxuICAgICAgICBsZXQgc3BsaXRfc2l6ZSA9IHtcclxuICAgICAgICAgICAgXCIgXCI6IHRoaXMuY2FudmFzW3RpbGVdLmNvbnRleHQubWVhc3VyZVRleHQoXCIgXCIpLndpZHRoIC8gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSBpbiBzcGxpdCkge1xyXG4gICAgICAgICAgICBsZXQgd29yZCA9IHNwbGl0W2ldO1xyXG4gICAgICAgICAgICBzcGxpdF9zaXplW3dvcmRdID0gY3R4Lm1lYXN1cmVUZXh0KHdvcmQpLndpZHRoIC8gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHN0cl93aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoO1xyXG4gICAgICAgIGxldCB0ZXh0X3NpemUgPSBbXHJcbiAgICAgICAgICAgIHN0cl93aWR0aCAvIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyxcclxuICAgICAgICAgICAgdGhpcy5weF9zaXplIC8gVXRpbHMuZGV2aWNlX3BpeGVsX3JhdGlvXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgbGV0IHRleHR1cmVfdGV4dF9zaXplID0gW1xyXG4gICAgICAgICAgICBNYXRoLmNlaWwoc3RyX3dpZHRoKSArIGJ1ZmZlciAqIDIsXHJcbiAgICAgICAgICAgIHRoaXMucHhfc2l6ZSArIGJ1ZmZlciAqIDJcclxuICAgICAgICBdO1xyXG5cclxuICAgICAgICByZXR1cm4geyBzcGxpdF9zaXplLCB0ZXh0X3NpemUsIHRleHR1cmVfdGV4dF9zaXplLCBweF9zaXplLCBweF9sb2dpY2FsX3NpemUgfTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRHJhdyB0ZXh0IGF0IHNwZWNpZmllZCBsb2NhdGlvbiwgYWRqdXN0aW5nIGZvciBidWZmZXIgYW5kIGJhc2VsaW5lXHJcbiAgICBkcmF3VGV4dCAodGV4dCwgW3gsIHldLCB0aWxlLCBzdHJva2UsIGNhcGl0YWxpemVkKSB7XHJcbiAgICAgICAgbGV0IHN0ciA9IGNhcGl0YWxpemVkID8gdGV4dC50b1VwcGVyQ2FzZSgpIDogdGV4dDtcclxuICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy50ZXh0X2J1ZmZlciAqIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbztcclxuICAgICAgICBpZiAoc3Ryb2tlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzW3RpbGVdLmNvbnRleHQuc3Ryb2tlVGV4dChzdHIsIHggKyBidWZmZXIsIHkgKyBidWZmZXIgKyB0aGlzLnB4X3NpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbnZhc1t0aWxlXS5jb250ZXh0LmZpbGxUZXh0KHN0ciwgeCArIGJ1ZmZlciwgeSArIGJ1ZmZlciArIHRoaXMucHhfc2l6ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFRleHR1cmVUZXh0UG9zaXRpb25zICh0ZXh0cykge1xyXG4gICAgICAgIC8vIEZpbmQgd2lkZXN0IGxhYmVsIGFuZCBzdW0gb2YgYWxsIGxhYmVsIGhlaWdodHNcclxuICAgICAgICBsZXQgd2lkZXN0ID0gMCwgaGVpZ2h0ID0gMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcclxuICAgICAgICAgICAgbGV0IHRleHRfaW5mb3MgPSB0ZXh0c1tzdHlsZV07XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCB0ZXh0IGluIHRleHRfaW5mb3MpIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZXh0X2luZm8gPSB0ZXh0X2luZm9zW3RleHRdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSB0ZXh0X2luZm8uc2l6ZS50ZXh0dXJlX3RleHRfc2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB0ZXh0X2luZm8ucG9zaXRpb24gPSBbMCwgaGVpZ2h0XTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZVswXSA+IHdpZGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHNpemVbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICs9IHNpemVbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBbIHdpZGVzdCwgaGVpZ2h0IF07XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRleHRTaXplcyAodGlsZSwgdGV4dHMpIHtcclxuICAgICAgICAvLyBjcmVhdGUgYSBjYW52YXNcclxuICAgICAgICBpZighdGhpcy5jYW52YXNbdGlsZV0pIHtcclxuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc1t0aWxlXSA9IHtcclxuICAgICAgICAgICAgICAgIGNhbnZhczogY2FudmFzLFxyXG4gICAgICAgICAgICAgICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IHN0eWxlIGluIHRleHRzKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0X2luZm9zKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGV4dF9zdHlsZSA9IHRleHRfaW5mb3NbdGV4dF0udGV4dF9zdHlsZTtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0ZXh0IHNpemVzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZvbnQodGlsZSwgdGV4dF9zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0X2luZm9zW3RleHRdLnNpemUgPSB0aGlzLnRleHRTaXplKHRleHQsIHRpbGUsIHRleHRfc3R5bGUuY2FwaXRhbGl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRleHRzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHRvIHJlbGVhc2UgdGlsZS1zcGVjaWZpYyByZXNvdXJjZXNcclxuICAgIGZyZWVUaWxlICh0aWxlKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FudmFzW3RpbGVdO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRleHR1cmVzW3RpbGVdO1xyXG4gICAgfSxcclxuXHJcbiAgICByYXN0ZXJpemUgKHRpbGUsIHRleHRzLCB0ZXh0dXJlX3NpemUpIHtcclxuICAgICAgICBsZXQgcGl4ZWxfc2NhbGUgPSBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XHJcblxyXG4gICAgICAgIGZvciAobGV0IHN0eWxlIGluIHRleHRzKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0X2luZm9zKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5mbyA9IHRleHRfaW5mb3NbdGV4dF07XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGb250KHRpbGUsIGluZm8udGV4dF9zdHlsZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdUZXh0KHRleHQsIGluZm8ucG9zaXRpb24sIHRpbGUsIGluZm8udGV4dF9zdHlsZS5zdHJva2UsIGluZm8udGV4dF9zdHlsZS5jYXBpdGFsaXplZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaW5mby50ZXhjb29yZHMgPSBCdWlsZGVycy5nZXRUZXhjb29yZHNGb3JTcHJpdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgaW5mby5wb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUudGV4dHVyZV90ZXh0X3NpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZV9zaXplXHJcbiAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghaW5mby5zdWJfdGV4dHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRleHRfYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpc3RzID0gW107XHJcbiAgICAgICAgICAgICAgICBsZXQgc3BhY2Vfc2l6ZSA9IGluZm8uc2l6ZS5zcGxpdF9zaXplWycgJ107XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmZvLnN1Yl90ZXh0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWJfdGV4dCA9IGluZm8uc3ViX3RleHRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IHN1Yl90ZXh0LnNwbGl0KCcgJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RzW2ldID0gd2lkdGggKiBwaXhlbF9zY2FsZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzcGxpdC5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd29yZCA9IHNwbGl0W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSBpbmZvLnNpemUuc3BsaXRfc2l6ZVt3b3JkXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqICE9PSBzcGxpdC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSBzcGFjZV9zaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5mby5zdWJfdGV4dHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSBzcGFjZV9zaXplIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc3ViLXRleHRzIHV2IG1hcHBpbmdcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5mby5zdWJfdGV4dHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3ViX3RleHQgPSBpbmZvLnN1Yl90ZXh0c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmZvLnN1YnRleGNvb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnN1YnRleGNvb3JkcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgaW5mby5zdWJfdGV4dHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBpbmZvLnNpemUudGV4dHVyZV90ZXh0X3NpemVbMF0gLSBkaXN0c1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8ucG9zaXRpb25bMF0gKyBkaXN0c1tpXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5wb3NpdGlvblsxXVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoaW5mby5zaXplLnRleHR1cmVfdGV4dF9zaXplWzBdIC0gb2Zmc2V0KSAtIGRpc3RzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUudGV4dHVyZV90ZXh0X3NpemVbMV1cclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWluZm8uc3VidGV4dF9zaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uc3VidGV4dF9zaXplID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluZm8uc3VidGV4dF9zaXplW3N1Yl90ZXh0XSA9IHNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGluZm8uc3VidGV4Y29vcmRzW3N1Yl90ZXh0XSA9IEJ1aWxkZXJzLmdldFRleGNvb3Jkc0ZvclNwcml0ZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24sIHNpemUsIHRleHR1cmVfc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENhbGxlZCBvbiBtYWluIHRocmVhZCBmcm9tIHdvcmtlciwgdG8gY3JlYXRlIGF0bGFzIG9mIGxhYmVscyBmb3IgYSB0aWxlXHJcbiAgICBhZGRUZXh0cyAodGlsZSwgdGV4dHMpIHtcclxuICAgICAgICB0aGlzLnRleHRzW3RpbGVdID0gdGV4dHM7XHJcblxyXG4gICAgICAgIGxldCB0ZXh0dXJlX3NpemUgPSB0aGlzLnNldFRleHR1cmVUZXh0UG9zaXRpb25zKHRleHRzKTtcclxuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuY2FudmFzW3RpbGVdLmNvbnRleHQ7XHJcblxyXG4gICAgICAgIGxvZy50cmFjZShgdGV4dCBzdW1tYXJ5IGZvciB0aWxlICR7dGlsZX06IGZpdHMgaW4gJHt0ZXh0dXJlX3NpemVbMF19eCR7dGV4dHVyZV9zaXplWzFdfXB4YCk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY2FudmFzIFwiY29udGV4dFwiXHJcbiAgICAgICAgdGhpcy5jYW52YXNbdGlsZV0uY2FudmFzLndpZHRoID0gdGV4dHVyZV9zaXplWzBdO1xyXG4gICAgICAgIHRoaXMuY2FudmFzW3RpbGVdLmNhbnZhcy5oZWlnaHQgPSB0ZXh0dXJlX3NpemVbMV07XHJcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGV4dHVyZV9zaXplWzBdLCB0ZXh0dXJlX3NpemVbMV0pO1xyXG5cclxuICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0dXJlXHJcbiAgICAgICAgbGV0IHRleHR1cmUgPSAnbGFiZWxzLScgKyB0aWxlICsgJy0nICsgKFRleHRTdHlsZS50ZXh0dXJlX2lkKyspO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZXNbdGlsZV0gPSBuZXcgVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCB7IGZpbHRlcmluZzogJ2xpbmVhcicgfSk7XHJcbiAgICAgICAgLy8gdGhpcy50ZXh0dXJlc1t0aWxlXS5vd25lciA9IHsgdGlsZSB9O1xyXG5cclxuICAgICAgICAvLyBhc2sgZm9yIHJhc3Rlcml6YXRpb24gZm9yIHRoZSB0ZXh0IHNldFxyXG4gICAgICAgIHRoaXMucmFzdGVyaXplKHRpbGUsIHRleHRzLCB0ZXh0dXJlX3NpemUpO1xyXG5cclxuICAgICAgICB0aGlzLnRleHR1cmVzW3RpbGVdLnNldENhbnZhcyh0aGlzLmNhbnZhc1t0aWxlXS5jYW52YXMpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRleHR1cmVzW3RpbGVdO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbnZhc1t0aWxlXTsgLy8gd2UgZG9uJ3QgbmVlZCBjYW52YXMgb25jZSBpdCBoYXMgYmVlbiBjb3BpZWQgdG8gR1BVIHRleHR1cmVcclxuXHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHRleHRzOiB0aGlzLnRleHRzW3RpbGVdLCB0ZXh0dXJlIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBPdmVycmlkZVxyXG4gICAgc3RhcnREYXRhICgpIHtcclxuICAgICAgICBsZXQgdGlsZV9kYXRhID0gdGhpcy5zdXBlci5zdGFydERhdGEuYXBwbHkodGhpcyk7XHJcbiAgICAgICAgdGlsZV9kYXRhLnF1ZXVlID0gW107XHJcbiAgICAgICAgcmV0dXJuIHRpbGVfZGF0YTtcclxuICAgIH0sXHJcblxyXG4gICAgc3ViVGV4dEluZm9zIChsYWJlbF9jb21wb3NpdGUsIHRleHRfaW5mbykge1xyXG4gICAgICAgIGlmICghdGV4dF9pbmZvLnN1Yl90ZXh0cykge1xyXG4gICAgICAgICAgICB0ZXh0X2luZm8uc3ViX3RleHRzID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpIGluIGxhYmVsX2NvbXBvc2l0ZS5sYWJlbHMpIHtcclxuICAgICAgICAgICAgbGV0IGxhYmVsID0gbGFiZWxfY29tcG9zaXRlLmxhYmVsc1tpXTtcclxuICAgICAgICAgICAgdGV4dF9pbmZvLnN1Yl90ZXh0cy5wdXNoKGxhYmVsLnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlTGFiZWxzICh0aWxlLCB0ZXh0cykge1xyXG4gICAgICAgIGxldCBsYWJlbHNfcHJpb3JpdGllcyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBzdHlsZSBpbiB0ZXh0cykge1xyXG4gICAgICAgICAgICBsZXQgdGV4dF9pbmZvcyA9IHRleHRzW3N0eWxlXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IHRleHQgaW4gdGV4dF9pbmZvcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRleHRfaW5mbyA9IHRleHRfaW5mb3NbdGV4dF07XHJcbiAgICAgICAgICAgICAgICB0ZXh0X2luZm8ucmVmID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmID0gMDsgZiA8IHRoaXMuZmVhdHVyZXNbdGlsZV1bc3R5bGVdW3RleHRdLmxlbmd0aDsgZisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZlYXR1cmUgPSB0aGlzLmZlYXR1cmVzW3RpbGVdW3N0eWxlXVt0ZXh0XVtmXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWxzID0gTGFiZWxCdWlsZGVyLmxhYmVsc0Zyb21HZW9tZXRyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuZ2VvbWV0cnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHRleHQsIHNpemU6IHRleHRfaW5mby5zaXplIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsX3N0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gbGFiZWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJlYSA9IGxhYmVsLmFyZWE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHNfcHJpb3JpdGllc1t0ZXh0X2luZm8ucHJpb3JpdHldID0gbGFiZWxzX3ByaW9yaXRpZXNbdGV4dF9pbmZvLnByaW9yaXR5XSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzX3ByaW9yaXRpZXNbdGV4dF9pbmZvLnByaW9yaXR5XS5wdXNoKHsgc3R5bGUsIGZlYXR1cmUsIGxhYmVsLCBhcmVhIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViVGV4dEluZm9zKGxhYmVsLCB0ZXh0X2luZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzb3J0IGJ5IGFyZWEgc2l6ZSBpZiBkZWZpbmVkXHJcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBsYWJlbHNfcHJpb3JpdGllcy5sZW5ndGg7ICsrcCkge1xyXG4gICAgICAgICAgICBpZiAoIWxhYmVsc19wcmlvcml0aWVzW3BdKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGFiZWxzX3ByaW9yaXRpZXNbcF0uc29ydCgoZTEsIGUyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZTEuYXJlYSAmJiBlMi5hcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUxLmFyZWEgPCBlMi5hcmVhO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxhYmVsc19wcmlvcml0aWVzO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXNjYXJkTGFiZWxzICh0aWxlLCBsYWJlbHMsIHRleHRzKSB7XHJcbiAgICAgICAgdGhpcy5iYm94ZXNbdGlsZV0gPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgcHJpb3JpdHkgPSB0aGlzLm1heF9wcmlvcml0eTsgcHJpb3JpdHkgPj0gMDsgcHJpb3JpdHktLSkge1xyXG4gICAgICAgICAgICBpZiAoIWxhYmVsc1twcmlvcml0eV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhYmVsc1twcmlvcml0eV0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB7IHN0eWxlLCBmZWF0dXJlLCBsYWJlbCB9ID0gbGFiZWxzW3ByaW9yaXR5XVtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWxhYmVsLmRpc2NhcmQodGhpcy5iYm94ZXNbdGlsZV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmVfbGFiZWxzLmhhcyhmZWF0dXJlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVfbGFiZWxzLnNldChmZWF0dXJlLCBbXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZV9sYWJlbHMuZ2V0KGZlYXR1cmUpLnB1c2gobGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRzW3N0eWxlXVtsYWJlbC50ZXh0XS5yZWYrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgc3R5bGUgaW4gdGV4dHMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgdGV4dCBpbiB0ZXh0c1tzdHlsZV0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0c1tzdHlsZV1bdGV4dF0ucmVmIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZXh0c1tzdHlsZV1bdGV4dF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IHN0eWxlIGluIHRleHRzKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0X2luZm9zID0gdGV4dHNbc3R5bGVdO1xyXG4gICAgICAgICAgICAvLyBObyBsYWJlbHMgZm9yIHRoaXMgc3R5bGVcclxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRleHRfaW5mb3MpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRleHRzW3N0eWxlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gT3ZlcnJpZGVcclxuICAgIGVuZERhdGEgKHRpbGVfZGF0YSkge1xyXG4gICAgICAgIC8vIENvdW50IGNvbGxlY3RlZCB0ZXh0XHJcbiAgICAgICAgbGV0IHRpbGUsIGNvdW50O1xyXG4gICAgICAgIGlmICh0aWxlX2RhdGEucXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aWxlID0gdGlsZV9kYXRhLnF1ZXVlWzBdWzJdLnRpbGUua2V5O1xyXG4gICAgICAgICAgICBjb3VudCA9IE9iamVjdC5rZXlzKHRoaXMudGV4dHNbdGlsZV18fHt9KS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxvZy50cmFjZShgIyB0ZXh0cyBmb3IgdGlsZSAke3RpbGV9OiAke2NvdW50fWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpcnN0IGNhbGwgdG8gbWFpbiB0aHJlYWQsIGFzayBmb3IgdGV4dCBwaXhlbCBzaXplc1xyXG4gICAgICAgIHJldHVybiBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UoJ1RleHRTdHlsZScsICdnZXRUZXh0U2l6ZXMnLCB0aWxlLCB0aGlzLnRleHRzW3RpbGVdKS50aGVuKHRleHRzID0+IHtcclxuICAgICAgICAgICAgbGV0IGxhYmVscyA9IHRoaXMuY3JlYXRlTGFiZWxzKHRpbGUsIHRleHRzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGlzY2FyZExhYmVscyh0aWxlLCBsYWJlbHMsIHRleHRzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vIGxhYmVscyBmb3IgdGhpcyB0aWxlXHJcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0ZXh0cykubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UoJ1RleHRTdHlsZScsICdmcmVlVGlsZScsIHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gZWFybHkgZXhpdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBzZWNvbmQgY2FsbCB0byBtYWluIHRocmVhZCwgZm9yIHJhc3Rlcml6aW5nIHRoZSBzZXQgb2YgdGV4dHNcclxuICAgICAgICAgICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSgnVGV4dFN0eWxlJywgJ2FkZFRleHRzJywgdGlsZSwgdGV4dHMpLnRoZW4oKHsgdGV4dHMsIHRleHR1cmUgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0c1t0aWxlXSA9IHRleHRzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEF0dGFjaCB0aWxlLXNwZWNpZmljIGxhYmVsIGF0bGFzIHRvIG1lc2ggYXMgYSB0ZXh0dXJlIHVuaWZvcm1cclxuICAgICAgICAgICAgICAgIHRpbGVfZGF0YS51bmlmb3JtcyA9IHsgdV90ZXh0dXJlOiB0ZXh0dXJlIH07XHJcbiAgICAgICAgICAgICAgICB0aWxlX2RhdGEudGV4dHVyZXMgPSBbdGV4dHVyZV07IC8vIGFzc2lnbiB0ZXh0dXJlIG93bmVyc2hpcCB0byB0aWxlIC0gVE9ETzogaW1wbGVtZW50IGluIFZCT01lc2hcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBxdWV1ZWQgZmVhdHVyZXNcclxuICAgICAgICAgICAgICAgIHRpbGVfZGF0YS5xdWV1ZS5mb3JFYWNoKHEgPT4gdGhpcy5zdXBlci5hZGRGZWF0dXJlLmFwcGx5KHRoaXMsIHEpKTtcclxuICAgICAgICAgICAgICAgIHRpbGVfZGF0YS5xdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGV4dHNbdGlsZV07XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuZW5kRGF0YS5jYWxsKHRoaXMsIHRpbGVfZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBPdmVycmlkZSB0byBxdWV1ZSBmZWF0dXJlcyBpbnN0ZWFkIG9mIHByb2Nlc3NpbmcgaW1tZWRpYXRlbHlcclxuICAgIGFkZEZlYXR1cmUgKGZlYXR1cmUsIHJ1bGUsIGNvbnRleHQsIHRpbGVfZGF0YSkge1xyXG4gICAgICAgIC8vIENvbGxlY3QgdGV4dFxyXG4gICAgICAgIGxldCB0ZXh0O1xyXG4gICAgICAgIGxldCBzb3VyY2UgPSBydWxlLnRleHRfc291cmNlIHx8ICduYW1lJztcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSBmZWF0dXJlLnByb3BlcnRpZXNbc291cmNlXTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGV4dCA9IHNvdXJjZShjb250ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUudGV4dCA9IHRleHQ7XHJcblxyXG4gICAgICAgICAgICBsZXQgdGlsZSA9IGNvbnRleHQudGlsZS5rZXk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0c1t0aWxlXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0c1t0aWxlXSA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLmNvbnN0cnVjdEZvbnRTdHlsZShydWxlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKCFzdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgc3R5bGVfa2V5ID0gdGhpcy5jb25zdHJ1Y3RTdHlsZUtleShzdHlsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZV9zdHlsZV9rZXkuc2V0KGZlYXR1cmUsIHN0eWxlX2tleSlcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy50ZXh0c1t0aWxlXVtzdHlsZV9rZXldKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRzW3RpbGVdW3N0eWxlX2tleV0gPSB7fTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHByaW9yaXR5ID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGFiZWxfc3R5bGUucHJpb3JpdGllc1tmZWF0dXJlLnByb3BlcnRpZXMua2luZF0pIHtcclxuICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gdGhpcy5sYWJlbF9zdHlsZS5wcmlvcml0aWVzW2ZlYXR1cmUucHJvcGVydGllcy5raW5kXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5tYXhfcHJpb3JpdHkgPSBNYXRoLm1heChwcmlvcml0eSwgdGhpcy5tYXhfcHJpb3JpdHkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHRzW3RpbGVdW3N0eWxlX2tleV1bdGV4dF0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHNbdGlsZV1bc3R5bGVfa2V5XVt0ZXh0XSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0X3N0eWxlOiBzdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmOiAwXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcyB8fCB7fTtcclxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlc1t0aWxlXSA9IHRoaXMuZmVhdHVyZXNbdGlsZV0gfHzCoHt9O1xyXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzW3RpbGVdW3N0eWxlX2tleV0gPSB0aGlzLmZlYXR1cmVzW3RpbGVdW3N0eWxlX2tleV0gfHwge307XHJcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNbdGlsZV1bc3R5bGVfa2V5XVt0ZXh0XSA9IHRoaXMuZmVhdHVyZXNbdGlsZV1bc3R5bGVfa2V5XVt0ZXh0XSB8fCBbXTtcclxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlc1t0aWxlXVtzdHlsZV9rZXldW3RleHRdLnB1c2goZmVhdHVyZSk7XHJcblxyXG4gICAgICAgICAgICB0aWxlX2RhdGEucXVldWUucHVzaChbZmVhdHVyZSwgcnVsZSwgY29udGV4dCwgdGlsZV9kYXRhXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBjb25zdHJ1Y3RGb250U3R5bGUgKHJ1bGUsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgc3R5bGU7XHJcblxyXG4gICAgICAgIGlmIChydWxlLmZvbnQpIHtcclxuICAgICAgICAgICAgc3R5bGUgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSBmaWxsIGlmIHNwZWNpZmllZCwgb3IgZGVmYXVsdFxyXG4gICAgICAgICAgICBzdHlsZS5maWxsID0gKHJ1bGUuZm9udC5maWxsICYmIFV0aWxzLnRvQ2FudmFzQ29sb3IoU3R5bGVQYXJzZXIucGFyc2VDb2xvcihydWxlLmZvbnQuZmlsbCwgY29udGV4dCkpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb250X3N0eWxlLmZpbGw7XHJcblxyXG4gICAgICAgICAgICAvLyBVc2Ugc3Ryb2tlIGlmIHNwZWNpZmllZFxyXG4gICAgICAgICAgICBpZiAocnVsZS5mb250LnN0cm9rZSAmJiBydWxlLmZvbnQuc3Ryb2tlLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zdHJva2UgPSBVdGlscy50b0NhbnZhc0NvbG9yKFN0eWxlUGFyc2VyLnBhcnNlQ29sb3IocnVsZS5mb250LnN0cm9rZS5jb2xvcikpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuc3Ryb2tlX3dpZHRoID0gcnVsZS5mb250LnN0cm9rZS53aWR0aCB8fCB0aGlzLmZvbnRfc3R5bGUuc3Ryb2tlLndpZHRoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgZGVmYXVsdCB0eXBlZmFjZVxyXG4gICAgICAgICAgICBzdHlsZS5mb250ID0gcnVsZS5mb250LnR5cGVmYWNlIHx8wqB0aGlzLmZvbnRfc3R5bGUudHlwZWZhY2U7XHJcbiAgICAgICAgICAgIHN0eWxlLmNhcGl0YWxpemVkID0gcnVsZS5mb250LmNhcGl0YWxpemVkIHx8IHRoaXMuZm9udF9zdHlsZS5jYXBpdGFsaXplZDtcclxuXHJcbiAgICAgICAgICAgIGxldCBzaXplX3JlZ2V4ID0gLyhbMC05XSpcXC4pP1swLTldKyhweHxwdHxlbXwlKS9nO1xyXG4gICAgICAgICAgICBsZXQgZnRfc2l6ZSA9IHN0eWxlLmZvbnQubWF0Y2goc2l6ZV9yZWdleClbMF07XHJcbiAgICAgICAgICAgIGxldCBzaXplX2tpbmQgPSBmdF9zaXplLnJlcGxhY2UoLyhbMC05XSpcXC4pP1swLTldKy9nLCAnJyk7XHJcblxyXG4gICAgICAgICAgICBzdHlsZS5weF9sb2dpY2FsX3NpemUgPSBVdGlscy50b1BpeGVsU2l6ZShmdF9zaXplLnJlcGxhY2UoLyhbYS16XXwlKS9nLCAnJyksIHNpemVfa2luZCk7XHJcbiAgICAgICAgICAgIHN0eWxlLnB4X3NpemUgPSBzdHlsZS5weF9sb2dpY2FsX3NpemUgKiBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XHJcbiAgICAgICAgICAgIHN0eWxlLnN0cm9rZV93aWR0aCAqPSBVdGlscy5kZXZpY2VfcGl4ZWxfcmF0aW87XHJcbiAgICAgICAgICAgIHN0eWxlLmZvbnQgPSBzdHlsZS5mb250LnJlcGxhY2Uoc2l6ZV9yZWdleCwgc3R5bGUucHhfc2l6ZSArIFwicHhcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICB9LFxyXG5cclxuICAgIGNvbnN0cnVjdFN0eWxlS2V5ICh7IGZvbnQsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlX3dpZHRoIH0pIHtcclxuICAgICAgICByZXR1cm4gYCR7Zm9udH0vJHtmaWxsfS8ke3N0cm9rZX0vJHtzdHJva2Vfd2lkdGh9YDtcclxuICAgIH0sXHJcblxyXG4gICAgYnVpbGRMYWJlbCAobGFiZWwsIHNpemUsIHZlcnRleF9kYXRhLCB2ZXJ0ZXhfdGVtcGxhdGUsIHRleGNvb3JkX3NjYWxlKSB7XHJcbiAgICAgICAgbGV0IGFuZ2xlID0gbGFiZWwuYW5nbGUgfHwgMDtcclxuICAgICAgICBCdWlsZGVycy5idWlsZFNwcml0ZVF1YWRzRm9yUG9pbnRzKFxyXG4gICAgICAgICAgICBbIGxhYmVsLnBvc2l0aW9uIF0sXHJcbiAgICAgICAgICAgIFV0aWxzLnNjYWxlSW50MTYoc2l6ZVswXSwgMjU2KSxcclxuICAgICAgICAgICAgVXRpbHMuc2NhbGVJbnQxNihzaXplWzFdLCAyNTYpLFxyXG4gICAgICAgICAgICBVdGlscy5zY2FsZUludDE2KFV0aWxzLnJhZFRvRGVnKGFuZ2xlKSwgMzYwKSxcclxuICAgICAgICAgICAgVXRpbHMuc2NhbGVJbnQxNigxLCAyNTYpLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhfZGF0YSxcclxuICAgICAgICAgICAgdmVydGV4X3RlbXBsYXRlLFxyXG4gICAgICAgICAgICB0aGlzLnZlcnRleF9sYXlvdXQuaW5kZXguYV9zaGFwZSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRfaW5kZXg6IHRoaXMudmVydGV4X2xheW91dC5pbmRleC5hX3RleGNvb3JkLFxyXG4gICAgICAgICAgICAgICAgdGV4Y29vcmRfc2NhbGU6IHRleGNvb3JkX3NjYWxlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfSxcclxuXHJcbiAgICBidWlsZCAoc3R5bGUsIHZlcnRleF9kYXRhKSB7XHJcbiAgICAgICAgbGV0IHZlcnRleF90ZW1wbGF0ZSA9IHRoaXMubWFrZVZlcnRleFRlbXBsYXRlKHN0eWxlKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSBpbiBzdHlsZS5sYWJlbHMpIHtcclxuICAgICAgICAgICAgbGV0IGxhYmVsID0gc3R5bGUubGFiZWxzW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxhYmVsLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogaW4gbGFiZWwubGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBsYWJlbC5sYWJlbHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YnRleGNvb3JkX3NjYWxlID0gdGhpcy5zdWJ0ZXhjb29yZF9zY2FsZVtsLnRleHRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdGhpcy5zdWJ0ZXh0X3NpemVbbC50ZXh0XTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkTGFiZWwobCwgc2l6ZSwgdmVydGV4X2RhdGEsIHZlcnRleF90ZW1wbGF0ZSwgc3VidGV4Y29vcmRfc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZExhYmVsKGxhYmVsLCBsYWJlbC5zaXplLnRleHR1cmVfdGV4dF9zaXplLCB2ZXJ0ZXhfZGF0YSwgdmVydGV4X3RlbXBsYXRlLCB0aGlzLnRleGNvb3JkX3NjYWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgYnVpbGRMaW5lcyAobGluZXMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xyXG4gICAgICAgIHRoaXMuYnVpbGQoc3R5bGUsIHZlcnRleF9kYXRhKTtcclxuICAgIH0sXHJcblxyXG4gICAgYnVpbGRQb2ludHMgKHBvaW50cywgc3R5bGUsIHZlcnRleF9kYXRhKSB7XHJcbiAgICAgICAgdGhpcy5idWlsZChzdHlsZSwgdmVydGV4X2RhdGEpO1xyXG4gICAgfSxcclxuXHJcbiAgICBidWlsZFBvbHlnb25zIChwb2ludHMsIHN0eWxlLCB2ZXJ0ZXhfZGF0YSkge1xyXG4gICAgICAgIHRoaXMuYnVpbGQoc3R5bGUsIHZlcnRleF9kYXRhKTtcclxuICAgIH0sXHJcblxyXG4gICAgX3BhcnNlRmVhdHVyZSAoZmVhdHVyZSwgcnVsZV9zdHlsZSwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCB0ZXh0ID0gZmVhdHVyZS50ZXh0O1xyXG5cclxuICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLmZlYXR1cmVfc3R5bGU7XHJcbiAgICAgICAgbGV0IHRpbGUgPSBjb250ZXh0LnRpbGUua2V5O1xyXG4gICAgICAgIGxldCBzdHlsZV9rZXkgPSB0aGlzLmZlYXR1cmVfc3R5bGVfa2V5LmdldChmZWF0dXJlKTtcclxuICAgICAgICBsZXQgdGV4dF9pbmZvID0gdGhpcy50ZXh0c1t0aWxlXSAmJiB0aGlzLnRleHRzW3RpbGVdW3N0eWxlX2tleV0gJiYgdGhpcy50ZXh0c1t0aWxlXVtzdHlsZV9rZXldW3RleHRdO1xyXG5cclxuICAgICAgICBpZiAoIXRleHRfaW5mbyB8fCAhdGhpcy5mZWF0dXJlX2xhYmVscy5oYXMoZmVhdHVyZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50ZXhjb29yZF9zY2FsZSA9IHRleHRfaW5mby50ZXhjb29yZHM7XHJcbiAgICAgICAgdGhpcy5zdWJ0ZXhjb29yZF9zY2FsZSA9IHRleHRfaW5mby5zdWJ0ZXhjb29yZHM7XHJcbiAgICAgICAgdGhpcy5zdWJ0ZXh0X3NpemUgPSB0ZXh0X2luZm8uc3VidGV4dF9zaXplO1xyXG4gICAgICAgIHN0eWxlLnRleHQgPSB0ZXh0O1xyXG4gICAgICAgIHN0eWxlLmxhYmVscyA9IHRoaXMuZmVhdHVyZV9sYWJlbHMuZ2V0KGZlYXR1cmUpO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBwb2ludCBzdHlsZSAocGFyZW50IGNsYXNzKSByZXF1aXJlcyBhIGNvbG9yLCBzZXR0aW5nIGl0IHRvIHdoaXRlIGZvciBub3csXHJcbiAgICAgICAgLy8gYnV0IGNvdWxkIGJlIG1hZGUgY29uZGl0aW9uYWwgaW4gdGhlIHZlcnRleCBsYXlvdXQgdG8gc2F2ZSBzcGFjZVxyXG4gICAgICAgIHN0eWxlLmNvbG9yID0gWzEsIDEsIDEsIDFdO1xyXG5cclxuICAgICAgICAvLyB0ZWxsIHRoZSBwb2ludCBzdHlsZSAoYmFzZSBjbGFzcykgdGhhdCB3ZSB3YW50IHRvIHJlbmRlciBwb2x5Z29uIGxhYmVscyBhdCB0aGUgcG9seWdvbidzIGNlbnRyb2lkXHJcbiAgICAgICAgc3R5bGUuY2VudHJvaWQgPSB0cnVlO1xyXG5cclxuICAgICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXHJcblRleHRTdHlsZS50ZXh0dXJlX2lkID0gMDtcclxuIiwiLypnbG9iYWwgVGlsZSAqL1xyXG5pbXBvcnQgR2VvIGZyb20gJy4vZ2VvJztcclxuaW1wb3J0IHtTdHlsZVBhcnNlcn0gZnJvbSAnLi9zdHlsZXMvc3R5bGVfcGFyc2VyJztcclxuaW1wb3J0IFdvcmtlckJyb2tlciBmcm9tICcuL3V0aWxzL3dvcmtlcl9icm9rZXInO1xyXG5pbXBvcnQgVGV4dHVyZSBmcm9tICcuL2dsL3RleHR1cmUnO1xyXG5cclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAgICBUaWxlXHJcbiAgICAgICAgQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgUmVxdWlyZWQgcHJvcGVydGllczpcclxuICAgICAgICBjb29yZHM6IG9iamVjdCB3aXRoIHt4LCB5LCB6fSBwcm9wZXJ0aWVzIGlkZW50aWZ5aW5nIHRpbGUgY29vcmRpbmF0ZSBsb2NhdGlvblxyXG4gICAgICAgIHdvcmtlcjogd2ViIHdvcmtlciB0byBoYW5kbGUgdGlsZSBjb25zdHJ1Y3Rpb25cclxuICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih7IGNvb3Jkcywgd29ya2VyLCBtYXhfem9vbSB9KSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XHJcbiAgICAgICAgICAgIGNvb3Jkczoge1xyXG4gICAgICAgICAgICAgICAgeDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHk6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB6OiBudWxsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlYnVnOiB7fSxcclxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgIGxvYWRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxyXG4gICAgICAgICAgICB3b3JrZXI6IG51bGwsXHJcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjZW50ZXJfZGlzdDogMFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLndvcmtlciA9IHdvcmtlcjtcclxuICAgICAgICB0aGlzLm1heF96b29tID0gbWF4X3pvb207XHJcblxyXG4gICAgICAgIHRoaXMuY29vcmRzID0gY29vcmRzO1xyXG4gICAgICAgIHRoaXMuY29vcmRzID0gVGlsZS5jYWxjdWxhdGVPdmVyWm9vbSh0aGlzLmNvb3JkcywgdGhpcy5tYXhfem9vbSk7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBUaWxlLmtleSh0aGlzLmNvb3Jkcyk7XHJcbiAgICAgICAgdGhpcy5taW4gPSBHZW8ubWV0ZXJzRm9yVGlsZSh0aGlzLmNvb3Jkcyk7XHJcbiAgICAgICAgdGhpcy5tYXggPSBHZW8ubWV0ZXJzRm9yVGlsZSh7eDogdGhpcy5jb29yZHMueCArIDEsIHk6IHRoaXMuY29vcmRzLnkgKyAxLCB6OiB0aGlzLmNvb3Jkcy56IH0pLFxyXG4gICAgICAgIHRoaXMuc3BhbiA9IHsgeDogKHRoaXMubWF4LnggLSB0aGlzLm1pbi54KSwgeTogKHRoaXMubWF4LnkgLSB0aGlzLm1pbi55KSB9O1xyXG4gICAgICAgIHRoaXMuYm91bmRzID0geyBzdzogeyB4OiB0aGlzLm1pbi54LCB5OiB0aGlzLm1heC55IH0sIG5lOiB7IHg6IHRoaXMubWF4LngsIHk6IHRoaXMubWluLnkgfSB9O1xyXG5cclxuICAgICAgICB0aGlzLm1lc2hlcyA9IHt9OyAvLyByZW5kZXJhYmxlIFZCTyBtZXNoZXMga2V5ZWQgYnkgc3R5bGVcclxuICAgICAgICB0aGlzLnRleHR1cmVzID0gW107IC8vIHRleHR1cmVzIHRoYXQgdGhlIHRpbGUgb3ducyAobGFiZWxzLCBldGMuKVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBjcmVhdGUoc3BlYykge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGlsZShzcGVjKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMga2V5KHt4LCB5LCB6fSkge1xyXG4gICAgICAgIHJldHVybiBbeCwgeSwgel0uam9pbignLycpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBjYWxjdWxhdGVPdmVyWm9vbSh7eCwgeSwgen0sIG1heF96b29tKSB7XHJcbiAgICAgICAgbWF4X3pvb20gPSBtYXhfem9vbSB8fCB6O1xyXG5cclxuICAgICAgICBpZiAoeiA+IG1heF96b29tKSB7XHJcbiAgICAgICAgICAgIGxldCB6ZGlmZiA9IHogLSBtYXhfem9vbTtcclxuXHJcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKHggPj4gemRpZmYpO1xyXG4gICAgICAgICAgICB5ID0gTWF0aC5mbG9vcih5ID4+IHpkaWZmKTtcclxuICAgICAgICAgICAgeiAtPSB6ZGlmZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7eCwgeSwgen07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU29ydCBhIHNldCBvZiB0aWxlIGluc3RhbmNlcyAod2hpY2ggYWxyZWFkeSBoYXZlIGEgZGlzdGFuY2UgZnJvbSBjZW50ZXIgdGlsZSBjb21wdXRlZClcclxuICAgIHN0YXRpYyBzb3J0KHRpbGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRpbGVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgbGV0IGFkID0gYS5jZW50ZXJfZGlzdDtcclxuICAgICAgICAgICAgbGV0IGJkID0gYi5jZW50ZXJfZGlzdDtcclxuICAgICAgICAgICAgcmV0dXJuIChiZCA+IGFkID8gLTEgOiAoYmQgPT09IGFkID8gMCA6IDEpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmcmVlUmVzb3VyY2VzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1lc2hlcykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBtIGluIHRoaXMubWVzaGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lc2hlc1ttXS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRleHR1cmVzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50ZXh0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRleHR1cmUgPSBUZXh0dXJlLnRleHR1cmVzW3RdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5tZXNoZXMgPSB7fTtcclxuICAgICAgICB0aGlzLnRleHR1cmVzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLndvcmtlck1lc3NhZ2UoJ3JlbW92ZVRpbGUnLCB0aGlzLmtleSk7XHJcbiAgICAgICAgdGhpcy5mcmVlUmVzb3VyY2VzKCk7XHJcbiAgICAgICAgdGhpcy53b3JrZXIgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkQXNNZXNzYWdlKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXHJcbiAgICAgICAgICAgIGNvb3JkczogdGhpcy5jb29yZHMsXHJcbiAgICAgICAgICAgIG1pbjogdGhpcy5taW4sXHJcbiAgICAgICAgICAgIG1heDogdGhpcy5tYXgsXHJcbiAgICAgICAgICAgIGRlYnVnOiB0aGlzLmRlYnVnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB3b3JrZXJNZXNzYWdlICguLi5tZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFdvcmtlckJyb2tlci5wb3N0TWVzc2FnZSh0aGlzLndvcmtlciwgLi4ubWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogcmVtb3ZlIHNjZW5lIGRlcGVuZGVuY3lcclxuICAgIGJ1aWxkKHNjZW5lKSB7XHJcbiAgICAgICAgc2NlbmUudHJhY2tUaWxlQnVpbGRTdGFydCh0aGlzLmtleSk7XHJcbiAgICAgICAgdGhpcy53b3JrZXJNZXNzYWdlKFxyXG4gICAgICAgICAgICAnYnVpbGRUaWxlJyxcclxuICAgICAgICAgICAgeyB0aWxlOiB0aGlzLmJ1aWxkQXNNZXNzYWdlKCkgfSlcclxuICAgICAgICAudGhlbihtZXNzYWdlID0+IHtcclxuICAgICAgICAgICAgc2NlbmUuYnVpbGRUaWxlQ29tcGxldGVkKG1lc3NhZ2UpO1xyXG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJvY2VzcyBnZW9tZXRyeSBmb3IgdGlsZSAtIGNhbGxlZCBieSB3ZWIgd29ya2VyXHJcbiAgICAvLyBSZXR1cm5zIGEgc2V0IG9mIHRpbGUga2V5cyB0aGF0IHNob3VsZCBiZSBzZW50IHRvIHRoZSBtYWluIHRocmVhZCAoc28gdGhhdCB3ZSBjYW4gbWluaW1pemUgZGF0YSBleGNoYW5nZSBiZXR3ZWVuIHdvcmtlciBhbmQgbWFpbiB0aHJlYWQpXHJcbiAgICBzdGF0aWMgYnVpbGRHZW9tZXRyeSAodGlsZSwgbGF5ZXJzLCBydWxlcywgc3R5bGVzKSB7XHJcbiAgICAgICAgdGlsZS5kZWJ1Zy5yZW5kZXJpbmcgPSArbmV3IERhdGUoKTtcclxuXHJcbiAgICAgICAgbGV0IHRpbGVfZGF0YSA9IHt9O1xyXG5cclxuICAgICAgICBmb3IgKGxldCBzb3VyY2VfbmFtZSBpbiB0aWxlLnNvdXJjZXMpIHtcclxuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IHRpbGUuc291cmNlc1tzb3VyY2VfbmFtZV07XHJcbiAgICAgICAgICAgIHNvdXJjZS5kZWJ1Zy5yZW5kZXJpbmcgPSArbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgc291cmNlLmRlYnVnLmZlYXR1cmVzID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIFRyZWF0IHRvcC1sZXZlbCBzdHlsZSBydWxlcyBhcyAnbGF5ZXJzJ1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsYXllcl9uYW1lIGluIGxheWVycykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheWVyID0gbGF5ZXJzW2xheWVyX25hbWVdO1xyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBsYXllcnMgd2l0aCBubyBkYXRhIHNvdXJjZSBkZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihgTGF5ZXIgJHtsYXllcn0gd2FzIGRlZmluZWQgd2l0aG91dCBhIGdlb21ldHJ5IGRhdGEgc291cmNlIGFuZCB3aWxsIG5vdCBiZSByZW5kZXJlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTb3VyY2UgbmFtZXMgZG9uJ3QgbWF0Y2hcclxuICAgICAgICAgICAgICAgIGlmIChsYXllci5kYXRhLnNvdXJjZSAhPT0gc291cmNlX25hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgZ2VvbSA9IFRpbGUuZ2V0RGF0YUZvclNvdXJjZShzb3VyY2UsIGxheWVyLmRhdGEsIGxheWVyX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFnZW9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIGZlYXR1cmVzIGluIGxheWVyXHJcbiAgICAgICAgICAgICAgICBsZXQgbnVtX2ZlYXR1cmVzID0gZ2VvbS5mZWF0dXJlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmID0gbnVtX2ZlYXR1cmVzLTE7IGYgPj0gMDsgZi0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZlYXR1cmUgPSBnZW9tLmZlYXR1cmVzW2ZdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZXh0ID0gU3R5bGVQYXJzZXIuZ2V0RmVhdHVyZVBhcnNlQ29udGV4dChmZWF0dXJlLCB0aWxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGRyYXcgZ3JvdXBzIGZvciB0aGlzIGZlYXR1cmVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5ZXJfcnVsZXMgPSBydWxlc1tsYXllcl9uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZHJhd19ncm91cHMgPSBsYXllcl9ydWxlcy5idWlsZERyYXdHcm91cHMoY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkcmF3X2dyb3Vwcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbmRlciBkcmF3IGdyb3Vwc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGdyb3VwX25hbWUgaW4gZHJhd19ncm91cHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZHJhd19ncm91cHNbZ3JvdXBfbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ3JvdXAudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBzdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVfbmFtZSA9IGdyb3VwLnN0eWxlIHx8IGdyb3VwX25hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHN0eWxlc1tzdHlsZV9uYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBTdHlsZSAnJHtzdHlsZV9uYW1lfScgbm90IGZvdW5kIGZvciBydWxlIGluIGxheWVyICcke2xheWVyX25hbWV9JzpgLCBncm91cCwgZmVhdHVyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aWxlX2RhdGFbc3R5bGVfbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVfZGF0YVtzdHlsZV9uYW1lXSA9IHN0eWxlLnN0YXJ0RGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBncm91cC5wcm9wZXJ0aWVzOyAvLyBhZGQgcnVsZS1zcGVjaWZpYyBwcm9wZXJ0aWVzIHRvIGNvbnRleHRcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmFkZEZlYXR1cmUoZmVhdHVyZSwgZ3JvdXAsIGNvbnRleHQsIHRpbGVfZGF0YVtzdHlsZV9uYW1lXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnByb3BlcnRpZXMgPSBudWxsOyAvLyBjbGVhciBncm91cC1zcGVjaWZpYyBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UuZGVidWcuZmVhdHVyZXMrKztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNvdXJjZS5kZWJ1Zy5yZW5kZXJpbmcgPSArbmV3IERhdGUoKSAtIHNvdXJjZS5kZWJ1Zy5yZW5kZXJpbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaW5hbGl6ZSBhcnJheSBidWZmZXIgZm9yIGVhY2ggcmVuZGVyIHN0eWxlXHJcbiAgICAgICAgdGlsZS5tZXNoX2RhdGEgPSB7fTtcclxuICAgICAgICBsZXQgcXVldWUgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBzdHlsZV9uYW1lIGluIHRpbGVfZGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBzdHlsZXNbc3R5bGVfbmFtZV07XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goc3R5bGUuZW5kRGF0YSh0aWxlX2RhdGFbc3R5bGVfbmFtZV0pLnRoZW4oKHN0eWxlX2RhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZV9kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5tZXNoX2RhdGFbc3R5bGVfbmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleF9kYXRhOiBzdHlsZV9kYXRhLnZlcnRleF9kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlmb3Jtczogc3R5bGVfZGF0YS51bmlmb3JtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXM6IHN0eWxlX2RhdGEudGV4dHVyZXNcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVldWUpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBBZ2dyZWdhdGUgZGVidWcgaW5mb1xyXG4gICAgICAgICAgICB0aWxlLmRlYnVnLnJlbmRlcmluZyA9ICtuZXcgRGF0ZSgpIC0gdGlsZS5kZWJ1Zy5yZW5kZXJpbmc7XHJcbiAgICAgICAgICAgIHRpbGUuZGVidWcucHJvamVjdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHRpbGUuZGVidWcuZmVhdHVyZXMgPSAwO1xyXG4gICAgICAgICAgICB0aWxlLmRlYnVnLm5ldHdvcmsgPSAwO1xyXG4gICAgICAgICAgICB0aWxlLmRlYnVnLnBhcnNpbmcgPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiB0aWxlLnNvdXJjZXMpIHtcclxuICAgICAgICAgICAgICAgIHRpbGUuZGVidWcuZmVhdHVyZXMgICs9IHRpbGUuc291cmNlc1tpXS5kZWJ1Zy5mZWF0dXJlcztcclxuICAgICAgICAgICAgICAgIHRpbGUuZGVidWcucHJvamVjdGlvbiArPSB0aWxlLnNvdXJjZXNbaV0uZGVidWcucHJvamVjdGlvbjtcclxuICAgICAgICAgICAgICAgIHRpbGUuZGVidWcubmV0d29yayArPSB0aWxlLnNvdXJjZXNbaV0uZGVidWcubmV0d29yaztcclxuICAgICAgICAgICAgICAgIHRpbGUuZGVidWcucGFyc2luZyArPSB0aWxlLnNvdXJjZXNbaV0uZGVidWcucGFyc2luZztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIGtleXMgdG8gYmUgdHJhbnNmZXJlZCB0byBtYWluIHRocmVhZFxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbWVzaF9kYXRhOiB0cnVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgUmV0cmlldmVzIGdlb21ldHJ5IGZyb20gYSB0aWxlIGFjY29yZGluZyB0byBhIGRhdGEgc291cmNlIGRlZmluaXRpb25cclxuICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RGF0YUZvclNvdXJjZSAoc291cmNlX2RhdGEsIHNvdXJjZV9jb25maWcsIGRlZmF1bHRfbGF5ZXIgPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGdlb207XHJcblxyXG4gICAgICAgIGlmIChzb3VyY2VfY29uZmlnICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gSWYgbm8gbGF5ZXIgc3BlY2lmaWVkLCBhbmQgYSBkZWZhdWx0IHNvdXJjZSBsYXllciBleGlzdHNcclxuICAgICAgICAgICAgaWYgKCFzb3VyY2VfY29uZmlnLmxheWVyICYmIHNvdXJjZV9kYXRhLmxheWVycy5fZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgZ2VvbSA9IHNvdXJjZV9kYXRhLmxheWVycy5fZGVmYXVsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiBubyBsYXllciBzcGVjaWZpZWQsIGFuZCBhIGRlZmF1bHQgcmVxdWVzdGVkIGxheWVyIGV4aXN0c1xyXG4gICAgICAgICAgICBlbHNlIGlmICghc291cmNlX2NvbmZpZy5sYXllciAmJiBkZWZhdWx0X2xheWVyKSB7XHJcbiAgICAgICAgICAgICAgICBnZW9tID0gc291cmNlX2RhdGEubGF5ZXJzW2RlZmF1bHRfbGF5ZXJdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIGEgbGF5ZXIgaXMgc3BlY2lmaWVkIGJ5IG5hbWUsIHVzZSBpdFxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlX2NvbmZpZy5sYXllciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGdlb20gPSBzb3VyY2VfZGF0YS5sYXllcnNbc291cmNlX2NvbmZpZy5sYXllcl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQXNzZW1ibGUgYSBjdXN0b20gbGF5ZXIgdmlhIGEgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIGFsbCBzb3VyY2UgbGF5ZXJzXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2VfY29uZmlnLmxheWVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBnZW9tID0gc291cmNlX2NvbmZpZy5sYXllcihzb3VyY2VfZGF0YS5sYXllcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZ2VvbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgIENhbGxlZCBvbiBtYWluIHRocmVhZCB3aGVuIGEgd2ViIHdvcmtlciBjb21wbGV0ZXMgcHJvY2Vzc2luZ1xyXG4gICAgICAgZm9yIGEgc2luZ2xlIHRpbGUuXHJcbiAgICAqL1xyXG4gICAgZmluYWxpemVCdWlsZChzdHlsZXMpIHtcclxuICAgICAgICAvLyBDbGVhbnVwIGV4aXN0aW5nIFZCT3NcclxuICAgICAgICB0aGlzLmZyZWVSZXNvdXJjZXMoKTtcclxuXHJcbiAgICAgICAgLy8gRGVidWdcclxuICAgICAgICB0aGlzLmRlYnVnLmdlb21ldHJpZXMgPSAwO1xyXG4gICAgICAgIHRoaXMuZGVidWcuYnVmZmVyX3NpemUgPSAwO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgVkJPc1xyXG4gICAgICAgIGxldCBtZXNoX2RhdGEgPSB0aGlzLm1lc2hfZGF0YTtcclxuICAgICAgICBpZiAobWVzaF9kYXRhKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHMgaW4gbWVzaF9kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVzaF9kYXRhW3NdLnZlcnRleF9kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zy5idWZmZXJfc2l6ZSArPSBtZXNoX2RhdGFbc10udmVydGV4X2RhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc2hlc1tzXSA9IHN0eWxlc1tzXS5tYWtlTWVzaChtZXNoX2RhdGFbc10udmVydGV4X2RhdGEsIG1lc2hfZGF0YVtzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zy5nZW9tZXRyaWVzICs9IHRoaXMubWVzaGVzW3NdLmdlb21ldHJ5X2NvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBvd25lcnNoaXAgdG8gdGV4dHVyZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAobWVzaF9kYXRhW3NdLnRleHR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlcy5wdXNoKC4uLm1lc2hfZGF0YVtzXS50ZXh0dXJlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZGVidWcuZ2VvbV9yYXRpbyA9ICh0aGlzLmRlYnVnLmdlb21ldHJpZXMgLyB0aGlzLmRlYnVnLmZlYXR1cmVzKS50b0ZpeGVkKDEpO1xyXG4gICAgICAgIHRoaXMubWVzaF9kYXRhID0gbnVsbDsgLy8gVE9ETzogbWlnaHQgd2FudCB0byBwcmVzZXJ2ZSB0aGlzIGZvciByZWJ1aWxkaW5nIGdlb21ldHJpZXMgd2hlbiBzdHlsZXMvZXRjLiBjaGFuZ2U/XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICAgQ2FsbGVkIG9uIG1haW4gdGhyZWFkIHdoZW4gd2ViIHdvcmtlciBjb21wbGV0ZXMgcHJvY2Vzc2luZywgYnV0IHRpbGUgaGFzIHNpbmNlIGJlZW4gZGlzY2FyZGVkXHJcbiAgICAgICAgRnJlZXMgcmVzb3VyY2VzIHRoYXQgd291bGQgaGF2ZSBiZWVuIHRyYW5zZmVycmVkIHRvIHRoZSB0aWxlIG9iamVjdC5cclxuICAgICAgICBTdGF0aWMgbWV0aG9kIGJlY2F1c2UgdGhlIHRpbGUgb2JqZWN0IG5vIGxvbmdlciBleGlzdHMgKHRoZSB0aWxlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHdvcmtlciBpcyBwYXNzZWQgaW5zdGVhZCkuXHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGFib3J0QnVpbGQgKHRpbGUpIHtcclxuICAgICAgICBpZiAodGlsZS5tZXNoX2RhdGEpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgcyBpbiB0aWxlLm1lc2hfZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRleHR1cmVzID0gdGlsZS5tZXNoX2RhdGFbc10udGV4dHVyZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRleHR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gVGV4dHVyZS50ZXh0dXJlc1t0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy50cmFjZShgZGVzdHJveWluZyB0ZXh0dXJlICR7dH0gZm9yIHRpbGUgJHt0aWxlLmtleX1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaW50RGVidWcgKCkge1xyXG4gICAgICAgIGxvZy5kZWJ1ZyhgVGlsZTogZGVidWcgZm9yICR7dGhpcy5rZXl9OiBbICAke0pTT04uc3RyaW5naWZ5KHRoaXMuZGVidWcpfSBdYCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKHNjZW5lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29vcmRzLnogPT09IHNjZW5lLmNlbnRlcl90aWxlLnogJiYgc2NlbmUudmlzaWJsZV90aWxlc1t0aGlzLmtleV0pIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIHRpbGVzIG9mIG1pc21hdGNoaW5nIHpvb20gbGV2ZWxzXHJcbiAgICAgICAgaWYgKHRoaXMuY29vcmRzLnogPT09IHNjZW5lLmNlbnRlcl90aWxlLnopIHtcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXJfZGlzdCA9IE1hdGguYWJzKHNjZW5lLmNlbnRlcl90aWxlLnggLSB0aGlzLmNvb3Jkcy54KSArIE1hdGguYWJzKHNjZW5lLmNlbnRlcl90aWxlLnkgLSB0aGlzLmNvb3Jkcy55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2VudGVyX2Rpc3QgPSBJbmZpbml0eTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZChzY2VuZSkge1xyXG4gICAgICAgIHNjZW5lLnRyYWNrVGlsZVNldExvYWRTdGFydCgpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYnVpbGQoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKHNjZW5lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAgICBDYWxsZWQgb24gd29ya2VyIHRvIGNhbmNlbCBsb2FkaW5nXHJcbiAgICAgICAgU3RhdGljIG1ldGhvZCBiZWNhdXNlIHRoZSB3b3JrZXIgb25seSBoYXMgb2JqZWN0IHJlcHJlc2VudGF0aW9ucyBvZiB0aWxlIGRhdGEsIHRoZXJlIGlzIG5vXHJcbiAgICAgICAgdGlsZSBpbnN0YW5jZSBjcmVhdGVkIHlldC5cclxuICAgICovXHJcbiAgICBzdGF0aWMgY2FuY2VsKHRpbGUpIHtcclxuICAgICAgICBpZiAodGlsZSAmJiB0aWxlLnNvdXJjZXMpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXModGlsZS5zb3VyY2VzKS5cclxuICAgICAgICAgICAgICAgIG1hcChzID0+IHRpbGUuc291cmNlc1tzXS5yZXF1ZXN0KS5cclxuICAgICAgICAgICAgICAgIGZpbHRlcihzID0+IHMpLlxyXG4gICAgICAgICAgICAgICAgZm9yRWFjaChzID0+IHMuYWJvcnQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG1lcmdlKG90aGVyKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG90aGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdrZXknKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvdGhlcltrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJcclxuXHJcbmV4cG9ydCBjbGFzcyBNZXRob2ROb3RJbXBsZW1lbnRlZCBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubmFtZSAgICA9ICdNZXRob2ROb3RJbXBsZW1lbnRlZCc7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJ01ldGhvZCAnICsgbWV0aG9kTmFtZSArICcgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcyc7XHJcbiAgICB9XHJcbn1cclxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3Vic2NyaWJlTWl4aW4gKHRhcmdldCkge1xyXG5cclxuICAgIHZhciBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XHJcbiAgICAvLyB2YXIgbGlzdGVuZXJzID0gW107XHJcblxyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7XHJcblxyXG4gICAgICAgIHN1YnNjcmliZShsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgLy8gbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAvLyB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIC8vIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVuc3Vic2NyaWJlQWxsKCkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcclxuICAgICAgICAgICAgLy8gbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHJpZ2dlcihldmVudCwgLi4uZGF0YSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJbZXZlbnRdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJbZXZlbnRdKC4uLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pO1xyXG5cclxufVxyXG4iLCIvLyBNaXNjZWxsYW5lb3VzIHV0aWxpdGllc1xyXG4vKmpzaGludCB3b3JrZXI6IHRydWUqL1xyXG5cclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xyXG5pbXBvcnQgR2VvIGZyb20gJy4uL2dlbyc7XHJcblxyXG52YXIgVXRpbHM7XHJcbmV4cG9ydCBkZWZhdWx0IFV0aWxzID0ge307XHJcblxyXG4vLyBBZGQgdGhlIGN1cnJlbnQgYmFzZSBVUkwgZm9yIHNjaGVtZWxlc3Mgb3IgcHJvdG9jb2wtbGVzcyBVUkxzXHJcbi8vIE1heWJlIHVzZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL1VSSS5qcyBpZiBtb3JlIHJvYnVzdCBmdW5jdGlvbmFsaXR5IGlzIG5lZWRlZFxyXG5VdGlscy5hZGRCYXNlVVJMID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgaWYgKCF1cmwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2NoZW1lbGVzcywgYWRkIHByb3RvY29sXHJcbiAgICBpZiAodXJsLnN1YnN0cigwLCAyKSA9PT0gJy8vJykge1xyXG4gICAgICAgIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIHVybDtcclxuICAgIH1cclxuICAgIC8vIE5vIGh0dHAocykgb3IgZGF0YSwgYWRkIGJhc2VcclxuICAgIGVsc2UgaWYgKHVybC5zZWFyY2goLyhodHRwfGh0dHBzfGRhdGEpOlxcL1xcLy8pIDwgMCkge1xyXG4gICAgICAgIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB1cmw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXJsO1xyXG59O1xyXG5cclxuVXRpbHMuY2FjaGVCdXN0ZXJGb3JVcmwgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICByZXR1cm4gdXJsICsgJz8nICsgKCtuZXcgRGF0ZSgpKTtcclxufTtcclxuXHJcblV0aWxzLmlvID0gZnVuY3Rpb24gKHVybCwgdGltZW91dCA9IDYwMDAwLCByZXNwb25zZVR5cGUgPSAndGV4dCcsIG1ldGhvZCA9ICdHRVQnLCBoZWFkZXJzID0ge30pIHtcclxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICByZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xyXG4gICAgICAgIHJlcXVlc3QudGltZW91dCA9IHRpbWVvdXQ7XHJcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XHJcbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoWyd0ZXh0JywgJ2pzb24nXS5pbmRleE9mKHJlcXVlc3QucmVzcG9uc2VUeXBlKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KEVycm9yKCdSZXF1ZXN0IGVycm9yIHdpdGggYSBzdGF0dXMgb2YgJyArIHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHJlamVjdChFcnJvcignVGhlcmUgd2FzIGEgbmV0d29yayBlcnJvcicgKyBldnQudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHJlamVjdChFcnJvcigndGltZW91dCAnKyBldnQudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ3JlcXVlc3QnLCB7XHJcbiAgICAgICAgdmFsdWU6IHJlcXVlc3RcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBwcm9taXNlO1xyXG59O1xyXG5cclxuVXRpbHMucGFyc2VSZXNvdXJjZSA9IGZ1bmN0aW9uIChib2R5KSB7XHJcbiAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGV2YWwoJ2RhdGEgPSAnICsgYm9keSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB5YW1sLnNhZmVMb2FkKGJvZHkpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nLmVycm9yKCdVdGlscy5wYXJzZVJlc291cmNlOiBmYWlsZWQgdG8gcGFyc2UnLCBlKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxufTtcclxuXHJcblV0aWxzLmxvYWRSZXNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIFV0aWxzLmlvKFV0aWxzLmNhY2hlQnVzdGVyRm9yVXJsKHNvdXJjZSkpLnRoZW4oKGJvZHkpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gVXRpbHMucGFyc2VSZXNvdXJjZShib2R5KTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuLy8gTmVlZGVkIGZvciBvbGRlciBicm93c2VycyB0aGF0IHN0aWxsIHN1cHBvcnQgV2ViR0wgKFNhZmFyaSA2IGV0Yy4pXHJcblV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZVBvbHlmaWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxyXG4gICAgICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XHJcbiAgICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCAxMDAwIC82MCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBTdHJpbmdpZnkgYW4gb2JqZWN0IGludG8gSlNPTiwgYnV0IGNvbnZlcnQgZnVuY3Rpb25zIHRvIHN0cmluZ3NcclxuVXRpbHMuc2VyaWFsaXplV2l0aEZ1bmN0aW9ucyA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkob2JqLCBmdW5jdGlvbihrLCB2KSB7XHJcbiAgICAgICAgLy8gQ29udmVydCBmdW5jdGlvbnMgdG8gc3RyaW5nc1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBzZXJpYWxpemVkO1xyXG59O1xyXG5cclxuLy8gUGFyc2UgYSBKU09OIHN0cmluZywgYnV0IGNvbnZlcnQgZnVuY3Rpb24tbGlrZSBzdHJpbmdzIGJhY2sgaW50byBmdW5jdGlvbnNcclxuVXRpbHMuZGVzZXJpYWxpemVXaXRoRnVuY3Rpb25zID0gZnVuY3Rpb24oc2VyaWFsaXplZCwgd3JhcCkge1xyXG4gICAgdmFyIG9iaiA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCk7XHJcbiAgICBvYmogPSBVdGlscy5zdHJpbmdzVG9GdW5jdGlvbnMob2JqLCB3cmFwKTtcclxuICAgIHJldHVybiBvYmo7XHJcbn07XHJcblxyXG4vLyBSZWN1cnNpdmVseSBwYXJzZSBhbiBvYmplY3QsIGF0dGVtcHRpbmcgdG8gY29udmVydCBzdHJpbmcgcHJvcGVydGllcyB0aGF0IGxvb2sgbGlrZSBmdW5jdGlvbnMgYmFjayBpbnRvIGZ1bmN0aW9uc1xyXG5VdGlscy5zdHJpbmdzVG9GdW5jdGlvbnMgPSBmdW5jdGlvbihvYmosIHdyYXApIHtcclxuICAgIGZvciAodmFyIHAgaW4gb2JqKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIG9iamVjdCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIG9ialtwXSA9IFV0aWxzLnN0cmluZ3NUb0Z1bmN0aW9ucyh2YWwsIHdyYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb252ZXJ0IHN0cmluZ3MgYmFjayBpbnRvIGZ1bmN0aW9uc1xyXG4gICAgICAgIC8vIFRPRE86IG1ha2UgZnVuY3Rpb24gbWF0Y2hpbmcgdG9sZXJhbnQgb2Ygd2hpdGVzcGFjZSBhbmQgbXVsdGlsaW5lc1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbC5tYXRjaCgvXmZ1bmN0aW9uLipcXCguKlxcKS8pICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGY7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdyYXAgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmFsKCdmID0gJyArIHdyYXAodmFsKSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZhbCgnZiA9ICcgKyB2YWwpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9ialtwXSA9IGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZhbGwtYmFjayB0byBvcmlnaW5hbCB2YWx1ZSBpZiBwYXJzaW5nIGZhaWxlZFxyXG4gICAgICAgICAgICAgICAgb2JqW3BdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvYmo7XHJcbn07XHJcblxyXG4vLyBMb2cgd3JhcHBlciwgc2VuZHMgbWVzc2FnZSB0byBtYWluIHRocmVhZCBmb3IgZGlzcGxheSwgYW5kIGluY2x1ZGVzIHdvcmtlciBpZCAjXHJcblV0aWxzLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgLi4ubXNnKSB7XHJcbiAgICBsZXZlbCA9IGxldmVsIHx8ICdpbmZvJztcclxuICAgIGlmIChVdGlscy5pc1dvcmtlclRocmVhZCkge1xyXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICB0eXBlOiAnbG9nJyxcclxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxyXG4gICAgICAgICAgICB3b3JrZXJfaWQ6IHNlbGYuX3dvcmtlcl9pZCxcclxuICAgICAgICAgICAgbXNnOiBtc2dcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBsb2dbbGV2ZWxdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgbG9nW2xldmVsXSguLi5tc2cpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gRGVmYXVsdCB0byBhbGxvd2luZyBoaWdoIHBpeGVsIGRlbnNpdHlcclxuVXRpbHMudXNlX2hpZ2hfZGVuc2l0eV9kaXNwbGF5ID0gdHJ1ZTtcclxuVXRpbHMudXBkYXRlRGV2aWNlUGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIFV0aWxzLmRldmljZV9waXhlbF9yYXRpbyA9IChVdGlscy51c2VfaGlnaF9kZW5zaXR5X2Rpc3BsYXkgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XHJcbn07XHJcblxyXG4vLyBNYXJrIHRocmVhZCBhcyBtYWluIG9yIHdvcmtlclxyXG4oZnVuY3Rpb24oKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBVdGlscy5pc1dvcmtlclRocmVhZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBVdGlscy5pc01haW5UaHJlYWQgICA9IHRydWU7XHJcbiAgICAgICAgICAgIFV0aWxzLnVwZGF0ZURldmljZVBpeGVsUmF0aW8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChzZWxmICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgVXRpbHMuaXNXb3JrZXJUaHJlYWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBVdGlscy5pc01haW5UaHJlYWQgICA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSkoKTtcclxuXHJcbi8vIEdldCBVUkwgdGhhdCB0aGUgY3VycmVudCBzY3JpcHQgd2FzIGxvYWRlZCBmcm9tXHJcbi8vIElmIGN1cnJlbnRTY3JpcHQgaXMgbm90IGF2YWlsYWJsZSwgbG9vcHMgdGhyb3VnaCA8c2NyaXB0PiBlbGVtZW50cyBzZWFyY2hpbmcgZm9yIGEgbGlzdCBvZiBwcm92aWRlZCBwYXRoc1xyXG4vLyBlLmcuIFV0aWxzLmZpbmRDdXJyZW50VVJMKCd0YW5ncmFtLmRlYnVnLmpzJywgJ3RhbmdyYW0ubWluLmpzJyk7XHJcblV0aWxzLmZpbmRDdXJyZW50VVJMID0gZnVuY3Rpb24gKC4uLnBhdGhzKSB7XHJcbiAgICAvLyBGaW5kIGN1cnJlbnRseSBleGVjdXRpbmcgc2NyaXB0XHJcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdDtcclxuICAgIGlmIChzY3JpcHQpIHtcclxuICAgICAgICByZXR1cm4gc2NyaXB0LnNyYztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGF0aHMpKSB7XHJcbiAgICAgICAgLy8gRmFsbGJhY2sgb24gbG9vcGluZyB0aHJvdWdoIDxzY3JpcHQ+IGVsZW1lbnRzIGlmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgaXMgbm90IHN1cHBvcnRlZFxyXG4gICAgICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xyXG4gICAgICAgIGZvciAodmFyIHM9MDsgcyA8IHNjcmlwdHMubGVuZ3RoOyBzKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcGF0aCBvZiBwYXRocykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdHNbc10uc3JjLmluZGV4T2YocGF0aCkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHNbc10uc3JjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gVXNlZCBmb3IgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gcG93ZXItb2YtMiBhbmQgbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcclxuLy8gVmlhOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5NzIyMjQ3L3dlYmdsLXdhaXQtZm9yLXRleHR1cmUtdG8tbG9hZFxyXG5VdGlscy5pc1Bvd2VyT2YyID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDA7XHJcbn07XHJcblxyXG5VdGlscy5uZXh0UG93ZXJPZjIgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIodmFsdWUpKSk7XHJcbn07XHJcblxyXG4vLyBJbnRlcnBvbGF0ZSAneCcgYWxvbmcgYSBzZXJpZXMgb2YgY29udHJvbCBwb2ludHNcclxuLy8gJ3BvaW50cycgaXMgYW4gYXJyYXkgb2YgY29udHJvbCBwb2ludHMgaW4gdGhlIGZvcm0gW3gsIHldXHJcbi8vXHJcbi8vIEV4YW1wbGU6XHJcbi8vICAgICBDb250cm9sIHBvaW50czpcclxuLy8gICAgICAgICBbMCwgNV06ICB3aGVuIHg9MCwgeT01XHJcbi8vICAgICAgICAgWzQsIDEwXTogd2hlbiB4PTQsIHk9MTBcclxuLy9cclxuLy8gICAgIFV0aWxzLmludGVycG9sYXRlKDIsIFtbMCwgNV0sIFs0LCAxMF1dKTtcclxuLy8gICAgIC0+IGNvbXB1dGVzIHg9MiwgaGFsZndheSBiZXR3ZWVuIHg9MCBhbmQgeD00OiAoMTAgLSA1KSAvIDIgKzVcclxuLy8gICAgIC0+IHJldHVybnMgNy41XHJcbi8vXHJcbi8vIFRPRE86IGFkZCBvdGhlciBpbnRlcnBvbGF0aW9uIG1ldGhvZHMgYmVzaWRlcyBsaW5lYXJcclxuLy9cclxuVXRpbHMuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbih4LCBwb2ludHMpIHtcclxuICAgIC8vIElmIHRoaXMgZG9lc24ndCByZXNlbWJsZSBhIGxpc3Qgb2YgY29udHJvbCBwb2ludHMsIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykgfHwgcG9pbnRzLnNvbWUodiA9PiB7IHJldHVybiAhQXJyYXkuaXNBcnJheSh2KTsgfSkpIHtcclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocG9pbnRzLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4MSwgeDIsIGQsIHk7XHJcblxyXG4gICAgLy8gTWluIGJvdW5kc1xyXG4gICAgaWYgKHggPD0gcG9pbnRzWzBdWzBdKSB7XHJcbiAgICAgICAgeSA9IHBvaW50c1swXVsxXTtcclxuICAgIH1cclxuICAgIC8vIE1heCBib3VuZHNcclxuICAgIGVsc2UgaWYgKHggPj0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV1bMF0pIHtcclxuICAgICAgICB5ID0gcG9pbnRzW3BvaW50cy5sZW5ndGgtMV1bMV07XHJcbiAgICB9XHJcbiAgICAvLyBGaW5kIHdoaWNoIGNvbnRyb2wgcG9pbnRzIHggaXMgYmV0d2VlblxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoeCA+PSBwb2ludHNbaV1bMF0gJiYgeCA8IHBvaW50c1tpKzFdWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMaW5lYXIgaW50ZXJwb2xhdGlvblxyXG4gICAgICAgICAgICAgICAgeDEgPSBwb2ludHNbaV1bMF07XHJcbiAgICAgICAgICAgICAgICB4MiA9IHBvaW50c1tpKzFdWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE11bHRpcGxlIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnRzW2ldWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjPTA7IGMgPCBwb2ludHNbaV1bMV0ubGVuZ3RoOyBjKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdW2NdIC0gcG9pbnRzW2ldWzFdW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5W2NdID0gZCAqICh4IC0geDEpIC8gKHgyIC0geDEpICsgcG9pbnRzW2ldWzFdW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNpbmdsZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IHBvaW50c1tpKzFdWzFdIC0gcG9pbnRzW2ldWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBkICogKHggLSB4MSkgLyAoeDIgLSB4MSkgKyBwb2ludHNbaV1bMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB5O1xyXG59O1xyXG5cclxuLy8gSXRlcmF0b3JzIChFUzYgZ2VuZXJhdG9ycylcclxuXHJcbi8vIEl0ZXJhdG9yIGZvciBrZXkvdmFsdWUgcGFpcnMgb2YgYW4gb2JqZWN0XHJcblV0aWxzLmVudHJpZXMgPSBmdW5jdGlvbiogKG9iaikge1xyXG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcclxuICAgICAgICB5aWVsZCBba2V5LCBvYmpba2V5XV07XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBJdGVyYXRvciBmb3IgdmFsdWVzIG9mIGFuIG9iamVjdFxyXG5VdGlscy52YWx1ZXMgPSBmdW5jdGlvbiogKG9iaikge1xyXG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcclxuICAgICAgICB5aWVsZCBvYmpba2V5XTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIFJlY3Vyc2l2ZSBpdGVyYXRvcnMgZm9yIGFsbCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCwgbm8gbWF0dGVyIGhvdyBkZWVwbHkgbmVzdGVkXHJcbi8vIFRPRE86IGZpeCBmb3IgY2lyY3VsYXIgc3RydWN0dXJlc1xyXG5VdGlscy5yZWN1cnNlRW50cmllcyA9IGZ1bmN0aW9uKiAob2JqKSB7XHJcbiAgICBpZiAoIW9iaikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XHJcbiAgICAgICAgaWYgKG9ialtrZXldKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIFtrZXksIG9ialtrZXldLCBvYmpdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgeWllbGQqIFV0aWxzLnJlY3Vyc2VFbnRyaWVzKG9ialtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblV0aWxzLnJlY3Vyc2VWYWx1ZXMgPSBmdW5jdGlvbiogKG9iaikge1xyXG4gICAgaWYgKCFvYmopIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xyXG4gICAgICAgIGlmIChvYmpba2V5XSkge1xyXG4gICAgICAgICAgICB5aWVsZCBvYmpba2V5XTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkKiBVdGlscy5yZWN1cnNlVmFsdWVzKG9ialtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblV0aWxzLnNjYWxlSW50MTYgPSBmdW5jdGlvbiAodmFsLCBtYXgpIHtcclxuICAgIHJldHVybiAodmFsIC8gbWF4KSAqIDMyNzY4O1xyXG59O1xyXG5cclxuVXRpbHMuZGVnVG9SYWQgPSBmdW5jdGlvbiAoZGVncmVlcykge1xyXG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xyXG59O1xyXG5cclxuVXRpbHMucmFkVG9EZWcgPSBmdW5jdGlvbiAocmFkaWFucykge1xyXG4gICAgcmV0dXJuIHJhZGlhbnMgKiAxODAgLyBNYXRoLlBJO1xyXG59O1xyXG5cclxuVXRpbHMudG9DYW52YXNDb2xvciA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgcmV0dXJuICdyZ2IoJyArICBNYXRoLnJvdW5kKGNvbG9yWzBdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JbMV0gICogMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JbMl0gKiAyNTUpICsgJyknO1xyXG59O1xyXG5cclxuVXRpbHMuY2VudHJvaWQgPSBmdW5jdGlvbiAocG9seWdvbikge1xyXG4gICAgbGV0IG4gPSBwb2x5Z29uLmxlbmd0aDtcclxuICAgIGxldCBjZW50cm9pZCA9IFswLCAwXTtcclxuXHJcbiAgICBmb3IgKGxldCBwPTA7IHAgPCBwb2x5Z29uLmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgICAgY2VudHJvaWRbMF0gKz0gcG9seWdvbltwXVswXTtcclxuICAgICAgICBjZW50cm9pZFsxXSArPSBwb2x5Z29uW3BdWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIGNlbnRyb2lkWzBdIC89IG47XHJcbiAgICBjZW50cm9pZFsxXSAvPSBuO1xyXG5cclxuICAgIHJldHVybiBjZW50cm9pZDtcclxufTtcclxuXHJcblV0aWxzLm11bHRpQ2VudHJvaWQgPSBmdW5jdGlvbiAocG9seWdvbnMpIHtcclxuICAgIGxldCBuID0gcG9seWdvbnMubGVuZ3RoO1xyXG4gICAgbGV0IGNlbnRyb2lkID0gWzAsIDBdO1xyXG5cclxuICAgIGZvciAobGV0IHA9MDsgcCA8IHBvbHlnb25zLmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgICAgbGV0IHBvbHlnb24gPSBwb2x5Z29uc1twXVswXTtcclxuICAgICAgICBsZXQgYyA9IFV0aWxzLmNlbnRyb2lkKHBvbHlnb24pO1xyXG4gICAgICAgIGNlbnRyb2lkWzBdICs9IGNbMF07XHJcbiAgICAgICAgY2VudHJvaWRbMV0gKz0gY1sxXTtcclxuICAgIH1cclxuXHJcbiAgICBjZW50cm9pZFswXSAvPSBuO1xyXG4gICAgY2VudHJvaWRbMV0gLz0gbjtcclxuXHJcbiAgICByZXR1cm4gY2VudHJvaWQ7XHJcbn07XHJcblxyXG5VdGlscy5wb2x5Z29uQXJlYSA9IGZ1bmN0aW9uIChwb2x5Z29uKSB7XHJcbiAgICBsZXQgYXJlYSA9IDA7XHJcbiAgICBsZXQgbiA9IHBvbHlnb24ubGVuZ3RoO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgIGxldCBwMCA9IHBvbHlnb25baV07XHJcbiAgICAgICAgbGV0IHAxID0gcG9seWdvbltpKzFdO1xyXG5cclxuICAgICAgICBhcmVhICs9IHAwWzBdICogcDFbMV0gLSBwMVswXSAqIHAwWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIGFyZWEgKz0gcG9seWdvbltuIC0gMV1bMF0gKiBwb2x5Z29uWzBdWzFdIC0gcG9seWdvblswXVswXSAqIHBvbHlnb25bbiAtIDFdWzFdO1xyXG5cclxuICAgIHJldHVybiBNYXRoLmFicyhhcmVhKSAvIDI7XHJcbn07XHJcblxyXG5VdGlscy5tdWx0aVBvbHlnb25BcmVhID0gZnVuY3Rpb24gKHBvbHlnb25zKSB7XHJcbiAgICBsZXQgYXJlYSA9IDA7XHJcblxyXG4gICAgZm9yIChsZXQgcD0wOyBwIDwgcG9seWdvbnMubGVuZ3RoOyBwKyspIHtcclxuICAgICAgICBsZXQgcG9seWdvbiA9IHBvbHlnb25zW3BdWzBdO1xyXG4gICAgICAgIGFyZWEgKz0gVXRpbHMucG9seWdvbkFyZWEocG9seWdvbik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFyZWE7XHJcbn07XHJcblxyXG5VdGlscy50b1BpeGVsU2l6ZSA9IGZ1bmN0aW9uIChzaXplLCBraW5kKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJweFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwiZW1cIikge1xyXG4gICAgICAgIHJldHVybiAxNiAqIHNpemU7XHJcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwicHRcIikge1xyXG4gICAgICAgIHJldHVybiBzaXplIC8gMC43NTtcclxuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCIlXCIpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZSAvIDYuMjU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5VdGlscy5wb2ludEluVGlsZSA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgcmV0dXJuIHBvaW50WzBdID4gMCAmJsKgcG9pbnRbMV0gPiAtR2VvLnRpbGVfc2NhbGUgJiYgcG9pbnRbMF0gPCBHZW8udGlsZV9zY2FsZSAmJiBwb2ludFsxXSA8IDA7XHJcbn07XHJcblxyXG5VdGlscy5waXhlbFRvTWVyY2F0b3IgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgcmV0dXJuIHNpemUgKiBHZW8udW5pdHNfcGVyX3BpeGVsO1xyXG59O1xyXG5cclxuIiwiLypqc2hpbnQgd29ya2VyOiB0cnVlKi9cclxuXHJcbi8vIFdvcmtlckJyb2tlciByb3V0ZXMgbWVzc2FnZXMgYmV0d2VlbiB3ZWIgd29ya2VycyBhbmQgdGhlIG1haW4gdGhyZWFkLCBhbGxvd2luZyBmb3Igc2ltcGxlclxyXG4vLyBhc3luYyBjb2RlIHZpYSBwcm9taXNlcy4gRXhhbXBsZSB1c2FnZTpcclxuLy9cclxuLy8gSW4gd2ViIHdvcmtlciwgZGVmaW5lIGEgbWV0aG9kOlxyXG4vL1xyXG4vLyAgICAgc2VsZi5zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xyXG4vLyAgICAgICAgIHJldHVybiB4ICogeDtcclxuLy8gICAgIH07XHJcbi8vXHJcbi8vIEluIG1haW4gdGhyZWFkLCBpbnZva2UgdGhhdCBtZXRob2QgYW5kIHJlY2VpdmUgdGhlIHJlc3VsdCAoaWYgYW55KSBhcyBhIHByb21pc2U6XHJcbi8vXHJcbi8vICAgICB3b3JrZXIgPSBuZXcgV29ya2VyKC4uLik7XHJcbi8vICAgICBXb3JrZXJCcm9rZXIuYWRkV29ya2VyKHdvcmtlcik7XHJcbi8vXHJcbi8vICAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2Uod29ya2VyLCAnc3F1YXJlJywgNSkudGhlbihmdW5jdGlvbih5KSB7XHJcbi8vICAgICAgICAgY29uc29sZS5sb2coeSk7XHJcbi8vICAgICB9KTtcclxuLy9cclxuLy8gICAgIC0+IHByaW50cyAyNVxyXG4vL1xyXG4vLyBBc3luYyBjb2RlOlxyXG4vL1xyXG4vLyBGb3Igc3luY2hyb25vdXMgY29kZSB0aGF0IG11c3QgcGFzcyBhIHJldHVybiB2YWx1ZSB0byB0aGUgbWFpbiB0aHJlYWQsIHRoZSBmdW5jdGlvbiBjYW4gc2ltcGx5XHJcbi8vIHJldHVybiBhbiBpbW1lZGlhdGUgdmFsdWUgKHNlZSBleGFtcGxlIGFib3ZlKS4gRm9yIGNhc2VzIHdoZXJlIHRoZSB3b3JrZXIgbWV0aG9kIG5lZWRzIHRvIHJ1blxyXG4vLyBhc3luY2hyb25vdXMgY29kZSwgdGhlIGZ1bmN0aW9uIGNhbiByZXR1cm4gYSBwcm9taXNlLCBhbmQgdGhlIHJlc29sdmVkIG9yIHJlamVjdGVkIHZhbHVlIHdpbGxcclxuLy8gYmUgc2VudCBiYWNrIHRvIHRoZSBtYWluIHRocmVhZCB3aGVuIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cclxuLy9cclxuLy8gRXJyb3IgaGFuZGxpbmc6XHJcbi8vXHJcbi8vIElmIHRoZSB3b3JrZXIgbWV0aG9kIGVpdGhlciB0aHJvd3MgYW4gZXJyb3IsIG9yIHJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgcmVqZWN0ZWQsIGl0IHdpbGwgYmVcclxuLy8gc2VudCBiYWNrIHRvIHRoZSBtYWluIHRocmVhZCBhcyBhIHByb21pc2UgcmVqZWN0aW9uLiBUaGVzZSB0d28gZXhhbXBsZXMgYXJlIGVxdWl2YWxlbnQ6XHJcbi8vXHJcbi8vICAgICBJbiB3b3JrZXIsIHRocm93aW5nIGFuIGVycm9yOlxyXG4vL1xyXG4vLyAgICAgICAgIHNlbGYuYnJva2VuID0gZnVuY3Rpb24gKCkge1xyXG4vLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yIGluIHdvcmtlciEnKTtcclxuLy8gICAgICAgICB9O1xyXG4vL1xyXG4vLyAgICAgSW4gd29ya2VyLCByZXR1cm5pbmcgYSByZWplY3RlZCBwcm9taXNlOlxyXG4vL1xyXG4vLyAgICAgICAgIHNlbGYuYnJva2VuID0gZnVuY3Rpb24gKCkge1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdlcnJvciBpbiB3b3JrZXIhJykpO1xyXG4vLyAgICAgICAgIH07XHJcbi8vXHJcbi8vICAgICBJbiBtYWluIHRocmVhZCwgYm90aCBlcnJvcnMgYXJlIHJlY2VpdmVkIGFzIGEgcHJvbWlzZSByZWplY3Rpb246XHJcbi8vXHJcbi8vICAgICAgICAgV29ya2VyQnJva2VyLnBvc3RNZXNzYWdlKHdvcmtlciwgJ2Jyb2tlbicpLnRoZW4oXHJcbi8vICAgICAgICAgICAgIC8vIFByb21pc2UgcmVzb2x2ZWRcclxuLy8gICAgICAgICAgICAgZnVuY3Rpb24oKSB7XHJcbi8vICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc3VjY2VzcyEnKTtcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgLy8gUHJvbWlzZSByZWplY3RlZFxyXG4vLyAgICAgICAgICAgICBmdW5jdGlvbihlcnJvcikge1xyXG4vLyAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yIScsIGVycm9yKTtcclxuLy8gICAgICAgICAgICAgfSk7XHJcbi8vXHJcbi8vICAgICAgICAgLT4gcHJpbnRzICdlcnJvciEgZXJyb3IgaW4gd29ya2VyJ1xyXG4vL1xyXG4vLyBUT0RPOiBhZGQgZG9jdW1lbnRhdGlvbiBmb3IgaW52b2tpbmcgbWFpbiB0aHJlYWQgbWV0aG9kcyBmcm9tIGEgd29ya2VyIChiYXNpY2FsbHkgc2FtZSBBUEksIGJ1dCBpbiByZXZlcnNlKVxyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscyc7XHJcblxyXG52YXIgV29ya2VyQnJva2VyO1xyXG5leHBvcnQgZGVmYXVsdCBXb3JrZXJCcm9rZXIgPSB7fTtcclxuXHJcbi8vIEdsb2JhbCBsaXN0IG9mIGFsbCB3b3JrZXIgbWVzc2FnZXNcclxuLy8gVW5pcXVlbHkgdHJhY2tzIGV2ZXJ5IGNhbGwgbWFkZSBiZXR3ZWVuIG1haW4gdGhyZWFkIGFuZCBhIHdvcmtlclxyXG52YXIgbWVzc2FnZV9pZCA9IDA7XHJcbnZhciBtZXNzYWdlcyA9IHt9O1xyXG5cclxuLy8gTWFpbiB0aHJlYWQ6XHJcbi8vIC0gU2VuZCBtZXNzYWdlcyB0byB3b3JrZXJzLCBhbmQgb3B0aW9uYWxseSByZWNlaXZlIGFuIGFzeW5jIHJlc3BvbnNlIGFzIGEgcHJvbWlzZVxyXG4vLyAtIFJlY2VpdmUgbWVzc2FnZXMgZnJvbSB3b3JrZXJzLCBhbmQgb3B0aW9uYWxseSBzZW5kIGFuIGFzeW5jIHJlc3BvbnNlIGJhY2sgYXMgYSBwcm9taXNlXHJcbmZ1bmN0aW9uIHNldHVwTWFpblRocmVhZCAoKSB7XHJcblxyXG4gICAgLy8gU2VuZCBhIG1lc3NhZ2UgdG8gYSB3b3JrZXIsIGFuZCBvcHRpb25hbGx5IGdldCBhbiBhc3luYyByZXNwb25zZVxyXG4gICAgLy8gQXJndW1lbnRzOlxyXG4gICAgLy8gICAtIHdvcmtlcjogdGhlIHdlYiB3b3JrZXIgaW5zdGFuY2VcclxuICAgIC8vICAgLSBtZXRob2Q6IHRoZSBtZXRob2Qgd2l0aCB0aGlzIG5hbWUgd2lsbCBiZSBpbnZva2VkIGluIHRoZSB3b3JrZXJcclxuICAgIC8vICAgLSBtZXNzYWdlOiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNhbGwgaW4gdGhlIHdvcmtlclxyXG4gICAgLy8gUmV0dXJuczpcclxuICAgIC8vICAgLSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCBpZiB0aGUgd29ya2VyIG1ldGhvZCByZXR1cm5zIGEgdmFsdWUgKGNvdWxkIGJlIGltbWVkaWF0ZWx5LCBvciBhc3luYylcclxuICAgIC8vXHJcbiAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAod29ya2VyLCBtZXRob2QsIC4uLm1lc3NhZ2UpIHtcclxuICAgICAgICAvLyBUcmFjayBzdGF0ZSBvZiB0aGlzIG1lc3NhZ2VcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbWVzc2FnZXNbbWVzc2FnZV9pZF0gPSB7IG1ldGhvZCwgbWVzc2FnZSwgcmVzb2x2ZSwgcmVqZWN0IH07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdtYWluX3NlbmQnLCAgICAgIC8vIG1hcmsgbWVzc2FnZSBhcyBtZXRob2QgaW52b2NhdGlvbiBmcm9tIG1haW4gdGhyZWFkXHJcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQsICAgICAgICAgICAgIC8vIHVuaXF1ZSBpZCBmb3IgdGhpcyBtZXNzYWdlLCBmb3IgbGlmZSBvZiBwcm9ncmFtXHJcbiAgICAgICAgICAgIG1ldGhvZCwgICAgICAgICAgICAgICAgIC8vIHdpbGwgZGlzcGF0Y2ggdG8gYSBmdW5jdGlvbiBvZiB0aGlzIG5hbWUgd2l0aGluIHRoZSB3b3JrZXJcclxuICAgICAgICAgICAgbWVzc2FnZSAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBwYXlsb2FkXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG1lc3NhZ2VfaWQrKztcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gQWRkIGEgd29ya2VyIHRvIGNvbW11bmljYXRlIHdpdGggLSBlYWNoIHdvcmtlciBtdXN0IGJlIHJlZ2lzdGVyZWQgZnJvbSB0aGUgbWFpbiB0aHJlYWRcclxuICAgIHZhciB3b3JrZXJfaWQgPSAwO1xyXG4gICAgdmFyIHdvcmtlcnMgPSB7fTtcclxuXHJcbiAgICBXb3JrZXJCcm9rZXIuYWRkV29ya2VyID0gZnVuY3Rpb24gKHdvcmtlcikge1xyXG5cclxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCByZWdpc3RlcmVkIHdvcmtlcnNcclxuICAgICAgICAvLyBUT0RPOiBhZGRpbmcgYSBwcm9wZXJ0eSBkaXJlY3RseSB0byB0aGUgd29ya2VyLCB3b3VsZCBiZSBiZXR0ZXIgdG8gdHJhY2sgbm9uLWluc3RydXNpdmVseSxcclxuICAgICAgICAvLyBtYXliZSB3aXRoIGFuIEVTNiBNYXBcclxuICAgICAgICB3b3JrZXIuX3dvcmtlcl9icm9rZXJfaWQgPSB3b3JrZXJfaWQrKztcclxuICAgICAgICB3b3JrZXJzW3dvcmtlci5fd29ya2VyX2Jyb2tlcl9pZF0gPSB3b3JrZXI7XHJcblxyXG4gICAgICAgIC8vIExpc3RlbiBmb3IgbWVzc2FnZXMgY29taW5nIGJhY2sgZnJvbSB0aGUgd29ya2VyLCBhbmQgZnVsZmlsbCB0aGF0IG1lc3NhZ2UncyBwcm9taXNlXHJcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ3dvcmtlcl9yZXBseScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUGFzcyB0aGUgcmVzdWx0IHRvIHRoZSBwcm9taXNlXHJcbiAgICAgICAgICAgIHZhciBpZCA9IGV2ZW50LmRhdGEubWVzc2FnZV9pZDtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0ucmVqZWN0KGV2ZW50LmRhdGEuZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdLnJlc29sdmUoZXZlbnQuZGF0YS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXNzYWdlc1tpZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gTGlzdGVuIGZvciBtZXNzYWdlcyBpbml0aWF0aW5nIGEgY2FsbCBmcm9tIHRoZSB3b3JrZXIsIGRpc3BhdGNoIHRoZW0sXHJcbiAgICAgICAgLy8gYW5kIHNlbmQgYW55IHJldHVybiB2YWx1ZSBiYWNrIHRvIHRoZSB3b3JrZXJcclxuICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBVbmlxdWUgaWQgZm9yIHRoaXMgbWVzc2FnZSAmIHJldHVybiBjYWxsIHRvIG1haW4gdGhyZWFkXHJcbiAgICAgICAgICAgIHZhciBpZCA9IGV2ZW50LmRhdGEubWVzc2FnZV9pZDtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ3dvcmtlcl9zZW5kJyB8fCBpZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENhbGwgdGhlIHJlcXVlc3RlZCBtZXRob2QgYW5kIHNhdmUgdGhlIHJldHVybiB2YWx1ZVxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1tldmVudC5kYXRhLnRhcmdldF07XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgV29ya2VyIGJyb2tlciBjb3VsZCBub3QgZGlzcGF0Y2ggbWVzc2FnZSB0eXBlICR7ZXZlbnQuZGF0YS5tZXRob2R9IG9uIHRhcmdldCAke2V2ZW50LmRhdGEudGFyZ2V0fSBiZWNhdXNlIG5vIG9iamVjdCB3aXRoIHRoYXQgbmFtZSBpcyByZWdpc3RlcmVkIG9uIG1haW4gdGhyZWFkYCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSAodHlwZW9mIHRhcmdldFtldmVudC5kYXRhLm1ldGhvZF0gPT09ICdmdW5jdGlvbicpICYmIHRhcmdldFtldmVudC5kYXRhLm1ldGhvZF07XHJcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgV29ya2VyIGJyb2tlciBjb3VsZCBub3QgZGlzcGF0Y2ggbWVzc2FnZSB0eXBlICR7ZXZlbnQuZGF0YS5tZXRob2R9IG9uIHRhcmdldCAke2V2ZW50LmRhdGEudGFyZ2V0fSBiZWNhdXNlIG9iamVjdCBoYXMgbm8gbWV0aG9kIHdpdGggdGhhdCBuYW1lYCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGVycm9yO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRhcmdldCwgZXZlbnQuZGF0YS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaHJvd24gZXJyb3JzIHdpbGwgYmUgcGFzc2VkIGJhY2sgKGluIHN0cmluZyBmb3JtKSB0byB3b3JrZXJcclxuICAgICAgICAgICAgICAgIGVycm9yID0gZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2VuZCByZXR1cm4gdmFsdWUgdG8gd29ya2VyXHJcbiAgICAgICAgICAgIC8vIEFzeW5jIHJlc3VsdFxyXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21haW5fcmVwbHknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtYWluX3JlcGx5JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEltbWVkaWF0ZSByZXN1bHRcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtYWluX3JlcGx5JyxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXN1bHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYCR7ZXJyb3IubWVzc2FnZX06ICR7ZXJyb3Iuc3RhY2t9YCA6IGVycm9yKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJlZ2lzdGVyIGFuIG9iamVjdCB0byByZWNlaXZlIGNhbGxzIGZyb20gdGhlIHdvcmtlclxyXG4gICAgdmFyIHRhcmdldHMgPSB7fTtcclxuICAgIFdvcmtlckJyb2tlci5hZGRUYXJnZXQgPSBmdW5jdGlvbiAobmFtZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0c1tuYW1lXSA9IHRhcmdldDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRXhwb3NlIGZvciBkZWJ1Z2dpbmdcclxuICAgIFdvcmtlckJyb2tlci5nZXRNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIFdvcmtlckJyb2tlci5nZXRNZXNzYWdlSWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VfaWQ7XHJcbiAgICB9O1xyXG5cclxufVxyXG5cclxuLy8gV29ya2VyIHRocmVhZHM6XHJcbi8vIC0gUmVjZWl2ZSBtZXNzYWdlcyBmcm9tIG1haW4gdGhyZWFkLCBhbmQgb3B0aW9uYWxseSBzZW5kIGFuIGFzeW5jIHJlc3BvbnNlIGJhY2sgYXMgYSBwcm9taXNlXHJcbi8vIC0gU2VuZCBtZXNzYWdlcyB0byBtYWluIHRocmVhZCwgYW5kIG9wdGlvbmFsbHkgcmVjZWl2ZSBhbiBhc3luYyByZXNwb25zZSBhcyBhIHByb21pc2VcclxuZnVuY3Rpb24gc2V0dXBXb3JrZXJUaHJlYWQgKCkge1xyXG5cclxuICAgIC8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBtYWluIHRocmVhZCwgYW5kIG9wdGlvbmFsbHkgZ2V0IGFuIGFzeW5jIHJlc3BvbnNlIGFzIGEgcHJvbWlzZVxyXG4gICAgLy8gQXJndW1lbnRzOlxyXG4gICAgLy8gICAtIHRhcmdldDogdGhlIG5hbWUgb2YgdGhlIG9iamVjdCBpbiB0aGUgbWFpbiB0aHJlYWQgdG8gYmUgY2FsbGVkXHJcbiAgICAvLyAgIC0gbWV0aG9kOiB0aGUgbWV0aG9kIHdpdGggdGhpcyBuYW1lIHdpbGwgYmUgaW52b2tlZCBvbiB0aGUgbWFpbiB0aHJlYWQgdGFyZ2V0IG9iamVjdFxyXG4gICAgLy8gICAtIG1lc3NhZ2U6IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QgY2FsbCBpbiB0aGUgbWFpbiB0aHJlYWRcclxuICAgIC8vIFJldHVybnM6XHJcbiAgICAvLyAgIC0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgaWYgdGhlIG1haW4gdGhyZWFkIG1ldGhvZCByZXR1cm5zIGEgdmFsdWUgKGNvdWxkIGJlIGltbWVkaWF0ZWx5LCBvciBhc3luYylcclxuICAgIC8vXHJcbiAgICBXb3JrZXJCcm9rZXIucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBtZXRob2QsIC4uLm1lc3NhZ2UpIHtcclxuICAgICAgICAvLyBUcmFjayBzdGF0ZSBvZiB0aGlzIG1lc3NhZ2VcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbWVzc2FnZXNbbWVzc2FnZV9pZF0gPSB7IHRhcmdldCwgbWV0aG9kLCBtZXNzYWdlLCByZXNvbHZlLCByZWplY3QgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgIHR5cGU6ICd3b3JrZXJfc2VuZCcsICAgIC8vIG1hcmsgbWVzc2FnZSBhcyBtZXRob2QgaW52b2NhdGlvbiBmcm9tIHdvcmtlclxyXG4gICAgICAgICAgICBtZXNzYWdlX2lkLCAgICAgICAgICAgICAvLyB1bmlxdWUgaWQgZm9yIHRoaXMgbWVzc2FnZSwgZm9yIGxpZmUgb2YgcHJvZ3JhbVxyXG4gICAgICAgICAgICB0YXJnZXQsICAgICAgICAgICAgICAgICAvLyBuYW1lIG9mIHRoZSBvYmplY3QgdG8gYmUgY2FsbGVkIG9uIG1haW4gdGhyZWFkXHJcbiAgICAgICAgICAgIG1ldGhvZCwgICAgICAgICAgICAgICAgIC8vIHdpbGwgZGlzcGF0Y2ggdG8gYSBtZXRob2Qgb2YgdGhpcyBuYW1lIG9uIHRoZSBtYWluIHRocmVhZFxyXG4gICAgICAgICAgICBtZXNzYWdlICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIHBheWxvYWRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbWVzc2FnZV9pZCsrO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGNvbWluZyBiYWNrIGZyb20gdGhlIG1haW4gdGhyZWFkLCBhbmQgZnVsZmlsbCB0aGF0IG1lc3NhZ2UncyBwcm9taXNlXHJcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoZXZlbnQuZGF0YS50eXBlICE9PSAnbWFpbl9yZXBseScpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGFzcyB0aGUgcmVzdWx0IHRvIHRoZSBwcm9taXNlXHJcbiAgICAgICAgdmFyIGlkID0gZXZlbnQuZGF0YS5tZXNzYWdlX2lkO1xyXG4gICAgICAgIGlmIChtZXNzYWdlc1tpZF0pIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXS5yZWplY3QoZXZlbnQuZGF0YS5lcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0ucmVzb2x2ZShldmVudC5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbGV0ZSBtZXNzYWdlc1tpZF07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUmVjZWl2ZSBtZXNzYWdlcyBmcm9tIG1haW4gdGhyZWFkLCBkaXNwYXRjaCB0aGVtLCBhbmQgc2VuZCBiYWNrIGEgcmVwbHlcclxuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xyXG4gICAgICAgIC8vIFVuaXF1ZSBpZCBmb3IgdGhpcyBtZXNzYWdlICYgcmV0dXJuIGNhbGwgdG8gbWFpbiB0aHJlYWRcclxuICAgICAgICB2YXIgaWQgPSBldmVudC5kYXRhLm1lc3NhZ2VfaWQ7XHJcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSAhPT0gJ21haW5fc2VuZCcgfHwgaWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxsIHRoZSByZXF1ZXN0ZWQgd29ya2VyIG1ldGhvZCBhbmQgc2F2ZSB0aGUgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgdmFyIG1ldGhvZF9uYW1lID0gZXZlbnQuZGF0YS5tZXRob2Q7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9ICh0eXBlb2Ygc2VsZlttZXRob2RfbmFtZV0gPT09ICdmdW5jdGlvbicpICYmIHNlbGZbbWV0aG9kX25hbWVdO1xyXG4gICAgICAgIGlmICghbWV0aG9kKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBXb3JrZXIgYnJva2VyIGNvdWxkIG5vdCBkaXNwYXRjaCBtZXNzYWdlIHR5cGUgJHttZXRob2RfbmFtZX0gYmVjYXVzZSB3b3JrZXIgaGFzIG5vIG1ldGhvZCB3aXRoIHRoYXQgbmFtZWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCwgZXJyb3I7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHNlbGYsIGV2ZW50LmRhdGEubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgLy8gVGhyb3duIGVycm9ycyB3aWxsIGJlIHBhc3NlZCBiYWNrIChpbiBzdHJpbmcgZm9ybSkgdG8gbWFpbiB0aHJlYWRcclxuICAgICAgICAgICAgZXJyb3IgPSBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2VuZCByZXR1cm4gdmFsdWUgdG8gbWFpbiB0aHJlYWRcclxuICAgICAgICBsZXQgdHJhbnNmZXJhYmxlcztcclxuICAgICAgICAvLyBBc3luYyByZXN1bHRcclxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXN1bHQudGhlbigodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMgPSBmaW5kVHJhbnNmZXJhYmxlcyh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3dvcmtlcl9yZXBseScsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZDogaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmFsdWVcclxuICAgICAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2ZlcmFibGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYCcke21ldGhvZF9uYW1lfScgdHJhbnNmZXJyZWQgJHt0cmFuc2ZlcmFibGVzLmxlbmd0aH0gb2JqZWN0cyB0byBtYWluIHRocmVhZGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3b3JrZXJfcmVwbHknLFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IGlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW1tZWRpYXRlIHJlc3VsdFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVzID0gZmluZFRyYW5zZmVyYWJsZXMocmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3dvcmtlcl9yZXBseScsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBpZCxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdCxcclxuICAgICAgICAgICAgICAgIGVycm9yOiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGAke2Vycm9yLm1lc3NhZ2V9OiAke2Vycm9yLnN0YWNrfWAgOiBlcnJvcilcclxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBVdGlscy5sb2coJ3RyYWNlJywgYCcke21ldGhvZF9uYW1lfScgdHJhbnNmZXJyZWQgJHt0cmFuc2ZlcmFibGVzLmxlbmd0aH0gb2JqZWN0cyB0byBtYWluIHRocmVhZGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG59XHJcblxyXG4vLyBCdWlsZCBhIGxpc3Qgb2YgdHJhbnNmZXJhYmxlIG9iamVjdHMgZnJvbSBhIHNvdXJjZSBvYmplY3RcclxuLy8gVE9ETzogYWRkIG9wdGlvbiBpbiBjYXNlIHlvdSBET04nVCB3YW50IHRvIHRyYW5zZmVyIG9iamVjdHNcclxuZnVuY3Rpb24gZmluZFRyYW5zZmVyYWJsZXMoc291cmNlLCBsaXN0ID0gW10pIHtcclxuICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICAvLyBDaGVjayBlYWNoIGFycmF5IGVsZW1lbnRcclxuICAgICAgICBzb3VyY2UuZm9yRWFjaCh4ID0+IGZpbmRUcmFuc2ZlcmFibGVzKHgsIGxpc3QpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gSXMgdGhlIG9iamVjdCBhIHRyYW5zZmVyYWJsZSBhcnJheSBidWZmZXI/XHJcbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaChzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPciBsb29rcyBsaWtlIGEgdHlwZWQgYXJyYXkgKGhhcyBhbiBhcnJheSBidWZmZXIgcHJvcGVydHkpP1xyXG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goc291cmNlLmJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE90aGVyd2lzZSBjaGVjayBlYWNoIHByb3BlcnR5XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICBmaW5kVHJhbnNmZXJhYmxlcyhzb3VyY2VbcF0sIGxpc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxpc3Q7XHJcbn1cclxuXHJcbi8vIFNldHVwIHRoaXMgdGhyZWFkIGFzIGFwcHJvcHJpYXRlXHJcbmlmIChVdGlscy5pc01haW5UaHJlYWQpIHtcclxuICAgIHNldHVwTWFpblRocmVhZCgpO1xyXG59XHJcblxyXG5pZiAoVXRpbHMuaXNXb3JrZXJUaHJlYWQpIHtcclxuICAgIHNldHVwV29ya2VyVGhyZWFkKCk7XHJcbn1cclxuIiwiLyoqKiBWZWN0b3IgZnVuY3Rpb25zIC0gdmVjdG9ycyBwcm92aWRlZCBhcyBbeCwgeSwgel0gYXJyYXlzICoqKi9cclxuXHJcbnZhciBWZWN0b3I7XHJcbmV4cG9ydCBkZWZhdWx0IFZlY3RvciA9IHt9O1xyXG5cclxuVmVjdG9yLnNldCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICB2YXIgViA9IFtdO1xyXG4gICAgdmFyIGxpbSA9IHYubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW07IGkrKykge1xyXG4gICAgICAgIFZbaV0gPSB2W2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFY7XHJcbn07XHJcblxyXG5WZWN0b3IubmVnID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIHZhciBWID0gW107XHJcbiAgICB2YXIgbGltID0gdi5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XHJcbiAgICAgICAgVltpXSA9IHZbaV0gKiAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiBWO1xyXG59O1xyXG5cclxuLy8gQWRkaXRpb24gb2YgdHdvIHZlY3RvcnNcclxuVmVjdG9yLmFkZCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuICAgIHZhciB2ID0gW107XHJcbiAgICB2YXIgbGltID0gTWF0aC5taW4odjEubGVuZ3RoLHYyLmxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XHJcbiAgICAgICAgdltpXSA9IHYxW2ldICsgdjJbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdjtcclxufTtcclxuXHJcbi8vIFN1YnN0cmFjdGlvbiBvZiB0d28gdmVjdG9yc1xyXG5WZWN0b3Iuc3ViID0gZnVuY3Rpb24gKHYxLCB2Mikge1xyXG4gICAgdmFyIHYgPSBbXTtcclxuICAgIHZhciBsaW0gPSBNYXRoLm1pbih2MS5sZW5ndGgsdjIubGVuZ3RoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbTsgaSsrKSB7XHJcbiAgICAgICAgdltpXSA9IHYxW2ldIC0gdjJbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdjtcclxufTtcclxuXHJcblZlY3Rvci5zaWduZWRfYXJlYSA9IGZ1bmN0aW9uICh2MSwgdjIsIHYzKSB7XHJcbiAgICByZXR1cm4gKHYyWzBdLXYxWzBdKSoodjNbMV0tdjFbMV0pIC0gKHYzWzBdLXYxWzBdKSoodjJbMV0tdjFbMV0pO1xyXG59O1xyXG5cclxuLy8gTXVsdGlwbGljYXRpb24gb2YgdHdvIHZlY3RvcnNcclxuVmVjdG9yLm11bHQgPSBmdW5jdGlvbiAodjEsIHYyKSB7XHJcbiAgICB2YXIgdiA9IFtdLFxyXG4gICAgICAgIGxlbiA9IHYxLmxlbmd0aCxcclxuICAgICAgICBpO1xyXG5cclxuICAgIGlmICh0eXBlb2YgdjIgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgLy8gTXVsaXRwbHkgYnkgc2NhbGFyXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAqIHYyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE11bHRpcGx5IHR3byB2ZWN0b3JzXHJcbiAgICAgICAgbGVuID0gTWF0aC5taW4odjEubGVuZ3RoLHYyLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZbaV0gPSB2MVtpXSAqIHYyW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2O1xyXG59O1xyXG5cclxuLy8gRGl2aXNpb24gb2YgdHdvIHZlY3RvcnNcclxuVmVjdG9yLmRpdiA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuICAgIHZhciB2ID0gW10sXHJcbiAgICAgICAgaTtcclxuICAgIGlmKHR5cGVvZiB2MiA9PT0gJ251bWJlcicpe1xyXG4gICAgICAgIC8vIERpdmlkZSBieSBzY2FsYXJcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICB2W2ldID0gdjFbaV0gLyB2MjtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIERpdmlkZSB0byB2ZWN0b3JzXHJcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHYxLmxlbmd0aCx2Mi5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2W2ldID0gdjFbaV0gLyB2MltpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdjtcclxufTtcclxuXHJcbi8vIEdldCAyRCBwZXJwZW5kaWN1bGFyXHJcblZlY3Rvci5wZXJwID0gZnVuY3Rpb24gKHYxLCB2Mikge1xyXG4gICAgcmV0dXJuIFsgdjJbMV0gLSB2MVsxXSxcclxuICAgICAgICAgICAgIHYxWzBdIC0gdjJbMF0gXTtcclxufTtcclxuXHJcbi8vIEdldCAyRCB2ZWN0b3Igcm90YXRlZFxyXG5WZWN0b3Iucm90ID0gZnVuY3Rpb24gKHYsIGEpIHtcclxuICAgIHZhciB2ciA9IFZlY3Rvci5sZW5ndGgodik7XHJcbiAgICB2YXIgdmEgPSBWZWN0b3IuYW5nbGUodik7XHJcbiAgICByZXR1cm4gW3ZyICogTWF0aC5jb3ModmErYSksXHJcbiAgICAgICAgICAgIHZyICogTWF0aC5zaW4odmErYSldO1xyXG59O1xyXG5cclxuLy8gR2V0IDJEIGhlYWRpbmcgYW5nbGVcclxuVmVjdG9yLmFuZ2xlID0gZnVuY3Rpb24gKFt4LCB5XSkge1xyXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSx4KTtcclxufTtcclxuXHJcbi8vIENvbXBhcmUgdHdvIHBvaW50c1xyXG5WZWN0b3IuaXNFcXVhbCA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuICAgIHZhciBsZW4gPSB2MS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHYxW2ldICE9PSB2MltpXSl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8vIFZlY3RvciBsZW5ndGggc3F1YXJlZFxyXG5WZWN0b3IubGVuZ3RoU3EgPSBmdW5jdGlvbiAodilcclxue1xyXG4gICAgaWYgKHYubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgcmV0dXJuICh2WzBdKnZbMF0gKyB2WzFdKnZbMV0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICh2WzBdKnZbMF0gKyB2WzFdKnZbMV0gKyB2WzJdKnZbMl0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLy8gVmVjdG9yIGxlbmd0aFxyXG5WZWN0b3IubGVuZ3RoID0gZnVuY3Rpb24gKHYpXHJcbntcclxuICAgIHJldHVybiBNYXRoLnNxcnQoVmVjdG9yLmxlbmd0aFNxKHYpKTtcclxufTtcclxuXHJcbi8vIE5vcm1hbGl6ZSBhIHZlY3RvclxyXG5WZWN0b3Iubm9ybWFsaXplID0gZnVuY3Rpb24gKHYpXHJcbntcclxuICAgIHZhciBkO1xyXG4gICAgaWYgKHYubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgZCA9IHZbMF0qdlswXSArIHZbMV0qdlsxXTtcclxuICAgICAgICBkID0gTWF0aC5zcXJ0KGQpO1xyXG5cclxuICAgICAgICBpZiAoZCAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3ZbMF0gLyBkLCB2WzFdIC8gZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbMCwgMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGQgPSB2WzBdKnZbMF0gKyB2WzFdKnZbMV0gKyB2WzJdKnZbMl07XHJcbiAgICAgICAgZCA9IE1hdGguc3FydChkKTtcclxuXHJcbiAgICAgICAgaWYgKGQgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt2WzBdIC8gZCwgdlsxXSAvIGQsIHZbMl0gLyBkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFswLCAwLCAwXTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIENyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnNcclxuVmVjdG9yLmNyb3NzICA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgKHYxWzFdICogdjJbMl0pIC0gKHYxWzJdICogdjJbMV0pLFxyXG4gICAgICAgICh2MVsyXSAqIHYyWzBdKSAtICh2MVswXSAqIHYyWzJdKSxcclxuICAgICAgICAodjFbMF0gKiB2MlsxXSkgLSAodjFbMV0gKiB2MlswXSlcclxuICAgIF07XHJcbn07XHJcblxyXG4vLyBEb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9yc1xyXG5WZWN0b3IuZG90ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgdmFyIGxpbSA9IE1hdGgubWluKHYxLmxlbmd0aCwgdjIubGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGltOyBpKyspIHtcclxuICAgICAgICBuICs9IHYxW2ldICogdjJbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjtcclxufTtcclxuXHJcbi8vIEZpbmQgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gbGluZXMgc3BlY2lmaWVkIGFzIHNlZ21lbnRzIGZyb20gcG9pbnRzIChwMSwgcDIpIGFuZCAocDMsIHA0KVxyXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmUtbGluZV9pbnRlcnNlY3Rpb25cclxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DcmFtZXInc19ydWxlXHJcblZlY3Rvci5saW5lSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0LCBwYXJhbGxlbF90b2xlcmFuY2UpIHtcclxuICAgIHBhcmFsbGVsX3RvbGVyYW5jZSA9IHBhcmFsbGVsX3RvbGVyYW5jZSB8fCAwLjAxO1xyXG5cclxuICAgIC8vIGExKnggKyBiMSp5ID0gYzEgZm9yIGxpbmUgKHgxLCB5MSkgdG8gKHgyLCB5MilcclxuICAgIC8vIGEyKnggKyBiMip5ID0gYzIgZm9yIGxpbmUgKHgzLCB5MykgdG8gKHg0LCB5NClcclxuICAgIHZhciBhMSA9IHAxWzFdIC0gcDJbMV07IC8vIHkxIC0geTJcclxuICAgIHZhciBiMSA9IHAxWzBdIC0gcDJbMF07IC8vIHgxIC0geDJcclxuICAgIHZhciBhMiA9IHAzWzFdIC0gcDRbMV07IC8vIHkzIC0geTRcclxuICAgIHZhciBiMiA9IHAzWzBdIC0gcDRbMF07IC8vIHgzIC0geDRcclxuICAgIHZhciBjMSA9IChwMVswXSAqIHAyWzFdKSAtIChwMVsxXSAqIHAyWzBdKTsgLy8geDEqeTIgLSB5MSp4MlxyXG4gICAgdmFyIGMyID0gKHAzWzBdICogcDRbMV0pIC0gKHAzWzFdICogcDRbMF0pOyAvLyB4Myp5NCAtIHkzKng0XHJcbiAgICB2YXIgZGVub20gPSAoYjEgKiBhMikgLSAoYTEgKiBiMik7XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKGRlbm9tKSA+IHBhcmFsbGVsX3RvbGVyYW5jZSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICgoYzEgKiBiMikgLSAoYjEgKiBjMikpIC8gZGVub20sXHJcbiAgICAgICAgICAgICgoYzEgKiBhMikgLSAoYTEgKiBjMikpIC8gZGVub21cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7IC8vIHJldHVybiBudWxsIGlmIGxpbmVzIGFyZSAoY2xvc2UgdG8pIHBhcmFsbGVsXHJcbn07XHJcbiJdfQ==
